import {
  NavigationCancel,
  NavigationEnd,
  Router,
  RouterLink,
  RouterModule
} from "./chunk-AFIVYDVE.js";
import {
  DomSanitizer,
  Title
} from "./chunk-5PMOYFJX.js";
import {
  HTTP_INTERCEPTORS,
  HttpClient,
  HttpEventType,
  HttpHeaders,
  HttpRequest,
  HttpResponse
} from "./chunk-MIIY6XF5.js";
import {
  AsyncPipe,
  CommonModule,
  CurrencyPipe,
  DOCUMENT,
  DatePipe,
  DecimalPipe,
  JsonPipe,
  Location,
  LowerCasePipe,
  NgClass,
  NgForOf,
  NgIf,
  NgOptimizedImage,
  NgPlural,
  NgPluralCase,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  TitleCasePipe,
  getDOM,
  isPlatformBrowser
} from "./chunk-MJLP5YTM.js";
import {
  ANIMATION_MODULE_TYPE,
  APP_ID,
  APP_INITIALIZER,
  ApplicationRef,
  BehaviorSubject,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ConnectableObservable,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  IterableDiffers,
  NgModule,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  QueryList,
  Renderer2,
  RendererFactory2,
  ReplaySubject,
  RuntimeError,
  Self,
  SkipSelf,
  Subject,
  Subscription,
  TemplateRef,
  Version,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  __async,
  __objRest,
  __spreadProps,
  __spreadValues,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  booleanAttribute,
  catchError,
  combineLatest,
  concat,
  concatMap,
  debounceTime,
  defer,
  delay,
  distinctUntilChanged,
  filter,
  finalize,
  forkJoin,
  forwardRef,
  from,
  fromEvent,
  inject,
  interval,
  isObservable,
  isPromise,
  isSubscribable,
  map,
  mapTo,
  merge,
  of,
  pairwise,
  scan,
  setClassMetadata,
  shareReplay,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throwError,
  timer,
  ɵsetClassDebugInfo,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassMapInterpolate2,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind4,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵsetComponentScope,
  ɵɵsetNgModuleScope,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-5XMACM3B.js";

// node_modules/@angular/animations/fesm2022/animations.mjs
var AnimationMetadataType;
(function(AnimationMetadataType2) {
  AnimationMetadataType2[AnimationMetadataType2["State"] = 0] = "State";
  AnimationMetadataType2[AnimationMetadataType2["Transition"] = 1] = "Transition";
  AnimationMetadataType2[AnimationMetadataType2["Sequence"] = 2] = "Sequence";
  AnimationMetadataType2[AnimationMetadataType2["Group"] = 3] = "Group";
  AnimationMetadataType2[AnimationMetadataType2["Animate"] = 4] = "Animate";
  AnimationMetadataType2[AnimationMetadataType2["Keyframes"] = 5] = "Keyframes";
  AnimationMetadataType2[AnimationMetadataType2["Style"] = 6] = "Style";
  AnimationMetadataType2[AnimationMetadataType2["Trigger"] = 7] = "Trigger";
  AnimationMetadataType2[AnimationMetadataType2["Reference"] = 8] = "Reference";
  AnimationMetadataType2[AnimationMetadataType2["AnimateChild"] = 9] = "AnimateChild";
  AnimationMetadataType2[AnimationMetadataType2["AnimateRef"] = 10] = "AnimateRef";
  AnimationMetadataType2[AnimationMetadataType2["Query"] = 11] = "Query";
  AnimationMetadataType2[AnimationMetadataType2["Stagger"] = 12] = "Stagger";
})(AnimationMetadataType || (AnimationMetadataType = {}));
function trigger(name, definitions) {
  return {
    type: AnimationMetadataType.Trigger,
    name,
    definitions,
    options: {}
  };
}
function animate(timings, styles = null) {
  return {
    type: AnimationMetadataType.Animate,
    styles,
    timings
  };
}
function group(steps, options = null) {
  return {
    type: AnimationMetadataType.Group,
    steps,
    options
  };
}
function sequence(steps, options = null) {
  return {
    type: AnimationMetadataType.Sequence,
    steps,
    options
  };
}
function style(tokens) {
  return {
    type: AnimationMetadataType.Style,
    styles: tokens,
    offset: null
  };
}
function state(name, styles, options) {
  return {
    type: AnimationMetadataType.State,
    name,
    styles,
    options
  };
}
function keyframes(steps) {
  return {
    type: AnimationMetadataType.Keyframes,
    steps
  };
}
function transition(stateChangeExpr, steps, options = null) {
  return {
    type: AnimationMetadataType.Transition,
    expr: stateChangeExpr,
    animation: steps,
    options
  };
}
function animateChild(options = null) {
  return {
    type: AnimationMetadataType.AnimateChild,
    options
  };
}
function query(selector, animation, options = null) {
  return {
    type: AnimationMetadataType.Query,
    selector,
    animation,
    options
  };
}
var _AnimationBuilder = class _AnimationBuilder {
};
_AnimationBuilder.ɵfac = function AnimationBuilder_Factory(t) {
  return new (t || _AnimationBuilder)();
};
_AnimationBuilder.ɵprov = ɵɵdefineInjectable({
  token: _AnimationBuilder,
  factory: () => (() => inject(BrowserAnimationBuilder))(),
  providedIn: "root"
});
var AnimationBuilder = _AnimationBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(BrowserAnimationBuilder)
    }]
  }], null, null);
})();
var AnimationFactory = class {
};
var _BrowserAnimationBuilder = class _BrowserAnimationBuilder extends AnimationBuilder {
  constructor(rootRenderer, doc) {
    super();
    this.animationModuleType = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    });
    this._nextAnimationId = 0;
    const typeData = {
      id: "0",
      encapsulation: ViewEncapsulation$1.None,
      styles: [],
      data: {
        animation: []
      }
    };
    this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    if (this.animationModuleType === null && !isAnimationRenderer(this._renderer)) {
      throw new RuntimeError(3600, (typeof ngDevMode === "undefined" || ngDevMode) && "Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.");
    }
  }
  build(animation) {
    const id = this._nextAnimationId;
    this._nextAnimationId++;
    const entry = Array.isArray(animation) ? sequence(animation) : animation;
    issueAnimationCommand(this._renderer, null, id, "register", [entry]);
    return new BrowserAnimationFactory(id, this._renderer);
  }
};
_BrowserAnimationBuilder.ɵfac = function BrowserAnimationBuilder_Factory(t) {
  return new (t || _BrowserAnimationBuilder)(ɵɵinject(RendererFactory2), ɵɵinject(DOCUMENT));
};
_BrowserAnimationBuilder.ɵprov = ɵɵdefineInjectable({
  token: _BrowserAnimationBuilder,
  factory: _BrowserAnimationBuilder.ɵfac,
  providedIn: "root"
});
var BrowserAnimationBuilder = _BrowserAnimationBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var BrowserAnimationFactory = class extends AnimationFactory {
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
};
var RendererAnimationPlayer = class {
  constructor(id, element, options, _renderer) {
    this.id = id;
    this.element = element;
    this._renderer = _renderer;
    this.parentPlayer = null;
    this._started = false;
    this.totalTime = 0;
    this._command("create", options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen("done", fn);
  }
  onStart(fn) {
    this._listen("start", fn);
  }
  onDestroy(fn) {
    this._listen("destroy", fn);
  }
  init() {
    this._command("init");
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command("play");
    this._started = true;
  }
  pause() {
    this._command("pause");
  }
  restart() {
    this._command("restart");
  }
  finish() {
    this._command("finish");
  }
  destroy() {
    this._command("destroy");
  }
  reset() {
    this._command("reset");
    this._started = false;
  }
  setPosition(p) {
    this._command("setPosition", p);
  }
  getPosition() {
    return unwrapAnimationRenderer(this._renderer)?.engine?.players[this.id]?.getPosition() ?? 0;
  }
};
function issueAnimationCommand(renderer, element, id, command, args) {
  renderer.setProperty(element, `@@${id}:${command}`, args);
}
function unwrapAnimationRenderer(renderer) {
  const type = renderer.ɵtype;
  if (type === 0) {
    return renderer;
  } else if (type === 1) {
    return renderer.animationRenderer;
  }
  return null;
}
function isAnimationRenderer(renderer) {
  const type = renderer.ɵtype;
  return type === 0 || type === 1;
}

// node_modules/@angular/cdk/fesm2022/platform.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var _Platform = class _Platform {
  constructor(_platformId) {
    this._platformId = _platformId;
    this.isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
    this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
    this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
    this.BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
    this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
    this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
    this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
    this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
    this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  }
};
_Platform.ɵfac = function Platform_Factory(t) {
  return new (t || _Platform)(ɵɵinject(PLATFORM_ID));
};
_Platform.ɵprov = ɵɵdefineInjectable({
  token: _Platform,
  factory: _Platform.ɵfac,
  providedIn: "root"
});
var Platform = _Platform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var _PlatformModule = class _PlatformModule {
};
_PlatformModule.ɵfac = function PlatformModule_Factory(t) {
  return new (t || _PlatformModule)();
};
_PlatformModule.ɵmod = ɵɵdefineNgModule({
  type: _PlatformModule
});
_PlatformModule.ɵinj = ɵɵdefineInjector({});
var PlatformModule = _PlatformModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return 0;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = 0;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? 1 : 2;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
function _isTestEnvironment() {
  return (
    // @ts-ignore
    typeof __karma__ !== "undefined" && !!__karma__ || // @ts-ignore
    typeof jasmine !== "undefined" && !!jasmine || // @ts-ignore
    typeof jest !== "undefined" && !!jest || // @ts-ignore
    typeof Mocha !== "undefined" && !!Mocha
  );
}

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
var TAB = 9;
var ENTER = 13;
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var ESCAPE = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var ZERO = 48;
var NINE = 57;
var A = 65;
var Z = 90;
var META = 91;
var MAC_META = 224;
function hasModifierKey(event, ...modifiers) {
  if (modifiers.length) {
    return modifiers.some((modifier) => event[modifier]);
  }
  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
}

// node_modules/@angular/cdk/fesm2022/coercion.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
function coerceCssPixelValue(value) {
  if (value == null) {
    return "";
  }
  return typeof value === "string" ? value : `${value}px`;
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
var _MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
};
_MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t) {
  return new (t || _MutationObserverFactory)();
};
_MutationObserverFactory.ɵprov = ɵɵdefineInjectable({
  token: _MutationObserverFactory,
  factory: _MutationObserverFactory.ɵfac,
  providedIn: "root"
});
var MutationObserverFactory = _MutationObserverFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ContentObserver = class _ContentObserver {
  constructor(_mutationObserverFactory) {
    this._mutationObserverFactory = _mutationObserverFactory;
    this._observedElements = /* @__PURE__ */ new Map();
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.subscribe(observer);
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing MutationObserver if available, or creating a
   * new one if not.
   */
  _observeElement(element) {
    if (!this._observedElements.has(element)) {
      const stream = new Subject();
      const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
      if (observer) {
        observer.observe(element, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }
      this._observedElements.set(element, {
        observer,
        stream,
        count: 1
      });
    } else {
      this._observedElements.get(element).count++;
    }
    return this._observedElements.get(element).stream;
  }
  /**
   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
   * observing this element.
   */
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying MutationObserver for the specified element. */
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
};
_ContentObserver.ɵfac = function ContentObserver_Factory(t) {
  return new (t || _ContentObserver)(ɵɵinject(MutationObserverFactory));
};
_ContentObserver.ɵprov = ɵɵdefineInjectable({
  token: _ContentObserver,
  factory: _ContentObserver.ɵfac,
  providedIn: "root"
});
var ContentObserver = _ContentObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MutationObserverFactory
  }], null);
})();
var _CdkObserveContent = class _CdkObserveContent {
  /**
   * Whether observing content is disabled. This option can be used
   * to disconnect the underlying MutationObserver until it is needed.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  /** Debounce interval for emitting the changes. */
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  constructor(_contentObserver, _elementRef, _ngZone) {
    this._contentObserver = _contentObserver;
    this._elementRef = _elementRef;
    this._ngZone = _ngZone;
    this.event = new EventEmitter();
    this._disabled = false;
    this._currentSubscription = null;
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._ngZone.runOutsideAngular(() => {
      this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
    });
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
};
_CdkObserveContent.ɵfac = function CdkObserveContent_Factory(t) {
  return new (t || _CdkObserveContent)(ɵɵdirectiveInject(ContentObserver), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
_CdkObserveContent.ɵdir = ɵɵdefineDirective({
  type: _CdkObserveContent,
  selectors: [["", "cdkObserveContent", ""]],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkObserveContentDisabled", "disabled", booleanAttribute],
    debounce: "debounce"
  },
  outputs: {
    event: "cdkObserveContent"
  },
  exportAs: ["cdkObserveContent"],
  features: [ɵɵInputTransformsFeature]
});
var CdkObserveContent = _CdkObserveContent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent"
    }]
  }], () => [{
    type: ContentObserver
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var _ObserversModule = class _ObserversModule {
};
_ObserversModule.ɵfac = function ObserversModule_Factory(t) {
  return new (t || _ObserversModule)();
};
_ObserversModule.ɵmod = ɵɵdefineNgModule({
  type: _ObserversModule,
  declarations: [CdkObserveContent],
  exports: [CdkObserveContent]
});
_ObserversModule.ɵinj = ɵɵdefineInjector({
  providers: [MutationObserverFactory]
});
var ObserversModule = _ObserversModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      exports: [CdkObserveContent],
      declarations: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/layout.mjs
var _LayoutModule = class _LayoutModule {
};
_LayoutModule.ɵfac = function LayoutModule_Factory(t) {
  return new (t || _LayoutModule)();
};
_LayoutModule.ɵmod = ɵɵdefineNgModule({
  type: _LayoutModule
});
_LayoutModule.ɵinj = ɵɵdefineInjector({});
var LayoutModule = _LayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var _MediaMatcher = class _MediaMatcher {
  constructor(_platform, _nonce) {
    this._platform = _platform;
    this._nonce = _nonce;
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query2) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query2, this._nonce);
    }
    return this._matchMedia(query2);
  }
};
_MediaMatcher.ɵfac = function MediaMatcher_Factory(t) {
  return new (t || _MediaMatcher)(ɵɵinject(Platform), ɵɵinject(CSP_NONCE, 8));
};
_MediaMatcher.ɵprov = ɵɵdefineInjectable({
  token: _MediaMatcher,
  factory: _MediaMatcher.ɵfac,
  providedIn: "root"
});
var MediaMatcher = _MediaMatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CSP_NONCE]
    }]
  }], null);
})();
function createEmptyStyleRule(query2, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query2)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.nonce = nonce;
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query2} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query2);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query2) {
  return {
    matches: query2 === "all" || query2 === "",
    media: query2,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var _BreakpointObserver = class _BreakpointObserver {
  constructor(_mediaMatcher, _zone) {
    this._mediaMatcher = _mediaMatcher;
    this._zone = _zone;
    this._queries = /* @__PURE__ */ new Map();
    this._destroySubject = new Subject();
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query2) => this._registerQuery(query2).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query: query2
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query2] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query2) {
    if (this._queries.has(query2)) {
      return this._queries.get(query2);
    }
    const mql = this._mediaMatcher.matchMedia(query2);
    const queryObservable = new Observable((observer) => {
      const handler = (e) => this._zone.run(() => observer.next(e));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query: query2,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query2, output);
    return output;
  }
};
_BreakpointObserver.ɵfac = function BreakpointObserver_Factory(t) {
  return new (t || _BreakpointObserver)(ɵɵinject(MediaMatcher), ɵɵinject(NgZone));
};
_BreakpointObserver.ɵprov = ɵɵdefineInjectable({
  token: _BreakpointObserver,
  factory: _BreakpointObserver.ɵfac,
  providedIn: "root"
});
var BreakpointObserver = _BreakpointObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MediaMatcher
  }, {
    type: NgZone
  }], null);
})();
function splitQueries(queries) {
  return queries.map((query2) => query2.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query2) => query2.trim());
}

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var _AriaDescriber = class _AriaDescriber {
  constructor(_document, _platform) {
    this._platform = _platform;
    this._messageRegistry = /* @__PURE__ */ new Map();
    this._messagesContainer = null;
    this._id = `${nextId++}`;
    this._document = _document;
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  /** Unregisters all created message elements and removes the message container. */
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i = 0; i < describedElements.length; i++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i]);
      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  /**
   * Creates a new element in the visually hidden message container element with the message
   * as its content and adds it to the message registry.
   */
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  /** Deletes the message element from the global messages container. */
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  /** Creates the global container for all aria-describedby messages. */
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i = 0; i < serverContainers.length; i++) {
      serverContainers[i].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (this._platform && !this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  /** Removes all cdk-describedby messages that are hosted through the element. */
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  /**
   * Adds a message reference to the element using aria-describedby and increments the registered
   * message's reference count.
   */
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  /**
   * Removes a message reference from the element using aria-describedby
   * and decrements the registered message's reference count.
   */
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  /** Returns true if the element has been described by the provided message ID. */
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  /** Determines whether a message can be described on a particular element. */
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  /** Checks whether a node is an Element node. */
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
};
_AriaDescriber.ɵfac = function AriaDescriber_Factory(t) {
  return new (t || _AriaDescriber)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_AriaDescriber.ɵprov = ɵɵdefineInjectable({
  token: _AriaDescriber,
  factory: _AriaDescriber.ɵfac,
  providedIn: "root"
});
var AriaDescriber = _AriaDescriber;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var ListKeyManager = class {
  constructor(_items) {
    this._items = _items;
    this._activeItemIndex = -1;
    this._activeItem = null;
    this._wrap = false;
    this._letterKeyStream = new Subject();
    this._typeaheadSubscription = Subscription.EMPTY;
    this._vertical = true;
    this._allowedModifierKeys = [];
    this._homeAndEnd = false;
    this._pageUpAndDown = {
      enabled: false,
      delta: 10
    };
    this._skipPredicateFn = (item) => item.disabled;
    this._pressedLetters = [];
    this.tabOut = new Subject();
    this.change = new Subject();
    if (_items instanceof QueryList) {
      this._itemChangesSubscription = _items.changes.subscribe((newItems) => {
        if (this._activeItem) {
          const itemArray = newItems.toArray();
          const newIndex = itemArray.indexOf(this._activeItem);
          if (newIndex > -1 && newIndex !== this._activeItemIndex) {
            this._activeItemIndex = newIndex;
          }
        }
      });
    }
  }
  /**
   * Sets the predicate function that determines which items should be skipped by the
   * list key manager.
   * @param predicate Function that determines whether the given item should be skipped.
   */
  skipPredicate(predicate) {
    this._skipPredicateFn = predicate;
    return this;
  }
  /**
   * Configures wrapping mode, which determines whether the active item will wrap to
   * the other end of list when there are no more items in the given direction.
   * @param shouldWrap Whether the list should wrap when reaching the end.
   */
  withWrap(shouldWrap = true) {
    this._wrap = shouldWrap;
    return this;
  }
  /**
   * Configures whether the key manager should be able to move the selection vertically.
   * @param enabled Whether vertical selection should be enabled.
   */
  withVerticalOrientation(enabled = true) {
    this._vertical = enabled;
    return this;
  }
  /**
   * Configures the key manager to move the selection horizontally.
   * Passing in `null` will disable horizontal movement.
   * @param direction Direction in which the selection can be moved.
   */
  withHorizontalOrientation(direction) {
    this._horizontal = direction;
    return this;
  }
  /**
   * Modifier keys which are allowed to be held down and whose default actions will be prevented
   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.
   */
  withAllowedModifierKeys(keys) {
    this._allowedModifierKeys = keys;
    return this;
  }
  /**
   * Turns on typeahead mode which allows users to set the active item by typing.
   * @param debounceInterval Time to wait after the last keystroke before setting the active item.
   */
  withTypeAhead(debounceInterval = 200) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && this._items.length && this._items.some((item) => typeof item.getLabel !== "function")) {
      throw Error("ListKeyManager items in typeahead mode must implement the `getLabel` method.");
    }
    this._typeaheadSubscription.unsubscribe();
    this._typeaheadSubscription = this._letterKeyStream.pipe(tap((letter) => this._pressedLetters.push(letter)), debounceTime(debounceInterval), filter(() => this._pressedLetters.length > 0), map(() => this._pressedLetters.join(""))).subscribe((inputString) => {
      const items = this._getItemsArray();
      for (let i = 1; i < items.length + 1; i++) {
        const index = (this._activeItemIndex + i) % items.length;
        const item = items[index];
        if (!this._skipPredicateFn(item) && item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {
          this.setActiveItem(index);
          break;
        }
      }
      this._pressedLetters = [];
    });
    return this;
  }
  /** Cancels the current typeahead sequence. */
  cancelTypeahead() {
    this._pressedLetters = [];
    return this;
  }
  /**
   * Configures the key manager to activate the first and last items
   * respectively when the Home or End key is pressed.
   * @param enabled Whether pressing the Home or End key activates the first/last item.
   */
  withHomeAndEnd(enabled = true) {
    this._homeAndEnd = enabled;
    return this;
  }
  /**
   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction
   * respectively when the Page-Up or Page-Down key is pressed.
   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.
   * @param delta Whether pressing the Home or End key activates the first/last item.
   */
  withPageUpDown(enabled = true, delta = 10) {
    this._pageUpAndDown = {
      enabled,
      delta
    };
    return this;
  }
  setActiveItem(item) {
    const previousActiveItem = this._activeItem;
    this.updateActiveItem(item);
    if (this._activeItem !== previousActiveItem) {
      this.change.next(this._activeItemIndex);
    }
  }
  /**
   * Sets the active item depending on the key event passed in.
   * @param event Keyboard event to be used for determining which element should be active.
   */
  onKeydown(event) {
    const keyCode = event.keyCode;
    const modifiers = ["altKey", "ctrlKey", "metaKey", "shiftKey"];
    const isModifierAllowed = modifiers.every((modifier) => {
      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;
    });
    switch (keyCode) {
      case TAB:
        this.tabOut.next();
        return;
      case DOWN_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setNextItemActive();
          break;
        } else {
          return;
        }
      case UP_ARROW:
        if (this._vertical && isModifierAllowed) {
          this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case RIGHT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setPreviousItemActive() : this.setNextItemActive();
          break;
        } else {
          return;
        }
      case LEFT_ARROW:
        if (this._horizontal && isModifierAllowed) {
          this._horizontal === "rtl" ? this.setNextItemActive() : this.setPreviousItemActive();
          break;
        } else {
          return;
        }
      case HOME:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setFirstItemActive();
          break;
        } else {
          return;
        }
      case END:
        if (this._homeAndEnd && isModifierAllowed) {
          this.setLastItemActive();
          break;
        } else {
          return;
        }
      case PAGE_UP:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;
          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);
          break;
        } else {
          return;
        }
      case PAGE_DOWN:
        if (this._pageUpAndDown.enabled && isModifierAllowed) {
          const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;
          const itemsLength = this._getItemsArray().length;
          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);
          break;
        } else {
          return;
        }
      default:
        if (isModifierAllowed || hasModifierKey(event, "shiftKey")) {
          if (event.key && event.key.length === 1) {
            this._letterKeyStream.next(event.key.toLocaleUpperCase());
          } else if (keyCode >= A && keyCode <= Z || keyCode >= ZERO && keyCode <= NINE) {
            this._letterKeyStream.next(String.fromCharCode(keyCode));
          }
        }
        return;
    }
    this._pressedLetters = [];
    event.preventDefault();
  }
  /** Index of the currently active item. */
  get activeItemIndex() {
    return this._activeItemIndex;
  }
  /** The active item. */
  get activeItem() {
    return this._activeItem;
  }
  /** Gets whether the user is currently typing into the manager using the typeahead feature. */
  isTyping() {
    return this._pressedLetters.length > 0;
  }
  /** Sets the active item to the first enabled item in the list. */
  setFirstItemActive() {
    this._setActiveItemByIndex(0, 1);
  }
  /** Sets the active item to the last enabled item in the list. */
  setLastItemActive() {
    this._setActiveItemByIndex(this._items.length - 1, -1);
  }
  /** Sets the active item to the next enabled item in the list. */
  setNextItemActive() {
    this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
  }
  /** Sets the active item to a previous enabled item in the list. */
  setPreviousItemActive() {
    this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);
  }
  updateActiveItem(item) {
    const itemArray = this._getItemsArray();
    const index = typeof item === "number" ? item : itemArray.indexOf(item);
    const activeItem = itemArray[index];
    this._activeItem = activeItem == null ? null : activeItem;
    this._activeItemIndex = index;
  }
  /** Cleans up the key manager. */
  destroy() {
    this._typeaheadSubscription.unsubscribe();
    this._itemChangesSubscription?.unsubscribe();
    this._letterKeyStream.complete();
    this.tabOut.complete();
    this.change.complete();
    this._pressedLetters = [];
  }
  /**
   * This method sets the active item, given a list of items and the delta between the
   * currently active item and the new active item. It will calculate differently
   * depending on whether wrap mode is turned on.
   */
  _setActiveItemByDelta(delta) {
    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);
  }
  /**
   * Sets the active item properly given "wrap" mode. In other words, it will continue to move
   * down the list until it finds an item that is not disabled, and it will wrap if it
   * encounters either end of the list.
   */
  _setActiveInWrapMode(delta) {
    const items = this._getItemsArray();
    for (let i = 1; i <= items.length; i++) {
      const index = (this._activeItemIndex + delta * i + items.length) % items.length;
      const item = items[index];
      if (!this._skipPredicateFn(item)) {
        this.setActiveItem(index);
        return;
      }
    }
  }
  /**
   * Sets the active item properly given the default mode. In other words, it will
   * continue to move down the list until it finds an item that is not disabled. If
   * it encounters either end of the list, it will stop and not wrap.
   */
  _setActiveInDefaultMode(delta) {
    this._setActiveItemByIndex(this._activeItemIndex + delta, delta);
  }
  /**
   * Sets the active item to the first enabled item starting at the index specified. If the
   * item is disabled, it will move in the fallbackDelta direction until it either
   * finds an enabled item or encounters the end of the list.
   */
  _setActiveItemByIndex(index, fallbackDelta) {
    const items = this._getItemsArray();
    if (!items[index]) {
      return;
    }
    while (this._skipPredicateFn(items[index])) {
      index += fallbackDelta;
      if (!items[index]) {
        return;
      }
    }
    this.setActiveItem(index);
  }
  /** Returns the items as an array. */
  _getItemsArray() {
    return this._items instanceof QueryList ? this._items.toArray() : this._items;
  }
};
var ActiveDescendantKeyManager = class extends ListKeyManager {
  setActiveItem(index) {
    if (this.activeItem) {
      this.activeItem.setInactiveStyles();
    }
    super.setActiveItem(index);
    if (this.activeItem) {
      this.activeItem.setActiveStyles();
    }
  }
};
var _InteractivityChecker = class _InteractivityChecker {
  constructor(_platform) {
    this._platform = _platform;
  }
  /**
   * Gets whether an element is disabled.
   *
   * @param element Element to be checked.
   * @returns Whether the element is disabled.
   */
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  /**
   * Gets whether an element is visible for the purposes of interactivity.
   *
   * This will capture states like `display: none` and `visibility: hidden`, but not things like
   * being clipped by an `overflow: hidden` parent or being outside the viewport.
   *
   * @returns Whether the element is visible.
   */
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  /**
   * Gets whether an element can be reached via Tab key.
   * Assumes that the element has already been checked with isFocusable.
   *
   * @param element Element to be checked.
   * @returns Whether the element is tabbable.
   */
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  /**
   * Gets whether an element can be focused by the user.
   *
   * @param element Element to be checked.
   * @param config The config object with options to customize this method's behavior
   * @returns Whether the element is focusable.
   */
  isFocusable(element, config) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
  }
};
_InteractivityChecker.ɵfac = function InteractivityChecker_Factory(t) {
  return new (t || _InteractivityChecker)(ɵɵinject(Platform));
};
_InteractivityChecker.ɵprov = ɵɵdefineInjectable({
  token: _InteractivityChecker,
  factory: _InteractivityChecker.ɵfac,
  providedIn: "root"
});
var InteractivityChecker = _InteractivityChecker;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  /** Whether the focus trap is active. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
    this._hasAttached = false;
    this.startAnchorListener = () => this.focusLastTabbableElement();
    this.endAnchorListener = () => this.focusFirstTabbableElement();
    this._enabled = true;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  /** Destroys the focus trap by cleaning up the anchors. */
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  /**
   * Inserts the anchors into the DOM. This is usually done automatically
   * in the constructor, but can be deferred for cases like directives with `*ngIf`.
   * @returns Whether the focus trap managed to attach successfully. This may not be the case
   * if the target element isn't currently in the DOM.
   */
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  /**
   * Waits for the zone to stabilize, then focuses the first tabbable element.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the first tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the last tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  /**
   * Get the specified boundary element of the trapped region.
   * @param bound The boundary to get (start or end of trapped region).
   * @returns The boundary element.
   */
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i = 0; i < markers.length; i++) {
        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  /**
   * Focuses the element that should be focused when the focus trap is initialized.
   * @returns Whether focus was moved successfully.
   */
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  /**
   * Focuses the first tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Focuses the last tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Checks whether the focus trap has successfully been attached.
   */
  hasAttached() {
    return this._hasAttached;
  }
  /** Get the first tabbable element from a DOM subtree (inclusive). */
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Get the last tabbable element from a DOM subtree (inclusive). */
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = children.length - 1; i >= 0; i--) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Creates an anchor element. */
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  /**
   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
   * @param isEnabled Whether the focus trap is enabled.
   * @param anchor Anchor on which to toggle the tabindex.
   */
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  /**
   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
   * @param enabled: Whether the anchors should trap Tab.
   */
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  /** Executes a function when the zone is stable. */
  _executeOnStable(fn) {
    if (this._ngZone.isStable) {
      fn();
    } else {
      this._ngZone.onStable.pipe(take(1)).subscribe(fn);
    }
  }
};
var _FocusTrapFactory = class _FocusTrapFactory {
  constructor(_checker, _ngZone, _document) {
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
  }
  /**
   * Creates a focus-trapped region around the given element.
   * @param element The element around which focus will be trapped.
   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
   *     manually by the user.
   * @returns The created focus trap instance.
   */
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
  }
};
_FocusTrapFactory.ɵfac = function FocusTrapFactory_Factory(t) {
  return new (t || _FocusTrapFactory)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_FocusTrapFactory.ɵprov = ɵɵdefineInjectable({
  token: _FocusTrapFactory,
  factory: _FocusTrapFactory.ɵfac,
  providedIn: "root"
});
var FocusTrapFactory = _FocusTrapFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _CdkTrapFocus = class _CdkTrapFocus {
  /** Whether the focus trap is active. */
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  constructor(_elementRef, _focusTrapFactory, _document) {
    this._elementRef = _elementRef;
    this._focusTrapFactory = _focusTrapFactory;
    this._previouslyFocusedElement = null;
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
};
_CdkTrapFocus.ɵfac = function CdkTrapFocus_Factory(t) {
  return new (t || _CdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT));
};
_CdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: _CdkTrapFocus,
  selectors: [["", "cdkTrapFocus", ""]],
  inputs: {
    enabled: [InputFlags.HasDecoratorInputTransform, "cdkTrapFocus", "enabled", booleanAttribute],
    autoCapture: [InputFlags.HasDecoratorInputTransform, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
  },
  exportAs: ["cdkTrapFocus"],
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkTrapFocus = _CdkTrapFocus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusTrapFactory
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var ConfigurableFocusTrap = class extends FocusTrap {
  /** Whether the FocusTrap is enabled. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {
    super(_element, _checker, _ngZone, _document, config.defer);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var EventListenerFocusTrapInertStrategy = class {
  constructor() {
    this._listener = null;
  }
  /** Adds a document event listener that keeps focus inside the FocusTrap. */
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e) => this._trapFocus(focusTrap, e);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  /** Removes the event listener added in preventFocus. */
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  /**
   * Refocuses the first element in the FocusTrap if the focus event target was outside
   * the FocusTrap.
   *
   * This is an event listener callback. The event listener is added in runOutsideAngular,
   * so all this code runs outside Angular as well.
   */
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var _FocusTrapManager = class _FocusTrapManager {
  constructor() {
    this._focusTrapStack = [];
  }
  /**
   * Disables the FocusTrap at the top of the stack, and then pushes
   * the new FocusTrap onto the stack.
   */
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  /**
   * Removes the FocusTrap from the stack, and activates the
   * FocusTrap that is the new top of the stack.
   */
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i = stack.indexOf(focusTrap);
    if (i !== -1) {
      stack.splice(i, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
};
_FocusTrapManager.ɵfac = function FocusTrapManager_Factory(t) {
  return new (t || _FocusTrapManager)();
};
_FocusTrapManager.ɵprov = ɵɵdefineInjectable({
  token: _FocusTrapManager,
  factory: _FocusTrapManager.ɵfac,
  providedIn: "root"
});
var FocusTrapManager = _FocusTrapManager;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._focusTrapManager = _focusTrapManager;
    this._document = _document;
    this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config = {
    defer: false
  }) {
    let configObject;
    if (typeof config === "boolean") {
      configObject = {
        defer: config
      };
    } else {
      configObject = config;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);
  }
};
_ConfigurableFocusTrapFactory.ɵfac = function ConfigurableFocusTrapFactory_Factory(t) {
  return new (t || _ConfigurableFocusTrapFactory)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(FocusTrapManager), ɵɵinject(DOCUMENT), ɵɵinject(FOCUS_TRAP_INERT_STRATEGY, 8));
};
_ConfigurableFocusTrapFactory.ɵprov = ɵɵdefineInjectable({
  token: _ConfigurableFocusTrapFactory,
  factory: _ConfigurableFocusTrapFactory.ɵfac,
  providedIn: "root"
});
var ConfigurableFocusTrapFactory = _ConfigurableFocusTrapFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: FocusTrapManager
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_TRAP_INERT_STRATEGY]
    }]
  }], null);
})();
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var _InputModalityDetector = class _InputModalityDetector {
  /** The most recently detected input modality. */
  get mostRecentModality() {
    return this._modality.value;
  }
  constructor(_platform, ngZone, document2, options) {
    this._platform = _platform;
    this._mostRecentTarget = null;
    this._modality = new BehaviorSubject(null);
    this._lastTouchMs = 0;
    this._onKeydown = (event) => {
      if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
        return;
      }
      this._modality.next("keyboard");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._onMousedown = (event) => {
      if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
        return;
      }
      this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._onTouchstart = (event) => {
      if (isFakeTouchstartFromScreenReader(event)) {
        this._modality.next("keyboard");
        return;
      }
      this._lastTouchMs = Date.now();
      this._modality.next("touch");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (_platform.isBrowser) {
      ngZone.runOutsideAngular(() => {
        document2.addEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
        document2.addEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
        document2.addEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    if (this._platform.isBrowser) {
      document.removeEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
      document.removeEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
      document.removeEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
    }
  }
};
_InputModalityDetector.ɵfac = function InputModalityDetector_Factory(t) {
  return new (t || _InputModalityDetector)(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(INPUT_MODALITY_DETECTOR_OPTIONS, 8));
};
_InputModalityDetector.ɵprov = ɵɵdefineInjectable({
  token: _InputModalityDetector,
  factory: _InputModalityDetector.ɵfac,
  providedIn: "root"
});
var InputModalityDetector = _InputModalityDetector;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: NgZone
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [INPUT_MODALITY_DETECTOR_OPTIONS]
    }]
  }], null);
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
});
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var _LiveAnnouncer = class _LiveAnnouncer {
  constructor(elementToken, _ngZone, _document, _defaultOptions) {
    this._ngZone = _ngZone;
    this._defaultOptions = _defaultOptions;
    this._document = _document;
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite";
    }
    if (duration == null && defaultOptions) {
      duration = defaultOptions.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  /**
   * Clears the current text from the announcer element. Can be used to prevent
   * screen readers from reading the text out again while the user is going
   * through the page landmarks.
   */
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i = 0; i < previousElements.length; i++) {
      previousElements[i].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  /**
   * Some browsers won't expose the accessibility node of the live announcer element if there is an
   * `aria-modal` and the live announcer is outside of it. This method works around the issue by
   * pointing the `aria-owns` of all modals to the live announcer element.
   */
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i = 0; i < modals.length; i++) {
      const modal = modals[i];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
};
_LiveAnnouncer.ɵfac = function LiveAnnouncer_Factory(t) {
  return new (t || _LiveAnnouncer)(ɵɵinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8));
};
_LiveAnnouncer.ɵprov = ɵɵdefineInjectable({
  token: _LiveAnnouncer,
  factory: _LiveAnnouncer.ɵfac,
  providedIn: "root"
});
var LiveAnnouncer = _LiveAnnouncer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [LIVE_ANNOUNCER_ELEMENT_TOKEN]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS]
    }]
  }], null);
})();
var _CdkAriaLive = class _CdkAriaLive {
  /** The aria-live politeness level to use when announcing messages. */
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {
    this._elementRef = _elementRef;
    this._liveAnnouncer = _liveAnnouncer;
    this._contentObserver = _contentObserver;
    this._ngZone = _ngZone;
    this._politeness = "polite";
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
};
_CdkAriaLive.ɵfac = function CdkAriaLive_Factory(t) {
  return new (t || _CdkAriaLive)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LiveAnnouncer), ɵɵdirectiveInject(ContentObserver), ɵɵdirectiveInject(NgZone));
};
_CdkAriaLive.ɵdir = ɵɵdefineDirective({
  type: _CdkAriaLive,
  selectors: [["", "cdkAriaLive", ""]],
  inputs: {
    politeness: [InputFlags.None, "cdkAriaLive", "politeness"],
    duration: [InputFlags.None, "cdkAriaLiveDuration", "duration"]
  },
  exportAs: ["cdkAriaLive"]
});
var CdkAriaLive = _CdkAriaLive;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: LiveAnnouncer
  }, {
    type: ContentObserver
  }, {
    type: NgZone
  }], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var _FocusMonitor = class _FocusMonitor {
  constructor(_ngZone, _platform, _inputModalityDetector, document2, options) {
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._inputModalityDetector = _inputModalityDetector;
    this._origin = null;
    this._windowFocused = false;
    this._originFromTouchInteraction = false;
    this._elementInfo = /* @__PURE__ */ new Map();
    this._monitoredElementCount = 0;
    this._rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
    this._windowFocusListener = () => {
      this._windowFocused = true;
      this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = false);
    };
    this._stopInputModalityDetector = new Subject();
    this._rootNodeFocusAndBlurListener = (event) => {
      const target = _getEventTarget(event);
      for (let element = target; element; element = element.parentElement) {
        if (event.type === "focus") {
          this._onFocus(event, element);
        } else {
          this._onBlur(event, element);
        }
      }
    };
    this._document = document2;
    this._detectionMode = options?.detectionMode || 0;
  }
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._getDocument();
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._getDocument().activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  /** Access injected document if available or fallback to global document reference */
  _getDocument() {
    return this._document || document;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    const doc = this._getDocument();
    return doc.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  /**
   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
   * handle a focus event following a touch interaction, we need to determine whether (1) the focus
   * event was directly caused by the touch interaction or (2) the focus event was caused by a
   * subsequent programmatic focus call triggered by the touch interaction.
   * @param focusEventTarget The target of the focus event under examination.
   */
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === 1 || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  /**
   * Sets the focus classes on the element based on the given focus origin.
   * @param element The element to update the classes on.
   * @param origin The focus origin.
   */
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  /**
   * Updates the focus origin. If we're using immediate detection mode, we schedule an async
   * function to clear the origin at the end of a timeout. The duration of the timeout depends on
   * the origin being set.
   * @param origin The origin to set.
   * @param isFromInteraction Whether we are setting the origin from an interaction event.
   */
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === 0) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  /**
   * Handles focus events on a registered element.
   * @param event The focus event.
   * @param element The monitored element.
   */
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  /**
   * Handles blur events on a registered element.
   * @param event The blur event.
   * @param element The monitored element.
   */
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(
          modality,
          true
          /* isFromInteraction */
        );
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  /** Updates all the state on an element once its focus origin has changed. */
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  /**
   * Collects the `MonitoredElementInfo` of a particular element and
   * all of its ancestors that have enabled `checkChildren`.
   * @param element Element from which to start the search.
   */
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  /**
   * Returns whether an interaction is likely to have come from the user clicking the `label` of
   * an `input` or `textarea` in order to focus it.
   * @param focusEventTarget Target currently receiving focus.
   */
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
};
_FocusMonitor.ɵfac = function FocusMonitor_Factory(t) {
  return new (t || _FocusMonitor)(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(InputModalityDetector), ɵɵinject(DOCUMENT, 8), ɵɵinject(FOCUS_MONITOR_DEFAULT_OPTIONS, 8));
};
_FocusMonitor.ɵprov = ɵɵdefineInjectable({
  token: _FocusMonitor,
  factory: _FocusMonitor.ɵfac,
  providedIn: "root"
});
var FocusMonitor = _FocusMonitor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Platform
  }, {
    type: InputModalityDetector
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_MONITOR_DEFAULT_OPTIONS]
    }]
  }], null);
})();
var _CdkMonitorFocus = class _CdkMonitorFocus {
  constructor(_elementRef, _focusMonitor) {
    this._elementRef = _elementRef;
    this._focusMonitor = _focusMonitor;
    this._focusOrigin = null;
    this.cdkFocusChange = new EventEmitter();
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
};
_CdkMonitorFocus.ɵfac = function CdkMonitorFocus_Factory(t) {
  return new (t || _CdkMonitorFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor));
};
_CdkMonitorFocus.ɵdir = ɵɵdefineDirective({
  type: _CdkMonitorFocus,
  selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
  outputs: {
    cdkFocusChange: "cdkFocusChange"
  },
  exportAs: ["cdkMonitorFocus"]
});
var CdkMonitorFocus = _CdkMonitorFocus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusMonitor
  }], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var _HighContrastModeDetector = class _HighContrastModeDetector {
  constructor(_platform, document2) {
    this._platform = _platform;
    this._document = document2;
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  /** Gets the current high-contrast-mode for the page. */
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return 0;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      case "rgb(0,0,0)":
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return 2;
      case "rgb(255,255,255)":
      case "rgb(255,250,239)":
        return 1;
    }
    return 0;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === 1) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === 2) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
};
_HighContrastModeDetector.ɵfac = function HighContrastModeDetector_Factory(t) {
  return new (t || _HighContrastModeDetector)(ɵɵinject(Platform), ɵɵinject(DOCUMENT));
};
_HighContrastModeDetector.ɵprov = ɵɵdefineInjectable({
  token: _HighContrastModeDetector,
  factory: _HighContrastModeDetector.ɵfac,
  providedIn: "root"
});
var HighContrastModeDetector = _HighContrastModeDetector;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _A11yModule = class _A11yModule {
  constructor(highContrastModeDetector) {
    highContrastModeDetector._applyBodyHighContrastModeCssClasses();
  }
};
_A11yModule.ɵfac = function A11yModule_Factory(t) {
  return new (t || _A11yModule)(ɵɵinject(HighContrastModeDetector));
};
_A11yModule.ɵmod = ɵɵdefineNgModule({
  type: _A11yModule,
  declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
  imports: [ObserversModule],
  exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
});
_A11yModule.ɵinj = ɵɵdefineInjector({
  imports: [ObserversModule]
});
var A11yModule = _A11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule],
      declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [{
    type: HighContrastModeDetector
  }], null);
})();

// node_modules/@angular/cdk/fesm2022/collections.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var ArrayDataSource = class extends DataSource {
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _RecycleViewRepeaterStrategy = class {
  constructor() {
    this.viewCacheSize = 20;
    this._viewCache = [];
  }
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? 1 : 0;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = 3;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = 2;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};
var SelectionModel = class {
  /** Selected values. */
  get selected() {
    if (!this._selected) {
      this._selected = Array.from(this._selection.values());
    }
    return this._selected;
  }
  constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {
    this._multiple = _multiple;
    this._emitChanges = _emitChanges;
    this.compareWith = compareWith;
    this._selection = /* @__PURE__ */ new Set();
    this._deselectedToEmit = [];
    this._selectedToEmit = [];
    this.changed = new Subject();
    if (initiallySelectedValues && initiallySelectedValues.length) {
      if (_multiple) {
        initiallySelectedValues.forEach((value) => this._markSelected(value));
      } else {
        this._markSelected(initiallySelectedValues[0]);
      }
      this._selectedToEmit.length = 0;
    }
  }
  /**
   * Selects a value or an array of values.
   * @param values The values to select
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  select(...values) {
    this._verifyValueAssignment(values);
    values.forEach((value) => this._markSelected(value));
    const changed = this._hasQueuedChanges();
    this._emitChangeEvent();
    return changed;
  }
  /**
   * Deselects a value or an array of values.
   * @param values The values to deselect
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  deselect(...values) {
    this._verifyValueAssignment(values);
    values.forEach((value) => this._unmarkSelected(value));
    const changed = this._hasQueuedChanges();
    this._emitChangeEvent();
    return changed;
  }
  /**
   * Sets the selected values
   * @param values The new selected values
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  setSelection(...values) {
    this._verifyValueAssignment(values);
    const oldValues = this.selected;
    const newSelectedSet = new Set(values);
    values.forEach((value) => this._markSelected(value));
    oldValues.filter((value) => !newSelectedSet.has(this._getConcreteValue(value, newSelectedSet))).forEach((value) => this._unmarkSelected(value));
    const changed = this._hasQueuedChanges();
    this._emitChangeEvent();
    return changed;
  }
  /**
   * Toggles a value between selected and deselected.
   * @param value The value to toggle
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  toggle(value) {
    return this.isSelected(value) ? this.deselect(value) : this.select(value);
  }
  /**
   * Clears all of the selected values.
   * @param flushEvent Whether to flush the changes in an event.
   *   If false, the changes to the selection will be flushed along with the next event.
   * @return Whether the selection changed as a result of this call
   * @breaking-change 16.0.0 make return type boolean
   */
  clear(flushEvent = true) {
    this._unmarkAll();
    const changed = this._hasQueuedChanges();
    if (flushEvent) {
      this._emitChangeEvent();
    }
    return changed;
  }
  /**
   * Determines whether a value is selected.
   */
  isSelected(value) {
    return this._selection.has(this._getConcreteValue(value));
  }
  /**
   * Determines whether the model does not have a value.
   */
  isEmpty() {
    return this._selection.size === 0;
  }
  /**
   * Determines whether the model has a value.
   */
  hasValue() {
    return !this.isEmpty();
  }
  /**
   * Sorts the selected values based on a predicate function.
   */
  sort(predicate) {
    if (this._multiple && this.selected) {
      this._selected.sort(predicate);
    }
  }
  /**
   * Gets whether multiple values can be selected.
   */
  isMultipleSelection() {
    return this._multiple;
  }
  /** Emits a change event and clears the records of selected and deselected values. */
  _emitChangeEvent() {
    this._selected = null;
    if (this._selectedToEmit.length || this._deselectedToEmit.length) {
      this.changed.next({
        source: this,
        added: this._selectedToEmit,
        removed: this._deselectedToEmit
      });
      this._deselectedToEmit = [];
      this._selectedToEmit = [];
    }
  }
  /** Selects a value. */
  _markSelected(value) {
    value = this._getConcreteValue(value);
    if (!this.isSelected(value)) {
      if (!this._multiple) {
        this._unmarkAll();
      }
      if (!this.isSelected(value)) {
        this._selection.add(value);
      }
      if (this._emitChanges) {
        this._selectedToEmit.push(value);
      }
    }
  }
  /** Deselects a value. */
  _unmarkSelected(value) {
    value = this._getConcreteValue(value);
    if (this.isSelected(value)) {
      this._selection.delete(value);
      if (this._emitChanges) {
        this._deselectedToEmit.push(value);
      }
    }
  }
  /** Clears out the selected values. */
  _unmarkAll() {
    if (!this.isEmpty()) {
      this._selection.forEach((value) => this._unmarkSelected(value));
    }
  }
  /**
   * Verifies the value assignment and throws an error if the specified value array is
   * including multiple values while the selection model is not supporting multiple values.
   */
  _verifyValueAssignment(values) {
    if (values.length > 1 && !this._multiple && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMultipleValuesInSingleSelectionError();
    }
  }
  /** Whether there are queued up change to be emitted. */
  _hasQueuedChanges() {
    return !!(this._deselectedToEmit.length || this._selectedToEmit.length);
  }
  /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */
  _getConcreteValue(inputValue, selection) {
    if (!this.compareWith) {
      return inputValue;
    } else {
      selection = selection ?? this._selection;
      for (let selectedValue of selection) {
        if (this.compareWith(inputValue, selectedValue)) {
          return selectedValue;
        }
      }
      return inputValue;
    }
  }
};
function getMultipleValuesInSingleSelectionError() {
  return Error("Cannot pass multiple values into SelectionModel with single-value mode.");
}
var _UniqueSelectionDispatcher = class _UniqueSelectionDispatcher {
  constructor() {
    this._listeners = [];
  }
  /**
   * Notify other items that selection for the given name has been set.
   * @param id ID of the item.
   * @param name Name of the item.
   */
  notify(id, name) {
    for (let listener of this._listeners) {
      listener(id, name);
    }
  }
  /**
   * Listen for future changes to item selection.
   * @return Function used to deregister listener
   */
  listen(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((registered) => {
        return listener !== registered;
      });
    };
  }
  ngOnDestroy() {
    this._listeners = [];
  }
};
_UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t) {
  return new (t || _UniqueSelectionDispatcher)();
};
_UniqueSelectionDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _UniqueSelectionDispatcher,
  factory: _UniqueSelectionDispatcher.ɵfac,
  providedIn: "root"
});
var UniqueSelectionDispatcher = _UniqueSelectionDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UniqueSelectionDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");

// node_modules/@angular/forms/fesm2022/forms.mjs
var _BaseControlValueAccessor = class _BaseControlValueAccessor {
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
    this.onChange = (_) => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Helper method that sets a property on a target element using the current Renderer
   * implementation.
   * @nodoc
   */
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  /**
   * Registers a function called when the control is touched.
   * @nodoc
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * Sets the "disabled" property on the range input element.
   * @nodoc
   */
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
};
_BaseControlValueAccessor.ɵfac = function BaseControlValueAccessor_Factory(t) {
  return new (t || _BaseControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
_BaseControlValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _BaseControlValueAccessor
});
var BaseControlValueAccessor = _BaseControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var _BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
};
_BuiltInControlValueAccessor.ɵfac = /* @__PURE__ */ (() => {
  let ɵBuiltInControlValueAccessor_BaseFactory;
  return function BuiltInControlValueAccessor_Factory(t) {
    return (ɵBuiltInControlValueAccessor_BaseFactory || (ɵBuiltInControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_BuiltInControlValueAccessor)))(t || _BuiltInControlValueAccessor);
  };
})();
_BuiltInControlValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _BuiltInControlValueAccessor,
  features: [ɵɵInheritDefinitionFeature]
});
var BuiltInControlValueAccessor = _BuiltInControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var _CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "checked" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("checked", value);
  }
};
_CheckboxControlValueAccessor.ɵfac = /* @__PURE__ */ (() => {
  let ɵCheckboxControlValueAccessor_BaseFactory;
  return function CheckboxControlValueAccessor_Factory(t) {
    return (ɵCheckboxControlValueAccessor_BaseFactory || (ɵCheckboxControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_CheckboxControlValueAccessor)))(t || _CheckboxControlValueAccessor);
  };
})();
_CheckboxControlValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _CheckboxControlValueAccessor,
  selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
  hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.checked);
      })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [ɵɵProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var CheckboxControlValueAccessor = _CheckboxControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($event.target.checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? "CompositionEventMode" : "");
var _DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    this._composing = false;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /** @internal */
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  /** @internal */
  _compositionStart() {
    this._composing = true;
  }
  /** @internal */
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
};
_DefaultValueAccessor.ɵfac = function DefaultValueAccessor_Factory(t) {
  return new (t || _DefaultValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8));
};
_DefaultValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _DefaultValueAccessor,
  selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
  hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
        return ctx._handleInput($event.target.value);
      })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
        return ctx._compositionStart();
      })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
        return ctx._compositionEnd($event.target.value);
      });
    }
  },
  features: [ɵɵProvidersFeature([DEFAULT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var DefaultValueAccessor = _DefaultValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      // TODO: vsavkin replace the above selector with the one below it once
      // https://github.com/angular/angular/issues/3011 is implemented
      // selector: '[ngModel],[formControl],[formControlName]',
      host: {
        "(input)": "$any(this)._handleInput($event.target.value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "$any(this)._compositionStart()",
        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || (typeof value === "string" || Array.isArray(value)) && value.length === 0;
}
function hasValidLength(value) {
  return value != null && typeof value.length === "number";
}
var NG_VALIDATORS = new InjectionToken(ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function minValidator(min) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
      return null;
    }
    return control.value.length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    return hasValidLength(control.value) && control.value.length > maxLength ? {
      "maxlength": {
        "requiredLength": maxLength,
        "actualLength": control.value.length
      }
    } : null;
  };
}
function patternValidator(pattern) {
  if (!pattern)
    return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^")
      regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$")
      regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators)
    return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0)
    return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null)
    return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators)
    return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  constructor() {
    this._rawValidators = [];
    this._rawAsyncValidators = [];
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Reports the value of the control if it is present, otherwise null.
   */
  get value() {
    return this.control ? this.control.value : null;
  }
  /**
   * @description
   * Reports whether the control is valid. A control is considered valid if no
   * validation errors exist with the current value.
   * If the control is not present, null is returned.
   */
  get valid() {
    return this.control ? this.control.valid : null;
  }
  /**
   * @description
   * Reports whether the control is invalid, meaning that an error exists in the input value.
   * If the control is not present, null is returned.
   */
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  /**
   * @description
   * Reports whether a control is pending, meaning that async validation is occurring and
   * errors are not yet available for the input value. If the control is not present, null is
   * returned.
   */
  get pending() {
    return this.control ? this.control.pending : null;
  }
  /**
   * @description
   * Reports whether the control is disabled, meaning that the control is disabled
   * in the UI and is exempt from validation checks and excluded from aggregate
   * values of ancestor controls. If the control is not present, null is returned.
   */
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  /**
   * @description
   * Reports whether the control is enabled, meaning that the control is included in ancestor
   * calculations of validity or value. If the control is not present, null is returned.
   */
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  /**
   * @description
   * Reports the control's validation errors. If the control is not present, null is returned.
   */
  get errors() {
    return this.control ? this.control.errors : null;
  }
  /**
   * @description
   * Reports whether the control is pristine, meaning that the user has not yet changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  /**
   * @description
   * Reports whether the control is dirty, meaning that the user has changed
   * the value in the UI. If the control is not present, null is returned.
   */
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  /**
   * @description
   * Reports whether the control is touched, meaning that the user has triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get touched() {
    return this.control ? this.control.touched : null;
  }
  /**
   * @description
   * Reports the validation status of the control. Possible values include:
   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
   * If the control is not present, null is returned.
   */
  get status() {
    return this.control ? this.control.status : null;
  }
  /**
   * @description
   * Reports whether the control is untouched, meaning that the user has not yet triggered
   * a `blur` event on it. If the control is not present, null is returned.
   */
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  /**
   * @description
   * Returns a multicasting observable that emits a validation status whenever it is
   * calculated for the control. If the control is not present, null is returned.
   */
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  /**
   * @description
   * Returns a multicasting observable of value changes for the control that emits every time the
   * value of the control changes in the UI or programmatically.
   * If the control is not present, null is returned.
   */
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return null;
  }
  /**
   * Sets synchronous validators for this directive.
   * @internal
   */
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  /**
   * Sets asynchronous validators for this directive.
   * @internal
   */
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  /**
   * @description
   * Synchronous validator function composed of all the synchronous validators registered with this
   * directive.
   */
  get validator() {
    return this._composedValidatorFn || null;
  }
  /**
   * @description
   * Asynchronous validator function composed of all the asynchronous validators registered with
   * this directive.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  /**
   * Internal function to register callbacks that should be invoked
   * when directive instance is being destroyed.
   * @internal
   */
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  /**
   * Internal function to invoke all registered "on destroy" callbacks.
   * Note: calling this function also clears the list of callbacks.
   * @internal
   */
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  /**
   * @description
   * Resets the control with the provided value if the control is present.
   */
  reset(value = void 0) {
    if (this.control)
      this.control.reset(value);
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  /**
   * @description
   * The top-level form directive for the control.
   */
  get formDirective() {
    return null;
  }
  /**
   * @description
   * The path to this group.
   */
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  constructor() {
    super(...arguments);
    this._parent = null;
    this.name = null;
    this.valueAccessor = null;
  }
};
var AbstractControlStatus = class {
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {
  "[class.ng-submitted]": "isSubmitted"
});
var _NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatus.ɵfac = function NgControlStatus_Factory(t) {
  return new (t || _NgControlStatus)(ɵɵdirectiveInject(NgControl, 2));
};
_NgControlStatus.ɵdir = ɵɵdefineDirective({
  type: _NgControlStatus,
  selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
  hostVars: 14,
  hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
var NgControlStatus = _NgControlStatus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var _NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
};
_NgControlStatusGroup.ɵfac = function NgControlStatusGroup_Factory(t) {
  return new (t || _NgControlStatusGroup)(ɵɵdirectiveInject(ControlContainer, 10));
};
_NgControlStatusGroup.ɵdir = ɵɵdefineDirective({
  type: _NgControlStatusGroup,
  selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
  hostVars: 16,
  hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
var NgControlStatusGroup = _NgControlStatusGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
      host: ngGroupStatusHost
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException() {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  /**
   * Initialize the AbstractControl instance.
   *
   * @param validators The function or array of functions that is used to determine the validity of
   *     this control synchronously.
   * @param asyncValidators The function or array of functions that is used to determine validity of
   *     this control asynchronously.
   */
  constructor(validators, asyncValidators) {
    this._pendingDirty = false;
    this._hasOwnPendingAsyncValidator = false;
    this._pendingTouched = false;
    this._onCollectionChange = () => {
    };
    this._parent = null;
    this.pristine = true;
    this.touched = false;
    this._onDisabledChange = [];
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  /**
   * Returns the function that is used to determine the validity of this control synchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  /**
   * Returns the function that is used to determine the validity of this control asynchronously.
   * If multiple validators have been added, this will be a single composed function.
   * See `Validators.compose()` for additional information.
   */
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  /**
   * The parent control.
   */
  get parent() {
    return this._parent;
  }
  /**
   * A control is `valid` when its `status` is `VALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control has passed all of its validation tests,
   * false otherwise.
   */
  get valid() {
    return this.status === VALID;
  }
  /**
   * A control is `invalid` when its `status` is `INVALID`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control has failed one or more of its validation checks,
   * false otherwise.
   */
  get invalid() {
    return this.status === INVALID;
  }
  /**
   * A control is `pending` when its `status` is `PENDING`.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if this control is in the process of conducting a validation check,
   * false otherwise.
   */
  get pending() {
    return this.status == PENDING;
  }
  /**
   * A control is `disabled` when its `status` is `DISABLED`.
   *
   * Disabled controls are exempt from validation checks and
   * are not included in the aggregate value of their ancestor
   * controls.
   *
   * @see {@link AbstractControl.status}
   *
   * @returns True if the control is disabled, false otherwise.
   */
  get disabled() {
    return this.status === DISABLED;
  }
  /**
   * A control is `enabled` as long as its `status` is not `DISABLED`.
   *
   * @returns True if the control has any status other than 'DISABLED',
   * false if the status is 'DISABLED'.
   *
   * @see {@link AbstractControl.status}
   *
   */
  get enabled() {
    return this.status !== DISABLED;
  }
  /**
   * A control is `dirty` if the user has changed the value
   * in the UI.
   *
   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
   * Programmatic changes to a control's value do not mark it dirty.
   */
  get dirty() {
    return !this.pristine;
  }
  /**
   * True if the control has not been marked as touched
   *
   * A control is `untouched` if the user has not yet triggered
   * a `blur` event on it.
   */
  get untouched() {
    return !this.touched;
  }
  /**
   * Reports the update strategy of the `AbstractControl` (meaning
   * the event on which the control updates itself).
   * Possible values: `'change'` | `'blur'` | `'submit'`
   * Default value: `'change'`
   */
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  /**
   * Sets the synchronous validators that are active on this control.  Calling
   * this overwrites any existing synchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addValidators()` method instead.
   */
  setValidators(validators) {
    this._assignValidators(validators);
  }
  /**
   * Sets the asynchronous validators that are active on this control. Calling this
   * overwrites any existing asynchronous validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * If you want to add a new validator without affecting existing ones, consider
   * using `addAsyncValidators()` method instead.
   */
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  /**
   * Add a synchronous validator or validators to this control, without affecting other validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect. If duplicate validator functions
   * are present in the `validators` array, only the first instance would be added to a form
   * control.
   *
   * @param validators The new validator function or functions to add to this control.
   */
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  /**
   * Add an asynchronous validator or validators to this control, without affecting other
   * validators.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * Adding a validator that already exists will have no effect.
   *
   * @param validators The new asynchronous validator function or functions to add to this control.
   */
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Remove a synchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found,
   * it is ignored.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<string | null>('', Validators.required);
   * ctrl.removeValidators(Validators.required);
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<string | null>('', minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   *
   * ctrl.removeValidators(minValidator);
   * ```
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The validator or validators to remove.
   */
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  /**
   * Remove an asynchronous validator from this control, without affecting other validators.
   * Validators are compared by function reference; you must pass a reference to the exact same
   * validator function as the one that was originally set. If a provided validator is not found, it
   * is ignored.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   * @param validators The asynchronous validator or validators to remove.
   */
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  /**
   * Check whether a synchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @usageNotes
   *
   * ### Reference to a ValidatorFn
   *
   * ```
   * // Reference to the RequiredValidator
   * const ctrl = new FormControl<number | null>(0, Validators.required);
   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
   *
   * // Reference to anonymous function inside MinValidator
   * const minValidator = Validators.min(3);
   * const ctrl = new FormControl<number | null>(0, minValidator);
   * expect(ctrl.hasValidator(minValidator)).toEqual(true)
   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
   * ```
   *
   * @param validator The validator to check for presence. Compared by function reference.
   * @returns Whether the provided validator was found on this control.
   */
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  /**
   * Check whether an asynchronous validator function is present on this control. The provided
   * validator must be a reference to the exact same function that was provided.
   *
   * @param validator The asynchronous validator to check for presence. Compared by function
   *     reference.
   * @returns Whether the provided asynchronous validator was found on this control.
   */
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  /**
   * Empties out the synchronous validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearValidators() {
    this.validator = null;
  }
  /**
   * Empties out the async validator list.
   *
   * When you add or remove a validator at run time, you must call
   * `updateValueAndValidity()` for the new validation to take effect.
   *
   */
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  /**
   * Marks the control as `touched`. A control is touched by focus and
   * blur events that do not change the value.
   *
   * @see {@link markAsUntouched()}
   * @see {@link markAsDirty()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsTouched(opts = {}) {
    this.touched = true;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(opts);
    }
  }
  /**
   * Marks the control and all its descendant controls as `touched`.
   * @see {@link markAsTouched()}
   */
  markAllAsTouched() {
    this.markAsTouched({
      onlySelf: true
    });
    this._forEachChild((control) => control.markAllAsTouched());
  }
  /**
   * Marks the control as `untouched`.
   *
   * If the control has any children, also marks all children as `untouched`
   * and recalculates the `touched` status of all parent controls.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsDirty()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after the marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsUntouched(opts = {}) {
    this.touched = false;
    this._pendingTouched = false;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /**
   * Marks the control as `dirty`. A control becomes dirty when
   * the control's value is changed through the UI; compare `markAsTouched`.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsUntouched()}
   * @see {@link markAsPristine()}
   *
   * @param opts Configuration options that determine how the control propagates changes
   * and emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsDirty(opts = {}) {
    this.pristine = false;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(opts);
    }
  }
  /**
   * Marks the control as `pristine`.
   *
   * If the control has any children, marks all children as `pristine`,
   * and recalculates the `pristine` status of all parent
   * controls.
   *
   * @see {@link markAsTouched()}
   * @see {@link markAsUntouched()}
   * @see {@link markAsDirty()}
   *
   * @param opts Configuration options that determine how the control emits events after
   * marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   */
  markAsPristine(opts = {}) {
    this.pristine = true;
    this._pendingDirty = false;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /**
   * Marks the control as `pending`.
   *
   * A control is pending while the control performs async validation.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates changes and
   * emits events after marking is applied.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event with the latest status the control is marked pending.
   * When false, no events are emitted.
   *
   */
  markAsPending(opts = {}) {
    this.status = PENDING;
    if (opts.emitEvent !== false) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(opts);
    }
  }
  /**
   * Disables the control. This means the control is exempt from validation checks and
   * excluded from the aggregate value of any parent. Its status is `DISABLED`.
   *
   * If the control has children, all children are also disabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control is disabled.
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is disabled.
   * When false, no events are emitted.
   */
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  /**
   * Enables the control. This means the control is included in validation checks and
   * the aggregate value of its parent. Its status recalculates based on its value and
   * its validators.
   *
   * By default, if the control has children, all children are enabled.
   *
   * @see {@link AbstractControl.status}
   *
   * @param opts Configure options that control how the control propagates changes and
   * emits events when marked as untouched
   * * `onlySelf`: When true, mark only this control. When false or not supplied,
   * marks all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is enabled.
   * When false, no events are emitted.
   */
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }));
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine();
      }
      this._parent._updateTouched();
    }
  }
  /**
   * Sets the parent of the control
   *
   * @param parent The new parent.
   */
  setParent(parent) {
    this._parent = parent;
  }
  /**
   * The raw value of this control. For most control implementations, the raw value will include
   * disabled children.
   */
  getRawValue() {
    return this.value;
  }
  /**
   * Recalculates the value and validation status of the control.
   *
   * By default, it also updates the value and validity of its ancestors.
   *
   * @param opts Configuration options determine how the control propagates changes and emits events
   * after updates and validity checks are applied.
   * * `onlySelf`: When true, only update this control. When false or not supplied,
   * update all direct ancestors. Default is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is updated.
   * When false, no events are emitted.
   */
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(opts.emitEvent);
      }
    }
    if (opts.emitEvent !== false) {
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
    }
  }
  /** @internal */
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = true;
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = false;
        this.setErrors(errors, {
          emitEvent
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      this._hasOwnPendingAsyncValidator = false;
    }
  }
  /**
   * Sets errors on a form control when running validations manually, rather than automatically.
   *
   * Calling `setErrors` also updates the validity of the parent control.
   *
   * @param opts Configuration options that determine how the control propagates
   * changes and emits events after the control errors are set.
   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
   * observable emits an event after the errors are set.
   *
   * @usageNotes
   *
   * ### Manually set the errors for a control
   *
   * ```
   * const login = new FormControl('someLogin');
   * login.setErrors({
   *   notUnique: true
   * });
   *
   * expect(login.valid).toEqual(false);
   * expect(login.errors).toEqual({ notUnique: true });
   *
   * login.setValue('someOtherLogin');
   *
   * expect(login.valid).toEqual(true);
   * ```
   */
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false);
  }
  /**
   * Retrieves a child control given the control's name or path.
   *
   * @param path A dot-delimited string or array of string/number values that define the path to the
   * control. If a string is provided, passing it as a string literal will result in improved type
   * information. Likewise, if an array is provided, passing it `as const` will cause improved type
   * information to be available.
   *
   * @usageNotes
   * ### Retrieve a nested control
   *
   * For example, to get a `name` control nested within a `person` sub-group:
   *
   * * `this.form.get('person.name');`
   *
   * -OR-
   *
   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
   *
   * ### Retrieve a control in a FormArray
   *
   * When accessing an element inside a FormArray, you can use an element index.
   * For example, to get a `price` control from the first element in an `items` array you can use:
   *
   * * `this.form.get('items.0.price');`
   *
   * -OR-
   *
   * * `this.form.get(['items', 0, 'price']);`
   */
  get(path) {
    let currPath = path;
    if (currPath == null)
      return null;
    if (!Array.isArray(currPath))
      currPath = currPath.split(".");
    if (currPath.length === 0)
      return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  /**
   * @description
   * Reports error data for the control with the given path.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * @returns error data for that particular error. If the control or error is not present,
   * null is returned.
   */
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  /**
   * @description
   * Reports whether the control with the given path has the error specified.
   *
   * @param errorCode The code of the error to check
   * @param path A list of control names that designates how to move from the current control
   * to the control that should be queried for errors.
   *
   * @usageNotes
   * For example, for the following `FormGroup`:
   *
   * ```
   * form = new FormGroup({
   *   address: new FormGroup({ street: new FormControl() })
   * });
   * ```
   *
   * The path to the 'street' control from the root form would be 'address' -> 'street'.
   *
   * It can be provided to this method in one of two formats:
   *
   * 1. An array of string control names, e.g. `['address', 'street']`
   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
   *
   * If no path is given, this method checks for the error on the current control.
   *
   * @returns whether the given error is present in the control at the given path.
   *
   * If the control is not present, false is returned.
   */
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  /**
   * Retrieves the top-level ancestor of this control.
   */
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  /** @internal */
  _updateControlsErrors(emitEvent) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent);
    }
  }
  /** @internal */
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled())
      return DISABLED;
    if (this.errors)
      return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))
      return PENDING;
    if (this._anyControlsHaveStatus(INVALID))
      return INVALID;
    return VALID;
  }
  /** @internal */
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  /** @internal */
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  /** @internal */
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  /** @internal */
  _updatePristine(opts = {}) {
    this.pristine = !this._anyControlsDirty();
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts);
    }
  }
  /** @internal */
  _updateTouched(opts = {}) {
    this.touched = this._anyControlsTouched();
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts);
    }
  }
  /** @internal */
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  /** @internal */
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  /**
   * Check to see if parent has been marked artificially dirty.
   *
   * @internal
   */
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  /** @internal */
  _find(name) {
    return null;
  }
  /**
   * Internal implementation of the `setValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  /**
   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
   * different method, because it is called in the constructor and it can break cases where
   * a control is extended.
   */
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  /**
   * Creates a new `FormGroup` instance.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
      // so we set `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  registerControl(name, control) {
    if (this.controls[name])
      return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Remove a control from this group. In a strongly-typed group, required controls cannot be
   * removed.
   *
   * This method also updates the value and validity of the control.
   *
   * @param name The control name to remove from the collection
   * @param options Specifies whether this FormGroup instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeControl(name, options = {}) {
    if (this.controls[name])
      this.controls[name]._registerOnCollectionChange(() => {
      });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name])
      this.controls[name]._registerOnCollectionChange(() => {
      });
    delete this.controls[name];
    if (control)
      this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  /**
   * Sets the value of the `FormGroup`. It accepts an object that matches
   * the structure of the group, with control names as keys.
   *
   * @usageNotes
   * ### Set the complete value for the form group
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl(),
   *   last: new FormControl()
   * });
   *
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.setValue({first: 'Nancy', last: 'Drew'});
   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
   * ```
   *
   * @throws When strict checks fail, such as setting the value of a control
   * that doesn't exist or if you exclude a value of a control that does exist.
   *
   * @param value The new value for the control that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes
   * and emits events after the value changes.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormGroup`. It accepts an object with control
   * names as keys, and does its best to match the values to the correct controls
   * in the group.
   *
   * It accepts both super-sets and sub-sets of the group without throwing an error.
   *
   * @usageNotes
   * ### Patch the value for a form group
   *
   * ```
   * const form = new FormGroup({
   *    first: new FormControl(),
   *    last: new FormControl()
   * });
   * console.log(form.value);   // {first: null, last: null}
   *
   * form.patchValue({first: 'Nancy'});
   * console.log(form.value);   // {first: 'Nancy', last: null}
   * ```
   *
   * @param value The object that matches the structure of the group.
   * @param options Configuration options that determine how the control propagates changes and
   * emits events after the value is patched.
   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
   * true.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control value
   * is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null)
      return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(
          /* Guaranteed to be present, due to the outer forEach. */
          value[name],
          {
            onlySelf: true,
            emitEvent: options.emitEvent
          }
        );
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
   * the value of all descendants to their default values, or null if no defaults were provided.
   *
   * You reset to a specific form state by passing in a map of states
   * that matches the structure of your form, with control names as keys. The state
   * is a standalone value or a form state object with both a value and a disabled
   * status.
   *
   * @param value Resets the control with an initial value,
   * or an object that defines the initial value and disabled state.
   *
   * @param options Configuration options that determine how the control propagates changes
   * and emits events when the group is reset.
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
   * false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   *
   * @usageNotes
   *
   * ### Reset the form group values
   *
   * ```ts
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * console.log(form.value);  // {first: 'first name', last: 'last name'}
   *
   * form.reset({ first: 'name', last: 'last name' });
   *
   * console.log(form.value);  // {first: 'name', last: 'last name'}
   * ```
   *
   * ### Reset the form group values and disabled status
   *
   * ```
   * const form = new FormGroup({
   *   first: new FormControl('first name'),
   *   last: new FormControl('last name')
   * });
   *
   * form.reset({
   *   first: {value: 'name', disabled: true},
   *   last: 'last'
   * });
   *
   * console.log(form.value);  // {last: 'last'}
   * console.log(form.get('first').status);  // 'DISABLED'
   * ```
   */
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the `FormGroup`, including any disabled controls.
   *
   * Retrieves all values regardless of disabled status.
   */
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated)
      this.updateValueAndValidity({
        onlySelf: true
      });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this._reduceValue();
  }
  /** @internal */
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  /** @internal */
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  /** @internal */
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  /** @internal */
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  /** @internal */
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken("CallSetDisabledState", {
  providedIn: "root",
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control)
      _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor)
      _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop);
    dir.valueAccessor.registerOnTouched(noop);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange)
      validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop);
  registerOnValidatorChange(dir._rawAsyncValidators, noop);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change")
      updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange)
      updateControl(control, dir);
    if (control.updateOn !== "submit")
      control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty)
    control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent)
      dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode))
    _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1)
    return `path: '${path.join(" -> ")}'`;
  if (path?.[0])
    return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model"))
    return false;
  const change = changes["model"];
  if (change.isFirstChange())
    return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors)
    return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode))
    _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode))
        _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode))
        _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor)
    return customAccessor;
  if (builtinAccessor)
    return builtinAccessor;
  if (defaultAccessor)
    return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list, el) {
  const index = list.indexOf(el);
  if (index > -1)
    list.splice(index, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never")
    return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var _NgForm = class _NgForm extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._directives = /* @__PURE__ */ new Set();
    this.ngSubmit = new EventEmitter();
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  /** @nodoc */
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  /**
   * @description
   * The directive instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * The internal `FormGroup` instance.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it is always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Returns a map of the controls in this group.
   */
  get controls() {
    return this.form.controls;
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `NgModel` directive instance.
   */
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `NgModel` directive.
   *
   * @param dir The `NgModel` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `NgModel` instance from the internal list of directives
   *
   * @param dir The `NgModel` directive instance.
   */
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  /**
   * @description
   * Adds a new `NgModelGroup` directive instance to the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group2 = new FormGroup({});
      setUpFormContainer(group2, dir);
      container.registerControl(dir.name, group2);
      group2.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  /**
   * @description
   * Removes the `NgModelGroup` directive instance from the form.
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
   *
   * @param dir The `NgModelGroup` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `NgControl` directive.
   *
   * @param dir The `NgControl` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  /**
   * @description
   * Sets the value for this `FormGroup`.
   *
   * @param value The new value
   */
  setValue(value) {
    this.control.setValue(value);
  }
  /**
   * @description
   * Method called when the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
};
_NgForm.ɵfac = function NgForm_Factory(t) {
  return new (t || _NgForm)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgForm.ɵdir = ɵɵdefineDirective({
  type: _NgForm,
  selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]],
  hostBindings: function NgForm_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("submit", function NgForm_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function NgForm_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    options: [InputFlags.None, "ngFormOptions", "options"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [ɵɵProvidersFeature([formDirectiveProvider$1]), ɵɵInheritDefinitionFeature]
});
var NgForm = _NgForm;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list, el) {
  const index = list.indexOf(el);
  if (index > -1)
    list.splice(index, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.defaultValue = null;
    this._onChange = [];
    this._pendingChange = false;
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set
      // `emitEvent` to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    this._pendingChange = false;
  }
  /**  @internal */
  _updateValue() {
  }
  /**  @internal */
  _anyControls(condition) {
    return false;
  }
  /**  @internal */
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  /** @internal */
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  /** @internal */
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  /** @internal */
  _forEachChild(cb) {
  }
  /** @internal */
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty)
        this.markAsDirty();
      if (this._pendingTouched)
        this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var _AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  /** @nodoc */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  /**
   * @description
   * The `FormGroup` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  /**
   * @description
   * The path to this group from the top-level directive.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /** @internal */
  _checkParentType() {
  }
};
_AbstractFormGroupDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵAbstractFormGroupDirective_BaseFactory;
  return function AbstractFormGroupDirective_Factory(t) {
    return (ɵAbstractFormGroupDirective_BaseFactory || (ɵAbstractFormGroupDirective_BaseFactory = ɵɵgetInheritedFactory(_AbstractFormGroupDirective)))(t || _AbstractFormGroupDirective);
  };
})();
_AbstractFormGroupDirective.ɵdir = ɵɵdefineDirective({
  type: _AbstractFormGroupDirective,
  features: [ɵɵInheritDefinitionFeature]
});
var AbstractFormGroupDirective = _AbstractFormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var _NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = "";
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
};
_NgModelGroup.ɵfac = function NgModelGroup_Factory(t) {
  return new (t || _NgModelGroup)(ɵɵdirectiveInject(ControlContainer, 5), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
};
_NgModelGroup.ɵdir = ɵɵdefineDirective({
  type: _NgModelGroup,
  selectors: [["", "ngModelGroup", ""]],
  inputs: {
    name: [InputFlags.None, "ngModelGroup", "name"]
  },
  exportAs: ["ngModelGroup"],
  features: [ɵɵProvidersFeature([modelGroupProvider]), ɵɵInheritDefinitionFeature]
});
var NgModelGroup = _NgModelGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var _NgModel = class _NgModel extends NgControl {
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this.control = new FormControl();
    this._registered = false;
    this.name = "";
    this.update = new EventEmitter();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return this._getPath(this.name);
  }
  /**
   * @description
   * The top-level directive for this control if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value emitted by `ngModelChange`.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if (!this._isStandalone()) {
      this._checkParentType();
    }
    this._checkName();
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof NgModelGroup) && this._parent instanceof AbstractFormGroupDirective) {
        throw formGroupNameException();
      } else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
        throw modelParentException();
      }
    }
  }
  _checkName() {
    if (this.options && this.options.name)
      this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
};
_NgModel.ɵfac = function NgModel_Factory(t) {
  return new (t || _NgModel)(ɵɵdirectiveInject(ControlContainer, 9), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(ChangeDetectorRef, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
};
_NgModel.ɵdir = ɵɵdefineDirective({
  type: _NgModel,
  selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
  inputs: {
    name: "name",
    isDisabled: [InputFlags.None, "disabled", "isDisabled"],
    model: [InputFlags.None, "ngModel", "model"],
    options: [InputFlags.None, "ngModelOptions", "options"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngModel"],
  features: [ɵɵProvidersFeature([formControlBinding$1]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NgModel = _NgModel;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel"
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var _ɵNgNoValidate = class _ɵNgNoValidate {
};
_ɵNgNoValidate.ɵfac = function ɵNgNoValidate_Factory(t) {
  return new (t || _ɵNgNoValidate)();
};
_ɵNgNoValidate.ɵdir = ɵɵdefineDirective({
  type: _ɵNgNoValidate,
  selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
  hostAttrs: ["novalidate", ""]
});
var ɵNgNoValidate = _ɵNgNoValidate;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      }
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var _NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_NumberValueAccessor.ɵfac = /* @__PURE__ */ (() => {
  let ɵNumberValueAccessor_BaseFactory;
  return function NumberValueAccessor_Factory(t) {
    return (ɵNumberValueAccessor_BaseFactory || (ɵNumberValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_NumberValueAccessor)))(t || _NumberValueAccessor);
  };
})();
_NumberValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _NumberValueAccessor,
  selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
  hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [ɵɵProvidersFeature([NUMBER_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var NumberValueAccessor = _NumberValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var _RadioControlRegistry = class _RadioControlRegistry {
  constructor() {
    this._accessors = [];
  }
  /**
   * @description
   * Adds a control to the internal registry. For internal use only.
   */
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  /**
   * @description
   * Removes a control from the internal registry. For internal use only.
   */
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  /**
   * @description
   * Selects a radio button. For internal use only.
   */
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control)
      return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
};
_RadioControlRegistry.ɵfac = function RadioControlRegistry_Factory(t) {
  return new (t || _RadioControlRegistry)();
};
_RadioControlRegistry.ɵprov = ɵɵdefineInjectable({
  token: _RadioControlRegistry,
  factory: _RadioControlRegistry.ɵfac,
  providedIn: "root"
});
var RadioControlRegistry = _RadioControlRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
    this.setDisabledStateFired = false;
    this.onChange = () => {
    };
    this.callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
      optional: true
    }) ?? setDisabledStateDefault;
  }
  /** @nodoc */
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  /** @nodoc */
  ngOnDestroy() {
    this._registry.remove(this);
  }
  /**
   * Sets the "checked" property value on the radio input element.
   * @nodoc
   */
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  /** @nodoc */
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  /**
   * Sets the "value" on the radio input element and unchecks it.
   *
   * @param value
   */
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName)
      this.name = this.formControlName;
  }
};
_RadioControlValueAccessor.ɵfac = function RadioControlValueAccessor_Factory(t) {
  return new (t || _RadioControlValueAccessor)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(RadioControlRegistry), ɵɵdirectiveInject(Injector));
};
_RadioControlValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _RadioControlValueAccessor,
  selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
  hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
        return ctx.onChange();
      })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    name: "name",
    formControlName: "formControlName",
    value: "value"
  },
  features: [ɵɵProvidersFeature([RADIO_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var RadioControlValueAccessor = _RadioControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var _RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  /**
   * Sets the "value" property on the input element.
   * @nodoc
   */
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
};
_RangeValueAccessor.ɵfac = /* @__PURE__ */ (() => {
  let ɵRangeValueAccessor_BaseFactory;
  return function RangeValueAccessor_Factory(t) {
    return (ɵRangeValueAccessor_BaseFactory || (ɵRangeValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_RangeValueAccessor)))(t || _RangeValueAccessor);
  };
})();
_RangeValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _RangeValueAccessor,
  selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
  hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  features: [ɵɵProvidersFeature([RANGE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var RangeValueAccessor = _RangeValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(input)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR]
    }]
  }], null, null);
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var _FormControlDirective = class _FormControlDirective extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(
          previousForm,
          this,
          /* validateControlPresenceOnChange */
          false
        );
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(
        this.form,
        this,
        /* validateControlPresenceOnChange */
        false
      );
    }
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * The `FormControl` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
};
_FormControlDirective._ngModelWarningSentOnce = false;
_FormControlDirective.ɵfac = function FormControlDirective_Factory(t) {
  return new (t || _FormControlDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormControlDirective.ɵdir = ɵɵdefineDirective({
  type: _FormControlDirective,
  selectors: [["", "formControl", ""]],
  inputs: {
    form: [InputFlags.None, "formControl", "form"],
    isDisabled: [InputFlags.None, "disabled", "isDisabled"],
    model: [InputFlags.None, "ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  exportAs: ["ngForm"],
  features: [ɵɵProvidersFeature([formControlBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var FormControlDirective = _FormControlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var _FormGroupDirective = class _FormGroupDirective extends ControlContainer {
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.submitted = false;
    this._onCollectionChange = () => this._updateDomValue();
    this.directives = [];
    this.form = null;
    this.ngSubmit = new EventEmitter();
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  /**
   * @description
   * Returns this directive's instance.
   */
  get formDirective() {
    return this;
  }
  /**
   * @description
   * Returns the `FormGroup` bound to this directive.
   */
  get control() {
    return this.form;
  }
  /**
   * @description
   * Returns an array representing the path to this group. Because this directive
   * always lives at the top level of a form, it always an empty array.
   */
  get path() {
    return [];
  }
  /**
   * @description
   * Method that sets up the control directive in this group, re-calculates its value
   * and validity, and adds the instance to the internal list of directives.
   *
   * @param dir The `FormControlName` directive instance.
   */
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  /**
   * @description
   * Retrieves the `FormControl` instance from the provided `FormControlName` directive
   *
   * @param dir The `FormControlName` directive instance.
   */
  getControl(dir) {
    return this.form.get(dir.path);
  }
  /**
   * @description
   * Removes the `FormControlName` instance from the internal list of directives
   *
   * @param dir The `FormControlName` directive instance.
   */
  removeControl(dir) {
    cleanUpControl(
      dir.control || null,
      dir,
      /* validateControlPresenceOnChange */
      false
    );
    removeListItem$1(this.directives, dir);
  }
  /**
   * Adds a new `FormGroupName` directive instance to the form.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormGroupName` directive instance.
   */
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
   *
   * @param dir The `FormGroupName` directive instance.
   */
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  /**
   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
   * view.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  /**
   * @description
   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
   *
   * @param dir The `FormArrayName` directive instance.
   */
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  /**
   * Sets the new value for the provided `FormControlName` directive.
   *
   * @param dir The `FormControlName` directive instance.
   * @param value The new value for the directive's control.
   */
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  /**
   * @description
   * Method called with the "submit" event is triggered on the form.
   * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
   *
   * @param $event The "submit" event object
   */
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    return $event?.target?.method === "dialog";
  }
  /**
   * @description
   * Method called when the "reset" event is triggered on the form.
   */
  onReset() {
    this.resetForm();
  }
  /**
   * @description
   * Resets the form to an initial value and resets its submitted status.
   *
   * @param value The new value for the form.
   */
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submitted = false;
  }
  /** @internal */
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
};
_FormGroupDirective.ɵfac = function FormGroupDirective_Factory(t) {
  return new (t || _FormGroupDirective)(ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(CALL_SET_DISABLED_STATE, 8));
};
_FormGroupDirective.ɵdir = ɵɵdefineDirective({
  type: _FormGroupDirective,
  selectors: [["", "formGroup", ""]],
  hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
        return ctx.onSubmit($event);
      })("reset", function FormGroupDirective_reset_HostBindingHandler() {
        return ctx.onReset();
      });
    }
  },
  inputs: {
    form: [InputFlags.None, "formGroup", "form"]
  },
  outputs: {
    ngSubmit: "ngSubmit"
  },
  exportAs: ["ngForm"],
  features: [ɵɵProvidersFeature([formDirectiveProvider]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var FormGroupDirective = _FormGroupDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var _FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /** @internal */
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
};
_FormGroupName.ɵfac = function FormGroupName_Factory(t) {
  return new (t || _FormGroupName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormGroupName.ɵdir = ɵɵdefineDirective({
  type: _FormGroupName,
  selectors: [["", "formGroupName", ""]],
  inputs: {
    name: [InputFlags.None, "formGroupName", "name"]
  },
  features: [ɵɵProvidersFeature([formGroupNameProvider]), ɵɵInheritDefinitionFeature]
});
var FormGroupName = _FormGroupName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var _FormArrayName = class _FormArrayName extends ControlContainer {
  constructor(parent, validators, asyncValidators) {
    super();
    this.name = null;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  /**
   * A lifecycle method called when the directive's inputs are initialized. For internal use only.
   * @throws If the directive does not have a valid parent.
   * @nodoc
   */
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormArray(this);
  }
  /**
   * A lifecycle method called before the directive's instance is destroyed. For internal use only.
   * @nodoc
   */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormArray(this);
    }
  }
  /**
   * @description
   * The `FormArray` bound to this directive.
   */
  get control() {
    return this.formDirective.getFormArray(this);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  _checkParentType() {
    if (_hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
  }
};
_FormArrayName.ɵfac = function FormArrayName_Factory(t) {
  return new (t || _FormArrayName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10));
};
_FormArrayName.ɵdir = ɵɵdefineDirective({
  type: _FormArrayName,
  selectors: [["", "formArrayName", ""]],
  inputs: {
    name: [InputFlags.None, "formArrayName", "name"]
  },
  features: [ɵɵProvidersFeature([formArrayNameProvider]), ɵɵInheritDefinitionFeature]
});
var FormArrayName = _FormArrayName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function _hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var _FormControlName = class _FormControlName extends NgControl {
  /**
   * @description
   * Triggers a warning in dev mode that this input should not be used with reactive forms.
   */
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._added = false;
    this.name = null;
    this.update = new EventEmitter();
    this._ngModelWarningSent = false;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (!this._added)
      this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  /**
   * @description
   * Sets the new value for the view model and emits an `ngModelChange` event.
   *
   * @param newValue The new value for the view model.
   */
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  /**
   * @description
   * Returns an array that represents the path from the top-level form to this control.
   * Each index is the string name of the control on that level.
   */
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  /**
   * @description
   * The top-level directive for this group if present, otherwise null.
   */
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!(this._parent instanceof FormGroupName) && this._parent instanceof AbstractFormGroupDirective) {
        throw ngModelGroupException();
      } else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) && !(this._parent instanceof FormArrayName)) {
        throw controlParentException();
      }
    }
  }
  _setUpControl() {
    this._checkParentType();
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
};
_FormControlName._ngModelWarningSentOnce = false;
_FormControlName.ɵfac = function FormControlName_Factory(t) {
  return new (t || _FormControlName)(ɵɵdirectiveInject(ControlContainer, 13), ɵɵdirectiveInject(NG_VALIDATORS, 10), ɵɵdirectiveInject(NG_ASYNC_VALIDATORS, 10), ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10), ɵɵdirectiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
};
_FormControlName.ɵdir = ɵɵdefineDirective({
  type: _FormControlName,
  selectors: [["", "formControlName", ""]],
  inputs: {
    name: [InputFlags.None, "formControlName", "name"],
    isDisabled: [InputFlags.None, "disabled", "isDisabled"],
    model: [InputFlags.None, "ngModel", "model"]
  },
  outputs: {
    update: "ngModelChange"
  },
  features: [ɵɵProvidersFeature([controlNameBinding]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var FormControlName = _FormControlName;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding]
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null)
    return `${value}`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var _SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on the select element.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  /**
   * Registers a function called when the control value changes.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  /** @internal */
  _registerOption() {
    return (this._idCounter++).toString();
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value))
        return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
};
_SelectControlValueAccessor.ɵfac = /* @__PURE__ */ (() => {
  let ɵSelectControlValueAccessor_BaseFactory;
  return function SelectControlValueAccessor_Factory(t) {
    return (ɵSelectControlValueAccessor_BaseFactory || (ɵSelectControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectControlValueAccessor)))(t || _SelectControlValueAccessor);
  };
})();
_SelectControlValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _SelectControlValueAccessor,
  selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
  hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target.value);
      })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [ɵɵProvidersFeature([SELECT_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var SelectControlValueAccessor = _SelectControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($event.target.value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _NgSelectOption = class _NgSelectOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select)
      this.id = this._select._registerOption();
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null)
      return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    this._setElementValue(value);
    if (this._select)
      this._select.writeValue(this._select.value);
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_NgSelectOption.ɵfac = function NgSelectOption_Factory(t) {
  return new (t || _NgSelectOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectControlValueAccessor, 9));
};
_NgSelectOption.ɵdir = ɵɵdefineDirective({
  type: _NgSelectOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var NgSelectOption = _NgSelectOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null)
    return `${value}`;
  if (typeof value === "string")
    value = `'${value}'`;
  if (value && typeof value === "object")
    value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var _SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  constructor() {
    super(...arguments);
    this._optionMap = /* @__PURE__ */ new Map();
    this._idCounter = 0;
    this._compareWith = Object.is;
  }
  /**
   * @description
   * Tracks the option comparison algorithm for tracking identities when
   * checking for changes.
   */
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  /**
   * Sets the "value" property on one or of more of the select's options.
   * @nodoc
   */
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  /**
   * Registers a function called when the control value changes
   * and writes an array of the selected options.
   * @nodoc
   */
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  /** @internal */
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  /** @internal */
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value))
        return id;
    }
    return null;
  }
  /** @internal */
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
};
_SelectMultipleControlValueAccessor.ɵfac = /* @__PURE__ */ (() => {
  let ɵSelectMultipleControlValueAccessor_BaseFactory;
  return function SelectMultipleControlValueAccessor_Factory(t) {
    return (ɵSelectMultipleControlValueAccessor_BaseFactory || (ɵSelectMultipleControlValueAccessor_BaseFactory = ɵɵgetInheritedFactory(_SelectMultipleControlValueAccessor)))(t || _SelectMultipleControlValueAccessor);
  };
})();
_SelectMultipleControlValueAccessor.ɵdir = ɵɵdefineDirective({
  type: _SelectMultipleControlValueAccessor,
  selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
  hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
        return ctx.onChange($event.target);
      })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
        return ctx.onTouched();
      });
    }
  },
  inputs: {
    compareWith: "compareWith"
  },
  features: [ɵɵProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature]
});
var SelectMultipleControlValueAccessor = _SelectMultipleControlValueAccessor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var _ɵNgSelectMultipleOption = class _ɵNgSelectMultipleOption {
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  /**
   * @description
   * Tracks the value bound to the option element. Unlike the value binding,
   * ngValue supports binding to objects.
   */
  set ngValue(value) {
    if (this._select == null)
      return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  /**
   * @description
   * Tracks simple string values bound to the option element.
   * For objects, use the `ngValue` input binding.
   */
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  /** @internal */
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  /** @internal */
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  /** @nodoc */
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
};
_ɵNgSelectMultipleOption.ɵfac = function ɵNgSelectMultipleOption_Factory(t) {
  return new (t || _ɵNgSelectMultipleOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(SelectMultipleControlValueAccessor, 9));
};
_ɵNgSelectMultipleOption.ɵdir = ɵɵdefineDirective({
  type: _ɵNgSelectMultipleOption,
  selectors: [["option"]],
  inputs: {
    ngValue: "ngValue",
    value: "value"
  }
});
var ɵNgSelectMultipleOption = _ɵNgSelectMultipleOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵNgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var _AbstractValidatorDirective = class _AbstractValidatorDirective {
  constructor() {
    this._validator = nullValidator;
  }
  /** @nodoc */
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input);
      this._validator = this._enabled ? this.createValidator(input) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  /** @nodoc */
  validate(control) {
    return this._validator(control);
  }
  /** @nodoc */
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  /**
   * @description
   * Determines whether this validator should be active or not based on an input.
   * Base class implementation checks whether an input is defined (if the value is different from
   * `null` and `undefined`). Validator classes that extend this base class can override this
   * function with the logic specific to a particular validator directive.
   */
  enabled(input) {
    return input != null;
  }
};
_AbstractValidatorDirective.ɵfac = function AbstractValidatorDirective_Factory(t) {
  return new (t || _AbstractValidatorDirective)();
};
_AbstractValidatorDirective.ɵdir = ɵɵdefineDirective({
  type: _AbstractValidatorDirective,
  features: [ɵɵNgOnChangesFeature]
});
var AbstractValidatorDirective = _AbstractValidatorDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var _MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "max";
    this.normalizeInput = (input) => toFloat(input);
    this.createValidator = (max) => maxValidator(max);
  }
};
_MaxValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵMaxValidator_BaseFactory;
  return function MaxValidator_Factory(t) {
    return (ɵMaxValidator_BaseFactory || (ɵMaxValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxValidator)))(t || _MaxValidator);
  };
})();
_MaxValidator.ɵdir = ɵɵdefineDirective({
  type: _MaxValidator,
  selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("max", ctx._enabled ? ctx.max : null);
    }
  },
  inputs: {
    max: "max"
  },
  features: [ɵɵProvidersFeature([MAX_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var MaxValidator = _MaxValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      }
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var _MinValidator = class _MinValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "min";
    this.normalizeInput = (input) => toFloat(input);
    this.createValidator = (min) => minValidator(min);
  }
};
_MinValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵMinValidator_BaseFactory;
  return function MinValidator_Factory(t) {
    return (ɵMinValidator_BaseFactory || (ɵMinValidator_BaseFactory = ɵɵgetInheritedFactory(_MinValidator)))(t || _MinValidator);
  };
})();
_MinValidator.ɵdir = ɵɵdefineDirective({
  type: _MinValidator,
  selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("min", ctx._enabled ? ctx.min : null);
    }
  },
  inputs: {
    min: "min"
  },
  features: [ɵɵProvidersFeature([MIN_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var MinValidator = _MinValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      }
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var _RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "required";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input) => requiredValidator;
  }
  /** @nodoc */
  enabled(input) {
    return input;
  }
};
_RequiredValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵRequiredValidator_BaseFactory;
  return function RequiredValidator_Factory(t) {
    return (ɵRequiredValidator_BaseFactory || (ɵRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_RequiredValidator)))(t || _RequiredValidator);
  };
})();
_RequiredValidator.ɵdir = ɵɵdefineDirective({
  type: _RequiredValidator,
  selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
  hostVars: 1,
  hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("required", ctx._enabled ? "" : null);
    }
  },
  inputs: {
    required: "required"
  },
  features: [ɵɵProvidersFeature([REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var RequiredValidator = _RequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var _CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  constructor() {
    super(...arguments);
    this.createValidator = (input) => requiredTrueValidator;
  }
};
_CheckboxRequiredValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵCheckboxRequiredValidator_BaseFactory;
  return function CheckboxRequiredValidator_Factory(t) {
    return (ɵCheckboxRequiredValidator_BaseFactory || (ɵCheckboxRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(_CheckboxRequiredValidator)))(t || _CheckboxRequiredValidator);
  };
})();
_CheckboxRequiredValidator.ɵdir = ɵɵdefineDirective({
  type: _CheckboxRequiredValidator,
  selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("required", ctx._enabled ? "" : null);
    }
  },
  features: [ɵɵProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var CheckboxRequiredValidator = _CheckboxRequiredValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      }
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var _EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "email";
    this.normalizeInput = booleanAttribute;
    this.createValidator = (input) => emailValidator;
  }
  /** @nodoc */
  enabled(input) {
    return input;
  }
};
_EmailValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵEmailValidator_BaseFactory;
  return function EmailValidator_Factory(t) {
    return (ɵEmailValidator_BaseFactory || (ɵEmailValidator_BaseFactory = ɵɵgetInheritedFactory(_EmailValidator)))(t || _EmailValidator);
  };
})();
_EmailValidator.ɵdir = ɵɵdefineDirective({
  type: _EmailValidator,
  selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
  inputs: {
    email: "email"
  },
  features: [ɵɵProvidersFeature([EMAIL_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var EmailValidator = _EmailValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR]
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var _MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "minlength";
    this.normalizeInput = (input) => toInteger(input);
    this.createValidator = (minlength) => minLengthValidator(minlength);
  }
};
_MinLengthValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵMinLengthValidator_BaseFactory;
  return function MinLengthValidator_Factory(t) {
    return (ɵMinLengthValidator_BaseFactory || (ɵMinLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MinLengthValidator)))(t || _MinLengthValidator);
  };
})();
_MinLengthValidator.ɵdir = ɵɵdefineDirective({
  type: _MinLengthValidator,
  selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("minlength", ctx._enabled ? ctx.minlength : null);
    }
  },
  inputs: {
    minlength: "minlength"
  },
  features: [ɵɵProvidersFeature([MIN_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var MinLengthValidator = _MinLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      }
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var _MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "maxlength";
    this.normalizeInput = (input) => toInteger(input);
    this.createValidator = (maxlength) => maxLengthValidator(maxlength);
  }
};
_MaxLengthValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵMaxLengthValidator_BaseFactory;
  return function MaxLengthValidator_Factory(t) {
    return (ɵMaxLengthValidator_BaseFactory || (ɵMaxLengthValidator_BaseFactory = ɵɵgetInheritedFactory(_MaxLengthValidator)))(t || _MaxLengthValidator);
  };
})();
_MaxLengthValidator.ɵdir = ɵɵdefineDirective({
  type: _MaxLengthValidator,
  selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("maxlength", ctx._enabled ? ctx.maxlength : null);
    }
  },
  inputs: {
    maxlength: "maxlength"
  },
  features: [ɵɵProvidersFeature([MAX_LENGTH_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var MaxLengthValidator = _MaxLengthValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      }
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var _PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  constructor() {
    super(...arguments);
    this.inputName = "pattern";
    this.normalizeInput = (input) => input;
    this.createValidator = (input) => patternValidator(input);
  }
};
_PatternValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵPatternValidator_BaseFactory;
  return function PatternValidator_Factory(t) {
    return (ɵPatternValidator_BaseFactory || (ɵPatternValidator_BaseFactory = ɵɵgetInheritedFactory(_PatternValidator)))(t || _PatternValidator);
  };
})();
_PatternValidator.ɵdir = ɵɵdefineDirective({
  type: _PatternValidator,
  selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
  hostVars: 1,
  hostBindings: function PatternValidator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("pattern", ctx._enabled ? ctx.pattern : null);
    }
  },
  inputs: {
    pattern: "pattern"
  },
  features: [ɵɵProvidersFeature([PATTERN_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
var PatternValidator = _PatternValidator;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      }
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
var _ɵInternalFormsSharedModule = class _ɵInternalFormsSharedModule {
};
_ɵInternalFormsSharedModule.ɵfac = function ɵInternalFormsSharedModule_Factory(t) {
  return new (t || _ɵInternalFormsSharedModule)();
};
_ɵInternalFormsSharedModule.ɵmod = ɵɵdefineNgModule({
  type: _ɵInternalFormsSharedModule,
  declarations: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
  exports: [ɵNgNoValidate, NgSelectOption, ɵNgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
});
_ɵInternalFormsSharedModule.ɵinj = ɵɵdefineInjector({});
var ɵInternalFormsSharedModule = _ɵInternalFormsSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ɵInternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  /**
   * Creates a new `FormArray` instance.
   *
   * @param controls An array of child controls. Each child control is given an index
   * where it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or an `AbstractControlOptions` object that contains validation functions
   * and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions
   *
   */
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
      // `VALID` or `INVALID`.
      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
      // to `true` to allow that during the control creation process.
      emitEvent: !!this.asyncValidator
    });
  }
  /**
   * Get the `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
   *     around from the back, and if index is greatly negative (less than `-length`), the result is
   * undefined. This behavior is the same as `Array.at(index)`.
   */
  at(index) {
    return this.controls[this._adjustIndex(index)];
  }
  /**
   * Insert a new `AbstractControl` at the end of the array.
   *
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is added.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  push(control, options = {}) {
    this.controls.push(control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Insert a new `AbstractControl` at the given `index` in the array.
   *
   * @param index Index in the array to insert the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
   * This behavior is the same as `Array.splice(index, 0, control)`.
   * @param control Form control to be inserted
   * @param options Specifies whether this FormArray instance should emit events after a new
   *     control is inserted.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * inserted. When false, no events are emitted.
   */
  insert(index, control, options = {}) {
    this.controls.splice(index, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Remove the control at the given `index` in the array.
   *
   * @param index Index in the array to remove the control.  If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), removes the first
   *     element. This behavior is the same as `Array.splice(index, 1)`.
   * @param options Specifies whether this FormArray instance should emit events after a
   *     control is removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * removed. When false, no events are emitted.
   */
  removeAt(index, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0)
      adjustedIndex = 0;
    if (this.controls[adjustedIndex])
      this.controls[adjustedIndex]._registerOnCollectionChange(() => {
      });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Replace an existing control.
   *
   * @param index Index in the array to replace the control. If `index` is negative, wraps around
   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
   *     element. This behavior is the same as `Array.splice(index, 1, control)`.
   * @param control The `AbstractControl` control to replace the existing control
   * @param options Specifies whether this FormArray instance should emit events after an
   *     existing control is replaced with a new one.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control is
   * replaced with a new one. When false, no events are emitted.
   */
  setControl(index, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index);
    if (adjustedIndex < 0)
      adjustedIndex = 0;
    if (this.controls[adjustedIndex])
      this.controls[adjustedIndex]._registerOnCollectionChange(() => {
      });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  /**
   * Length of the control array.
   */
  get length() {
    return this.controls.length;
  }
  /**
   * Sets the value of the `FormArray`. It accepts an array that matches
   * the structure of the control.
   *
   * This method performs strict checks, and throws an error if you try
   * to set the value of a control that doesn't exist or if you exclude the
   * value of a control.
   *
   * @usageNotes
   * ### Set the values for the controls in the form array
   *
   * ```
   * const arr = new FormArray([
   *   new FormControl(),
   *   new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.setValue(['Nancy', 'Drew']);
   * console.log(arr.value);   // ['Nancy', 'Drew']
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control value is updated.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index) => {
      assertControlPresent(this, false, index);
      this.at(index).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Patches the value of the `FormArray`. It accepts an array that matches the
   * structure of the control, and does its best to match the values to the correct
   * controls in the group.
   *
   * It accepts both super-sets and sub-sets of the array without throwing an error.
   *
   * @usageNotes
   * ### Patch the values for controls in a form array
   *
   * ```
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.value);   // [null, null]
   *
   * arr.patchValue(['Nancy']);
   * console.log(arr.value);   // ['Nancy', null]
   * ```
   *
   * @param value Array of latest values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when the control
   * value is updated. When false, no events are emitted. The configuration options are passed to
   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
   */
  patchValue(value, options = {}) {
    if (value == null)
      return;
    value.forEach((newValue, index) => {
      if (this.at(index)) {
        this.at(index).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  /**
   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
   * value of all descendants to null or null maps.
   *
   * You reset to a specific form state by passing in an array of states
   * that matches the structure of the control. The state is a standalone value
   * or a form state object with both a value and a disabled status.
   *
   * @usageNotes
   * ### Reset the values in a form array
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * arr.reset(['name', 'last name']);
   *
   * console.log(arr.value);  // ['name', 'last name']
   * ```
   *
   * ### Reset the values in a form array and the disabled status for the first control
   *
   * ```
   * arr.reset([
   *   {value: 'name', disabled: true},
   *   'last'
   * ]);
   *
   * console.log(arr.value);  // ['last']
   * console.log(arr.at(0).status);  // 'DISABLED'
   * ```
   *
   * @param value Array of values for the controls
   * @param options Configure options that determine how the control propagates changes and
   * emits events after the value changes
   *
   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
   * is false.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges`
   * observables emit events with the latest status and value when the control is reset.
   * When false, no events are emitted.
   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
   * updateValueAndValidity} method.
   */
  reset(value = [], options = {}) {
    this._forEachChild((control, index) => {
      control.reset(value[index], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this._updatePristine(options);
    this._updateTouched(options);
    this.updateValueAndValidity(options);
  }
  /**
   * The aggregate value of the array, including any disabled controls.
   *
   * Reports all values regardless of disabled status.
   */
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  /**
   * Remove all controls in the `FormArray`.
   *
   * @param options Specifies whether this FormArray instance should emit events after all
   *     controls are removed.
   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
   * `valueChanges` observables emit events with the latest status and value when all controls
   * in this FormArray instance are removed. When false, no events are emitted.
   *
   * @usageNotes
   * ### Remove all elements from a FormArray
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   * console.log(arr.length);  // 2
   *
   * arr.clear();
   * console.log(arr.length);  // 0
   * ```
   *
   * It's a simpler and more efficient alternative to removing all elements one by one:
   *
   * ```ts
   * const arr = new FormArray([
   *    new FormControl(),
   *    new FormControl()
   * ]);
   *
   * while (arr.length) {
   *    arr.removeAt(0);
   * }
   * ```
   */
  clear(options = {}) {
    if (this.controls.length < 1)
      return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  /**
   * Adjusts a negative index by summing it with the length of the array. For very negative
   * indices, the result may remain negative.
   * @internal
   */
  _adjustIndex(index) {
    return index < 0 ? index + this.length : index;
  }
  /** @internal */
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated)
      this.updateValueAndValidity({
        onlySelf: true
      });
    return subtreeUpdated;
  }
  /** @internal */
  _forEachChild(cb) {
    this.controls.forEach((control, index) => {
      cb(control, index);
    });
  }
  /** @internal */
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  /** @internal */
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  /** @internal */
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  /** @internal */
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled)
        return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  /** @internal */
  _find(name) {
    return this.at(name) ?? null;
  }
};
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var _FormBuilder = class _FormBuilder {
  constructor() {
    this.useNonNullable = false;
  }
  /**
   * @description
   * Returns a FormBuilder in which automatically constructed `FormControl` elements
   * have `{nonNullable: true}` and are non-nullable.
   *
   * **Constructing non-nullable controls**
   *
   * When constructing a control, it will be non-nullable, and will reset to its initial value.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.control('Alex'); // FormControl<string>
   * name.reset();
   * console.log(name); // 'Alex'
   * ```
   *
   * **Constructing non-nullable groups or arrays**
   *
   * When constructing a group or array, all automatically created inner controls will be
   * non-nullable, and will reset to their initial values.
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
   * name.reset();
   * console.log(name); // {who: 'Alex'}
   * ```
   * **Constructing *nullable* fields on groups or arrays**
   *
   * It is still possible to have a nullable field. In particular, any `FormControl` which is
   * *already* constructed will not be altered. For example:
   *
   * ```ts
   * let nnfb = new FormBuilder().nonNullable;
   * // FormGroup<{who: FormControl<string|null>}>
   * let name = nnfb.group({who: new FormControl('Alex')});
   * name.reset(); console.log(name); // {who: null}
   * ```
   *
   * Because the inner control is constructed explicitly by the caller, the builder has
   * no control over how it is created, and cannot exclude the `null`.
   */
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  /**
   * @description
   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
   * containing all the keys and corresponding inner control types.
   *
   * @param controls A collection of child controls. The key for each child is the name
   * under which it is registered.
   *
   * @param options Configuration options object for the `FormRecord`. The object should have the
   * `AbstractControlOptions` type and might contain the following fields:
   * * `validators`: A synchronous validator function, or an array of validator functions.
   * * `asyncValidators`: A single async validator or array of async validator functions.
   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
   * | submit').
   */
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  /**
   * @description
   * Constructs a new `FormControl` with the given state, validators and options. Sets
   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
   * control will be nullable. Accepts a single generic argument, which is the type  of the
   * control's value.
   *
   * @param formState Initializes the control with an initial state value, or
   * with an object that contains both a value and a disabled status.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of
   * such functions, or a `FormControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator
   * functions.
   *
   * @usageNotes
   *
   * ### Initialize a control as disabled
   *
   * The following example returns a control with an initial value in a disabled state.
   *
   * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
   * </code-example>
   */
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  /**
   * Constructs a new `FormArray` from the given array of configurations,
   * validators and options. Accepts a single generic argument, which is the type of each control
   * inside the array.
   *
   * @param controls An array of child controls or control configs. Each child control is given an
   *     index when it is registered.
   *
   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
   *     `AbstractControlOptions` object that contains
   * validation functions and a validation trigger.
   *
   * @param asyncValidator A single async validator or array of async validator functions.
   */
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  /** @internal */
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  /** @internal */
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
};
_FormBuilder.ɵfac = function FormBuilder_Factory(t) {
  return new (t || _FormBuilder)();
};
_FormBuilder.ɵprov = ɵɵdefineInjectable({
  token: _FormBuilder,
  factory: _FormBuilder.ɵfac,
  providedIn: "root"
});
var FormBuilder = _FormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NonNullableFormBuilder = class _NonNullableFormBuilder {
};
_NonNullableFormBuilder.ɵfac = function NonNullableFormBuilder_Factory(t) {
  return new (t || _NonNullableFormBuilder)();
};
_NonNullableFormBuilder.ɵprov = ɵɵdefineInjectable({
  token: _NonNullableFormBuilder,
  factory: () => (() => inject(FormBuilder).nonNullable)(),
  providedIn: "root"
});
var NonNullableFormBuilder = _NonNullableFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var _UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  /**
   * Like `FormBuilder#control`, except the resulting control is untyped.
   */
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  /**
   * Like `FormBuilder#array`, except the resulting array is untyped.
   */
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
};
_UntypedFormBuilder.ɵfac = /* @__PURE__ */ (() => {
  let ɵUntypedFormBuilder_BaseFactory;
  return function UntypedFormBuilder_Factory(t) {
    return (ɵUntypedFormBuilder_BaseFactory || (ɵUntypedFormBuilder_BaseFactory = ɵɵgetInheritedFactory(_UntypedFormBuilder)))(t || _UntypedFormBuilder);
  };
})();
_UntypedFormBuilder.ɵprov = ɵɵdefineInjectable({
  token: _UntypedFormBuilder,
  factory: _UntypedFormBuilder.ɵfac,
  providedIn: "root"
});
var UntypedFormBuilder = _UntypedFormBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var VERSION = new Version("17.3.1");
var _FormsModule = class _FormsModule {
  /**
   * @description
   * Provides options for configuring the forms module.
   *
   * @param opts An object of configuration options
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_FormsModule.ɵfac = function FormsModule_Factory(t) {
  return new (t || _FormsModule)();
};
_FormsModule.ɵmod = ɵɵdefineNgModule({
  type: _FormsModule,
  declarations: [NgModel, NgModelGroup, NgForm],
  exports: [ɵInternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
});
_FormsModule.ɵinj = ɵɵdefineInjector({
  imports: [ɵInternalFormsSharedModule]
});
var FormsModule = _FormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [ɵInternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var _ReactiveFormsModule = class _ReactiveFormsModule {
  /**
   * @description
   * Provides options for configuring the reactive forms module.
   *
   * @param opts An object of configuration options
   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
   * binding is used with reactive form directives.
   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
   * correct, or to only call it `whenDisabled`, which is the legacy behavior.
   */
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
};
_ReactiveFormsModule.ɵfac = function ReactiveFormsModule_Factory(t) {
  return new (t || _ReactiveFormsModule)();
};
_ReactiveFormsModule.ɵmod = ɵɵdefineNgModule({
  type: _ReactiveFormsModule,
  declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName],
  exports: [ɵInternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName]
});
_ReactiveFormsModule.ɵinj = ɵɵdefineInjector({
  imports: [ɵInternalFormsSharedModule]
});
var ReactiveFormsModule = _ReactiveFormsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [ɵInternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var _Directionality = class _Directionality {
  constructor(_document) {
    this.value = "ltr";
    this.change = new EventEmitter();
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.value = _resolveDirectionality(bodyDir || htmlDir || "ltr");
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
_Directionality.ɵfac = function Directionality_Factory(t) {
  return new (t || _Directionality)(ɵɵinject(DIR_DOCUMENT, 8));
};
_Directionality.ɵprov = ɵɵdefineInjectable({
  token: _Directionality,
  factory: _Directionality.ɵfac,
  providedIn: "root"
});
var Directionality = _Directionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DIR_DOCUMENT]
    }]
  }], null);
})();
var _Dir = class _Dir {
  constructor() {
    this._dir = "ltr";
    this._isInitialized = false;
    this.change = new EventEmitter();
  }
  /** @docs-private */
  get dir() {
    return this._dir;
  }
  set dir(value) {
    const previousValue = this._dir;
    this._dir = _resolveDirectionality(value);
    this._rawDir = value;
    if (previousValue !== this._dir && this._isInitialized) {
      this.change.emit(this._dir);
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
_Dir.ɵfac = function Dir_Factory(t) {
  return new (t || _Dir)();
};
_Dir.ɵdir = ɵɵdefineDirective({
  type: _Dir,
  selectors: [["", "dir", ""]],
  hostVars: 1,
  hostBindings: function Dir_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("dir", ctx._rawDir);
    }
  },
  inputs: {
    dir: "dir"
  },
  outputs: {
    change: "dirChange"
  },
  exportAs: ["dir"],
  features: [ɵɵProvidersFeature([{
    provide: Directionality,
    useExisting: _Dir
  }])]
});
var Dir = _Dir;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir"
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var _BidiModule = class _BidiModule {
};
_BidiModule.ɵfac = function BidiModule_Factory(t) {
  return new (t || _BidiModule)();
};
_BidiModule.ɵmod = ɵɵdefineNgModule({
  type: _BidiModule,
  declarations: [Dir],
  exports: [Dir]
});
_BidiModule.ɵinj = ɵɵdefineInjector({});
var BidiModule = _BidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      exports: [Dir],
      declarations: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/listbox.mjs
var nextId2 = 0;
var ListboxSelectionModel = class extends SelectionModel {
  constructor(multiple = false, initiallySelectedValues, emitChanges = true, compareWith) {
    super(true, initiallySelectedValues, emitChanges, compareWith);
    this.multiple = multiple;
  }
  isMultipleSelection() {
    return this.multiple;
  }
  select(...values) {
    if (this.multiple) {
      return super.select(...values);
    } else {
      return super.setSelection(...values);
    }
  }
};
var _CdkOption = class _CdkOption {
  constructor() {
    this._generatedId = `cdk-option-${nextId2++}`;
    this._disabled = false;
    this.element = inject(ElementRef).nativeElement;
    this.listbox = inject(CdkListbox);
    this.destroyed = new Subject();
    this._clicked = new Subject();
  }
  /** The id of the option's host element. */
  get id() {
    return this._id || this._generatedId;
  }
  set id(value) {
    this._id = value;
  }
  /** Whether this option is disabled. */
  get disabled() {
    return this.listbox.disabled || this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  /** The tabindex of the option when it is enabled. */
  get enabledTabIndex() {
    return this._enabledTabIndex === void 0 ? this.listbox.enabledTabIndex : this._enabledTabIndex;
  }
  set enabledTabIndex(value) {
    this._enabledTabIndex = value;
  }
  ngOnDestroy() {
    this.destroyed.next();
    this.destroyed.complete();
  }
  /** Whether this option is selected. */
  isSelected() {
    return this.listbox.isSelected(this);
  }
  /** Whether this option is active. */
  isActive() {
    return this.listbox.isActive(this);
  }
  /** Toggle the selected state of this option. */
  toggle() {
    this.listbox.toggle(this);
  }
  /** Select this option if it is not selected. */
  select() {
    this.listbox.select(this);
  }
  /** Deselect this option if it is selected. */
  deselect() {
    this.listbox.deselect(this);
  }
  /** Focus this option. */
  focus() {
    this.element.focus();
  }
  /** Get the label for this element which is required by the FocusableOption interface. */
  getLabel() {
    return (this.typeaheadLabel ?? this.element.textContent?.trim()) || "";
  }
  /**
   * No-op implemented as a part of `Highlightable`.
   * @docs-private
   */
  setActiveStyles() {
  }
  /**
   * No-op implemented as a part of `Highlightable`.
   * @docs-private
   */
  setInactiveStyles() {
  }
  /** Handle focus events on the option. */
  _handleFocus() {
    if (this.listbox.useActiveDescendant) {
      this.listbox._setActiveOption(this);
      this.listbox.focus();
    }
  }
  /** Get the tabindex for this option. */
  _getTabIndex() {
    if (this.listbox.useActiveDescendant || this.disabled) {
      return -1;
    }
    return this.isActive() ? this.enabledTabIndex : -1;
  }
};
_CdkOption.ɵfac = function CdkOption_Factory(t) {
  return new (t || _CdkOption)();
};
_CdkOption.ɵdir = ɵɵdefineDirective({
  type: _CdkOption,
  selectors: [["", "cdkOption", ""]],
  hostAttrs: ["role", "option", 1, "cdk-option"],
  hostVars: 6,
  hostBindings: function CdkOption_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CdkOption_click_HostBindingHandler($event) {
        return ctx._clicked.next($event);
      })("focus", function CdkOption_focus_HostBindingHandler() {
        return ctx._handleFocus();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("aria-selected", ctx.isSelected())("tabindex", ctx._getTabIndex())("aria-disabled", ctx.disabled);
      ɵɵclassProp("cdk-option-active", ctx.isActive());
    }
  },
  inputs: {
    id: "id",
    value: [InputFlags.None, "cdkOption", "value"],
    typeaheadLabel: [InputFlags.None, "cdkOptionTypeaheadLabel", "typeaheadLabel"],
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkOptionDisabled", "disabled", booleanAttribute],
    enabledTabIndex: [InputFlags.None, "tabindex", "enabledTabIndex"]
  },
  exportAs: ["cdkOption"],
  standalone: true,
  features: [ɵɵInputTransformsFeature]
});
var CdkOption = _CdkOption;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOption, [{
    type: Directive,
    args: [{
      selector: "[cdkOption]",
      standalone: true,
      exportAs: "cdkOption",
      host: {
        "role": "option",
        "class": "cdk-option",
        "[id]": "id",
        "[attr.aria-selected]": "isSelected()",
        "[attr.tabindex]": "_getTabIndex()",
        "[attr.aria-disabled]": "disabled",
        "[class.cdk-option-active]": "isActive()",
        "(click)": "_clicked.next($event)",
        "(focus)": "_handleFocus()"
      }
    }]
  }], null, {
    id: [{
      type: Input
    }],
    value: [{
      type: Input,
      args: ["cdkOption"]
    }],
    typeaheadLabel: [{
      type: Input,
      args: ["cdkOptionTypeaheadLabel"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkOptionDisabled",
        transform: booleanAttribute
      }]
    }],
    enabledTabIndex: [{
      type: Input,
      args: ["tabindex"]
    }]
  });
})();
var _CdkListbox = class _CdkListbox {
  /** The id of the option's host element. */
  get id() {
    return this._id || this._generatedId;
  }
  set id(value) {
    this._id = value;
  }
  /** The tabindex to use when the listbox is enabled. */
  get enabledTabIndex() {
    return this._enabledTabIndex === void 0 ? 0 : this._enabledTabIndex;
  }
  set enabledTabIndex(value) {
    this._enabledTabIndex = value;
  }
  /** The value selected in the listbox, represented as an array of option values. */
  get value() {
    return this._invalid ? [] : this.selectionModel.selected;
  }
  set value(value) {
    this._setSelection(value);
  }
  /**
   * Whether the listbox allows multiple options to be selected. If the value switches from `true`
   * to `false`, and more than one option is selected, all options are deselected.
   */
  get multiple() {
    return this.selectionModel.multiple;
  }
  set multiple(value) {
    this.selectionModel.multiple = value;
    if (this.options) {
      this._updateInternalValue();
    }
  }
  /** The orientation of the listbox. Only affects keyboard interaction, not visual layout. */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    this._orientation = value === "horizontal" ? "horizontal" : "vertical";
    if (value === "horizontal") {
      this.listKeyManager?.withHorizontalOrientation(this._dir?.value || "ltr");
    } else {
      this.listKeyManager?.withVerticalOrientation();
    }
  }
  /** The function used to compare option values. */
  get compareWith() {
    return this.selectionModel.compareWith;
  }
  set compareWith(fn) {
    this.selectionModel.compareWith = fn;
  }
  /**
   * Whether the keyboard navigation should wrap when the user presses arrow down on the last item
   * or arrow up on the first item.
   */
  get navigationWrapDisabled() {
    return this._navigationWrapDisabled;
  }
  set navigationWrapDisabled(wrap) {
    this._navigationWrapDisabled = wrap;
    this.listKeyManager?.withWrap(!this._navigationWrapDisabled);
  }
  /** Whether keyboard navigation should skip over disabled items. */
  get navigateDisabledOptions() {
    return this._navigateDisabledOptions;
  }
  set navigateDisabledOptions(skip2) {
    this._navigateDisabledOptions = skip2;
    this.listKeyManager?.skipPredicate(this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate);
  }
  constructor() {
    this._generatedId = `cdk-listbox-${nextId2++}`;
    this.disabled = false;
    this.useActiveDescendant = false;
    this._orientation = "vertical";
    this._navigationWrapDisabled = false;
    this._navigateDisabledOptions = false;
    this.valueChange = new Subject();
    this.selectionModel = new ListboxSelectionModel();
    this.destroyed = new Subject();
    this.element = inject(ElementRef).nativeElement;
    this.ngZone = inject(NgZone);
    this.changeDetectorRef = inject(ChangeDetectorRef);
    this._invalid = false;
    this._lastTriggered = null;
    this._onTouched = () => {
    };
    this._onChange = () => {
    };
    this._optionClicked = defer(() => this.options.changes.pipe(startWith(this.options), switchMap((options) => merge(...options.map((option) => option._clicked.pipe(map((event) => ({
      option,
      event
    }))))))));
    this._dir = inject(Directionality, {
      optional: true
    });
    this._skipDisabledPredicate = (option) => option.disabled;
    this._skipNonePredicate = () => false;
    this._hasFocus = false;
    this._previousActiveOption = null;
    this._setPreviousActiveOptionAsActiveOptionOnWindowBlur();
  }
  ngAfterContentInit() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      this._verifyNoOptionValueCollisions();
      this._verifyOptionValues();
    }
    this._initKeyManager();
    merge(this.selectionModel.changed, this.options.changes).pipe(startWith(null), takeUntil(this.destroyed)).subscribe(() => this._updateInternalValue());
    this._optionClicked.pipe(filter(({
      option
    }) => !option.disabled), takeUntil(this.destroyed)).subscribe(({
      option,
      event
    }) => this._handleOptionClicked(option, event));
  }
  ngOnDestroy() {
    this.listKeyManager?.destroy();
    this.destroyed.next();
    this.destroyed.complete();
  }
  /**
   * Toggle the selected state of the given option.
   * @param option The option to toggle
   */
  toggle(option) {
    this.toggleValue(option.value);
  }
  /**
   * Toggle the selected state of the given value.
   * @param value The value to toggle
   */
  toggleValue(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.toggle(value);
  }
  /**
   * Select the given option.
   * @param option The option to select
   */
  select(option) {
    this.selectValue(option.value);
  }
  /**
   * Select the given value.
   * @param value The value to select
   */
  selectValue(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.select(value);
  }
  /**
   * Deselect the given option.
   * @param option The option to deselect
   */
  deselect(option) {
    this.deselectValue(option.value);
  }
  /**
   * Deselect the given value.
   * @param value The value to deselect
   */
  deselectValue(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.deselect(value);
  }
  /**
   * Set the selected state of all options.
   * @param isSelected The new selected state to set
   */
  setAllSelected(isSelected) {
    if (!isSelected) {
      this.selectionModel.clear();
    } else {
      if (this._invalid) {
        this.selectionModel.clear(false);
      }
      this.selectionModel.select(...this.options.map((option) => option.value));
    }
  }
  /**
   * Get whether the given option is selected.
   * @param option The option to get the selected state of
   */
  isSelected(option) {
    return this.isValueSelected(option.value);
  }
  /**
   * Get whether the given option is active.
   * @param option The option to get the active state of
   */
  isActive(option) {
    return !!(this.listKeyManager?.activeItem === option);
  }
  /**
   * Get whether the given value is selected.
   * @param value The value to get the selected state of
   */
  isValueSelected(value) {
    if (this._invalid) {
      return false;
    }
    return this.selectionModel.isSelected(value);
  }
  /**
   * Registers a callback to be invoked when the listbox's value changes from user input.
   * @param fn The callback to register
   * @docs-private
   */
  registerOnChange(fn) {
    this._onChange = fn;
  }
  /**
   * Registers a callback to be invoked when the listbox is blurred by the user.
   * @param fn The callback to register
   * @docs-private
   */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  /**
   * Sets the listbox's value.
   * @param value The new value of the listbox
   * @docs-private
   */
  writeValue(value) {
    this._setSelection(value);
    this._verifyOptionValues();
  }
  /**
   * Sets the disabled state of the listbox.
   * @param isDisabled The new disabled state
   * @docs-private
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  /** Focus the listbox's host element. */
  focus() {
    this.element.focus();
  }
  /**
   * Triggers the given option in response to user interaction.
   * - In single selection mode: selects the option and deselects any other selected option.
   * - In multi selection mode: toggles the selected state of the option.
   * @param option The option to trigger
   */
  triggerOption(option) {
    if (option && !option.disabled) {
      this._lastTriggered = option;
      const changed = this.multiple ? this.selectionModel.toggle(option.value) : this.selectionModel.select(option.value);
      if (changed) {
        this._onChange(this.value);
        this.valueChange.next({
          value: this.value,
          listbox: this,
          option
        });
      }
    }
  }
  /**
   * Trigger the given range of options in response to user interaction.
   * Should only be called in multi-selection mode.
   * @param trigger The option that was triggered
   * @param from The start index of the options to toggle
   * @param to The end index of the options to toggle
   * @param on Whether to toggle the option range on
   */
  triggerRange(trigger2, from2, to, on) {
    if (this.disabled || trigger2 && trigger2.disabled) {
      return;
    }
    this._lastTriggered = trigger2;
    const isEqual = this.compareWith ?? Object.is;
    const updateValues = [...this.options].slice(Math.max(0, Math.min(from2, to)), Math.min(this.options.length, Math.max(from2, to) + 1)).filter((option) => !option.disabled).map((option) => option.value);
    const selected = [...this.value];
    for (const updateValue of updateValues) {
      const selectedIndex = selected.findIndex((selectedValue) => isEqual(selectedValue, updateValue));
      if (on && selectedIndex === -1) {
        selected.push(updateValue);
      } else if (!on && selectedIndex !== -1) {
        selected.splice(selectedIndex, 1);
      }
    }
    let changed = this.selectionModel.setSelection(...selected);
    if (changed) {
      this._onChange(this.value);
      this.valueChange.next({
        value: this.value,
        listbox: this,
        option: trigger2
      });
    }
  }
  /**
   * Sets the given option as active.
   * @param option The option to make active
   */
  _setActiveOption(option) {
    this.listKeyManager.setActiveItem(option);
  }
  /** Called when the listbox receives focus. */
  _handleFocus() {
    if (!this.useActiveDescendant) {
      if (this.selectionModel.selected.length > 0) {
        this._setNextFocusToSelectedOption();
      } else {
        this.listKeyManager.setNextItemActive();
      }
      this._focusActiveOption();
    }
  }
  /** Called when the user presses keydown on the listbox. */
  _handleKeydown(event) {
    if (this.disabled) {
      return;
    }
    const {
      keyCode
    } = event;
    const previousActiveIndex = this.listKeyManager.activeItemIndex;
    const ctrlKeys = ["ctrlKey", "metaKey"];
    if (this.multiple && keyCode === A && hasModifierKey(event, ...ctrlKeys)) {
      this.triggerRange(null, 0, this.options.length - 1, this.options.length !== this.value.length);
      event.preventDefault();
      return;
    }
    if (this.multiple && (keyCode === SPACE || keyCode === ENTER) && hasModifierKey(event, "shiftKey")) {
      if (this.listKeyManager.activeItem && this.listKeyManager.activeItemIndex != null) {
        this.triggerRange(this.listKeyManager.activeItem, this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex, this.listKeyManager.activeItemIndex, !this.listKeyManager.activeItem.isSelected());
      }
      event.preventDefault();
      return;
    }
    if (this.multiple && keyCode === HOME && hasModifierKey(event, ...ctrlKeys) && hasModifierKey(event, "shiftKey")) {
      const trigger2 = this.listKeyManager.activeItem;
      if (trigger2) {
        const from2 = this.listKeyManager.activeItemIndex;
        this.listKeyManager.setFirstItemActive();
        this.triggerRange(trigger2, from2, this.listKeyManager.activeItemIndex, !trigger2.isSelected());
      }
      event.preventDefault();
      return;
    }
    if (this.multiple && keyCode === END && hasModifierKey(event, ...ctrlKeys) && hasModifierKey(event, "shiftKey")) {
      const trigger2 = this.listKeyManager.activeItem;
      if (trigger2) {
        const from2 = this.listKeyManager.activeItemIndex;
        this.listKeyManager.setLastItemActive();
        this.triggerRange(trigger2, from2, this.listKeyManager.activeItemIndex, !trigger2.isSelected());
      }
      event.preventDefault();
      return;
    }
    if (keyCode === SPACE || keyCode === ENTER) {
      this.triggerOption(this.listKeyManager.activeItem);
      event.preventDefault();
      return;
    }
    const isNavKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW || keyCode === HOME || keyCode === END;
    this.listKeyManager.onKeydown(event);
    if (isNavKey && event.shiftKey && previousActiveIndex !== this.listKeyManager.activeItemIndex) {
      this.triggerOption(this.listKeyManager.activeItem);
    }
  }
  /** Called when a focus moves into the listbox. */
  _handleFocusIn() {
    this._hasFocus = true;
  }
  /**
   * Called when the focus leaves an element in the listbox.
   * @param event The focusout event
   */
  _handleFocusOut(event) {
    this._previousActiveOption = this.listKeyManager.activeItem;
    const otherElement = event.relatedTarget;
    if (this.element !== otherElement && !this.element.contains(otherElement)) {
      this._onTouched();
      this._hasFocus = false;
      this._setNextFocusToSelectedOption();
    }
  }
  /** Get the id of the active option if active descendant is being used. */
  _getAriaActiveDescendant() {
    return this.useActiveDescendant ? this.listKeyManager?.activeItem?.id : null;
  }
  /** Get the tabindex for the listbox. */
  _getTabIndex() {
    if (this.disabled) {
      return -1;
    }
    return this.useActiveDescendant || !this.listKeyManager.activeItem ? this.enabledTabIndex : -1;
  }
  /** Initialize the key manager. */
  _initKeyManager() {
    this.listKeyManager = new ActiveDescendantKeyManager(this.options).withWrap(!this._navigationWrapDisabled).withTypeAhead().withHomeAndEnd().withAllowedModifierKeys(["shiftKey"]).skipPredicate(this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate);
    if (this.orientation === "vertical") {
      this.listKeyManager.withVerticalOrientation();
    } else {
      this.listKeyManager.withHorizontalOrientation(this._dir?.value || "ltr");
    }
    if (this.selectionModel.selected.length) {
      Promise.resolve().then(() => this._setNextFocusToSelectedOption());
    }
    this.listKeyManager.change.subscribe(() => this._focusActiveOption());
  }
  /** Focus the active option. */
  _focusActiveOption() {
    if (!this.useActiveDescendant) {
      this.listKeyManager.activeItem?.focus();
    }
    this.changeDetectorRef.markForCheck();
  }
  /**
   * Set the selected values.
   * @param value The list of new selected values.
   */
  _setSelection(value) {
    if (this._invalid) {
      this.selectionModel.clear(false);
    }
    this.selectionModel.setSelection(...this._coerceValue(value));
    if (!this._hasFocus) {
      this._setNextFocusToSelectedOption();
    }
  }
  /** Sets the first selected option as first in the keyboard focus order. */
  _setNextFocusToSelectedOption() {
    const selected = this.options?.find((option) => option.isSelected());
    if (selected) {
      this.listKeyManager.updateActiveItem(selected);
    }
  }
  /** Update the internal value of the listbox based on the selection model. */
  _updateInternalValue() {
    const indexCache = /* @__PURE__ */ new Map();
    this.selectionModel.sort((a, b) => {
      const aIndex = this._getIndexForValue(indexCache, a);
      const bIndex = this._getIndexForValue(indexCache, b);
      return aIndex - bIndex;
    });
    const selected = this.selectionModel.selected;
    this._invalid = !this.multiple && selected.length > 1 || !!this._getInvalidOptionValues(selected).length;
    this.changeDetectorRef.markForCheck();
  }
  /**
   * Gets the index of the given value in the given list of options.
   * @param cache The cache of indices found so far
   * @param value The value to find
   * @return The index of the value in the options list
   */
  _getIndexForValue(cache, value) {
    const isEqual = this.compareWith || Object.is;
    if (!cache.has(value)) {
      let index = -1;
      for (let i = 0; i < this.options.length; i++) {
        if (isEqual(value, this.options.get(i).value)) {
          index = i;
          break;
        }
      }
      cache.set(value, index);
    }
    return cache.get(value);
  }
  /**
   * Handle the user clicking an option.
   * @param option The option that was clicked.
   */
  _handleOptionClicked(option, event) {
    event.preventDefault();
    this.listKeyManager.setActiveItem(option);
    if (event.shiftKey && this.multiple) {
      this.triggerRange(option, this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex, this.listKeyManager.activeItemIndex, !option.isSelected());
    } else {
      this.triggerOption(option);
    }
  }
  /** Verifies that no two options represent the same value under the compareWith function. */
  _verifyNoOptionValueCollisions() {
    this.options.changes.pipe(startWith(this.options), takeUntil(this.destroyed)).subscribe(() => {
      const isEqual = this.compareWith ?? Object.is;
      for (let i = 0; i < this.options.length; i++) {
        const option = this.options.get(i);
        let duplicate = null;
        for (let j = i + 1; j < this.options.length; j++) {
          const other = this.options.get(j);
          if (isEqual(option.value, other.value)) {
            duplicate = other;
            break;
          }
        }
        if (duplicate) {
          if (this.compareWith) {
            console.warn(`Found multiple CdkOption representing the same value under the given compareWith function`, {
              option1: option.element,
              option2: duplicate.element,
              compareWith: this.compareWith
            });
          } else {
            console.warn(`Found multiple CdkOption with the same value`, {
              option1: option.element,
              option2: duplicate.element
            });
          }
          return;
        }
      }
    });
  }
  /** Verifies that the option values are valid. */
  _verifyOptionValues() {
    if (this.options && (typeof ngDevMode === "undefined" || ngDevMode)) {
      const selected = this.selectionModel.selected;
      const invalidValues = this._getInvalidOptionValues(selected);
      if (!this.multiple && selected.length > 1) {
        throw Error("Listbox cannot have more than one selected value in multi-selection mode.");
      }
      if (invalidValues.length) {
        throw Error("Listbox has selected values that do not match any of its options.");
      }
    }
  }
  /**
   * Coerces a value into an array representing a listbox selection.
   * @param value The value to coerce
   * @return An array
   */
  _coerceValue(value) {
    return value == null ? [] : coerceArray(value);
  }
  /**
   * Get the sublist of values that do not represent valid option values in this listbox.
   * @param values The list of values
   * @return The sublist of values that are not valid option values
   */
  _getInvalidOptionValues(values) {
    const isEqual = this.compareWith || Object.is;
    const validValues = (this.options || []).map((option) => option.value);
    return values.filter((value) => !validValues.some((validValue2) => isEqual(value, validValue2)));
  }
  /** Get the index of the last triggered option. */
  _getLastTriggeredIndex() {
    const index = this.options.toArray().indexOf(this._lastTriggered);
    return index === -1 ? null : index;
  }
  /**
   * Set previous active option as active option on window blur.
   * This ensures that the `activeOption` matches the actual focused element when the user returns to the document.
   */
  _setPreviousActiveOptionAsActiveOptionOnWindowBlur() {
    this.ngZone.runOutsideAngular(() => {
      fromEvent(window, "blur").pipe(takeUntil(this.destroyed)).subscribe(() => {
        if (this.element.contains(document.activeElement) && this._previousActiveOption) {
          this._setActiveOption(this._previousActiveOption);
          this._previousActiveOption = null;
        }
      });
    });
  }
};
_CdkListbox.ɵfac = function CdkListbox_Factory(t) {
  return new (t || _CdkListbox)();
};
_CdkListbox.ɵdir = ɵɵdefineDirective({
  type: _CdkListbox,
  selectors: [["", "cdkListbox", ""]],
  contentQueries: function CdkListbox_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkOption, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  hostAttrs: ["role", "listbox", 1, "cdk-listbox"],
  hostVars: 6,
  hostBindings: function CdkListbox_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function CdkListbox_focus_HostBindingHandler() {
        return ctx._handleFocus();
      })("keydown", function CdkListbox_keydown_HostBindingHandler($event) {
        return ctx._handleKeydown($event);
      })("focusout", function CdkListbox_focusout_HostBindingHandler($event) {
        return ctx._handleFocusOut($event);
      })("focusin", function CdkListbox_focusin_HostBindingHandler() {
        return ctx._handleFocusIn();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("tabindex", ctx._getTabIndex())("aria-disabled", ctx.disabled)("aria-multiselectable", ctx.multiple)("aria-activedescendant", ctx._getAriaActiveDescendant())("aria-orientation", ctx.orientation);
    }
  },
  inputs: {
    id: "id",
    enabledTabIndex: [InputFlags.None, "tabindex", "enabledTabIndex"],
    value: [InputFlags.None, "cdkListboxValue", "value"],
    multiple: [InputFlags.HasDecoratorInputTransform, "cdkListboxMultiple", "multiple", booleanAttribute],
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkListboxDisabled", "disabled", booleanAttribute],
    useActiveDescendant: [InputFlags.HasDecoratorInputTransform, "cdkListboxUseActiveDescendant", "useActiveDescendant", booleanAttribute],
    orientation: [InputFlags.None, "cdkListboxOrientation", "orientation"],
    compareWith: [InputFlags.None, "cdkListboxCompareWith", "compareWith"],
    navigationWrapDisabled: [InputFlags.HasDecoratorInputTransform, "cdkListboxNavigationWrapDisabled", "navigationWrapDisabled", booleanAttribute],
    navigateDisabledOptions: [InputFlags.HasDecoratorInputTransform, "cdkListboxNavigatesDisabledOptions", "navigateDisabledOptions", booleanAttribute]
  },
  outputs: {
    valueChange: "cdkListboxValueChange"
  },
  exportAs: ["cdkListbox"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _CdkListbox),
    multi: true
  }]), ɵɵInputTransformsFeature]
});
var CdkListbox = _CdkListbox;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkListbox, [{
    type: Directive,
    args: [{
      selector: "[cdkListbox]",
      standalone: true,
      exportAs: "cdkListbox",
      host: {
        "role": "listbox",
        "class": "cdk-listbox",
        "[id]": "id",
        "[attr.tabindex]": "_getTabIndex()",
        "[attr.aria-disabled]": "disabled",
        "[attr.aria-multiselectable]": "multiple",
        "[attr.aria-activedescendant]": "_getAriaActiveDescendant()",
        "[attr.aria-orientation]": "orientation",
        "(focus)": "_handleFocus()",
        "(keydown)": "_handleKeydown($event)",
        "(focusout)": "_handleFocusOut($event)",
        "(focusin)": "_handleFocusIn()"
      },
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => CdkListbox),
        multi: true
      }]
    }]
  }], () => [], {
    id: [{
      type: Input
    }],
    enabledTabIndex: [{
      type: Input,
      args: ["tabindex"]
    }],
    value: [{
      type: Input,
      args: ["cdkListboxValue"]
    }],
    multiple: [{
      type: Input,
      args: [{
        alias: "cdkListboxMultiple",
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkListboxDisabled",
        transform: booleanAttribute
      }]
    }],
    useActiveDescendant: [{
      type: Input,
      args: [{
        alias: "cdkListboxUseActiveDescendant",
        transform: booleanAttribute
      }]
    }],
    orientation: [{
      type: Input,
      args: ["cdkListboxOrientation"]
    }],
    compareWith: [{
      type: Input,
      args: ["cdkListboxCompareWith"]
    }],
    navigationWrapDisabled: [{
      type: Input,
      args: [{
        alias: "cdkListboxNavigationWrapDisabled",
        transform: booleanAttribute
      }]
    }],
    navigateDisabledOptions: [{
      type: Input,
      args: [{
        alias: "cdkListboxNavigatesDisabledOptions",
        transform: booleanAttribute
      }]
    }],
    valueChange: [{
      type: Output,
      args: ["cdkListboxValueChange"]
    }],
    options: [{
      type: ContentChildren,
      args: [CdkOption, {
        descendants: true
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkListbox, CdkOption];
var _CdkListboxModule = class _CdkListboxModule {
};
_CdkListboxModule.ɵfac = function CdkListboxModule_Factory(t) {
  return new (t || _CdkListboxModule)();
};
_CdkListboxModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkListboxModule,
  imports: [CdkListbox, CdkOption],
  exports: [CdkListbox, CdkOption]
});
_CdkListboxModule.ɵinj = ɵɵdefineInjector({});
var CdkListboxModule = _CdkListboxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkListboxModule, [{
    type: NgModule,
    args: [{
      imports: [...EXPORTED_DECLARATIONS],
      exports: [...EXPORTED_DECLARATIONS]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._scrolledIndexChange = new Subject();
    this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
    this._viewport = null;
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var _CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  constructor() {
    this._itemSize = 20;
    this._minBufferPx = 100;
    this._maxBufferPx = 200;
    this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
};
_CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t) {
  return new (t || _CdkFixedSizeVirtualScroll)();
};
_CdkFixedSizeVirtualScroll.ɵdir = ɵɵdefineDirective({
  type: _CdkFixedSizeVirtualScroll,
  selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
  inputs: {
    itemSize: "itemSize",
    minBufferPx: "minBufferPx",
    maxBufferPx: "maxBufferPx"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLL_STRATEGY,
    useFactory: _fixedSizeVirtualScrollStrategyFactory,
    deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
  }]), ɵɵNgOnChangesFeature]
});
var CdkFixedSizeVirtualScroll = _CdkFixedSizeVirtualScroll;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      standalone: true,
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var _ScrollDispatcher = class _ScrollDispatcher {
  constructor(_ngZone, _platform, document2) {
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._scrolled = new Subject();
    this._globalSubscription = null;
    this._scrolledCount = 0;
    this.scrollContainers = /* @__PURE__ */ new Map();
    this._document = document2;
  }
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._globalSubscription) {
        this._addGlobalListener();
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._removeGlobalListener();
        }
      };
    });
  }
  ngOnDestroy() {
    this._removeGlobalListener();
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => {
      return !target || ancestors.indexOf(target) > -1;
    }));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  /** Sets up the global scroll listeners. */
  _addGlobalListener() {
    this._globalSubscription = this._ngZone.runOutsideAngular(() => {
      const window2 = this._getWindow();
      return fromEvent(window2.document, "scroll").subscribe(() => this._scrolled.next());
    });
  }
  /** Cleans up the global scroll listener. */
  _removeGlobalListener() {
    if (this._globalSubscription) {
      this._globalSubscription.unsubscribe();
      this._globalSubscription = null;
    }
  }
};
_ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t) {
  return new (t || _ScrollDispatcher)(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(DOCUMENT, 8));
};
_ScrollDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _ScrollDispatcher,
  factory: _ScrollDispatcher.ɵfac,
  providedIn: "root"
});
var ScrollDispatcher = _ScrollDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _CdkScrollable = class _CdkScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    this.elementRef = elementRef;
    this.scrollDispatcher = scrollDispatcher;
    this.ngZone = ngZone;
    this.dir = dir;
    this._destroyed = new Subject();
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  }
  ngOnInit() {
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != 0) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == 2) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == 1) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from2) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from2 == "top") {
      return el.scrollTop;
    }
    if (from2 == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from2 == "start") {
      from2 = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      from2 = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == 2) {
      if (from2 == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == 1) {
      if (from2 == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from2 == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
};
_CdkScrollable.ɵfac = function CdkScrollable_Factory(t) {
  return new (t || _CdkScrollable)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkScrollable.ɵdir = ɵɵdefineDirective({
  type: _CdkScrollable,
  selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]],
  standalone: true
});
var CdkScrollable = _CdkScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var _ViewportRuler = class _ViewportRuler {
  constructor(_platform, ngZone, document2) {
    this._platform = _platform;
    this._change = new Subject();
    this._changeListener = (event) => {
      this._change.next(event);
    };
    this._document = document2;
    ngZone.runOutsideAngular(() => {
      if (_platform.isBrowser) {
        const window2 = this._getWindow();
        window2.addEventListener("resize", this._changeListener);
        window2.addEventListener("orientationchange", this._changeListener);
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    if (this._platform.isBrowser) {
      const window2 = this._getWindow();
      window2.removeEventListener("resize", this._changeListener);
      window2.removeEventListener("orientationchange", this._changeListener);
    }
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
};
_ViewportRuler.ɵfac = function ViewportRuler_Factory(t) {
  return new (t || _ViewportRuler)(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT, 8));
};
_ViewportRuler.ɵprov = ɵɵdefineInjectable({
  token: _ViewportRuler,
  factory: _ViewportRuler.ɵfac,
  providedIn: "root"
});
var ViewportRuler = _ViewportRuler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var _CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    super(elementRef, scrollDispatcher, ngZone, dir);
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
};
_CdkVirtualScrollable.ɵfac = function CdkVirtualScrollable_Factory(t) {
  return new (t || _CdkVirtualScrollable)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollable.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollable,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollable = _CdkVirtualScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var _CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {
    super(elementRef, scrollDispatcher, ngZone, dir);
    this.elementRef = elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._scrollStrategy = _scrollStrategy;
    this.scrollable = scrollable;
    this._platform = inject(Platform);
    this._detachedSubject = new Subject();
    this._renderedRangeSubject = new Subject();
    this._orientation = "vertical";
    this.appendOnly = false;
    this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
    this.renderedRangeStream = this._renderedRangeSubject;
    this._totalContentSize = 0;
    this._totalContentWidth = "";
    this._totalContentHeight = "";
    this._renderedRange = {
      start: 0,
      end: 0
    };
    this._dataLength = 0;
    this._viewportSize = 0;
    this._renderedContentOffset = 0;
    this._renderedContentOffsetNeedsRewrite = false;
    this._isChangeDetectionPending = false;
    this._runAfterChangeDetection = [];
    this._viewportChanges = Subscription.EMPTY;
    if (!_scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range) {
    if (!rangesEqual(this._renderedRange, range)) {
      if (this.appendOnly) {
        range = {
          start: 0,
          end: Math.max(this._renderedRange.end, range.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from2) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from2 ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from2) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from2 == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from2 == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from2) {
      fromRect = from2;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (!this._isChangeDetectionPending) {
      this._isChangeDetectionPending = true;
      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
        this._doChangeDetection();
      }));
    }
  }
  /** Run change detection. */
  _doChangeDetection() {
    this._isChangeDetectionPending = false;
    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
    this.ngZone.run(() => this._changeDetectorRef.markForCheck());
    const runAfterChangeDetection = this._runAfterChangeDetection;
    this._runAfterChangeDetection = [];
    for (const fn of runAfterChangeDetection) {
      fn();
    }
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight = this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`;
    this._totalContentWidth = this.orientation === "horizontal" ? `${this._totalContentSize}px` : "";
  }
};
_CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t) {
  return new (t || _CdkVirtualScrollViewport)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(VIRTUAL_SCROLLABLE, 8));
};
_CdkVirtualScrollViewport.ɵcmp = ɵɵdefineComponent({
  type: _CdkVirtualScrollViewport,
  selectors: [["cdk-virtual-scroll-viewport"]],
  viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);
    }
  },
  hostAttrs: [1, "cdk-virtual-scroll-viewport"],
  hostVars: 4,
  hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
    }
  },
  inputs: {
    orientation: "orientation",
    appendOnly: [InputFlags.HasDecoratorInputTransform, "appendOnly", "appendOnly", booleanAttribute]
  },
  outputs: {
    scrolledIndexChange: "scrolledIndexChange"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CdkScrollable,
    useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
    deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
  }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c1,
  decls: 4,
  vars: 4,
  consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
  template: function CdkVirtualScrollViewport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelement(3, "div", 2);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵstyleProp("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
    }
  },
  styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],
  encapsulation: 2,
  changeDetection: 0
});
var CdkVirtualScrollViewport = _CdkVirtualScrollViewport;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      providers: [{
        provide: CdkScrollable,
        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth" [style.height]="_totalContentHeight"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [VIRTUAL_SCROLL_STRATEGY]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ScrollDispatcher
  }, {
    type: ViewportRuler
  }, {
    type: CdkVirtualScrollable,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [VIRTUAL_SCROLLABLE]
    }]
  }], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var _CdkVirtualForOf = class _CdkVirtualForOf {
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  constructor(_viewContainerRef, _template, _differs, _viewRepeater, _viewport, ngZone) {
    this._viewContainerRef = _viewContainerRef;
    this._template = _template;
    this._differs = _differs;
    this._viewRepeater = _viewRepeater;
    this._viewport = _viewport;
    this.viewChange = new Subject();
    this._dataSourceChanges = new Subject();
    this.dataStream = this._dataSourceChanges.pipe(
      // Start off with null `DataSource`.
      startWith(null),
      // Bundle up the previous and current data sources so we can work with both.
      pairwise(),
      // Use `_changeDataSource` to disconnect from the previous data source and connect to the
      // new one, passing back a stream of data changes which we run through `switchMap` to give
      // us a data stream that emits the latest data from whatever the current `DataSource` is.
      switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
      // Replay the last emitted data when someone subscribes.
      shareReplay(1)
    );
    this._differ = null;
    this._needsUpdate = false;
    this._destroyed = new Subject();
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
      this._renderedRange = range;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range, orientation) {
    if (range.start >= range.end) {
      return 0;
    }
    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range.start - this._renderedRange.start;
    const rangeLen = range.end - range.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
};
_CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t) {
  return new (t || _CdkVirtualForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(CdkVirtualScrollViewport, 4), ɵɵdirectiveInject(NgZone));
};
_CdkVirtualForOf.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualForOf,
  selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
  inputs: {
    cdkVirtualForOf: "cdkVirtualForOf",
    cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
    cdkVirtualForTemplate: "cdkVirtualForTemplate",
    cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: _VIEW_REPEATER_STRATEGY,
    useClass: _RecycleViewRepeaterStrategy
  }])]
});
var CdkVirtualForOf = _CdkVirtualForOf;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }],
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: _RecycleViewRepeaterStrategy,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: CdkVirtualScrollViewport,
    decorators: [{
      type: SkipSelf
    }]
  }, {
    type: NgZone
  }], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var _CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    super(elementRef, scrollDispatcher, ngZone, dir);
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2] - this.measureScrollOffset(from2);
  }
};
_CdkVirtualScrollableElement.ɵfac = function CdkVirtualScrollableElement_Factory(t) {
  return new (t || _CdkVirtualScrollableElement)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollableElement.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollableElement,
  selectors: [["", "cdkVirtualScrollingElement", ""]],
  hostAttrs: [1, "cdk-virtual-scrollable"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableElement
  }]), ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollableElement = _CdkVirtualScrollableElement;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      standalone: true,
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor(scrollDispatcher, ngZone, dir) {
    super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(document, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  }
  measureBoundingClientRectWithScrollOffset(from2) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from2];
  }
};
_CdkVirtualScrollableWindow.ɵfac = function CdkVirtualScrollableWindow_Factory(t) {
  return new (t || _CdkVirtualScrollableWindow)(ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollableWindow.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollableWindow,
  selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableWindow
  }]), ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollableWindow = _CdkVirtualScrollableWindow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }],
      standalone: true
    }]
  }], () => [{
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _CdkScrollableModule = class _CdkScrollableModule {
};
_CdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t) {
  return new (t || _CdkScrollableModule)();
};
_CdkScrollableModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkScrollableModule,
  imports: [CdkScrollable],
  exports: [CdkScrollable]
});
_CdkScrollableModule.ɵinj = ɵɵdefineInjector({});
var CdkScrollableModule = _CdkScrollableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var _ScrollingModule = class _ScrollingModule {
};
_ScrollingModule.ɵfac = function ScrollingModule_Factory(t) {
  return new (t || _ScrollingModule)();
};
_ScrollingModule.ɵmod = ɵɵdefineNgModule({
  type: _ScrollingModule,
  imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
  exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
});
_ScrollingModule.ɵinj = ɵɵdefineInjector({
  imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
});
var ScrollingModule = _ScrollingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/portal.mjs
function throwNullPortalError() {
  throw Error("Must provide a portal to attach");
}
function throwPortalAlreadyAttachedError() {
  throw Error("Host already has a portal attached");
}
function throwPortalOutletAlreadyDisposedError() {
  throw Error("This PortalOutlet has already been disposed");
}
function throwUnknownPortalTypeError() {
  throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
}
function throwNullPortalOutletError() {
  throw Error("Attempting to attach a portal to a null PortalOutlet");
}
function throwNoPortalAttachedError() {
  throw Error("Attempting to detach a portal that is not attached to a host");
}
var Portal = class {
  /** Attach this portal to a host. */
  attach(host) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (host == null) {
        throwNullPortalOutletError();
      }
      if (host.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
    }
    this._attachedHost = host;
    return host.attach(this);
  }
  /** Detach this portal from its host */
  detach() {
    let host = this._attachedHost;
    if (host != null) {
      this._attachedHost = null;
      host.detach();
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwNoPortalAttachedError();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost != null;
  }
  /**
   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
   * the PortalOutlet when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal = class extends Portal {
  constructor(component, viewContainerRef, injector, componentFactoryResolver, projectableNodes) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.componentFactoryResolver = componentFactoryResolver;
    this.projectableNodes = projectableNodes;
  }
};
var TemplatePortal = class extends Portal {
  constructor(templateRef, viewContainerRef, context, injector) {
    super();
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.context = context;
    this.injector = injector;
  }
  get origin() {
    return this.templateRef.elementRef;
  }
  /**
   * Attach the portal to the provided `PortalOutlet`.
   * When a context is provided it will override the `context` property of the `TemplatePortal`
   * instance.
   */
  attach(host, context = this.context) {
    this.context = context;
    return super.attach(host);
  }
  detach() {
    this.context = void 0;
    return super.detach();
  }
};
var DomPortal = class extends Portal {
  constructor(element) {
    super();
    this.element = element instanceof ElementRef ? element.nativeElement : element;
  }
};
var BasePortalOutlet = class {
  constructor() {
    this._isDisposed = false;
    this.attachDomPortal = null;
  }
  /** Whether this host has an attached portal. */
  hasAttached() {
    return !!this._attachedPortal;
  }
  /** Attaches a portal. */
  attach(portal) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!portal) {
        throwNullPortalError();
      }
      if (this.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
      if (this._isDisposed) {
        throwPortalOutletAlreadyDisposedError();
      }
    }
    if (portal instanceof ComponentPortal) {
      this._attachedPortal = portal;
      return this.attachComponentPortal(portal);
    } else if (portal instanceof TemplatePortal) {
      this._attachedPortal = portal;
      return this.attachTemplatePortal(portal);
    } else if (this.attachDomPortal && portal instanceof DomPortal) {
      this._attachedPortal = portal;
      return this.attachDomPortal(portal);
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwUnknownPortalTypeError();
    }
  }
  /** Detaches a previously attached portal. */
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost(null);
      this._attachedPortal = null;
    }
    this._invokeDisposeFn();
  }
  /** Permanently dispose of this portal host. */
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this._invokeDisposeFn();
    this._isDisposed = true;
  }
  /** @docs-private */
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
  _invokeDisposeFn() {
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = null;
    }
  }
};
var DomPortalOutlet = class extends BasePortalOutlet {
  /**
   * @param outletElement Element into which the content is projected.
   * @param _componentFactoryResolver Used to resolve the component factory.
   *   Only required when attaching component portals.
   * @param _appRef Reference to the application. Only used in component portals when there
   *   is no `ViewContainerRef` available.
   * @param _defaultInjector Injector to use as a fallback when the portal being attached doesn't
   *   have one. Only used for component portals.
   * @param _document Reference to the document. Used when attaching a DOM portal. Will eventually
   *   become a required parameter.
   */
  constructor(outletElement, _componentFactoryResolver, _appRef, _defaultInjector, _document) {
    super();
    this.outletElement = outletElement;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._appRef = _appRef;
    this._defaultInjector = _defaultInjector;
    this.attachDomPortal = (portal) => {
      if (!this._document && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Cannot attach DOM portal without _document constructor parameter");
      }
      const element = portal.element;
      if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("DOM portal content must be attached to a parent node.");
      }
      const anchorNode = this._document.createComment("dom-portal");
      element.parentNode.insertBefore(anchorNode, element);
      this.outletElement.appendChild(element);
      this._attachedPortal = portal;
      super.setDisposeFn(() => {
        if (anchorNode.parentNode) {
          anchorNode.parentNode.replaceChild(element, anchorNode);
        }
      });
    };
    this._document = _document;
  }
  /**
   * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
   * @param portal Portal to be attached
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !resolver) {
      throw Error("Cannot attach component portal to outlet without a ComponentFactoryResolver.");
    }
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    let componentRef;
    if (portal.viewContainerRef) {
      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, portal.projectableNodes || void 0);
      this.setDisposeFn(() => componentRef.destroy());
    } else {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._appRef) {
        throw Error("Cannot attach component portal to outlet without an ApplicationRef.");
      }
      componentRef = componentFactory.create(portal.injector || this._defaultInjector || Injector.NULL);
      this._appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        if (this._appRef.viewCount > 0) {
          this._appRef.detachView(componentRef.hostView);
        }
        componentRef.destroy();
      });
    }
    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
    this._attachedPortal = portal;
    return componentRef;
  }
  /**
   * Attaches a template portal to the DOM as an embedded view.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    let viewContainer = portal.viewContainerRef;
    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    viewRef.rootNodes.forEach((rootNode) => this.outletElement.appendChild(rootNode));
    viewRef.detectChanges();
    this.setDisposeFn(() => {
      let index = viewContainer.indexOf(viewRef);
      if (index !== -1) {
        viewContainer.remove(index);
      }
    });
    this._attachedPortal = portal;
    return viewRef;
  }
  /**
   * Clears out a portal from the DOM.
   */
  dispose() {
    super.dispose();
    this.outletElement.remove();
  }
  /** Gets the root HTMLElement for an instantiated component. */
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var _CdkPortal = class _CdkPortal extends TemplatePortal {
  constructor(templateRef, viewContainerRef) {
    super(templateRef, viewContainerRef);
  }
};
_CdkPortal.ɵfac = function CdkPortal_Factory(t) {
  return new (t || _CdkPortal)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
_CdkPortal.ɵdir = ɵɵdefineDirective({
  type: _CdkPortal,
  selectors: [["", "cdkPortal", ""]],
  exportAs: ["cdkPortal"],
  features: [ɵɵInheritDefinitionFeature]
});
var CdkPortal = _CdkPortal;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortal, [{
    type: Directive,
    args: [{
      selector: "[cdkPortal]",
      exportAs: "cdkPortal"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }], null);
})();
var _TemplatePortalDirective = class _TemplatePortalDirective extends CdkPortal {
};
_TemplatePortalDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵTemplatePortalDirective_BaseFactory;
  return function TemplatePortalDirective_Factory(t) {
    return (ɵTemplatePortalDirective_BaseFactory || (ɵTemplatePortalDirective_BaseFactory = ɵɵgetInheritedFactory(_TemplatePortalDirective)))(t || _TemplatePortalDirective);
  };
})();
_TemplatePortalDirective.ɵdir = ɵɵdefineDirective({
  type: _TemplatePortalDirective,
  selectors: [["", "cdk-portal", ""], ["", "portal", ""]],
  exportAs: ["cdkPortal"],
  features: [ɵɵProvidersFeature([{
    provide: CdkPortal,
    useExisting: _TemplatePortalDirective
  }]), ɵɵInheritDefinitionFeature]
});
var TemplatePortalDirective = _TemplatePortalDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplatePortalDirective, [{
    type: Directive,
    args: [{
      selector: "[cdk-portal], [portal]",
      exportAs: "cdkPortal",
      providers: [{
        provide: CdkPortal,
        useExisting: TemplatePortalDirective
      }]
    }]
  }], null, null);
})();
var _CdkPortalOutlet = class _CdkPortalOutlet extends BasePortalOutlet {
  constructor(_componentFactoryResolver, _viewContainerRef, _document) {
    super();
    this._componentFactoryResolver = _componentFactoryResolver;
    this._viewContainerRef = _viewContainerRef;
    this._isInitialized = false;
    this.attached = new EventEmitter();
    this.attachDomPortal = (portal) => {
      if (!this._document && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("Cannot attach DOM portal without _document constructor parameter");
      }
      const element = portal.element;
      if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("DOM portal content must be attached to a parent node.");
      }
      const anchorNode = this._document.createComment("dom-portal");
      portal.setAttachedHost(this);
      element.parentNode.insertBefore(anchorNode, element);
      this._getRootNode().appendChild(element);
      this._attachedPortal = portal;
      super.setDisposeFn(() => {
        if (anchorNode.parentNode) {
          anchorNode.parentNode.replaceChild(element, anchorNode);
        }
      });
    };
    this._document = _document;
  }
  /** Portal associated with the Portal outlet. */
  get portal() {
    return this._attachedPortal;
  }
  set portal(portal) {
    if (this.hasAttached() && !portal && !this._isInitialized) {
      return;
    }
    if (this.hasAttached()) {
      super.detach();
    }
    if (portal) {
      super.attach(portal);
    }
    this._attachedPortal = portal || null;
  }
  /** Component or view reference that is attached to the portal. */
  get attachedRef() {
    return this._attachedRef;
  }
  ngOnInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    super.dispose();
    this._attachedRef = this._attachedPortal = null;
  }
  /**
   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
   *
   * @param portal Portal to be attached to the portal outlet.
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
    const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector, portal.projectableNodes || void 0);
    if (viewContainerRef !== this._viewContainerRef) {
      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this._attachedRef = ref;
    this.attached.emit(ref);
    return ref;
  }
  /**
   * Attach the given TemplatePortal to this PortalHost as an embedded View.
   * @param portal Portal to be attached.
   * @returns Reference to the created embedded view.
   */
  attachTemplatePortal(portal) {
    portal.setAttachedHost(this);
    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    super.setDisposeFn(() => this._viewContainerRef.clear());
    this._attachedPortal = portal;
    this._attachedRef = viewRef;
    this.attached.emit(viewRef);
    return viewRef;
  }
  /** Gets the root node of the portal outlet. */
  _getRootNode() {
    const nativeElement = this._viewContainerRef.element.nativeElement;
    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
  }
};
_CdkPortalOutlet.ɵfac = function CdkPortalOutlet_Factory(t) {
  return new (t || _CdkPortalOutlet)(ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DOCUMENT));
};
_CdkPortalOutlet.ɵdir = ɵɵdefineDirective({
  type: _CdkPortalOutlet,
  selectors: [["", "cdkPortalOutlet", ""]],
  inputs: {
    portal: [InputFlags.None, "cdkPortalOutlet", "portal"]
  },
  outputs: {
    attached: "attached"
  },
  exportAs: ["cdkPortalOutlet"],
  features: [ɵɵInheritDefinitionFeature]
});
var CdkPortalOutlet = _CdkPortalOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalOutlet]",
      exportAs: "cdkPortalOutlet",
      inputs: ["portal: cdkPortalOutlet"]
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    attached: [{
      type: Output
    }]
  });
})();
var _PortalHostDirective = class _PortalHostDirective extends CdkPortalOutlet {
};
_PortalHostDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵPortalHostDirective_BaseFactory;
  return function PortalHostDirective_Factory(t) {
    return (ɵPortalHostDirective_BaseFactory || (ɵPortalHostDirective_BaseFactory = ɵɵgetInheritedFactory(_PortalHostDirective)))(t || _PortalHostDirective);
  };
})();
_PortalHostDirective.ɵdir = ɵɵdefineDirective({
  type: _PortalHostDirective,
  selectors: [["", "cdkPortalHost", ""], ["", "portalHost", ""]],
  inputs: {
    portal: [InputFlags.None, "cdkPortalHost", "portal"]
  },
  exportAs: ["cdkPortalHost"],
  features: [ɵɵProvidersFeature([{
    provide: CdkPortalOutlet,
    useExisting: _PortalHostDirective
  }]), ɵɵInheritDefinitionFeature]
});
var PortalHostDirective = _PortalHostDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalHostDirective, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalHost], [portalHost]",
      exportAs: "cdkPortalHost",
      inputs: ["portal: cdkPortalHost"],
      providers: [{
        provide: CdkPortalOutlet,
        useExisting: PortalHostDirective
      }]
    }]
  }], null, null);
})();
var _PortalModule = class _PortalModule {
};
_PortalModule.ɵfac = function PortalModule_Factory(t) {
  return new (t || _PortalModule)();
};
_PortalModule.ɵmod = ɵɵdefineNgModule({
  type: _PortalModule,
  declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
  exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
});
_PortalModule.ɵinj = ɵɵdefineInjector({});
var PortalModule = _PortalModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalModule, [{
    type: NgModule,
    args: [{
      exports: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective],
      declarations: [CdkPortal, CdkPortalOutlet, TemplatePortalDirective, PortalHostDirective]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/overlay.mjs
var scrollBehaviorSupported2 = supportsScrollBehavior();
var BlockScrollStrategy = class {
  constructor(_viewportRuler, document2) {
    this._viewportRuler = _viewportRuler;
    this._previousHTMLStyles = {
      top: "",
      left: ""
    };
    this._isEnabled = false;
    this._document = document2;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach() {
  }
  /** Blocks page-level scroll while the attached overlay is open. */
  enable() {
    if (this._canBeEnabled()) {
      const root = this._document.documentElement;
      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
      this._previousHTMLStyles.left = root.style.left || "";
      this._previousHTMLStyles.top = root.style.top || "";
      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
      root.classList.add("cdk-global-scrollblock");
      this._isEnabled = true;
    }
  }
  /** Unblocks page-level scroll while the attached overlay is open. */
  disable() {
    if (this._isEnabled) {
      const html = this._document.documentElement;
      const body = this._document.body;
      const htmlStyle = html.style;
      const bodyStyle = body.style;
      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || "";
      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || "";
      this._isEnabled = false;
      htmlStyle.left = this._previousHTMLStyles.left;
      htmlStyle.top = this._previousHTMLStyles.top;
      html.classList.remove("cdk-global-scrollblock");
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = "auto";
      }
      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
      if (scrollBehaviorSupported2) {
        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
        bodyStyle.scrollBehavior = previousBodyScrollBehavior;
      }
    }
  }
  _canBeEnabled() {
    const html = this._document.documentElement;
    if (html.classList.contains("cdk-global-scrollblock") || this._isEnabled) {
      return false;
    }
    const body = this._document.body;
    const viewport = this._viewportRuler.getViewportSize();
    return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;
  }
};
function getMatScrollStrategyAlreadyAttachedError() {
  return Error(`Scroll strategy has already been attached.`);
}
var CloseScrollStrategy = class {
  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._config = _config;
    this._scrollSubscription = null;
    this._detach = () => {
      this.disable();
      if (this._overlayRef.hasAttached()) {
        this._ngZone.run(() => this._overlayRef.detach());
      }
    };
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables the closing of the attached overlay on scroll. */
  enable() {
    if (this._scrollSubscription) {
      return;
    }
    const stream = this._scrollDispatcher.scrolled(0).pipe(filter((scrollable) => {
      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);
    }));
    if (this._config && this._config.threshold && this._config.threshold > 1) {
      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
      this._scrollSubscription = stream.subscribe(() => {
        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;
        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {
          this._detach();
        } else {
          this._overlayRef.updatePosition();
        }
      });
    } else {
      this._scrollSubscription = stream.subscribe(this._detach);
    }
  }
  /** Disables the closing the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var NoopScrollStrategy = class {
  /** Does nothing, as this scroll strategy is a no-op. */
  enable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  disable() {
  }
  /** Does nothing, as this scroll strategy is a no-op. */
  attach() {
  }
};
function isElementScrolledOutsideView(element, scrollContainers) {
  return scrollContainers.some((containerBounds) => {
    const outsideAbove = element.bottom < containerBounds.top;
    const outsideBelow = element.top > containerBounds.bottom;
    const outsideLeft = element.right < containerBounds.left;
    const outsideRight = element.left > containerBounds.right;
    return outsideAbove || outsideBelow || outsideLeft || outsideRight;
  });
}
function isElementClippedByScrolling(element, scrollContainers) {
  return scrollContainers.some((scrollContainerRect) => {
    const clippedAbove = element.top < scrollContainerRect.top;
    const clippedBelow = element.bottom > scrollContainerRect.bottom;
    const clippedLeft = element.left < scrollContainerRect.left;
    const clippedRight = element.right > scrollContainerRect.right;
    return clippedAbove || clippedBelow || clippedLeft || clippedRight;
  });
}
var RepositionScrollStrategy = class {
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this._config = _config;
    this._scrollSubscription = null;
  }
  /** Attaches this scroll strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  /** Enables repositioning of the attached overlay on scroll. */
  enable() {
    if (!this._scrollSubscription) {
      const throttle = this._config ? this._config.scrollThrottle : 0;
      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {
        this._overlayRef.updatePosition();
        if (this._config && this._config.autoClose) {
          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const parentRects = [{
            width,
            height,
            bottom: height,
            right: width,
            top: 0,
            left: 0
          }];
          if (isElementScrolledOutsideView(overlayRect, parentRects)) {
            this.disable();
            this._ngZone.run(() => this._overlayRef.detach());
          }
        }
      });
    }
  }
  /** Disables repositioning of the attached overlay on scroll. */
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var _ScrollStrategyOptions = class _ScrollStrategyOptions {
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, document2) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this.noop = () => new NoopScrollStrategy();
    this.close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);
    this.block = () => new BlockScrollStrategy(this._viewportRuler, this._document);
    this.reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);
    this._document = document2;
  }
};
_ScrollStrategyOptions.ɵfac = function ScrollStrategyOptions_Factory(t) {
  return new (t || _ScrollStrategyOptions)(ɵɵinject(ScrollDispatcher), ɵɵinject(ViewportRuler), ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_ScrollStrategyOptions.ɵprov = ɵɵdefineInjectable({
  token: _ScrollStrategyOptions,
  factory: _ScrollStrategyOptions.ɵfac,
  providedIn: "root"
});
var ScrollStrategyOptions = _ScrollStrategyOptions;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollStrategyOptions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ScrollDispatcher
  }, {
    type: ViewportRuler
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var OverlayConfig = class {
  constructor(config) {
    this.scrollStrategy = new NoopScrollStrategy();
    this.panelClass = "";
    this.hasBackdrop = false;
    this.backdropClass = "cdk-overlay-dark-backdrop";
    this.disposeOnNavigation = false;
    if (config) {
      const configKeys = Object.keys(config);
      for (const key of configKeys) {
        if (config[key] !== void 0) {
          this[key] = config[key];
        }
      }
    }
  }
};
var ConnectedOverlayPositionChange = class {
  constructor(connectionPair, scrollableViewProperties) {
    this.connectionPair = connectionPair;
    this.scrollableViewProperties = scrollableViewProperties;
  }
};
function validateVerticalPosition(property, value) {
  if (value !== "top" && value !== "bottom" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "top", "bottom" or "center".`);
  }
}
function validateHorizontalPosition(property, value) {
  if (value !== "start" && value !== "end" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "start", "end" or "center".`);
  }
}
var _BaseOverlayDispatcher = class _BaseOverlayDispatcher {
  constructor(document2) {
    this._attachedOverlays = [];
    this._document = document2;
  }
  ngOnDestroy() {
    this.detach();
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    this.remove(overlayRef);
    this._attachedOverlays.push(overlayRef);
  }
  /** Remove an overlay from the list of attached overlay refs. */
  remove(overlayRef) {
    const index = this._attachedOverlays.indexOf(overlayRef);
    if (index > -1) {
      this._attachedOverlays.splice(index, 1);
    }
    if (this._attachedOverlays.length === 0) {
      this.detach();
    }
  }
};
_BaseOverlayDispatcher.ɵfac = function BaseOverlayDispatcher_Factory(t) {
  return new (t || _BaseOverlayDispatcher)(ɵɵinject(DOCUMENT));
};
_BaseOverlayDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _BaseOverlayDispatcher,
  factory: _BaseOverlayDispatcher.ɵfac,
  providedIn: "root"
});
var BaseOverlayDispatcher = _BaseOverlayDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseOverlayDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _OverlayKeyboardDispatcher = class _OverlayKeyboardDispatcher extends BaseOverlayDispatcher {
  constructor(document2, _ngZone) {
    super(document2);
    this._ngZone = _ngZone;
    this._keydownListener = (event) => {
      const overlays = this._attachedOverlays;
      for (let i = overlays.length - 1; i > -1; i--) {
        if (overlays[i]._keydownEvents.observers.length > 0) {
          const keydownEvents = overlays[i]._keydownEvents;
          if (this._ngZone) {
            this._ngZone.run(() => keydownEvents.next(event));
          } else {
            keydownEvents.next(event);
          }
          break;
        }
      }
    };
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      if (this._ngZone) {
        this._ngZone.runOutsideAngular(() => this._document.body.addEventListener("keydown", this._keydownListener));
      } else {
        this._document.body.addEventListener("keydown", this._keydownListener);
      }
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      this._document.body.removeEventListener("keydown", this._keydownListener);
      this._isAttached = false;
    }
  }
};
_OverlayKeyboardDispatcher.ɵfac = function OverlayKeyboardDispatcher_Factory(t) {
  return new (t || _OverlayKeyboardDispatcher)(ɵɵinject(DOCUMENT), ɵɵinject(NgZone, 8));
};
_OverlayKeyboardDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _OverlayKeyboardDispatcher,
  factory: _OverlayKeyboardDispatcher.ɵfac,
  providedIn: "root"
});
var OverlayKeyboardDispatcher = _OverlayKeyboardDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayKeyboardDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _OverlayOutsideClickDispatcher = class _OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {
  constructor(document2, _platform, _ngZone) {
    super(document2);
    this._platform = _platform;
    this._ngZone = _ngZone;
    this._cursorStyleIsSet = false;
    this._pointerDownListener = (event) => {
      this._pointerDownEventTarget = _getEventTarget(event);
    };
    this._clickListener = (event) => {
      const target = _getEventTarget(event);
      const origin = event.type === "click" && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;
      this._pointerDownEventTarget = null;
      const overlays = this._attachedOverlays.slice();
      for (let i = overlays.length - 1; i > -1; i--) {
        const overlayRef = overlays[i];
        if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {
          continue;
        }
        if (overlayRef.overlayElement.contains(target) || overlayRef.overlayElement.contains(origin)) {
          break;
        }
        const outsidePointerEvents = overlayRef._outsidePointerEvents;
        if (this._ngZone) {
          this._ngZone.run(() => outsidePointerEvents.next(event));
        } else {
          outsidePointerEvents.next(event);
        }
      }
    };
  }
  /** Add a new overlay to the list of attached overlay refs. */
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      const body = this._document.body;
      if (this._ngZone) {
        this._ngZone.runOutsideAngular(() => this._addEventListeners(body));
      } else {
        this._addEventListeners(body);
      }
      if (this._platform.IOS && !this._cursorStyleIsSet) {
        this._cursorOriginalValue = body.style.cursor;
        body.style.cursor = "pointer";
        this._cursorStyleIsSet = true;
      }
      this._isAttached = true;
    }
  }
  /** Detaches the global keyboard event listener. */
  detach() {
    if (this._isAttached) {
      const body = this._document.body;
      body.removeEventListener("pointerdown", this._pointerDownListener, true);
      body.removeEventListener("click", this._clickListener, true);
      body.removeEventListener("auxclick", this._clickListener, true);
      body.removeEventListener("contextmenu", this._clickListener, true);
      if (this._platform.IOS && this._cursorStyleIsSet) {
        body.style.cursor = this._cursorOriginalValue;
        this._cursorStyleIsSet = false;
      }
      this._isAttached = false;
    }
  }
  _addEventListeners(body) {
    body.addEventListener("pointerdown", this._pointerDownListener, true);
    body.addEventListener("click", this._clickListener, true);
    body.addEventListener("auxclick", this._clickListener, true);
    body.addEventListener("contextmenu", this._clickListener, true);
  }
};
_OverlayOutsideClickDispatcher.ɵfac = function OverlayOutsideClickDispatcher_Factory(t) {
  return new (t || _OverlayOutsideClickDispatcher)(ɵɵinject(DOCUMENT), ɵɵinject(Platform), ɵɵinject(NgZone, 8));
};
_OverlayOutsideClickDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _OverlayOutsideClickDispatcher,
  factory: _OverlayOutsideClickDispatcher.ɵfac,
  providedIn: "root"
});
var OverlayOutsideClickDispatcher = _OverlayOutsideClickDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayOutsideClickDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: NgZone,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _OverlayContainer = class _OverlayContainer {
  constructor(document2, _platform) {
    this._platform = _platform;
    this._document = document2;
  }
  ngOnDestroy() {
    this._containerElement?.remove();
  }
  /**
   * This method returns the overlay container element. It will lazily
   * create the element the first time it is called to facilitate using
   * the container in non-browser environments.
   * @returns the container element
   */
  getContainerElement() {
    if (!this._containerElement) {
      this._createContainer();
    }
    return this._containerElement;
  }
  /**
   * Create the overlay container element, which is simply a div
   * with the 'cdk-overlay-container' class on the document body.
   */
  _createContainer() {
    const containerClass = "cdk-overlay-container";
    if (this._platform.isBrowser || _isTestEnvironment()) {
      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform="server"], .${containerClass}[platform="test"]`);
      for (let i = 0; i < oppositePlatformContainers.length; i++) {
        oppositePlatformContainers[i].remove();
      }
    }
    const container = this._document.createElement("div");
    container.classList.add(containerClass);
    if (_isTestEnvironment()) {
      container.setAttribute("platform", "test");
    } else if (!this._platform.isBrowser) {
      container.setAttribute("platform", "server");
    }
    this._document.body.appendChild(container);
    this._containerElement = container;
  }
};
_OverlayContainer.ɵfac = function OverlayContainer_Factory(t) {
  return new (t || _OverlayContainer)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_OverlayContainer.ɵprov = ɵɵdefineInjectable({
  token: _OverlayContainer,
  factory: _OverlayContainer.ɵfac,
  providedIn: "root"
});
var OverlayContainer = _OverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();
var OverlayRef = class {
  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher, _animationsDisabled = false) {
    this._portalOutlet = _portalOutlet;
    this._host = _host;
    this._pane = _pane;
    this._config = _config;
    this._ngZone = _ngZone;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._document = _document;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsDisabled = _animationsDisabled;
    this._backdropElement = null;
    this._backdropClick = new Subject();
    this._attachments = new Subject();
    this._detachments = new Subject();
    this._locationChanges = Subscription.EMPTY;
    this._backdropClickHandler = (event) => this._backdropClick.next(event);
    this._backdropTransitionendHandler = (event) => {
      this._disposeBackdrop(event.target);
    };
    this._keydownEvents = new Subject();
    this._outsidePointerEvents = new Subject();
    if (_config.scrollStrategy) {
      this._scrollStrategy = _config.scrollStrategy;
      this._scrollStrategy.attach(this);
    }
    this._positionStrategy = _config.positionStrategy;
  }
  /** The overlay's HTML element */
  get overlayElement() {
    return this._pane;
  }
  /** The overlay's backdrop HTML element. */
  get backdropElement() {
    return this._backdropElement;
  }
  /**
   * Wrapper around the panel element. Can be used for advanced
   * positioning where a wrapper with specific styling is
   * required around the overlay pane.
   */
  get hostElement() {
    return this._host;
  }
  /**
   * Attaches content, given via a Portal, to the overlay.
   * If the overlay is configured to have a backdrop, it will be created.
   *
   * @param portal Portal instance to which to attach the overlay.
   * @returns The portal attachment result.
   */
  attach(portal) {
    if (!this._host.parentElement && this._previousHostParent) {
      this._previousHostParent.appendChild(this._host);
    }
    const attachResult = this._portalOutlet.attach(portal);
    if (this._positionStrategy) {
      this._positionStrategy.attach(this);
    }
    this._updateStackingOrder();
    this._updateElementSize();
    this._updateElementDirection();
    if (this._scrollStrategy) {
      this._scrollStrategy.enable();
    }
    this._ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (this.hasAttached()) {
        this.updatePosition();
      }
    });
    this._togglePointerEvents(true);
    if (this._config.hasBackdrop) {
      this._attachBackdrop();
    }
    if (this._config.panelClass) {
      this._toggleClasses(this._pane, this._config.panelClass, true);
    }
    this._attachments.next();
    this._keyboardDispatcher.add(this);
    if (this._config.disposeOnNavigation) {
      this._locationChanges = this._location.subscribe(() => this.dispose());
    }
    this._outsideClickDispatcher.add(this);
    if (typeof attachResult?.onDestroy === "function") {
      attachResult.onDestroy(() => {
        if (this.hasAttached()) {
          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));
        }
      });
    }
    return attachResult;
  }
  /**
   * Detaches an overlay from a portal.
   * @returns The portal detachment result.
   */
  detach() {
    if (!this.hasAttached()) {
      return;
    }
    this.detachBackdrop();
    this._togglePointerEvents(false);
    if (this._positionStrategy && this._positionStrategy.detach) {
      this._positionStrategy.detach();
    }
    if (this._scrollStrategy) {
      this._scrollStrategy.disable();
    }
    const detachmentResult = this._portalOutlet.detach();
    this._detachments.next();
    this._keyboardDispatcher.remove(this);
    this._detachContentWhenStable();
    this._locationChanges.unsubscribe();
    this._outsideClickDispatcher.remove(this);
    return detachmentResult;
  }
  /** Cleans up the overlay from the DOM. */
  dispose() {
    const isAttached = this.hasAttached();
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._disposeScrollStrategy();
    this._disposeBackdrop(this._backdropElement);
    this._locationChanges.unsubscribe();
    this._keyboardDispatcher.remove(this);
    this._portalOutlet.dispose();
    this._attachments.complete();
    this._backdropClick.complete();
    this._keydownEvents.complete();
    this._outsidePointerEvents.complete();
    this._outsideClickDispatcher.remove(this);
    this._host?.remove();
    this._previousHostParent = this._pane = this._host = null;
    if (isAttached) {
      this._detachments.next();
    }
    this._detachments.complete();
  }
  /** Whether the overlay has attached content. */
  hasAttached() {
    return this._portalOutlet.hasAttached();
  }
  /** Gets an observable that emits when the backdrop has been clicked. */
  backdropClick() {
    return this._backdropClick;
  }
  /** Gets an observable that emits when the overlay has been attached. */
  attachments() {
    return this._attachments;
  }
  /** Gets an observable that emits when the overlay has been detached. */
  detachments() {
    return this._detachments;
  }
  /** Gets an observable of keydown events targeted to this overlay. */
  keydownEvents() {
    return this._keydownEvents;
  }
  /** Gets an observable of pointer events targeted outside this overlay. */
  outsidePointerEvents() {
    return this._outsidePointerEvents;
  }
  /** Gets the current overlay configuration, which is immutable. */
  getConfig() {
    return this._config;
  }
  /** Updates the position of the overlay based on the position strategy. */
  updatePosition() {
    if (this._positionStrategy) {
      this._positionStrategy.apply();
    }
  }
  /** Switches to a new position strategy and updates the overlay position. */
  updatePositionStrategy(strategy) {
    if (strategy === this._positionStrategy) {
      return;
    }
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._positionStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      this.updatePosition();
    }
  }
  /** Update the size properties of the overlay. */
  updateSize(sizeConfig) {
    this._config = __spreadValues(__spreadValues({}, this._config), sizeConfig);
    this._updateElementSize();
  }
  /** Sets the LTR/RTL direction for the overlay. */
  setDirection(dir) {
    this._config = __spreadProps(__spreadValues({}, this._config), {
      direction: dir
    });
    this._updateElementDirection();
  }
  /** Add a CSS class or an array of classes to the overlay pane. */
  addPanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, true);
    }
  }
  /** Remove a CSS class or an array of classes from the overlay pane. */
  removePanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, false);
    }
  }
  /**
   * Returns the layout direction of the overlay panel.
   */
  getDirection() {
    const direction = this._config.direction;
    if (!direction) {
      return "ltr";
    }
    return typeof direction === "string" ? direction : direction.value;
  }
  /** Switches to a new scroll strategy. */
  updateScrollStrategy(strategy) {
    if (strategy === this._scrollStrategy) {
      return;
    }
    this._disposeScrollStrategy();
    this._scrollStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      strategy.enable();
    }
  }
  /** Updates the text direction of the overlay panel. */
  _updateElementDirection() {
    this._host.setAttribute("dir", this.getDirection());
  }
  /** Updates the size of the overlay element based on the overlay config. */
  _updateElementSize() {
    if (!this._pane) {
      return;
    }
    const style2 = this._pane.style;
    style2.width = coerceCssPixelValue(this._config.width);
    style2.height = coerceCssPixelValue(this._config.height);
    style2.minWidth = coerceCssPixelValue(this._config.minWidth);
    style2.minHeight = coerceCssPixelValue(this._config.minHeight);
    style2.maxWidth = coerceCssPixelValue(this._config.maxWidth);
    style2.maxHeight = coerceCssPixelValue(this._config.maxHeight);
  }
  /** Toggles the pointer events for the overlay pane element. */
  _togglePointerEvents(enablePointer) {
    this._pane.style.pointerEvents = enablePointer ? "" : "none";
  }
  /** Attaches a backdrop for this overlay. */
  _attachBackdrop() {
    const showingClass = "cdk-overlay-backdrop-showing";
    this._backdropElement = this._document.createElement("div");
    this._backdropElement.classList.add("cdk-overlay-backdrop");
    if (this._animationsDisabled) {
      this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation");
    }
    if (this._config.backdropClass) {
      this._toggleClasses(this._backdropElement, this._config.backdropClass, true);
    }
    this._host.parentElement.insertBefore(this._backdropElement, this._host);
    this._backdropElement.addEventListener("click", this._backdropClickHandler);
    if (!this._animationsDisabled && typeof requestAnimationFrame !== "undefined") {
      this._ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          if (this._backdropElement) {
            this._backdropElement.classList.add(showingClass);
          }
        });
      });
    } else {
      this._backdropElement.classList.add(showingClass);
    }
  }
  /**
   * Updates the stacking order of the element, moving it to the top if necessary.
   * This is required in cases where one overlay was detached, while another one,
   * that should be behind it, was destroyed. The next time both of them are opened,
   * the stacking will be wrong, because the detached element's pane will still be
   * in its original DOM position.
   */
  _updateStackingOrder() {
    if (this._host.nextSibling) {
      this._host.parentNode.appendChild(this._host);
    }
  }
  /** Detaches the backdrop (if any) associated with the overlay. */
  detachBackdrop() {
    const backdropToDetach = this._backdropElement;
    if (!backdropToDetach) {
      return;
    }
    if (this._animationsDisabled) {
      this._disposeBackdrop(backdropToDetach);
      return;
    }
    backdropToDetach.classList.remove("cdk-overlay-backdrop-showing");
    this._ngZone.runOutsideAngular(() => {
      backdropToDetach.addEventListener("transitionend", this._backdropTransitionendHandler);
    });
    backdropToDetach.style.pointerEvents = "none";
    this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => {
      this._disposeBackdrop(backdropToDetach);
    }, 500));
  }
  /** Toggles a single CSS class or an array of classes on an element. */
  _toggleClasses(element, cssClasses, isAdd) {
    const classes = coerceArray(cssClasses || []).filter((c) => !!c);
    if (classes.length) {
      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);
    }
  }
  /** Detaches the overlay content next time the zone stabilizes. */
  _detachContentWhenStable() {
    this._ngZone.runOutsideAngular(() => {
      const subscription = this._ngZone.onStable.pipe(takeUntil(merge(this._attachments, this._detachments))).subscribe(() => {
        if (!this._pane || !this._host || this._pane.children.length === 0) {
          if (this._pane && this._config.panelClass) {
            this._toggleClasses(this._pane, this._config.panelClass, false);
          }
          if (this._host && this._host.parentElement) {
            this._previousHostParent = this._host.parentElement;
            this._host.remove();
          }
          subscription.unsubscribe();
        }
      });
    });
  }
  /** Disposes of a scroll strategy. */
  _disposeScrollStrategy() {
    const scrollStrategy = this._scrollStrategy;
    if (scrollStrategy) {
      scrollStrategy.disable();
      if (scrollStrategy.detach) {
        scrollStrategy.detach();
      }
    }
  }
  /** Removes a backdrop element from the DOM. */
  _disposeBackdrop(backdrop) {
    if (backdrop) {
      backdrop.removeEventListener("click", this._backdropClickHandler);
      backdrop.removeEventListener("transitionend", this._backdropTransitionendHandler);
      backdrop.remove();
      if (this._backdropElement === backdrop) {
        this._backdropElement = null;
      }
    }
    if (this._backdropTimeout) {
      clearTimeout(this._backdropTimeout);
      this._backdropTimeout = void 0;
    }
  }
};
var boundingBoxClass = "cdk-overlay-connected-position-bounding-box";
var cssUnitPattern = /([A-Za-z%]+)$/;
var FlexibleConnectedPositionStrategy = class {
  /** Ordered list of preferred positions, from most to least desirable. */
  get positions() {
    return this._preferredPositions;
  }
  constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
    this._lastBoundingBoxSize = {
      width: 0,
      height: 0
    };
    this._isPushed = false;
    this._canPush = true;
    this._growAfterOpen = false;
    this._hasFlexibleDimensions = true;
    this._positionLocked = false;
    this._viewportMargin = 0;
    this._scrollables = [];
    this._preferredPositions = [];
    this._positionChanges = new Subject();
    this._resizeSubscription = Subscription.EMPTY;
    this._offsetX = 0;
    this._offsetY = 0;
    this._appliedPanelClasses = [];
    this.positionChanges = this._positionChanges;
    this.setOrigin(connectedTo);
  }
  /** Attaches this position strategy to an overlay. */
  attach(overlayRef) {
    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("This position strategy is already attached to an overlay");
    }
    this._validatePositions();
    overlayRef.hostElement.classList.add(boundingBoxClass);
    this._overlayRef = overlayRef;
    this._boundingBox = overlayRef.hostElement;
    this._pane = overlayRef.overlayElement;
    this._isDisposed = false;
    this._isInitialRender = true;
    this._lastPosition = null;
    this._resizeSubscription.unsubscribe();
    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
      this._isInitialRender = true;
      this.apply();
    });
  }
  /**
   * Updates the position of the overlay element, using whichever preferred position relative
   * to the origin best fits on-screen.
   *
   * The selection of a position goes as follows:
   *  - If any positions fit completely within the viewport as-is,
   *      choose the first position that does so.
   *  - If flexible dimensions are enabled and at least one satisfies the given minimum width/height,
   *      choose the position with the greatest available size modified by the positions' weight.
   *  - If pushing is enabled, take the position that went off-screen the least and push it
   *      on-screen.
   *  - If none of the previous criteria were met, use the position that goes off-screen the least.
   * @docs-private
   */
  apply() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
      this.reapplyLastPosition();
      return;
    }
    this._clearPanelClasses();
    this._resetOverlayElementStyles();
    this._resetBoundingBoxStyles();
    this._viewportRect = this._getNarrowedViewportRect();
    this._originRect = this._getOriginRect();
    this._overlayRect = this._pane.getBoundingClientRect();
    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
    const originRect = this._originRect;
    const overlayRect = this._overlayRect;
    const viewportRect = this._viewportRect;
    const containerRect = this._containerRect;
    const flexibleFits = [];
    let fallback;
    for (let pos of this._preferredPositions) {
      let originPoint = this._getOriginPoint(originRect, containerRect, pos);
      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
      if (overlayFit.isCompletelyWithinViewport) {
        this._isPushed = false;
        this._applyPosition(pos, originPoint);
        return;
      }
      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
        flexibleFits.push({
          position: pos,
          origin: originPoint,
          overlayRect,
          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
        });
        continue;
      }
      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
        fallback = {
          overlayFit,
          overlayPoint,
          originPoint,
          position: pos,
          overlayRect
        };
      }
    }
    if (flexibleFits.length) {
      let bestFit = null;
      let bestScore = -1;
      for (const fit of flexibleFits) {
        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
        if (score > bestScore) {
          bestScore = score;
          bestFit = fit;
        }
      }
      this._isPushed = false;
      this._applyPosition(bestFit.position, bestFit.origin);
      return;
    }
    if (this._canPush) {
      this._isPushed = true;
      this._applyPosition(fallback.position, fallback.originPoint);
      return;
    }
    this._applyPosition(fallback.position, fallback.originPoint);
  }
  detach() {
    this._clearPanelClasses();
    this._lastPosition = null;
    this._previousPushAmount = null;
    this._resizeSubscription.unsubscribe();
  }
  /** Cleanup after the element gets destroyed. */
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (this._boundingBox) {
      extendStyles(this._boundingBox.style, {
        top: "",
        left: "",
        right: "",
        bottom: "",
        height: "",
        width: "",
        alignItems: "",
        justifyContent: ""
      });
    }
    if (this._pane) {
      this._resetOverlayElementStyles();
    }
    if (this._overlayRef) {
      this._overlayRef.hostElement.classList.remove(boundingBoxClass);
    }
    this.detach();
    this._positionChanges.complete();
    this._overlayRef = this._boundingBox = null;
    this._isDisposed = true;
  }
  /**
   * This re-aligns the overlay element with the trigger in its last calculated position,
   * even if a position higher in the "preferred positions" list would now fit. This
   * allows one to re-align the panel without changing the orientation of the panel.
   */
  reapplyLastPosition() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    const lastPosition = this._lastPosition;
    if (lastPosition) {
      this._originRect = this._getOriginRect();
      this._overlayRect = this._pane.getBoundingClientRect();
      this._viewportRect = this._getNarrowedViewportRect();
      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);
      this._applyPosition(lastPosition, originPoint);
    } else {
      this.apply();
    }
  }
  /**
   * Sets the list of Scrollable containers that host the origin element so that
   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every
   * Scrollable must be an ancestor element of the strategy's origin element.
   */
  withScrollableContainers(scrollables) {
    this._scrollables = scrollables;
    return this;
  }
  /**
   * Adds new preferred positions.
   * @param positions List of positions options for this overlay.
   */
  withPositions(positions) {
    this._preferredPositions = positions;
    if (positions.indexOf(this._lastPosition) === -1) {
      this._lastPosition = null;
    }
    this._validatePositions();
    return this;
  }
  /**
   * Sets a minimum distance the overlay may be positioned to the edge of the viewport.
   * @param margin Required margin between the overlay and the viewport edge in pixels.
   */
  withViewportMargin(margin) {
    this._viewportMargin = margin;
    return this;
  }
  /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */
  withFlexibleDimensions(flexibleDimensions = true) {
    this._hasFlexibleDimensions = flexibleDimensions;
    return this;
  }
  /** Sets whether the overlay can grow after the initial open via flexible width/height. */
  withGrowAfterOpen(growAfterOpen = true) {
    this._growAfterOpen = growAfterOpen;
    return this;
  }
  /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */
  withPush(canPush = true) {
    this._canPush = canPush;
    return this;
  }
  /**
   * Sets whether the overlay's position should be locked in after it is positioned
   * initially. When an overlay is locked in, it won't attempt to reposition itself
   * when the position is re-applied (e.g. when the user scrolls away).
   * @param isLocked Whether the overlay should locked in.
   */
  withLockedPosition(isLocked = true) {
    this._positionLocked = isLocked;
    return this;
  }
  /**
   * Sets the origin, relative to which to position the overlay.
   * Using an element origin is useful for building components that need to be positioned
   * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be
   * used for cases like contextual menus which open relative to the user's pointer.
   * @param origin Reference to the new origin.
   */
  setOrigin(origin) {
    this._origin = origin;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the x-axis.
   * @param offset New offset in the X axis.
   */
  withDefaultOffsetX(offset) {
    this._offsetX = offset;
    return this;
  }
  /**
   * Sets the default offset for the overlay's connection point on the y-axis.
   * @param offset New offset in the Y axis.
   */
  withDefaultOffsetY(offset) {
    this._offsetY = offset;
    return this;
  }
  /**
   * Configures that the position strategy should set a `transform-origin` on some elements
   * inside the overlay, depending on the current position that is being applied. This is
   * useful for the cases where the origin of an animation can change depending on the
   * alignment of the overlay.
   * @param selector CSS selector that will be used to find the target
   *    elements onto which to set the transform origin.
   */
  withTransformOriginOn(selector) {
    this._transformOriginSelector = selector;
    return this;
  }
  /**
   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.
   */
  _getOriginPoint(originRect, containerRect, pos) {
    let x;
    if (pos.originX == "center") {
      x = originRect.left + originRect.width / 2;
    } else {
      const startX = this._isRtl() ? originRect.right : originRect.left;
      const endX = this._isRtl() ? originRect.left : originRect.right;
      x = pos.originX == "start" ? startX : endX;
    }
    if (containerRect.left < 0) {
      x -= containerRect.left;
    }
    let y;
    if (pos.originY == "center") {
      y = originRect.top + originRect.height / 2;
    } else {
      y = pos.originY == "top" ? originRect.top : originRect.bottom;
    }
    if (containerRect.top < 0) {
      y -= containerRect.top;
    }
    return {
      x,
      y
    };
  }
  /**
   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and
   * origin point to which the overlay should be connected.
   */
  _getOverlayPoint(originPoint, overlayRect, pos) {
    let overlayStartX;
    if (pos.overlayX == "center") {
      overlayStartX = -overlayRect.width / 2;
    } else if (pos.overlayX === "start") {
      overlayStartX = this._isRtl() ? -overlayRect.width : 0;
    } else {
      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
    }
    let overlayStartY;
    if (pos.overlayY == "center") {
      overlayStartY = -overlayRect.height / 2;
    } else {
      overlayStartY = pos.overlayY == "top" ? 0 : -overlayRect.height;
    }
    return {
      x: originPoint.x + overlayStartX,
      y: originPoint.y + overlayStartY
    };
  }
  /** Gets how well an overlay at the given point will fit within the viewport. */
  _getOverlayFit(point, rawOverlayRect, viewport, position) {
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    let {
      x,
      y
    } = point;
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      x += offsetX;
    }
    if (offsetY) {
      y += offsetY;
    }
    let leftOverflow = 0 - x;
    let rightOverflow = x + overlay.width - viewport.width;
    let topOverflow = 0 - y;
    let bottomOverflow = y + overlay.height - viewport.height;
    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
    let visibleArea = visibleWidth * visibleHeight;
    return {
      visibleArea,
      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
      fitsInViewportVertically: visibleHeight === overlay.height,
      fitsInViewportHorizontally: visibleWidth == overlay.width
    };
  }
  /**
   * Whether the overlay can fit within the viewport when it may resize either its width or height.
   * @param fit How well the overlay fits in the viewport at some position.
   * @param point The (x, y) coordinates of the overlay at some position.
   * @param viewport The geometry of the viewport.
   */
  _canFitWithFlexibleDimensions(fit, point, viewport) {
    if (this._hasFlexibleDimensions) {
      const availableHeight = viewport.bottom - point.y;
      const availableWidth = viewport.right - point.x;
      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);
      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);
      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
      return verticalFit && horizontalFit;
    }
    return false;
  }
  /**
   * Gets the point at which the overlay can be "pushed" on-screen. If the overlay is larger than
   * the viewport, the top-left corner will be pushed on-screen (with overflow occurring on the
   * right and bottom).
   *
   * @param start Starting point from which the overlay is pushed.
   * @param rawOverlayRect Dimensions of the overlay.
   * @param scrollPosition Current viewport scroll position.
   * @returns The point at which to position the overlay after pushing. This is effectively a new
   *     originPoint.
   */
  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {
    if (this._previousPushAmount && this._positionLocked) {
      return {
        x: start.x + this._previousPushAmount.x,
        y: start.y + this._previousPushAmount.y
      };
    }
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    const viewport = this._viewportRect;
    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);
    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);
    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
    let pushX = 0;
    let pushY = 0;
    if (overlay.width <= viewport.width) {
      pushX = overflowLeft || -overflowRight;
    } else {
      pushX = start.x < this._viewportMargin ? viewport.left - scrollPosition.left - start.x : 0;
    }
    if (overlay.height <= viewport.height) {
      pushY = overflowTop || -overflowBottom;
    } else {
      pushY = start.y < this._viewportMargin ? viewport.top - scrollPosition.top - start.y : 0;
    }
    this._previousPushAmount = {
      x: pushX,
      y: pushY
    };
    return {
      x: start.x + pushX,
      y: start.y + pushY
    };
  }
  /**
   * Applies a computed position to the overlay and emits a position change.
   * @param position The position preference
   * @param originPoint The point on the origin element where the overlay is connected.
   */
  _applyPosition(position, originPoint) {
    this._setTransformOrigin(position);
    this._setOverlayElementStyles(originPoint, position);
    this._setBoundingBoxStyles(originPoint, position);
    if (position.panelClass) {
      this._addPanelClasses(position.panelClass);
    }
    this._lastPosition = position;
    if (this._positionChanges.observers.length) {
      const scrollableViewProperties = this._getScrollVisibility();
      const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);
      this._positionChanges.next(changeEvent);
    }
    this._isInitialRender = false;
  }
  /** Sets the transform origin based on the configured selector and the passed-in position.  */
  _setTransformOrigin(position) {
    if (!this._transformOriginSelector) {
      return;
    }
    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
    let xOrigin;
    let yOrigin = position.overlayY;
    if (position.overlayX === "center") {
      xOrigin = "center";
    } else if (this._isRtl()) {
      xOrigin = position.overlayX === "start" ? "right" : "left";
    } else {
      xOrigin = position.overlayX === "start" ? "left" : "right";
    }
    for (let i = 0; i < elements.length; i++) {
      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;
    }
  }
  /**
   * Gets the position and size of the overlay's sizing container.
   *
   * This method does no measuring and applies no styles so that we can cheaply compute the
   * bounds for all positions and choose the best fit based on these results.
   */
  _calculateBoundingBoxRect(origin, position) {
    const viewport = this._viewportRect;
    const isRtl = this._isRtl();
    let height, top, bottom;
    if (position.overlayY === "top") {
      top = origin.y;
      height = viewport.height - top + this._viewportMargin;
    } else if (position.overlayY === "bottom") {
      bottom = viewport.height - origin.y + this._viewportMargin * 2;
      height = viewport.height - bottom + this._viewportMargin;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
      const previousHeight = this._lastBoundingBoxSize.height;
      height = smallestDistanceToViewportEdge * 2;
      top = origin.y - smallestDistanceToViewportEdge;
      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
        top = origin.y - previousHeight / 2;
      }
    }
    const isBoundedByRightViewportEdge = position.overlayX === "start" && !isRtl || position.overlayX === "end" && isRtl;
    const isBoundedByLeftViewportEdge = position.overlayX === "end" && !isRtl || position.overlayX === "start" && isRtl;
    let width, left, right;
    if (isBoundedByLeftViewportEdge) {
      right = viewport.width - origin.x + this._viewportMargin;
      width = origin.x - this._viewportMargin;
    } else if (isBoundedByRightViewportEdge) {
      left = origin.x;
      width = viewport.right - origin.x;
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
      const previousWidth = this._lastBoundingBoxSize.width;
      width = smallestDistanceToViewportEdge * 2;
      left = origin.x - smallestDistanceToViewportEdge;
      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
        left = origin.x - previousWidth / 2;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  /**
   * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the
   * origin's connection point and stretches to the bounds of the viewport.
   *
   * @param origin The point on the origin element where the overlay is connected.
   * @param position The position preference
   */
  _setBoundingBoxStyles(origin, position) {
    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
    if (!this._isInitialRender && !this._growAfterOpen) {
      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
    }
    const styles = {};
    if (this._hasExactPosition()) {
      styles.top = styles.left = "0";
      styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = "";
      styles.width = styles.height = "100%";
    } else {
      const maxHeight = this._overlayRef.getConfig().maxHeight;
      const maxWidth = this._overlayRef.getConfig().maxWidth;
      styles.height = coerceCssPixelValue(boundingBoxRect.height);
      styles.top = coerceCssPixelValue(boundingBoxRect.top);
      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);
      styles.width = coerceCssPixelValue(boundingBoxRect.width);
      styles.left = coerceCssPixelValue(boundingBoxRect.left);
      styles.right = coerceCssPixelValue(boundingBoxRect.right);
      if (position.overlayX === "center") {
        styles.alignItems = "center";
      } else {
        styles.alignItems = position.overlayX === "end" ? "flex-end" : "flex-start";
      }
      if (position.overlayY === "center") {
        styles.justifyContent = "center";
      } else {
        styles.justifyContent = position.overlayY === "bottom" ? "flex-end" : "flex-start";
      }
      if (maxHeight) {
        styles.maxHeight = coerceCssPixelValue(maxHeight);
      }
      if (maxWidth) {
        styles.maxWidth = coerceCssPixelValue(maxWidth);
      }
    }
    this._lastBoundingBoxSize = boundingBoxRect;
    extendStyles(this._boundingBox.style, styles);
  }
  /** Resets the styles for the bounding box so that a new positioning can be computed. */
  _resetBoundingBoxStyles() {
    extendStyles(this._boundingBox.style, {
      top: "0",
      left: "0",
      right: "0",
      bottom: "0",
      height: "",
      width: "",
      alignItems: "",
      justifyContent: ""
    });
  }
  /** Resets the styles for the overlay pane so that a new positioning can be computed. */
  _resetOverlayElementStyles() {
    extendStyles(this._pane.style, {
      top: "",
      left: "",
      bottom: "",
      right: "",
      position: "",
      transform: ""
    });
  }
  /** Sets positioning styles to the overlay element. */
  _setOverlayElementStyles(originPoint, position) {
    const styles = {};
    const hasExactPosition = this._hasExactPosition();
    const hasFlexibleDimensions = this._hasFlexibleDimensions;
    const config = this._overlayRef.getConfig();
    if (hasExactPosition) {
      const scrollPosition = this._viewportRuler.getViewportScrollPosition();
      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
    } else {
      styles.position = "static";
    }
    let transformString = "";
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      transformString += `translateX(${offsetX}px) `;
    }
    if (offsetY) {
      transformString += `translateY(${offsetY}px)`;
    }
    styles.transform = transformString.trim();
    if (config.maxHeight) {
      if (hasExactPosition) {
        styles.maxHeight = coerceCssPixelValue(config.maxHeight);
      } else if (hasFlexibleDimensions) {
        styles.maxHeight = "";
      }
    }
    if (config.maxWidth) {
      if (hasExactPosition) {
        styles.maxWidth = coerceCssPixelValue(config.maxWidth);
      } else if (hasFlexibleDimensions) {
        styles.maxWidth = "";
      }
    }
    extendStyles(this._pane.style, styles);
  }
  /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayY(position, originPoint, scrollPosition) {
    let styles = {
      top: "",
      bottom: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    if (position.overlayY === "bottom") {
      const documentHeight = this._document.documentElement.clientHeight;
      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;
    } else {
      styles.top = coerceCssPixelValue(overlayPoint.y);
    }
    return styles;
  }
  /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */
  _getExactOverlayX(position, originPoint, scrollPosition) {
    let styles = {
      left: "",
      right: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    let horizontalStyleProperty;
    if (this._isRtl()) {
      horizontalStyleProperty = position.overlayX === "end" ? "left" : "right";
    } else {
      horizontalStyleProperty = position.overlayX === "end" ? "right" : "left";
    }
    if (horizontalStyleProperty === "right") {
      const documentWidth = this._document.documentElement.clientWidth;
      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;
    } else {
      styles.left = coerceCssPixelValue(overlayPoint.x);
    }
    return styles;
  }
  /**
   * Gets the view properties of the trigger and overlay, including whether they are clipped
   * or completely outside the view of any of the strategy's scrollables.
   */
  _getScrollVisibility() {
    const originBounds = this._getOriginRect();
    const overlayBounds = this._pane.getBoundingClientRect();
    const scrollContainerBounds = this._scrollables.map((scrollable) => {
      return scrollable.getElementRef().nativeElement.getBoundingClientRect();
    });
    return {
      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
    };
  }
  /** Subtracts the amount that an element is overflowing on an axis from its length. */
  _subtractOverflows(length, ...overflows) {
    return overflows.reduce((currentValue, currentOverflow) => {
      return currentValue - Math.max(currentOverflow, 0);
    }, length);
  }
  /** Narrows the given viewport rect by the current _viewportMargin. */
  _getNarrowedViewportRect() {
    const width = this._document.documentElement.clientWidth;
    const height = this._document.documentElement.clientHeight;
    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
    return {
      top: scrollPosition.top + this._viewportMargin,
      left: scrollPosition.left + this._viewportMargin,
      right: scrollPosition.left + width - this._viewportMargin,
      bottom: scrollPosition.top + height - this._viewportMargin,
      width: width - 2 * this._viewportMargin,
      height: height - 2 * this._viewportMargin
    };
  }
  /** Whether the we're dealing with an RTL context */
  _isRtl() {
    return this._overlayRef.getDirection() === "rtl";
  }
  /** Determines whether the overlay uses exact or flexible positioning. */
  _hasExactPosition() {
    return !this._hasFlexibleDimensions || this._isPushed;
  }
  /** Retrieves the offset of a position along the x or y axis. */
  _getOffset(position, axis) {
    if (axis === "x") {
      return position.offsetX == null ? this._offsetX : position.offsetX;
    }
    return position.offsetY == null ? this._offsetY : position.offsetY;
  }
  /** Validates that the current position match the expected values. */
  _validatePositions() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!this._preferredPositions.length) {
        throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
      }
      this._preferredPositions.forEach((pair) => {
        validateHorizontalPosition("originX", pair.originX);
        validateVerticalPosition("originY", pair.originY);
        validateHorizontalPosition("overlayX", pair.overlayX);
        validateVerticalPosition("overlayY", pair.overlayY);
      });
    }
  }
  /** Adds a single CSS class or an array of classes on the overlay panel. */
  _addPanelClasses(cssClasses) {
    if (this._pane) {
      coerceArray(cssClasses).forEach((cssClass) => {
        if (cssClass !== "" && this._appliedPanelClasses.indexOf(cssClass) === -1) {
          this._appliedPanelClasses.push(cssClass);
          this._pane.classList.add(cssClass);
        }
      });
    }
  }
  /** Clears the classes that the position strategy has applied from the overlay panel. */
  _clearPanelClasses() {
    if (this._pane) {
      this._appliedPanelClasses.forEach((cssClass) => {
        this._pane.classList.remove(cssClass);
      });
      this._appliedPanelClasses = [];
    }
  }
  /** Returns the DOMRect of the current origin. */
  _getOriginRect() {
    const origin = this._origin;
    if (origin instanceof ElementRef) {
      return origin.nativeElement.getBoundingClientRect();
    }
    if (origin instanceof Element) {
      return origin.getBoundingClientRect();
    }
    const width = origin.width || 0;
    const height = origin.height || 0;
    return {
      top: origin.y,
      bottom: origin.y + height,
      left: origin.x,
      right: origin.x + width,
      height,
      width
    };
  }
};
function extendStyles(destination, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      destination[key] = source[key];
    }
  }
  return destination;
}
function getPixelValue(input) {
  if (typeof input !== "number" && input != null) {
    const [value, units] = input.split(cssUnitPattern);
    return !units || units === "px" ? parseFloat(value) : null;
  }
  return input || null;
}
function getRoundedBoundingClientRect(clientRect) {
  return {
    top: Math.floor(clientRect.top),
    right: Math.floor(clientRect.right),
    bottom: Math.floor(clientRect.bottom),
    left: Math.floor(clientRect.left),
    width: Math.floor(clientRect.width),
    height: Math.floor(clientRect.height)
  };
}
var wrapperClass = "cdk-global-overlay-wrapper";
var GlobalPositionStrategy = class {
  constructor() {
    this._cssPosition = "static";
    this._topOffset = "";
    this._bottomOffset = "";
    this._alignItems = "";
    this._xPosition = "";
    this._xOffset = "";
    this._width = "";
    this._height = "";
    this._isDisposed = false;
  }
  attach(overlayRef) {
    const config = overlayRef.getConfig();
    this._overlayRef = overlayRef;
    if (this._width && !config.width) {
      overlayRef.updateSize({
        width: this._width
      });
    }
    if (this._height && !config.height) {
      overlayRef.updateSize({
        height: this._height
      });
    }
    overlayRef.hostElement.classList.add(wrapperClass);
    this._isDisposed = false;
  }
  /**
   * Sets the top position of the overlay. Clears any previously set vertical position.
   * @param value New top offset.
   */
  top(value = "") {
    this._bottomOffset = "";
    this._topOffset = value;
    this._alignItems = "flex-start";
    return this;
  }
  /**
   * Sets the left position of the overlay. Clears any previously set horizontal position.
   * @param value New left offset.
   */
  left(value = "") {
    this._xOffset = value;
    this._xPosition = "left";
    return this;
  }
  /**
   * Sets the bottom position of the overlay. Clears any previously set vertical position.
   * @param value New bottom offset.
   */
  bottom(value = "") {
    this._topOffset = "";
    this._bottomOffset = value;
    this._alignItems = "flex-end";
    return this;
  }
  /**
   * Sets the right position of the overlay. Clears any previously set horizontal position.
   * @param value New right offset.
   */
  right(value = "") {
    this._xOffset = value;
    this._xPosition = "right";
    return this;
  }
  /**
   * Sets the overlay to the start of the viewport, depending on the overlay direction.
   * This will be to the left in LTR layouts and to the right in RTL.
   * @param offset Offset from the edge of the screen.
   */
  start(value = "") {
    this._xOffset = value;
    this._xPosition = "start";
    return this;
  }
  /**
   * Sets the overlay to the end of the viewport, depending on the overlay direction.
   * This will be to the right in LTR layouts and to the left in RTL.
   * @param offset Offset from the edge of the screen.
   */
  end(value = "") {
    this._xOffset = value;
    this._xPosition = "end";
    return this;
  }
  /**
   * Sets the overlay width and clears any previously set width.
   * @param value New width for the overlay
   * @deprecated Pass the `width` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  width(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        width: value
      });
    } else {
      this._width = value;
    }
    return this;
  }
  /**
   * Sets the overlay height and clears any previously set height.
   * @param value New height for the overlay
   * @deprecated Pass the `height` through the `OverlayConfig`.
   * @breaking-change 8.0.0
   */
  height(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        height: value
      });
    } else {
      this._height = value;
    }
    return this;
  }
  /**
   * Centers the overlay horizontally with an optional offset.
   * Clears any previously set horizontal position.
   *
   * @param offset Overlay offset from the horizontal center.
   */
  centerHorizontally(offset = "") {
    this.left(offset);
    this._xPosition = "center";
    return this;
  }
  /**
   * Centers the overlay vertically with an optional offset.
   * Clears any previously set vertical position.
   *
   * @param offset Overlay offset from the vertical center.
   */
  centerVertically(offset = "") {
    this.top(offset);
    this._alignItems = "center";
    return this;
  }
  /**
   * Apply the position to the element.
   * @docs-private
   */
  apply() {
    if (!this._overlayRef || !this._overlayRef.hasAttached()) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parentStyles = this._overlayRef.hostElement.style;
    const config = this._overlayRef.getConfig();
    const {
      width,
      height,
      maxWidth,
      maxHeight
    } = config;
    const shouldBeFlushHorizontally = (width === "100%" || width === "100vw") && (!maxWidth || maxWidth === "100%" || maxWidth === "100vw");
    const shouldBeFlushVertically = (height === "100%" || height === "100vh") && (!maxHeight || maxHeight === "100%" || maxHeight === "100vh");
    const xPosition = this._xPosition;
    const xOffset = this._xOffset;
    const isRtl = this._overlayRef.getConfig().direction === "rtl";
    let marginLeft = "";
    let marginRight = "";
    let justifyContent = "";
    if (shouldBeFlushHorizontally) {
      justifyContent = "flex-start";
    } else if (xPosition === "center") {
      justifyContent = "center";
      if (isRtl) {
        marginRight = xOffset;
      } else {
        marginLeft = xOffset;
      }
    } else if (isRtl) {
      if (xPosition === "left" || xPosition === "end") {
        justifyContent = "flex-end";
        marginLeft = xOffset;
      } else if (xPosition === "right" || xPosition === "start") {
        justifyContent = "flex-start";
        marginRight = xOffset;
      }
    } else if (xPosition === "left" || xPosition === "start") {
      justifyContent = "flex-start";
      marginLeft = xOffset;
    } else if (xPosition === "right" || xPosition === "end") {
      justifyContent = "flex-end";
      marginRight = xOffset;
    }
    styles.position = this._cssPosition;
    styles.marginLeft = shouldBeFlushHorizontally ? "0" : marginLeft;
    styles.marginTop = shouldBeFlushVertically ? "0" : this._topOffset;
    styles.marginBottom = this._bottomOffset;
    styles.marginRight = shouldBeFlushHorizontally ? "0" : marginRight;
    parentStyles.justifyContent = justifyContent;
    parentStyles.alignItems = shouldBeFlushVertically ? "flex-start" : this._alignItems;
  }
  /**
   * Cleans up the DOM changes from the position strategy.
   * @docs-private
   */
  dispose() {
    if (this._isDisposed || !this._overlayRef) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parent = this._overlayRef.hostElement;
    const parentStyles = parent.style;
    parent.classList.remove(wrapperClass);
    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = "";
    this._overlayRef = null;
    this._isDisposed = true;
  }
};
var _OverlayPositionBuilder = class _OverlayPositionBuilder {
  constructor(_viewportRuler, _document, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
  }
  /**
   * Creates a global position strategy.
   */
  global() {
    return new GlobalPositionStrategy();
  }
  /**
   * Creates a flexible position strategy.
   * @param origin Origin relative to which to position the overlay.
   */
  flexibleConnectedTo(origin) {
    return new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
  }
};
_OverlayPositionBuilder.ɵfac = function OverlayPositionBuilder_Factory(t) {
  return new (t || _OverlayPositionBuilder)(ɵɵinject(ViewportRuler), ɵɵinject(DOCUMENT), ɵɵinject(Platform), ɵɵinject(OverlayContainer));
};
_OverlayPositionBuilder.ɵprov = ɵɵdefineInjectable({
  token: _OverlayPositionBuilder,
  factory: _OverlayPositionBuilder.ɵfac,
  providedIn: "root"
});
var OverlayPositionBuilder = _OverlayPositionBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayPositionBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ViewportRuler
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: OverlayContainer
  }], null);
})();
var nextUniqueId = 0;
var _Overlay = class _Overlay {
  constructor(scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher, _animationsModuleType) {
    this.scrollStrategies = scrollStrategies;
    this._overlayContainer = _overlayContainer;
    this._componentFactoryResolver = _componentFactoryResolver;
    this._positionBuilder = _positionBuilder;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._injector = _injector;
    this._ngZone = _ngZone;
    this._document = _document;
    this._directionality = _directionality;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsModuleType = _animationsModuleType;
  }
  /**
   * Creates an overlay.
   * @param config Configuration applied to the overlay.
   * @returns Reference to the created overlay.
   */
  create(config) {
    const host = this._createHostElement();
    const pane = this._createPaneElement(host);
    const portalOutlet = this._createPortalOutlet(pane);
    const overlayConfig = new OverlayConfig(config);
    overlayConfig.direction = overlayConfig.direction || this._directionality.value;
    return new OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === "NoopAnimations");
  }
  /**
   * Gets a position builder that can be used, via fluent API,
   * to construct and configure a position strategy.
   * @returns An overlay position builder.
   */
  position() {
    return this._positionBuilder;
  }
  /**
   * Creates the DOM element for an overlay and appends it to the overlay container.
   * @returns Newly-created pane element
   */
  _createPaneElement(host) {
    const pane = this._document.createElement("div");
    pane.id = `cdk-overlay-${nextUniqueId++}`;
    pane.classList.add("cdk-overlay-pane");
    host.appendChild(pane);
    return pane;
  }
  /**
   * Creates the host element that wraps around an overlay
   * and can be used for advanced positioning.
   * @returns Newly-create host element.
   */
  _createHostElement() {
    const host = this._document.createElement("div");
    this._overlayContainer.getContainerElement().appendChild(host);
    return host;
  }
  /**
   * Create a DomPortalOutlet into which the overlay content can be loaded.
   * @param pane The DOM element to turn into a portal outlet.
   * @returns A portal outlet for the given DOM element.
   */
  _createPortalOutlet(pane) {
    if (!this._appRef) {
      this._appRef = this._injector.get(ApplicationRef);
    }
    return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);
  }
};
_Overlay.ɵfac = function Overlay_Factory(t) {
  return new (t || _Overlay)(ɵɵinject(ScrollStrategyOptions), ɵɵinject(OverlayContainer), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(OverlayPositionBuilder), ɵɵinject(OverlayKeyboardDispatcher), ɵɵinject(Injector), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(Directionality), ɵɵinject(Location), ɵɵinject(OverlayOutsideClickDispatcher), ɵɵinject(ANIMATION_MODULE_TYPE, 8));
};
_Overlay.ɵprov = ɵɵdefineInjectable({
  token: _Overlay,
  factory: _Overlay.ɵfac,
  providedIn: "root"
});
var Overlay = _Overlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: ScrollStrategyOptions
  }, {
    type: OverlayContainer
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: OverlayPositionBuilder
  }, {
    type: OverlayKeyboardDispatcher
  }, {
    type: Injector
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Directionality
  }, {
    type: Location
  }, {
    type: OverlayOutsideClickDispatcher
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [ANIMATION_MODULE_TYPE]
    }, {
      type: Optional
    }]
  }], null);
})();
var defaultPositionList = [{
  originX: "start",
  originY: "bottom",
  overlayX: "start",
  overlayY: "top"
}, {
  originX: "start",
  originY: "top",
  overlayX: "start",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "top",
  overlayX: "end",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "bottom",
  overlayX: "end",
  overlayY: "top"
}];
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken("cdk-connected-overlay-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const overlay = inject(Overlay);
    return () => overlay.scrollStrategies.reposition();
  }
});
var _CdkOverlayOrigin = class _CdkOverlayOrigin {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
};
_CdkOverlayOrigin.ɵfac = function CdkOverlayOrigin_Factory(t) {
  return new (t || _CdkOverlayOrigin)(ɵɵdirectiveInject(ElementRef));
};
_CdkOverlayOrigin.ɵdir = ɵɵdefineDirective({
  type: _CdkOverlayOrigin,
  selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]],
  exportAs: ["cdkOverlayOrigin"],
  standalone: true
});
var CdkOverlayOrigin = _CdkOverlayOrigin;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOverlayOrigin, [{
    type: Directive,
    args: [{
      selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]",
      exportAs: "cdkOverlayOrigin",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }], null);
})();
var _CdkConnectedOverlay = class _CdkConnectedOverlay {
  /** The offset in pixels for the overlay connection point on the x-axis */
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(offsetX) {
    this._offsetX = offsetX;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** The offset in pixels for the overlay connection point on the y-axis */
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(offsetY) {
    this._offsetY = offsetY;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  /** Whether the overlay should be disposed of when the user goes backwards/forwards in history. */
  get disposeOnNavigation() {
    return this._disposeOnNavigation;
  }
  set disposeOnNavigation(value) {
    this._disposeOnNavigation = value;
  }
  // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.
  constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {
    this._overlay = _overlay;
    this._dir = _dir;
    this._backdropSubscription = Subscription.EMPTY;
    this._attachSubscription = Subscription.EMPTY;
    this._detachSubscription = Subscription.EMPTY;
    this._positionSubscription = Subscription.EMPTY;
    this._disposeOnNavigation = false;
    this.viewportMargin = 0;
    this.open = false;
    this.disableClose = false;
    this.hasBackdrop = false;
    this.lockPosition = false;
    this.flexibleDimensions = false;
    this.growAfterOpen = false;
    this.push = false;
    this.backdropClick = new EventEmitter();
    this.positionChange = new EventEmitter();
    this.attach = new EventEmitter();
    this.detach = new EventEmitter();
    this.overlayKeydown = new EventEmitter();
    this.overlayOutsideClick = new EventEmitter();
    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    this._scrollStrategyFactory = scrollStrategyFactory;
    this.scrollStrategy = this._scrollStrategyFactory();
  }
  /** The associated overlay reference. */
  get overlayRef() {
    return this._overlayRef;
  }
  /** The element's layout direction. */
  get dir() {
    return this._dir ? this._dir.value : "ltr";
  }
  ngOnDestroy() {
    this._attachSubscription.unsubscribe();
    this._detachSubscription.unsubscribe();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    if (this._overlayRef) {
      this._overlayRef.dispose();
    }
  }
  ngOnChanges(changes) {
    if (this._position) {
      this._updatePositionStrategy(this._position);
      this._overlayRef.updateSize({
        width: this.width,
        minWidth: this.minWidth,
        height: this.height,
        minHeight: this.minHeight
      });
      if (changes["origin"] && this.open) {
        this._position.apply();
      }
    }
    if (changes["open"]) {
      this.open ? this._attachOverlay() : this._detachOverlay();
    }
  }
  /** Creates an overlay */
  _createOverlay() {
    if (!this.positions || !this.positions.length) {
      this.positions = defaultPositionList;
    }
    const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());
    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());
    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());
    overlayRef.keydownEvents().subscribe((event) => {
      this.overlayKeydown.next(event);
      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {
        event.preventDefault();
        this._detachOverlay();
      }
    });
    this._overlayRef.outsidePointerEvents().subscribe((event) => {
      this.overlayOutsideClick.next(event);
    });
  }
  /** Builds the overlay config based on the directive's inputs */
  _buildConfig() {
    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();
    const overlayConfig = new OverlayConfig({
      direction: this._dir,
      positionStrategy,
      scrollStrategy: this.scrollStrategy,
      hasBackdrop: this.hasBackdrop,
      disposeOnNavigation: this.disposeOnNavigation
    });
    if (this.width || this.width === 0) {
      overlayConfig.width = this.width;
    }
    if (this.height || this.height === 0) {
      overlayConfig.height = this.height;
    }
    if (this.minWidth || this.minWidth === 0) {
      overlayConfig.minWidth = this.minWidth;
    }
    if (this.minHeight || this.minHeight === 0) {
      overlayConfig.minHeight = this.minHeight;
    }
    if (this.backdropClass) {
      overlayConfig.backdropClass = this.backdropClass;
    }
    if (this.panelClass) {
      overlayConfig.panelClass = this.panelClass;
    }
    return overlayConfig;
  }
  /** Updates the state of a position strategy, based on the values of the directive inputs. */
  _updatePositionStrategy(positionStrategy) {
    const positions = this.positions.map((currentPosition) => ({
      originX: currentPosition.originX,
      originY: currentPosition.originY,
      overlayX: currentPosition.overlayX,
      overlayY: currentPosition.overlayY,
      offsetX: currentPosition.offsetX || this.offsetX,
      offsetY: currentPosition.offsetY || this.offsetY,
      panelClass: currentPosition.panelClass || void 0
    }));
    return positionStrategy.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);
  }
  /** Returns the position strategy of the overlay to be set on the overlay config */
  _createPositionStrategy() {
    const strategy = this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin());
    this._updatePositionStrategy(strategy);
    return strategy;
  }
  _getFlexibleConnectedPositionStrategyOrigin() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef;
    } else {
      return this.origin;
    }
  }
  /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */
  _attachOverlay() {
    if (!this._overlayRef) {
      this._createOverlay();
    } else {
      this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;
    }
    if (!this._overlayRef.hasAttached()) {
      this._overlayRef.attach(this._templatePortal);
    }
    if (this.hasBackdrop) {
      this._backdropSubscription = this._overlayRef.backdropClick().subscribe((event) => {
        this.backdropClick.emit(event);
      });
    } else {
      this._backdropSubscription.unsubscribe();
    }
    this._positionSubscription.unsubscribe();
    if (this.positionChange.observers.length > 0) {
      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe((position) => {
        this.positionChange.emit(position);
        if (this.positionChange.observers.length === 0) {
          this._positionSubscription.unsubscribe();
        }
      });
    }
  }
  /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */
  _detachOverlay() {
    if (this._overlayRef) {
      this._overlayRef.detach();
    }
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
  }
};
_CdkConnectedOverlay.ɵfac = function CdkConnectedOverlay_Factory(t) {
  return new (t || _CdkConnectedOverlay)(ɵɵdirectiveInject(Overlay), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), ɵɵdirectiveInject(Directionality, 8));
};
_CdkConnectedOverlay.ɵdir = ɵɵdefineDirective({
  type: _CdkConnectedOverlay,
  selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]],
  inputs: {
    origin: [InputFlags.None, "cdkConnectedOverlayOrigin", "origin"],
    positions: [InputFlags.None, "cdkConnectedOverlayPositions", "positions"],
    positionStrategy: [InputFlags.None, "cdkConnectedOverlayPositionStrategy", "positionStrategy"],
    offsetX: [InputFlags.None, "cdkConnectedOverlayOffsetX", "offsetX"],
    offsetY: [InputFlags.None, "cdkConnectedOverlayOffsetY", "offsetY"],
    width: [InputFlags.None, "cdkConnectedOverlayWidth", "width"],
    height: [InputFlags.None, "cdkConnectedOverlayHeight", "height"],
    minWidth: [InputFlags.None, "cdkConnectedOverlayMinWidth", "minWidth"],
    minHeight: [InputFlags.None, "cdkConnectedOverlayMinHeight", "minHeight"],
    backdropClass: [InputFlags.None, "cdkConnectedOverlayBackdropClass", "backdropClass"],
    panelClass: [InputFlags.None, "cdkConnectedOverlayPanelClass", "panelClass"],
    viewportMargin: [InputFlags.None, "cdkConnectedOverlayViewportMargin", "viewportMargin"],
    scrollStrategy: [InputFlags.None, "cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
    open: [InputFlags.None, "cdkConnectedOverlayOpen", "open"],
    disableClose: [InputFlags.None, "cdkConnectedOverlayDisableClose", "disableClose"],
    transformOriginSelector: [InputFlags.None, "cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"],
    hasBackdrop: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayHasBackdrop", "hasBackdrop", booleanAttribute],
    lockPosition: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayLockPosition", "lockPosition", booleanAttribute],
    flexibleDimensions: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions", booleanAttribute],
    growAfterOpen: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayGrowAfterOpen", "growAfterOpen", booleanAttribute],
    push: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayPush", "push", booleanAttribute],
    disposeOnNavigation: [InputFlags.HasDecoratorInputTransform, "cdkConnectedOverlayDisposeOnNavigation", "disposeOnNavigation", booleanAttribute]
  },
  outputs: {
    backdropClick: "backdropClick",
    positionChange: "positionChange",
    attach: "attach",
    detach: "detach",
    overlayKeydown: "overlayKeydown",
    overlayOutsideClick: "overlayOutsideClick"
  },
  exportAs: ["cdkConnectedOverlay"],
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkConnectedOverlay = _CdkConnectedOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkConnectedOverlay, [{
    type: Directive,
    args: [{
      selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]",
      exportAs: "cdkConnectedOverlay",
      standalone: true
    }]
  }], () => [{
    type: Overlay
  }, {
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], {
    origin: [{
      type: Input,
      args: ["cdkConnectedOverlayOrigin"]
    }],
    positions: [{
      type: Input,
      args: ["cdkConnectedOverlayPositions"]
    }],
    positionStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayPositionStrategy"]
    }],
    offsetX: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetX"]
    }],
    offsetY: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetY"]
    }],
    width: [{
      type: Input,
      args: ["cdkConnectedOverlayWidth"]
    }],
    height: [{
      type: Input,
      args: ["cdkConnectedOverlayHeight"]
    }],
    minWidth: [{
      type: Input,
      args: ["cdkConnectedOverlayMinWidth"]
    }],
    minHeight: [{
      type: Input,
      args: ["cdkConnectedOverlayMinHeight"]
    }],
    backdropClass: [{
      type: Input,
      args: ["cdkConnectedOverlayBackdropClass"]
    }],
    panelClass: [{
      type: Input,
      args: ["cdkConnectedOverlayPanelClass"]
    }],
    viewportMargin: [{
      type: Input,
      args: ["cdkConnectedOverlayViewportMargin"]
    }],
    scrollStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayScrollStrategy"]
    }],
    open: [{
      type: Input,
      args: ["cdkConnectedOverlayOpen"]
    }],
    disableClose: [{
      type: Input,
      args: ["cdkConnectedOverlayDisableClose"]
    }],
    transformOriginSelector: [{
      type: Input,
      args: ["cdkConnectedOverlayTransformOriginOn"]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayHasBackdrop",
        transform: booleanAttribute
      }]
    }],
    lockPosition: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayLockPosition",
        transform: booleanAttribute
      }]
    }],
    flexibleDimensions: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayFlexibleDimensions",
        transform: booleanAttribute
      }]
    }],
    growAfterOpen: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayGrowAfterOpen",
        transform: booleanAttribute
      }]
    }],
    push: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayPush",
        transform: booleanAttribute
      }]
    }],
    disposeOnNavigation: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayDisposeOnNavigation",
        transform: booleanAttribute
      }]
    }],
    backdropClick: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    attach: [{
      type: Output
    }],
    detach: [{
      type: Output
    }],
    overlayKeydown: [{
      type: Output
    }],
    overlayOutsideClick: [{
      type: Output
    }]
  });
})();
function CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition();
}
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
  provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY
};
var _OverlayModule = class _OverlayModule {
};
_OverlayModule.ɵfac = function OverlayModule_Factory(t) {
  return new (t || _OverlayModule)();
};
_OverlayModule.ɵmod = ɵɵdefineNgModule({
  type: _OverlayModule,
  imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
  exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]
});
_OverlayModule.ɵinj = ɵɵdefineInjector({
  providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER],
  imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]
});
var OverlayModule = _OverlayModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],
      providers: [Overlay, CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER]
    }]
  }], null, null);
})();
var _FullscreenOverlayContainer = class _FullscreenOverlayContainer extends OverlayContainer {
  constructor(_document, platform) {
    super(_document, platform);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this._fullScreenEventName && this._fullScreenListener) {
      this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);
    }
  }
  _createContainer() {
    super._createContainer();
    this._adjustParentForFullscreenChange();
    this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());
  }
  _adjustParentForFullscreenChange() {
    if (!this._containerElement) {
      return;
    }
    const fullscreenElement = this.getFullscreenElement();
    const parent = fullscreenElement || this._document.body;
    parent.appendChild(this._containerElement);
  }
  _addFullscreenChangeListener(fn) {
    const eventName = this._getEventName();
    if (eventName) {
      if (this._fullScreenListener) {
        this._document.removeEventListener(eventName, this._fullScreenListener);
      }
      this._document.addEventListener(eventName, fn);
      this._fullScreenListener = fn;
    }
  }
  _getEventName() {
    if (!this._fullScreenEventName) {
      const _document = this._document;
      if (_document.fullscreenEnabled) {
        this._fullScreenEventName = "fullscreenchange";
      } else if (_document.webkitFullscreenEnabled) {
        this._fullScreenEventName = "webkitfullscreenchange";
      } else if (_document.mozFullScreenEnabled) {
        this._fullScreenEventName = "mozfullscreenchange";
      } else if (_document.msFullscreenEnabled) {
        this._fullScreenEventName = "MSFullscreenChange";
      }
    }
    return this._fullScreenEventName;
  }
  /**
   * When the page is put into fullscreen mode, a specific element is specified.
   * Only that element and its children are visible when in fullscreen mode.
   */
  getFullscreenElement() {
    const _document = this._document;
    return _document.fullscreenElement || _document.webkitFullscreenElement || _document.mozFullScreenElement || _document.msFullscreenElement || null;
  }
};
_FullscreenOverlayContainer.ɵfac = function FullscreenOverlayContainer_Factory(t) {
  return new (t || _FullscreenOverlayContainer)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_FullscreenOverlayContainer.ɵprov = ɵɵdefineInjectable({
  token: _FullscreenOverlayContainer,
  factory: _FullscreenOverlayContainer.ɵfac,
  providedIn: "root"
});
var FullscreenOverlayContainer = _FullscreenOverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullscreenOverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function extendStyles2(dest, source, importantProperties) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles2(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties) {
  extendStyles2(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x, y) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top && y <= bottom && x >= left && x <= right;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
var ParentPositionTracker = class {
  constructor(_document) {
    this._document = _document;
    this.positions = /* @__PURE__ */ new Map();
  }
  /** Clears the cached positions. */
  clear() {
    this.positions.clear();
  }
  /** Caches the positions. Should be called at the beginning of a drag sequence. */
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach((element) => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  /** Handles scrolling while a drag is taking place. */
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  /**
   * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
   * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
   * the top/left offset of the `document.documentElement` which works for most cases, but breaks
   * if the element is offset by something like the `BlockScrollStrategy`.
   */
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i = 0; i < descendantsWithId.length; i++) {
    descendantsWithId[i].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var activeEventListenerOptions = normalizePassiveListenerOptions({
  passive: false
});
var MOUSE_EVENT_IGNORE_TIME = 800;
var dragImportantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var DragRef = class {
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
    }
  }
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._passiveTransform = {
      x: 0,
      y: 0
    };
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._hasStartedDragging = false;
    this._moveEvents = new Subject();
    this._pointerMoveSubscription = Subscription.EMPTY;
    this._pointerUpSubscription = Subscription.EMPTY;
    this._scrollSubscription = Subscription.EMPTY;
    this._resizeSubscription = Subscription.EMPTY;
    this._boundaryElement = null;
    this._nativeInteractionsEnabled = true;
    this._handles = [];
    this._disabledHandles = /* @__PURE__ */ new Set();
    this._direction = "ltr";
    this.dragStartDelay = 0;
    this._disabled = false;
    this.beforeStarted = new Subject();
    this.started = new Subject();
    this.released = new Subject();
    this.ended = new Subject();
    this.entered = new Subject();
    this.exited = new Subject();
    this.dropped = new Subject();
    this.moved = this._moveEvents;
    this._pointerDown = (event) => {
      this.beforeStarted.next();
      if (this._handles.length) {
        const targetHandle = this._getTargetHandle(event);
        if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
          this._initializeDragSequence(targetHandle, event);
        }
      } else if (!this.disabled) {
        this._initializeDragSequence(this._rootElement, event);
      }
    };
    this._pointerMove = (event) => {
      const pointerPosition = this._getPointerPositionOnPage(event);
      if (!this._hasStartedDragging) {
        const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
        const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
        const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
        if (isOverThreshold) {
          const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
          const container = this._dropContainer;
          if (!isDelayElapsed) {
            this._endDragSequence(event);
            return;
          }
          if (!container || !container.isDragging() && !container.isReceiving()) {
            event.preventDefault();
            this._hasStartedDragging = true;
            this._ngZone.run(() => this._startDragSequence(event));
          }
        }
        return;
      }
      event.preventDefault();
      const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
      this._hasMoved = true;
      this._lastKnownPointerPosition = pointerPosition;
      this._updatePointerDirectionDelta(constrainedPointerPosition);
      if (this._dropContainer) {
        this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
      } else {
        const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
        const activeTransform = this._activeTransform;
        activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
        activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
        this._applyRootElementTransform(activeTransform.x, activeTransform.y);
      }
      if (this._moveEvents.observers.length) {
        this._ngZone.run(() => {
          this._moveEvents.next({
            source: this,
            pointerPosition: constrainedPointerPosition,
            event,
            distance: this._getDragDistance(constrainedPointerPosition),
            delta: this._pointerDirectionDelta
          });
        });
      }
    };
    this._pointerUp = (event) => {
      this._endDragSequence(event);
    };
    this._nativeDragStart = (event) => {
      if (this._handles.length) {
        const targetHandle = this._getTargetHandle(event);
        if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
          event.preventDefault();
        }
      } else if (!this.disabled) {
        event.preventDefault();
      }
    };
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._placeholder;
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the currently-visible element that represents the drag item.
   * While dragging this is the placeholder, otherwise it's the root element.
   */
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  /** Registers the handles that can be used to drag the element. */
  withHandles(handles) {
    this._handles = handles.map((handle) => coerceElement(handle));
    this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */ new Set();
    this._disabledHandles.forEach((handle) => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  /**
   * Registers the template that should be used for the drag preview.
   * @param template Template that from which to stamp out the preview.
   */
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  /**
   * Registers the template that should be used for the drag placeholder.
   * @param template Template that from which to stamp out the placeholder.
   */
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  /**
   * Sets an alternate drag root element. The root element is the element that will be moved as
   * the user is dragging. Passing an alternate root element is useful when trying to enable
   * dragging on an element that you might not have access to.
   */
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      if (this._rootElement) {
        this._removeRootElementListeners(this._rootElement);
      }
      this._ngZone.runOutsideAngular(() => {
        element.addEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
        element.addEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
        element.addEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
      });
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  /**
   * Element to which the draggable's position will be constrained.
   */
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  /** Sets the parent ref that the ref is nested in.  */
  withParent(parent) {
    this._parentDragRef = parent;
    return this;
  }
  /** Removes the dragging functionality from the DOM element. */
  dispose() {
    this._removeRootElementListeners(this._rootElement);
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._anchor?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeSubscriptions();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null;
  }
  /** Checks whether the element is currently being dragged. */
  isDragging() {
    return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  /**
   * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
   * @param handle Handle element that should be disabled.
   */
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  /**
   * Enables a handle, if it has been disabled.
   * @param handle Handle element to be enabled.
   */
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  /** Sets the layout direction of the draggable item. */
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  /** Sets the container that the item is part of. */
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  /**
   * Gets the current position in pixels the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  /**
   * Sets the container into which to insert the preview element.
   * @param value Container into which to insert the preview.
   */
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  /** Updates the item's sort order based on the last-known pointer position. */
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  /** Unsubscribes from the global subscriptions. */
  _removeSubscriptions() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
  }
  /** Destroys the preview element and its ViewRef. */
  _destroyPreview() {
    this._preview?.remove();
    this._previewRef?.destroy();
    this._preview = this._previewRef = null;
  }
  /** Destroys the placeholder element and its ViewRef. */
  _destroyPlaceholder() {
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._placeholderRef = null;
  }
  /**
   * Clears subscriptions and stops the dragging sequence.
   * @param event Browser event object that ended the sequence.
   */
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeSubscriptions();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  /** Starts the dragging sequence. */
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const dropContainer = this._dropContainer;
    if (dropContainer) {
      const element = this._rootElement;
      const parent = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const anchor = this._anchor = this._anchor || this._document.createComment("");
      const shadowRoot = this._getShadowRoot();
      parent.insertBefore(anchor, element);
      this._initialTransform = element.style.transform || "";
      this._preview = this._createPreviewElement();
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent.replaceChild(placeholder, element));
      this._getPreviewInsertionPoint(parent, shadowRoot).appendChild(this._preview);
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  /**
   * Sets up the different variables and subscriptions
   * that will be necessary for the dragging sequence.
   * @param referenceElement Element that started the drag sequence.
   * @param event Browser event object that started the sequence.
   */
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasStartedDragging = this._hasMoved = false;
    this._removeSubscriptions();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  /**
   * Updates the item's position in its drop container, or moves it
   * into a new one, depending on its current drag position.
   */
  _updateActiveDropContainer({
    x,
    y
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._dropContainer = newContainer;
        this._dropContainer.enter(this, x, y, newContainer === this._initialContainer && // If we're re-entering the initial container and sorting is disabled,
        // put item the into its starting index to begin with.
        newContainer.sortingDisabled ? this._initialIndex : void 0);
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x, y);
      } else {
        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
      }
    }
  }
  /**
   * Creates the element that will be rendered next to the user's pointer
   * and will be used as a preview of the element that is being dragged.
   */
  _createPreviewElement() {
    const previewConfig = this._previewTemplate;
    const previewClass = this.previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewRef = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles2(preview.style, {
      // It's important that we disable the pointer events on the preview, because
      // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
      "pointer-events": "none",
      // We have to reset the margin, because it can throw off positioning relative to the viewport.
      "margin": "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": `${this._config.zIndex || 1e3}`
    }, dragImportantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach((className) => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
  /**
   * Animates the preview element from its current position to the location of the drop placeholder.
   * @returns Promise that resolves when the animation completes.
   */
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.classList.add("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = getTransformTransitionDurationInMs(this._preview);
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise((resolve) => {
        const handler = (event) => {
          if (!event || _getEventTarget(event) === this._preview && event.propertyName === "transform") {
            this._preview?.removeEventListener("transitionend", handler);
            resolve();
            clearTimeout(timeout);
          }
        };
        const timeout = setTimeout(handler, duration * 1.5);
        this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  /** Creates an element that will be shown instead of the current element while dragging. */
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add("cdk-drag-placeholder");
    return placeholder;
  }
  /**
   * Figures out the coordinates at which an element was picked up.
   * @param referenceElement Element that initiated the dragging.
   * @param event Event that initiated the dragging.
   */
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x = point.pageX - referenceRect.left - scrollPosition.left;
    const y = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x,
      y: referenceRect.top - elementRect.top + y
    };
  }
  /** Determines the point of the page that was touched by the user. */
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ? (
      // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
      // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
      // to have a value, but Firefox in device emulation mode has a bug where both can be empty
      // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
      // throwing an error. The value returned here will be incorrect, but since this only
      // breaks inside a developer tool and the value is only used for secondary information,
      // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
      event.touches[0] || event.changedTouches[0] || {
        pageX: 0,
        pageY: 0
      }
    ) : event;
    const x = point.pageX - scrollPosition.left;
    const y = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x;
        svgPoint.y = y;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x,
      y
    };
  }
  /** Gets the pointer position on the page, accounting for any position constraints. */
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x,
      y
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x = clamp$1(x, minX, maxX);
      y = clamp$1(y, minY, maxY);
    }
    return {
      x,
      y
    };
  }
  /** Updates the current drag delta, based on the user's current pointer position on the page. */
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x,
      y
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x - positionSinceLastChange.x);
    const changeY = Math.abs(y - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y;
    }
    return delta;
  }
  /** Toggles the native drag interactions, based on how many handles are registered. */
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  /** Removes the manually-added event listeners from the root element. */
  _removeRootElementListeners(element) {
    element.removeEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
    element.removeEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
    element.removeEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
  }
  /**
   * Applies a `transform` to the root element, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyRootElementTransform(x, y) {
    const transform = getTransform(x, y);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  /**
   * Applies a `transform` to the preview, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyPreviewTransform(x, y) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x, y);
    this._preview.style.transform = combineTransforms(transform, initialTransform);
  }
  /**
   * Gets the distance that the user has dragged during the current drag sequence.
   * @param currentPosition Current position of the user's pointer.
   */
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  /**
   * Checks whether the element is still inside its boundary after the viewport has been resized.
   * If not, the position is adjusted so that the element fits again.
   */
  _containInsideBoundaryOnResize() {
    let {
      x,
      y
    } = this._passiveTransform;
    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x += leftOverflow;
      }
      if (rightOverflow > 0) {
        x -= rightOverflow;
      }
    } else {
      x = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y += topOverflow;
      }
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
      }
    } else {
      y = 0;
    }
    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y,
        x
      });
    }
  }
  /** Gets the drag start delay, based on the event type. */
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  /** Updates the internal state of the draggable element when scrolling has occurred. */
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  /** Gets the scroll position of the viewport. */
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  /** Gets the element into which the drag preview should be inserted. */
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  /** Lazily resolves and returns the dimensions of the preview. */
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  /** Gets a handle that is the target of an event. */
  _getTargetHandle(event) {
    return this._handles.find((handle) => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
};
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from2 = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from2 === to) {
    return;
  }
  const target = array[from2];
  const delta = to < from2 ? -1 : 1;
  for (let i = from2; i !== to; i += delta) {
    array[i] = array[i + delta];
  }
  array[to] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
var SingleAxisSortStrategy = class {
  constructor(_element, _dragDropRegistry) {
    this._element = _element;
    this._dragDropRegistry = _dragDropRegistry;
    this._itemPositions = [];
    this.orientation = "vertical";
    this._previousSwap = {
      drag: null,
      delta: 0,
      overlaps: false
    };
  }
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${Math.round(sibling.offset)}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${Math.round(sibling.offset)}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ? (
      // We use the coordinates of where the item entered the drop
      // zone to figure out at which index it should be inserted.
      this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
    ) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      coerceElement(this._element).appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    this._activeDraggables.forEach((item) => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find((p) => p.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    const items = this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
    return items.findIndex((currentItem) => currentItem.drag === item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  /** Refreshes the position cache of the items and sibling containers. */
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map((drag) => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a, b) => {
      return isHorizontal ? a.clientRect.left - b.clientRect.left : a.clientRect.top - b.clientRect.top;
    });
  }
  /**
   * Gets the offset in pixels by which the item that is being dragged should be moved.
   * @param currentPosition Current position of the item.
   * @param newPosition Position of the item where the current item should be moved.
   * @param delta Direction in which the user is moving.
   */
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  /**
   * Gets the offset in pixels by which the items that aren't being dragged should be moved.
   * @param currentIndex Index of the item currently being dragged.
   * @param siblings All of the items in the list.
   * @param delta Direction in which the user is moving.
   */
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  /**
   * Checks if pointer is entering in the first position
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ? (
        // Round these down since most browsers report client rects with
        // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
        pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
      ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var DropListRef = class {
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this.disabled = false;
    this.sortingDisabled = false;
    this.autoScrollDisabled = false;
    this.autoScrollStep = 2;
    this.enterPredicate = () => true;
    this.sortPredicate = () => true;
    this.beforeStarted = new Subject();
    this.entered = new Subject();
    this.exited = new Subject();
    this.dropped = new Subject();
    this.sorted = new Subject();
    this.receivingStarted = new Subject();
    this.receivingStopped = new Subject();
    this._isDragging = false;
    this._draggables = [];
    this._siblings = [];
    this._activeSiblings = /* @__PURE__ */ new Set();
    this._viewportScrollSubscription = Subscription.EMPTY;
    this._verticalScrollDirection = 0;
    this._horizontalScrollDirection = 0;
    this._stopScrollTimers = new Subject();
    this._cachedShadowRoot = null;
    this._startScrollInterval = () => {
      this._stopScrolling();
      interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
        const node = this._scrollNode;
        const scrollStep = this.autoScrollStep;
        if (this._verticalScrollDirection === 1) {
          node.scrollBy(0, -scrollStep);
        } else if (this._verticalScrollDirection === 2) {
          node.scrollBy(0, scrollStep);
        }
        if (this._horizontalScrollDirection === 1) {
          node.scrollBy(-scrollStep, 0);
        } else if (this._horizontalScrollDirection === 2) {
          node.scrollBy(scrollStep, 0);
        }
      });
    };
    this.element = coerceElement(element);
    this._document = _document;
    this.withScrollableParents([this.element]);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
    this._sortStrategy = new SingleAxisSortStrategy(this.element, _dragDropRegistry);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
  }
  /** Removes the drop list functionality from the DOM element. */
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  /** Whether an item from this list is currently being dragged. */
  isDragging() {
    return this._isDragging;
  }
  /** Starts dragging an item. */
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  /**
   * Attempts to move an item into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  /**
   * Removes an item from the container after it was dragged into another container by the user.
   * @param item Item that was dragged out.
   */
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  /**
   * Drops an item into this container.
   * @param item Item being dropped into the container.
   * @param currentIndex Index at which the item should be inserted.
   * @param previousIndex Index of the item when dragging started.
   * @param previousContainer Container from which the item got dragged in.
   * @param isPointerOverContainer Whether the user's pointer was over the
   *    container when the item was dropped.
   * @param distance Distance the user has dragged since the start of the dragging sequence.
   * @param event Event that triggered the dropping sequence.
   *
   * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
   */
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  /**
   * Sets the draggable items that are a part of this list.
   * @param items Items that are a part of this list.
   */
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach((item) => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter((item) => item.isDragging());
      if (draggedItems.every((item) => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  /** Sets the layout direction of the drop list. */
  withDirection(direction) {
    this._sortStrategy.direction = direction;
    return this;
  }
  /**
   * Sets the containers that are connected to this one. When two or more containers are
   * connected, the user will be allowed to transfer items between them.
   * @param connectedTo Other containers that the current containers should be connected to.
   */
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  /**
   * Sets the orientation of the container.
   * @param orientation New orientation for the container.
   */
  withOrientation(orientation) {
    this._sortStrategy.orientation = orientation;
    return this;
  }
  /**
   * Sets which parent elements are can be scrolled while the user is dragging.
   * @param elements Elements that can be scrolled.
   */
  withScrollableParents(elements) {
    const element = coerceElement(this.element);
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  /** Gets the scrollable parents that are registered with this drop container. */
  getScrollableParents() {
    return this._scrollableElements;
  }
  /**
   * Figures out the index of an item in the container.
   * @param item Item whose index should be determined.
   */
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  /**
   * Whether the list is able to receive the item that
   * is currently being dragged inside a connected drop list.
   */
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  /**
   * Sorts an item inside the container based on its position.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  /**
   * Checks whether the user's pointer is close to the edges of either the
   * viewport or the drop list and starts the auto-scroll sequence.
   * @param pointerX User's pointer position along the x axis.
   * @param pointerY User's pointer position along the y axis.
   */
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = 0;
    let horizontalScrollDirection = 0;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._sortStrategy.direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  /** Stops any currently-running auto-scroll sequences. */
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  /** Starts the dragging sequence within the list. */
  _draggingStarted() {
    const styles = coerceElement(this.element).style;
    this.beforeStarted.next();
    this._isDragging = true;
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  /** Caches the positions of the configured scrollable parents. */
  _cacheParentPositions() {
    const element = coerceElement(this.element);
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(element).clientRect;
  }
  /** Resets the container to its initial state. */
  _reset() {
    this._isDragging = false;
    const styles = coerceElement(this.element).style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach((sibling) => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  /**
   * Checks whether the user's pointer is positioned over the container.
   * @param x Pointer position along the X axis.
   * @param y Pointer position along the Y axis.
   */
  _isOverContainer(x, y) {
    return this._domRect != null && isInsideClientRect(this._domRect, x, y);
  }
  /**
   * Figures out whether an item should be moved into a sibling
   * drop container, based on its current position.
   * @param item Drag item that is being moved.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _getSiblingContainerFromPosition(item, x, y) {
    return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
  }
  /**
   * Checks whether the drop list can receive the passed-in item.
   * @param item Item that is being dragged into the list.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _canReceive(item, x, y) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
    if (!elementFromPoint) {
      return false;
    }
    const nativeElement = coerceElement(this.element);
    return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);
  }
  /**
   * Called by one of the connected drop lists when a dragging sequence has started.
   * @param sibling Sibling in which dragging has started.
   */
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every((item) => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  /**
   * Called by a connected drop list when dragging has stopped.
   * @param sibling Sibling whose dragging has stopped.
   */
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  /**
   * Starts listening to scroll events on the viewport.
   * Used for updating the internal state of the list.
   */
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(coerceElement(this.element));
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  /** Notifies any siblings that may potentially receive the item. */
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
    this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
  }
};
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return 1;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return 2;
  }
  return 0;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return 1;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return 2;
  }
  return 0;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = 0;
  let horizontalScrollDirection = 0;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === 1) {
      if (scrollTop > 0) {
        verticalScrollDirection = 1;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = 2;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === 2) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = 2;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = 1;
      }
    } else {
      if (computedHorizontal === 1) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = 1;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = 2;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
var activeCapturingEventOptions = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var _DragDropRegistry = class _DragDropRegistry {
  constructor(_ngZone, _document) {
    this._ngZone = _ngZone;
    this._dropInstances = /* @__PURE__ */ new Set();
    this._dragInstances = /* @__PURE__ */ new Set();
    this._activeDragInstances = [];
    this._globalListeners = /* @__PURE__ */ new Map();
    this._draggingPredicate = (item) => item.isDragging();
    this.pointerMove = new Subject();
    this.pointerUp = new Subject();
    this.scroll = new Subject();
    this._preventDefaultWhileDragging = (event) => {
      if (this._activeDragInstances.length > 0) {
        event.preventDefault();
      }
    };
    this._persistentTouchmoveListener = (event) => {
      if (this._activeDragInstances.length > 0) {
        if (this._activeDragInstances.some(this._draggingPredicate)) {
          event.preventDefault();
        }
        this.pointerMove.next(event);
      }
    };
    this._document = _document;
  }
  /** Adds a drop container to the registry. */
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  /** Adds a drag item instance to the registry. */
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._document.addEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  /** Removes a drop container from the registry. */
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  /** Removes a drag item instance from the registry. */
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
    }
  }
  /**
   * Starts the dragging sequence for a drag instance.
   * @param drag Drag instance which is being dragged.
   * @param event Event that initiated the dragging.
   */
  startDragging(drag, event) {
    if (this._activeDragInstances.indexOf(drag) > -1) {
      return;
    }
    this._activeDragInstances.push(drag);
    if (this._activeDragInstances.length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      this._globalListeners.set(isTouchEvent2 ? "touchend" : "mouseup", {
        handler: (e) => this.pointerUp.next(e),
        options: true
      }).set("scroll", {
        handler: (e) => this.scroll.next(e),
        // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
        // the document. See https://github.com/angular/components/issues/17144.
        options: true
      }).set("selectstart", {
        handler: this._preventDefaultWhileDragging,
        options: activeCapturingEventOptions
      });
      if (!isTouchEvent2) {
        this._globalListeners.set("mousemove", {
          handler: (e) => this.pointerMove.next(e),
          options: activeCapturingEventOptions
        });
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners.forEach((config, name) => {
          this._document.addEventListener(name, config.handler, config.options);
        });
      });
    }
  }
  /** Stops dragging a drag item instance. */
  stopDragging(drag) {
    const index = this._activeDragInstances.indexOf(drag);
    if (index > -1) {
      this._activeDragInstances.splice(index, 1);
      if (this._activeDragInstances.length === 0) {
        this._clearGlobalListeners();
      }
    }
  }
  /** Gets whether a drag item instance is currently being dragged. */
  isDragging(drag) {
    return this._activeDragInstances.indexOf(drag) > -1;
  }
  /**
   * Gets a stream that will emit when any element on the page is scrolled while an item is being
   * dragged.
   * @param shadowRoot Optional shadow root that the current dragging sequence started from.
   *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
   *   be used to include an additional top-level listener at the shadow root level.
   */
  scrolled(shadowRoot) {
    const streams = [this.scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable((observer) => {
        return this._ngZone.runOutsideAngular(() => {
          const eventOptions = true;
          const callback = (event) => {
            if (this._activeDragInstances.length) {
              observer.next(event);
            }
          };
          shadowRoot.addEventListener("scroll", callback, eventOptions);
          return () => {
            shadowRoot.removeEventListener("scroll", callback, eventOptions);
          };
        });
      }));
    }
    return merge(...streams);
  }
  ngOnDestroy() {
    this._dragInstances.forEach((instance) => this.removeDragItem(instance));
    this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  /** Clears out the global event listeners from the `document`. */
  _clearGlobalListeners() {
    this._globalListeners.forEach((config, name) => {
      this._document.removeEventListener(name, config.handler, config.options);
    });
    this._globalListeners.clear();
  }
};
_DragDropRegistry.ɵfac = function DragDropRegistry_Factory(t) {
  return new (t || _DragDropRegistry)(ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_DragDropRegistry.ɵprov = ɵɵdefineInjectable({
  token: _DragDropRegistry,
  factory: _DragDropRegistry.ɵfac,
  providedIn: "root"
});
var DragDropRegistry = _DragDropRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var _DragDrop = class _DragDrop {
  constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * Turns an element into a draggable item.
   * @param element Element to which to attach the dragging functionality.
   * @param config Object used to configure the dragging behavior.
   */
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);
  }
  /**
   * Turns an element into a drop list.
   * @param element Element to which to attach the drop list functionality.
   */
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
};
_DragDrop.ɵfac = function DragDrop_Factory(t) {
  return new (t || _DragDrop)(ɵɵinject(DOCUMENT), ɵɵinject(NgZone), ɵɵinject(ViewportRuler), ɵɵinject(DragDropRegistry));
};
_DragDrop.ɵprov = ɵɵdefineInjectable({
  token: _DragDrop,
  factory: _DragDrop.ɵfac,
  providedIn: "root"
});
var DragDrop = _DragDrop;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone
  }, {
    type: ViewportRuler
  }, {
    type: DragDropRegistry
  }], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var _CdkDragHandle = class _CdkDragHandle {
  /** Whether starting to drag through this handle is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  constructor(element, parentDrag) {
    this.element = element;
    this._stateChanges = new Subject();
    this._disabled = false;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(element.nativeElement, "cdkDragHandle");
    }
    this._parentDrag = parentDrag;
  }
  ngOnDestroy() {
    this._stateChanges.complete();
  }
};
_CdkDragHandle.ɵfac = function CdkDragHandle_Factory(t) {
  return new (t || _CdkDragHandle)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CDK_DRAG_PARENT, 12));
};
_CdkDragHandle.ɵdir = ɵɵdefineDirective({
  type: _CdkDragHandle,
  selectors: [["", "cdkDragHandle", ""]],
  hostAttrs: [1, "cdk-drag-handle"],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDragHandleDisabled", "disabled", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_HANDLE,
    useExisting: _CdkDragHandle
  }]), ɵɵInputTransformsFeature]
});
var CdkDragHandle = _CdkDragHandle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      standalone: true,
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_DRAG_PARENT]
    }, {
      type: Optional
    }, {
      type: SkipSelf
    }]
  }], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var _CdkDragPlaceholder = class _CdkDragPlaceholder {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_CdkDragPlaceholder.ɵfac = function CdkDragPlaceholder_Factory(t) {
  return new (t || _CdkDragPlaceholder)(ɵɵdirectiveInject(TemplateRef));
};
_CdkDragPlaceholder.ɵdir = ɵɵdefineDirective({
  type: _CdkDragPlaceholder,
  selectors: [["ng-template", "cdkDragPlaceholder", ""]],
  inputs: {
    data: "data"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_PLACEHOLDER,
    useExisting: _CdkDragPlaceholder
  }])]
});
var CdkDragPlaceholder = _CdkDragPlaceholder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      standalone: true,
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [{
    type: TemplateRef
  }], {
    data: [{
      type: Input
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var _CdkDragPreview = class _CdkDragPreview {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this.matchSize = false;
  }
};
_CdkDragPreview.ɵfac = function CdkDragPreview_Factory(t) {
  return new (t || _CdkDragPreview)(ɵɵdirectiveInject(TemplateRef));
};
_CdkDragPreview.ɵdir = ɵɵdefineDirective({
  type: _CdkDragPreview,
  selectors: [["ng-template", "cdkDragPreview", ""]],
  inputs: {
    data: "data",
    matchSize: [InputFlags.HasDecoratorInputTransform, "matchSize", "matchSize", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_PREVIEW,
    useExisting: _CdkDragPreview
  }]), ɵɵInputTransformsFeature]
});
var CdkDragPreview = _CdkDragPreview;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      standalone: true,
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [{
    type: TemplateRef
  }], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var DRAG_HOST_CLASS = "cdk-drag";
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var _CdkDrag = class _CdkDrag {
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || this.dropContainer && this.dropContainer.disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef, _selfHandle, _parentDrag) {
    this.element = element;
    this.dropContainer = dropContainer;
    this._ngZone = _ngZone;
    this._viewContainerRef = _viewContainerRef;
    this._dir = _dir;
    this._changeDetectorRef = _changeDetectorRef;
    this._selfHandle = _selfHandle;
    this._parentDrag = _parentDrag;
    this._destroyed = new Subject();
    this.started = new EventEmitter();
    this.released = new EventEmitter();
    this.ended = new EventEmitter();
    this.entered = new EventEmitter();
    this.exited = new EventEmitter();
    this.dropped = new EventEmitter();
    this.moved = new Observable((observer) => {
      const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
        source: this,
        pointerPosition: movedEvent.pointerPosition,
        event: movedEvent.event,
        delta: movedEvent.delta,
        distance: movedEvent.distance
      }))).subscribe(observer);
      return () => {
        subscription.unsubscribe();
      };
    });
    this._dragRef = dragDrop.createDrag(element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    _CdkDrag._dragInstances.push(this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      this._dragRef._withDropContainer(dropContainer._dropListRef);
      dropContainer.addItem(this);
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._dragRef.reset();
  }
  /**
   * Gets the pixel coordinates of the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    this._ngZone.runOutsideAngular(() => {
      this._ngZone.onStable.pipe(take(1), takeUntil(this._destroyed)).subscribe(() => {
        this._updateRootElement();
        this._setupHandlesListener();
        if (this.freeDragPosition) {
          this._dragRef.setFreeDragPosition(this.freeDragPosition);
        }
      });
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    const index = _CdkDrag._dragInstances.indexOf(this);
    if (index > -1) {
      _CdkDrag._dragInstances.splice(index, 1);
    }
    this._ngZone.runOutsideAngular(() => {
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  /** Syncs the root element with the `DragRef`. */
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
        // Comment tag doesn't have closest method, so use parent's one.
        element.parentElement?.closest(this.rootElementSelector)
      );
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  /** Gets the boundary element, based on the `boundaryElement` value. */
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
  _syncInputs(ref) {
    ref.beforeStarted.subscribe(() => {
      if (!ref.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref.disabled = this.disabled;
        ref.lockAxis = this.lockAxis;
        ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref.constrainPosition = this.constrainPosition;
        ref.previewClass = this.previewClass;
        ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref.withDirection(dir.value);
        }
      }
    });
    ref.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        if (parent.classList.contains(DRAG_HOST_CLASS)) {
          ref.withParent(_CdkDrag._dragInstances.find((drag) => {
            return drag.element.nativeElement === parent;
          })?._dragRef || null);
          break;
        }
        parent = parent.parentElement;
      }
    });
  }
  /** Handles the events from the underlying `DragRef`. */
  _handleEvents(ref) {
    ref.started.subscribe((startEvent) => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.released.subscribe((releaseEvent) => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref.ended.subscribe((endEvent) => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((enterEvent) => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref.exited.subscribe((exitEvent) => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  /** Sets up the listener that syncs the handles with the drag ref. */
  _setupHandlesListener() {
    this._handles.changes.pipe(
      startWith(this._handles),
      // Sync the new handles with the DragRef.
      tap((handles) => {
        const childHandleElements = handles.filter((handle) => handle._parentDrag === this).map((handle) => handle.element);
        if (this._selfHandle && this.rootElementSelector) {
          childHandleElements.push(this.element);
        }
        this._dragRef.withHandles(childHandleElements);
      }),
      // Listen if the state of any of the handles changes.
      switchMap((handles) => {
        return merge(...handles.map((item) => {
          return item._stateChanges.pipe(startWith(item));
        }));
      }),
      takeUntil(this._destroyed)
    ).subscribe((handleInstance) => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
};
_CdkDrag._dragInstances = [];
_CdkDrag.ɵfac = function CdkDrag_Factory(t) {
  return new (t || _CdkDrag)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CDK_DROP_LIST, 12), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_DRAG_CONFIG, 8), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(DragDrop), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(CDK_DRAG_HANDLE, 10), ɵɵdirectiveInject(CDK_DRAG_PARENT, 12));
};
_CdkDrag.ɵdir = ɵɵdefineDirective({
  type: _CdkDrag,
  selectors: [["", "cdkDrag", ""]],
  contentQueries: function CdkDrag_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CDK_DRAG_PREVIEW, 5);
      ɵɵcontentQuery(dirIndex, CDK_DRAG_PLACEHOLDER, 5);
      ɵɵcontentQuery(dirIndex, CDK_DRAG_HANDLE, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._previewTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._placeholderTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._handles = _t);
    }
  },
  hostAttrs: [1, "cdk-drag"],
  hostVars: 4,
  hostBindings: function CdkDrag_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
    }
  },
  inputs: {
    data: [InputFlags.None, "cdkDragData", "data"],
    lockAxis: [InputFlags.None, "cdkDragLockAxis", "lockAxis"],
    rootElementSelector: [InputFlags.None, "cdkDragRootElement", "rootElementSelector"],
    boundaryElement: [InputFlags.None, "cdkDragBoundary", "boundaryElement"],
    dragStartDelay: [InputFlags.None, "cdkDragStartDelay", "dragStartDelay"],
    freeDragPosition: [InputFlags.None, "cdkDragFreeDragPosition", "freeDragPosition"],
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDragDisabled", "disabled", booleanAttribute],
    constrainPosition: [InputFlags.None, "cdkDragConstrainPosition", "constrainPosition"],
    previewClass: [InputFlags.None, "cdkDragPreviewClass", "previewClass"],
    previewContainer: [InputFlags.None, "cdkDragPreviewContainer", "previewContainer"]
  },
  outputs: {
    started: "cdkDragStarted",
    released: "cdkDragReleased",
    ended: "cdkDragEnded",
    entered: "cdkDragEntered",
    exited: "cdkDragExited",
    dropped: "cdkDragDropped",
    moved: "cdkDragMoved"
  },
  exportAs: ["cdkDrag"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_PARENT,
    useExisting: _CdkDrag
  }]), ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkDrag = _CdkDrag;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      standalone: true,
      host: {
        "class": DRAG_HOST_CLASS,
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_DROP_LIST]
    }, {
      type: Optional
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CDK_DRAG_CONFIG]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: DragDrop
  }, {
    type: ChangeDetectorRef
  }, {
    type: CdkDragHandle,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [CDK_DRAG_HANDLE]
    }]
  }, {
    type: CdkDrag,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [CDK_DRAG_PARENT]
    }]
  }], {
    _handles: [{
      type: ContentChildren,
      args: [CDK_DRAG_HANDLE, {
        descendants: true
      }]
    }],
    _previewTemplate: [{
      type: ContentChild,
      args: [CDK_DRAG_PREVIEW]
    }],
    _placeholderTemplate: [{
      type: ContentChild,
      args: [CDK_DRAG_PLACEHOLDER]
    }],
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var _CdkDropListGroup = class _CdkDropListGroup {
  constructor() {
    this._items = /* @__PURE__ */ new Set();
    this.disabled = false;
  }
  ngOnDestroy() {
    this._items.clear();
  }
};
_CdkDropListGroup.ɵfac = function CdkDropListGroup_Factory(t) {
  return new (t || _CdkDropListGroup)();
};
_CdkDropListGroup.ɵdir = ɵɵdefineDirective({
  type: _CdkDropListGroup,
  selectors: [["", "cdkDropListGroup", ""]],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
  },
  exportAs: ["cdkDropListGroup"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DROP_LIST_GROUP,
    useExisting: _CdkDropListGroup
  }]), ɵɵInputTransformsFeature]
});
var CdkDropListGroup = _CdkDropListGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      standalone: true,
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _uniqueIdCounter = 0;
var _CdkDropList = class _CdkDropList {
  /** Whether starting a dragging sequence from this container is disabled. */
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  constructor(element, dragDrop, _changeDetectorRef, _scrollDispatcher, _dir, _group, config) {
    this.element = element;
    this._changeDetectorRef = _changeDetectorRef;
    this._scrollDispatcher = _scrollDispatcher;
    this._dir = _dir;
    this._group = _group;
    this._destroyed = new Subject();
    this.connectedTo = [];
    this.id = `cdk-drop-list-${_uniqueIdCounter++}`;
    this.enterPredicate = () => true;
    this.sortPredicate = () => true;
    this.dropped = new EventEmitter();
    this.entered = new EventEmitter();
    this.exited = new EventEmitter();
    this.sorted = new EventEmitter();
    this._unsortedItems = /* @__PURE__ */ new Set();
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (_group) {
      _group._items.add(this);
    }
  }
  /** Registers an items with the drop list. */
  addItem(item) {
    this._unsortedItems.add(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Removes an item from the drop list. */
  removeItem(item) {
    this._unsortedItems.delete(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Gets the registered items in the list, sorted by their position in the DOM. */
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a, b) => {
      const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
  _setupInputSyncSubscription(ref) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
    }
    ref.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map((drop) => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach((drop) => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      ref.disabled = this.disabled;
      ref.lockAxis = this.lockAxis;
      ref.sortingDisabled = this.sortingDisabled;
      ref.autoScrollDisabled = this.autoScrollDisabled;
      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  /** Handles events from the underlying DropListRef. */
  _handleEvents(ref) {
    ref.beforeStarted.subscribe(() => {
      this._syncItemsWithRef();
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((event) => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref.exited.subscribe((event) => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.sorted.subscribe((event) => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
  }
  /** Syncs up the registered drag items with underlying drop list ref. */
  _syncItemsWithRef() {
    this._dropListRef.withItems(this.getSortedItems().map((item) => item._dragRef));
  }
};
_CdkDropList._dropLists = [];
_CdkDropList.ɵfac = function CdkDropList_Factory(t) {
  return new (t || _CdkDropList)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DragDrop), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(CDK_DROP_LIST_GROUP, 12), ɵɵdirectiveInject(CDK_DRAG_CONFIG, 8));
};
_CdkDropList.ɵdir = ɵɵdefineDirective({
  type: _CdkDropList,
  selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
  hostAttrs: [1, "cdk-drop-list"],
  hostVars: 7,
  hostBindings: function CdkDropList_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
    }
  },
  inputs: {
    connectedTo: [InputFlags.None, "cdkDropListConnectedTo", "connectedTo"],
    data: [InputFlags.None, "cdkDropListData", "data"],
    orientation: [InputFlags.None, "cdkDropListOrientation", "orientation"],
    id: "id",
    lockAxis: [InputFlags.None, "cdkDropListLockAxis", "lockAxis"],
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListDisabled", "disabled", booleanAttribute],
    sortingDisabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
    enterPredicate: [InputFlags.None, "cdkDropListEnterPredicate", "enterPredicate"],
    sortPredicate: [InputFlags.None, "cdkDropListSortPredicate", "sortPredicate"],
    autoScrollDisabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
    autoScrollStep: [InputFlags.None, "cdkDropListAutoScrollStep", "autoScrollStep"]
  },
  outputs: {
    dropped: "cdkDropListDropped",
    entered: "cdkDropListEntered",
    exited: "cdkDropListExited",
    sorted: "cdkDropListSorted"
  },
  exportAs: ["cdkDropList"],
  standalone: true,
  features: [ɵɵProvidersFeature([
    // Prevent child drop lists from picking up the same group as their parent.
    {
      provide: CDK_DROP_LIST_GROUP,
      useValue: void 0
    },
    {
      provide: CDK_DROP_LIST,
      useExisting: _CdkDropList
    }
  ]), ɵɵInputTransformsFeature]
});
var CdkDropList = _CdkDropList;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      standalone: true,
      providers: [
        // Prevent child drop lists from picking up the same group as their parent.
        {
          provide: CDK_DROP_LIST_GROUP,
          useValue: void 0
        },
        {
          provide: CDK_DROP_LIST,
          useExisting: CdkDropList
        }
      ],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: DragDrop
  }, {
    type: ChangeDetectorRef
  }, {
    type: ScrollDispatcher
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: CdkDropListGroup,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CDK_DROP_LIST_GROUP]
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CDK_DRAG_CONFIG]
    }]
  }], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var _DragDropModule = class _DragDropModule {
};
_DragDropModule.ɵfac = function DragDropModule_Factory(t) {
  return new (t || _DragDropModule)();
};
_DragDropModule.ɵmod = ɵɵdefineNgModule({
  type: _DragDropModule,
  imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
  exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
});
_DragDropModule.ɵinj = ɵɵdefineInjector({
  providers: [DragDrop],
  imports: [CdkScrollableModule]
});
var DragDropModule = _DragDropModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// node_modules/@po-ui/ng-components/fesm2022/po-ui-ng-components.mjs
var PoDividerSize;
(function(PoDividerSize2) {
  PoDividerSize2["small"] = "small";
  PoDividerSize2["medium"] = "medium";
  PoDividerSize2["large"] = "large";
})(PoDividerSize || (PoDividerSize = {}));
var PoDividerBaseComponent = class _PoDividerBaseComponent {
  coordinateX1;
  coordinateX2;
  _borderWidth = PoDividerSize.small;
  /** Valor do rótulo a ser exibido. */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Define a espessura da linha.
   *
   * Valores válidos:
   * - small
   * - medium
   * - large
   *
   * @default `small`
   */
  set borderWidth(value) {
    this._borderWidth = PoDividerSize[value] ? PoDividerSize[value] : PoDividerSize.small;
    this.getCoordinates();
  }
  get borderWidth() {
    return this._borderWidth;
  }
  ngOnInit() {
    this.getCoordinates();
  }
  getCoordinates() {
    if (this.borderWidth === PoDividerSize.small) {
      this.coordinateX1 = "0.1%";
      this.coordinateX2 = "99.9%";
    } else if (this.borderWidth === PoDividerSize.medium) {
      this.coordinateX1 = "0.2%";
      this.coordinateX2 = "99.8%";
    } else {
      this.coordinateX1 = "0.3%";
      this.coordinateX2 = "99.7%";
    }
  }
  static ɵfac = function PoDividerBaseComponent_Factory(t) {
    return new (t || _PoDividerBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDividerBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], borderWidth: [InputFlags.None, "p-border-width", "borderWidth"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDividerBaseComponent, [{
    type: Directive
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], borderWidth: [{
    type: Input,
    args: ["p-border-width"]
  }] });
})();
function PoDividerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
var PoDividerComponent = class _PoDividerComponent extends PoDividerBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoDividerComponent_BaseFactory;
    return function PoDividerComponent_Factory(t) {
      return (ɵPoDividerComponent_BaseFactory || (ɵPoDividerComponent_BaseFactory = ɵɵgetInheritedFactory(_PoDividerComponent)))(t || _PoDividerComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoDividerComponent, selectors: [["po-divider"]], features: [ɵɵInheritDefinitionFeature], decls: 4, vars: 4, consts: [[1, "po-divider"], ["class", "po-divider-label", 4, "ngIf"], ["xmlns", "http://www.w3.org/2000/svg"], ["y1", "50%", "y2", "50%"], [1, "po-divider-label"]], template: function PoDividerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoDividerComponent_div_1_Template, 2, 1, "div", 1);
      ɵɵnamespaceSVG();
      ɵɵelementStart(2, "svg", 2);
      ɵɵelement(3, "line", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵattribute("p-size", ctx.borderWidth);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance(2);
      ɵɵattribute("x1", ctx.coordinateX1)("x2", ctx.coordinateX2);
    }
  }, dependencies: [NgIf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDividerComponent, [{
    type: Component,
    args: [{ selector: "po-divider", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-divider" [attr.p-size]="borderWidth">\n  <div *ngIf="label" class="po-divider-label">{{ label }}</div>\n  <svg xmlns="http://www.w3.org/2000/svg">\n    <line [attr.x1]="coordinateX1" y1="50%" [attr.x2]="coordinateX2" y2="50%" />\n  </svg>\n</div>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDividerComponent, { className: "PoDividerComponent", filePath: "lib/components/po-divider/po-divider.component.ts", lineNumber: 30 });
})();
var PoDividerModule = class _PoDividerModule {
  static ɵfac = function PoDividerModule_Factory(t) {
    return new (t || _PoDividerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDividerModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDividerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoDividerComponent],
      exports: [PoDividerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDividerModule, { declarations: [PoDividerComponent], imports: [CommonModule], exports: [PoDividerComponent] });
})();
function PoIconComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoIconComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "i", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.class);
  }
}
var PoIconComponent = class _PoIconComponent {
  class;
  _icon;
  constructor() {
  }
  /**
   * Define o ícone a ser exibido.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-button p-icon="po-icon-user" p-label="PO button"></po-button>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-button p-icon="fa fa-podcast" p-label="PO button"></po-button>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-button [p-icon]="template" p-label="button template ionic"></po-button>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  set icon(value) {
    if (typeof value === "string") {
      this.addClasses(value);
    } else if (value instanceof TemplateRef) {
      this._icon = value;
    }
  }
  get icon() {
    return this._icon;
  }
  addClasses(value) {
    this.class = value.startsWith("po-icon-") ? this.class = `po-icon ${value}` : this.class = `po-fonts-icon ${value}`;
  }
  static ɵfac = function PoIconComponent_Factory(t) {
    return new (t || _PoIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoIconComponent, selectors: [["po-icon"]], inputs: { icon: [InputFlags.None, "p-icon", "icon"] }, decls: 3, vars: 3, consts: [[4, "ngIf", "ngIfThen", "ngIfElse"], ["fontTemplate", ""], ["aria-hidden", "true"]], template: function PoIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoIconComponent_ng_container_0_Template, 1, 0, "ng-container", 0)(1, PoIconComponent_ng_template_1_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.class)("ngIfThen", _r2)("ngIfElse", ctx.icon);
    }
  }, dependencies: [NgIf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoIconComponent, [{
    type: Component,
    args: [{ selector: "po-icon", changeDetection: ChangeDetectionStrategy.OnPush, template: '<ng-container *ngIf="class; then fontTemplate; else icon"></ng-container>\n\n<ng-template #fontTemplate>\n  <i [class]="class" aria-hidden="true"></i>\n</ng-template>\n' }]
  }], () => [], { icon: [{
    type: Input,
    args: ["p-icon"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoIconComponent, { className: "PoIconComponent", filePath: "lib/components/po-icon/po-icon.component.ts", lineNumber: 17 });
})();
var PoIconModule = class _PoIconModule {
  static ɵfac = function PoIconModule_Factory(t) {
    return new (t || _PoIconModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoIconModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoIconComponent],
      exports: [PoIconComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoIconModule, { declarations: [PoIconComponent], imports: [CommonModule], exports: [PoIconComponent] });
})();
var PoTagOrientation;
(function(PoTagOrientation2) {
  PoTagOrientation2["Horizontal"] = "horizontal";
  PoTagOrientation2["Vertical"] = "vertical";
})(PoTagOrientation || (PoTagOrientation = {}));
var PoTagType;
(function(PoTagType2) {
  PoTagType2["Danger"] = "danger";
  PoTagType2["Info"] = "info";
  PoTagType2["Success"] = "success";
  PoTagType2["Warning"] = "warning";
  PoTagType2["Neutral"] = "neutral";
})(PoTagType || (PoTagType = {}));
var PoTagIcon;
(function(PoTagIcon2) {
  PoTagIcon2["Danger"] = "po-icon-close";
  PoTagIcon2["Info"] = "po-icon-info";
  PoTagIcon2["Success"] = "po-icon-ok";
  PoTagIcon2["Warning"] = "po-icon-warning";
})(PoTagIcon || (PoTagIcon = {}));
var PoColorPaletteEnum;
(function(PoColorPaletteEnum2) {
  PoColorPaletteEnum2["Color01"] = "color-01";
  PoColorPaletteEnum2["Color02"] = "color-02";
  PoColorPaletteEnum2["Color03"] = "color-03";
  PoColorPaletteEnum2["Color04"] = "color-04";
  PoColorPaletteEnum2["Color05"] = "color-05";
  PoColorPaletteEnum2["Color06"] = "color-06";
  PoColorPaletteEnum2["Color07"] = "color-07";
  PoColorPaletteEnum2["Color08"] = "color-08";
  PoColorPaletteEnum2["Color09"] = "color-09";
  PoColorPaletteEnum2["Color10"] = "color-10";
  PoColorPaletteEnum2["Color11"] = "color-11";
  PoColorPaletteEnum2["Color12"] = "color-12";
})(PoColorPaletteEnum || (PoColorPaletteEnum = {}));
var poLanguageDefault = [
  { description: "English", language: "en" },
  { description: "Español", language: "es" },
  { description: "Português", language: "pt" },
  { description: "Pусский", language: "ru" }
];
var poLocales = poLanguageDefault.map((language) => language.language);
var poLocaleDefault = "pt";
var poLocaleDecimalSeparatorList = [
  { separator: ".", language: "en" },
  { separator: ",", language: "es" },
  { separator: ",", language: "pt" },
  { separator: ",", language: "ru" }
];
var poLocaleThousandSeparatorList = [
  { separator: ",", language: "en" },
  { separator: ".", language: "es" },
  { separator: ".", language: "pt" },
  { separator: " ", language: "ru" }
];
var poLocaleDateSeparatorList = [
  { separator: "/", locale: "en" },
  { separator: "/", locale: "es" },
  { separator: "/", locale: "pt" },
  { separator: ".", locale: "ru" }
];
function formatBytes(bytes, decimals = 2) {
  if (!bytes) {
    return void 0;
  }
  const multiplier = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const result = Math.floor(Math.log(bytes) / Math.log(multiplier));
  decimals = decimals < 0 ? 0 : decimals;
  return `${parseFloat((bytes / Math.pow(multiplier, result)).toFixed(decimals))} ${sizes[result]}`;
}
function getBrowserLanguage() {
  const language = navigator.language || navigator["userLanguage"];
  const shortLanguage = getShortLanguage(language);
  return poLocales.includes(shortLanguage) ? language : poLocaleDefault;
}
function getShortBrowserLanguage() {
  return getShortLanguage(getBrowserLanguage());
}
function getShortLanguage(language) {
  return (language || poLocaleDefault).toLowerCase().substring(0, 2);
}
function isLanguage(value) {
  const languageRegex = new RegExp("^[a-z]{2}(-[a-z]{2})?$", "i");
  return languageRegex.test(value);
}
function reloadCurrentPage() {
  window.location.assign(location.href);
}
function convertToBoolean(val) {
  if (typeof val === "string") {
    val = val.toLowerCase().trim();
    return val === "true" || val === "on" || val === "";
  }
  if (typeof val === "number") {
    return val === 1;
  }
  return !!val;
}
function convertToInt(value, valueDefault) {
  const validNumber = parseInt(value, 10);
  const validDefaultValue = parseInt(valueDefault, 10);
  const defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : void 0;
  return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
function isTypeof(object, type) {
  return typeof object === type;
}
function callFunction(fn, context, param) {
  if (isTypeof(fn, "function")) {
    fn.call(context, param);
  } else {
    context[fn](param);
  }
}
function convertIsoToDate(value, start, end) {
  if (value) {
    const day = parseInt(value.substring(8, 10), 10);
    const month = parseInt(value.substring(5, 7), 10);
    const year = parseInt(value.substring(0, 4), 10);
    if (start) {
      const date = new Date(year, month - 1, day, 0, 0, 0);
      setYearFrom0To100(date, year);
      return date;
    } else if (end) {
      const date = new Date(year, month - 1, day, 23, 59, 59);
      setYearFrom0To100(date, year);
      return date;
    } else {
      return new Date(year, month - 1, day);
    }
  }
}
function convertDateToISODate(date) {
  if (date) {
    const getMonth = date.getMonth() + 1;
    const day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
    const month = getMonth < 10 ? "0" + getMonth : getMonth;
    const year = formatYear(date.getFullYear());
    return year + "-" + month + "-" + day;
  } else {
    return null;
  }
}
function convertDateToISOExtended(date, time) {
  if (date) {
    const getMonth = date.getMonth() + 1;
    const day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
    const month = getMonth < 10 ? "0" + getMonth : getMonth;
    const year = formatYear(date.getFullYear());
    const dateString = date.toString();
    if (time !== null) {
      return year + "-" + month + "-" + day + time;
    } else {
      return year + "-" + month + "-" + day + "T" + dateString.substring(16, 24) + dateString.substring(28, 31) + ":" + dateString.substring(31, 33);
    }
  } else {
    return null;
  }
}
function formatYear(year) {
  if (year >= 1e3) {
    return year.toString();
  }
  if (year > 99 && year < 1e3) {
    return `0${year}`;
  }
  if (year > 9 && year < 100) {
    return `00${year}`;
  }
  if (year >= 0 && year < 10) {
    return `000${year}`;
  }
}
function isIEOrEdge() {
  const userAgent = window.navigator.userAgent;
  return /msie\s|trident\/|edge\//i.test(userAgent);
}
function isIE() {
  const userAgent = window.navigator.userAgent;
  return /msie\s|trident/i.test(userAgent);
}
function isFirefox() {
  const userAgent = window.navigator.userAgent;
  return userAgent.toLowerCase().indexOf("firefox") > -1;
}
function isSafari() {
  const userAgent = window.navigator.userAgent;
  return /^(?!.*chrome).*safari.*$/.test(userAgent.toLocaleLowerCase());
}
function isMobile() {
  const userAgent = window.navigator.userAgent;
  return userAgent.match(/Android|webOS|iPhone|iPad|iPod|BlackBerry|Windows Phone/i);
}
function isEquals(value, comparedValue) {
  return JSON.stringify(value) === JSON.stringify(comparedValue);
}
function isKeyCodeEnter(event) {
  return event.keyCode === 13 || event.which === 13;
}
function isKeyCodeSpace(event) {
  return event.keyCode === 32 || event.which === 32;
}
function setYearFrom0To100(date, year) {
  if (year >= 0 && year < 100) {
    date.setFullYear(year);
  }
}
function sortOptionsByProperty(options, property) {
  options.sort((optionA, optionB) => {
    optionA = optionA[property].toString().toLowerCase();
    optionB = optionB[property].toString().toLowerCase();
    if (optionA < optionB) {
      return -1;
    }
    if (optionA > optionB) {
      return 1;
    }
    return 0;
  });
}
function sortFields(fields = [], defaultOrdering = -1) {
  const resultClassification = { fieldAComesFirst: -1, fieldAComesAfter: 1, keepPositions: 0 };
  const isOrderValid = (order) => isTypeof(order, "number") && order > 0;
  const applyDefaultOrdering = (order) => isOrderValid(order) ? order : defaultOrdering;
  return fields.sort((fieldA, fieldB) => {
    const orderA = applyDefaultOrdering(fieldA.order);
    const orderB = applyDefaultOrdering(fieldB.order);
    if (orderA === orderB) {
      return resultClassification.keepPositions;
    }
    if (orderA === defaultOrdering) {
      return resultClassification.fieldAComesAfter;
    }
    if (orderB === defaultOrdering) {
      return resultClassification.fieldAComesFirst;
    }
    return orderA - orderB;
  });
}
function removeDuplicatedOptions(list) {
  for (let i = 0; i < list.length; i++) {
    if (i === 0) {
      continue;
    }
    if (list.findIndex((op) => op.value === list[i].value) !== i) {
      list.splice(i, 1);
      i--;
    }
  }
}
function removeDuplicatedOptionsWithFieldValue(list, newValue) {
  for (let i = 0; i < list.length; i++) {
    if (i === 0) {
      continue;
    }
    if (list.findIndex((op) => op[newValue] === list[i][newValue]) !== i) {
      list.splice(i, 1);
      i--;
    }
  }
}
function removeUndefinedAndNullOptions(list) {
  for (let i = 0; i < list.length; i++) {
    if (list[i].value === void 0 || list[i].value === null) {
      list.splice(i, 1);
      i--;
    }
  }
}
function removeUndefinedAndNullOptionsWithFieldValue(list, newValue) {
  for (let i = 0; i < list.length; i++) {
    if (list[i][newValue] === void 0 || list[i][newValue] === null) {
      list.splice(i, 1);
      i--;
    }
  }
}
function validValue(value) {
  return value !== null && value !== void 0 && value !== "" || value === false;
}
function isExternalLink(url) {
  return url ? url.startsWith("http") : false;
}
function openExternalLink(url) {
  window.open(url, "_blank");
}
function getFormattedLink(link) {
  let formattedLink = "";
  if (link) {
    formattedLink = link.replace(/^(\.)+/g, "");
  }
  if (!formattedLink.startsWith("/")) {
    formattedLink = "/".concat(formattedLink);
  }
  return formattedLink;
}
function sortValues(leftSide, rightSide, ascending = true) {
  const left = isTypeof(leftSide, "string") ? leftSide.toLowerCase() : leftSide;
  const right = isTypeof(rightSide, "string") ? rightSide.toLowerCase() : rightSide;
  const leftIsInvalid = left === null || left === void 0 || Number.isNaN(left);
  const rightIsInvalid = right === null || right === void 0 || Number.isNaN(right);
  if (ascending) {
    if (left < right || leftIsInvalid) {
      return -1;
    } else if (left > right || rightIsInvalid) {
      return 1;
    }
  } else if (ascending === false) {
    if (left < right || leftIsInvalid) {
      return 1;
    } else if (left > right || rightIsInvalid) {
      return -1;
    }
  }
  return 0;
}
function validateDateRange(date, dateStart, dateEnd) {
  if (dateStart && dateEnd) {
    return date >= dateStart && date <= dateEnd;
  } else if (dateStart && !dateEnd) {
    return date >= dateStart;
  } else if (!dateStart && dateEnd) {
    return date <= dateEnd;
  } else {
    return true;
  }
}
function uuid() {
  function hex4() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4();
}
function capitalizeFirstLetter(text) {
  return `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
}
function convertImageToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result);
    reader.onerror = (error) => reject(error);
  });
}
function isValidImageBase64(value) {
  try {
    return !!value.match(/^data:image\/([a-zA-Z]*);base64,([^\"]*)$/);
  } catch (err) {
    return false;
  }
}
function convertNumberToDecimal(number, decimalsPlace) {
  const isValidValue = (number || number === 0) && !isNaN(number);
  const floatValue = isValidValue ? parseFloat(number) : void 0;
  try {
    return parseFloat(floatValue.toFixed(decimalsPlace));
  } catch {
    return floatValue;
  }
}
function validateObjectType(value) {
  return isTypeof(value, "object") && !Array.isArray(value) ? value : void 0;
}
function getFocusableElements(parentElement) {
  const focusableElements = 'button:not([disabled]), [href], input, select, textarea, [tabindex]:not([tabindex="-1"]';
  return parentElement.querySelectorAll(focusableElements);
}
function replaceFormatSeparator(format, separator) {
  let newFormat = format;
  if (separator !== "/") {
    newFormat = newFormat.replace(/\//g, separator);
  }
  return newFormat;
}
function sortArrayOfObjects(items, key, isAscendingOrder) {
  if (items) {
    return items.sort((a, b) => {
      const valueA = a[key];
      const valueB = b[key];
      if (typeof valueA === "number" && typeof valueB === "number") {
        return isAscendingOrder ? valueA - valueB : valueB - valueA;
      } else {
        const compareResult = valueA.toString().localeCompare(valueB.toString());
        return isAscendingOrder ? compareResult : -compareResult;
      }
    });
  }
}
var poDefaultLanguage = "PO_DEFAULT_LANGUAGE";
var poLocaleKey = "PO_USER_LOCALE";
var PoLanguageService = class _PoLanguageService {
  constructor() {
  }
  set languageDefault(language) {
    if (language && isLanguage(language)) {
      localStorage.setItem(poDefaultLanguage, language);
    }
  }
  get languageDefault() {
    return localStorage.getItem(poDefaultLanguage);
  }
  /**
   * @description
   *
   * Método responsável por retornar o idioma ativo.
   *
   * A busca do idioma será feita na seguinte ordem:
   *
   *   1 - o idioma que foi armazenado no *localStorage*, através do método `setLanguage()` utilizado pelo i18n.
   *
   *   2 - o valor inserido nas configurações do módulo do i18n através do parâmetro `config`, sendo o idioma inserido
   * na propriedade `language` da interface `PoI18nConfigDefault`.
   *
   *   3 - o idioma do navegador utilizado.
   *
   * > Caso o idioma do navegador não seja suportado pelo PO (`pt`, `en`, `es` ou `ru`), será retornado valor `pt`.
   *
   * **Retorno:** `string` com a sigla do idioma ativo.
   */
  getLanguage() {
    const language = localStorage.getItem(poLocaleKey) || this.languageDefault || getBrowserLanguage();
    return language && language.toLowerCase();
  }
  /**
   * @description
   *
   * Método responsável por retornar o idioma *default* da aplicação definido nas configurações do módulo do i18n através
   * do parâmetro `config`.
   *
   * **Retorno:** `string` com a sigla do idioma *default*.
   */
  getLanguageDefault() {
    return this.languageDefault;
  }
  /**
   * @description
   *
   * Método responsável por retornar a abreviação do idioma ativo na aplicação.
   *
   * @default `pt`
   *
   * **Retorno:** `string` com a sigla abreviada do idioma ativo.
   */
  getShortLanguage() {
    const language = this.getLanguage();
    const shortLanguage = getShortLanguage(language);
    return poLocales.includes(shortLanguage) ? shortLanguage : poLocaleDefault;
  }
  /**
   * @description
   *
   * Método para salvar o idioma da aplicação no *storage*, utilizado pelo serviço do i18n.
   *
   * > Ao definir um idioma por este método, todos os módulos da aplicação utilizarão o idioma definido.
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma,
   * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  setLanguage(language) {
    if (!isLanguage(language)) {
      return;
    }
    localStorage.setItem(poLocaleKey, language.toLowerCase());
  }
  /**
   * @description
   *
   * Método que define o idioma configurado a partir do parâmetro `config` utilizado pelo módulo do i18n.
   *
   * > Ao definir um idioma por este serviço, apenas o módulo do i18n referente a esta configuração utilizará o idioma definido.
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma,
   * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  setLanguageDefault(language) {
    this.languageDefault = language;
  }
  /**
   * @description
   *
   * Método que retorna o separador
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  getNumberSeparators(language) {
    language = language || this.getShortLanguage();
    const decimal = poLocaleDecimalSeparatorList.find((separator) => separator.language === language) ?? {};
    const thousand = poLocaleThousandSeparatorList.find((separator) => separator.language === language) ?? {};
    const decimalSeparator = decimal.separator ?? ",";
    const thousandSeparator = thousand.separator ?? ".";
    return { decimalSeparator, thousandSeparator };
  }
  /**
   * @description
   *
   * Método que retorna o separador de datas
   *
   * @param language sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   */
  getDateSeparator(language) {
    language = language || this.getShortLanguage();
    const separatorChar = poLocaleDateSeparatorList.find((separator) => separator.locale === language) ?? {};
    return separatorChar.separator ?? "/";
  }
  static ɵfac = function PoLanguageService_Factory(t) {
    return new (t || _PoLanguageService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoLanguageService, factory: _PoLanguageService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLanguageService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var poTagColors = Object.values(PoColorPaletteEnum);
var poTagOrientationDefault = PoTagOrientation.Vertical;
var PoTagLiteralsDefault = {
  en: {
    remove: "Clear"
  },
  es: {
    remove: "Eliminar"
  },
  pt: {
    remove: "Remover"
  },
  ru: {
    remove: "удалять"
  }
};
var PoTagBaseComponent = class _PoTagBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define uma legenda que será exibida acima ou ao lado da *tag*, de acordo com a `p-orientation`.
   */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Habilita a opção de remover a tag
   *
   * @default `false`
   */
  removable = false;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o `po-tag` e não permite que o usuário interaja com o mesmo.
   * > A propriedade `p-disabled` somente terá efeito caso a propriedade `p-removable` esteja definida como `true`.
   *
   * @default `false`
   */
  disabled = false;
  /** Texto da tag. */
  value;
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada ao clicar sobre o `po-tag` e que receberá como parâmetro um objeto contendo o seu valor e tipo.
   *
   * O evento de click só funciona se a tag não for removível.
   */
  click = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que sera executada quando clicar sobre o ícone de remover no `po-tag`
   */
  remove = new EventEmitter();
  poTagOrientation = PoTagOrientation;
  customColor;
  customTextColor;
  _color;
  _textColor;
  _icon;
  _inverse;
  _orientation = poTagOrientationDefault;
  _type;
  _literals;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Determina a cor da tag. As maneiras de customizar as cores são:
   * - Hexadeximal, por exemplo `#c64840`;
   * - RGB, como `rgb(0, 0, 165)`;
   * - O nome da cor, por exemplo `blue`;
   * - Usando uma das cores do tema do PO:
   * Valores válidos:
   *  - <span class="dot po-color-01"></span> `color-01`
   *  - <span class="dot po-color-02"></span> `color-02`
   *  - <span class="dot po-color-03"></span> `color-03`
   *  - <span class="dot po-color-04"></span> `color-04`
   *  - <span class="dot po-color-05"></span> `color-05`
   *  - <span class="dot po-color-06"></span> `color-06`
   *  - <span class="dot po-color-07"></span> `color-07`
   *  - <span class="dot po-color-08"></span> `color-08`
   *  - <span class="dot po-color-09"></span> `color-09`
   *  - <span class="dot po-color-10"></span> `color-10`
   *  - <span class="dot po-color-11"></span> `color-11`
   *  - <span class="dot po-color-12"></span> `color-12`
   *
   * - Para uma melhor acessibilidade no uso do componente é recomendável utilizar cores com um melhor contraste em relação ao background.
   *
   * > **Atenção:** A propriedade `p-type` sobrepõe esta definição.
   */
  set color(value) {
    this._color = poTagColors.includes(value) ? value : void 0;
    if (this._color === void 0) {
      CSS.supports("color", value) ? this.customColor = value : this.customColor = void 0;
    }
  }
  get color() {
    return this._color;
  }
  /**
   * @optional
   *
   * @description
   *
   * Determina a cor do texto da tag. As maneiras de customizar as cores são:
   * - Hexadeximal, por exemplo `#c64840`;
   * - RGB, como `rgb(0, 0, 165)`;
   * - O nome da cor, por exemplo `blue`;
   * - Usando uma das cores do tema do PO:
   * Valores válidos:
   *  - <span class="dot po-color-01"></span> `color-01`
   *  - <span class="dot po-color-02"></span> `color-02`
   *  - <span class="dot po-color-03"></span> `color-03`
   *  - <span class="dot po-color-04"></span> `color-04`
   *  - <span class="dot po-color-05"></span> `color-05`
   *  - <span class="dot po-color-06"></span> `color-06`
   *  - <span class="dot po-color-07"></span> `color-07`
   *  - <span class="dot po-color-08"></span> `color-08`
   *  - <span class="dot po-color-09"></span> `color-09`
   *  - <span class="dot po-color-10"></span> `color-10`
   *  - <span class="dot po-color-11"></span> `color-11`
   *  - <span class="dot po-color-12"></span> `color-12`
   *
   * - Para uma melhor acessibilidade no uso do componente é recomendável utilizar cores com um melhor contraste em relação ao background.
   *
   * > **Atenção:** A propriedade `p-type` sobrepõe esta definição.
   */
  set textColor(value) {
    this._textColor = poTagColors.includes(value) ? value : void 0;
    if (this._textColor === void 0) {
      CSS.supports("color", value) ? this.customTextColor = value : this.customTextColor = void 0;
    }
  }
  get textColor() {
    return this._textColor;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define ou ativa um ícone que será exibido ao lado do valor da *tag*.
   *
   * Quando `p-type` estiver definida, basta informar um valor igual a `true` para que o ícone seja exibido conforme descrições abaixo:
   * - <span class="po-icon po-icon-ok"></span> - `success`
   * - <span class="po-icon po-icon-warning"></span> - `warning`
   * - <span class="po-icon po-icon-close"></span> - `danger`
   * - <span class="po-icon po-icon-info"></span> - `info`
   *
   * Também É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-tag p-icon="po-icon-user" p-value="PO Tag"></po-tag>
   * ```
   * como também utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-tag p-icon="fa fa-podcast" p-value="PO Tag"></po-button>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-tag [p-icon]="template" p-value="Tag template ionic"></po-button>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   *
   * @default `false`
   */
  set icon(value) {
    if (this.type) {
      this._icon = convertToBoolean(value);
    } else {
      this._icon = value;
    }
  }
  get icon() {
    return this._icon;
  }
  /**
   * @deprecated 16.x.x
   *
   * @optional
   *
   * @description
   *
   * > Por regras de acessibilidade e usabilidade a tag não terá a inversão de cores no componente.
   *
   * Ativa a inversão de cores configuradas no componente, possibilitando uma visualização de status ativo e inativo.
   *
   * > A cor do texto, do ícone e da borda ficam com a cor utilizada na propriedade `p-color` ou a cor correspondente ao `p-type`,
   * e a cor do fundo fica branca.
   *
   * @default `false`
   */
  set inverse(value) {
    this._inverse = convertToBoolean(value);
  }
  get inverse() {
    return this._inverse;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o *layout* de exibição.
   *
   * @default `vertical`
   */
  set orientation(value) {
    this._orientation = Object.values(PoTagOrientation).includes(value) ? value : poTagOrientationDefault;
  }
  get orientation() {
    return this._orientation;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tipo da *tag*.
   *
   * Valores válidos:
   *  - `success`: cor verde utilizada para simbolizar sucesso ou êxito.
   *  - `warning`: cor amarela que representa aviso ou advertência.
   *  - `danger`: cor vermelha para erro ou aviso crítico.
   *  - `info`: cor azul claro que caracteriza conteúdo informativo.
   *  - `neutral`: cor cinza claro para uso geral.
   *
   * > Quando esta propriedade for definida, irá sobrepor a definição de `p-color` e `p-icon` somente será exibido caso seja `true`.
   *
   * @default `info`
   */
  set type(value) {
    if (!this.removable) {
      this._type = Object.values(PoTagType).includes(value) ? value : void 0;
    }
  }
  get type() {
    return this._type;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-tag`.
   *
   *
   * Para utilizar, basta passar a literal customizada:
   *
   * ```
   *  const customLiterals: PoTagLiterals = {
   *    remove: 'Remover itens'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
   *
   * ```
   * <po-tag
   *   [p-literals]="customLiterals">
   * </po-tag>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, PoTagLiteralsDefault[poLocaleDefault]), PoTagLiteralsDefault[this.language]), value);
    } else {
      this._literals = PoTagLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || PoTagLiteralsDefault[this.language];
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoTagBaseComponent_Factory(t) {
    return new (t || _PoTagBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTagBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], removable: [InputFlags.HasDecoratorInputTransform, "p-removable", "removable", convertToBoolean], disabled: [InputFlags.HasDecoratorInputTransform, "p-disabled", "disabled", convertToBoolean], value: [InputFlags.None, "p-value", "value"], color: [InputFlags.None, "p-color", "color"], textColor: [InputFlags.None, "p-text-color", "textColor"], icon: [InputFlags.None, "p-icon", "icon"], inverse: [InputFlags.None, "p-inverse", "inverse"], orientation: [InputFlags.None, "p-orientation", "orientation"], type: [InputFlags.None, "p-type", "type"], literals: [InputFlags.None, "p-literals", "literals"] }, outputs: { click: "p-click", remove: "p-close" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTagBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { label: [{
    type: Input,
    args: ["p-label"]
  }], removable: [{
    type: Input,
    args: [{ alias: "p-removable", transform: convertToBoolean }]
  }], disabled: [{
    type: Input,
    args: [{ alias: "p-disabled", transform: convertToBoolean }]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], remove: [{
    type: Output,
    args: ["p-close"]
  }], color: [{
    type: Input,
    args: ["p-color"]
  }], textColor: [{
    type: Input,
    args: ["p-text-color"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], inverse: [{
    type: Input,
    args: ["p-inverse"]
  }], orientation: [{
    type: Input,
    args: ["p-orientation"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }] });
})();
var PO_CONTROL_POSITIONS = [
  "right",
  "right-top",
  "right-bottom",
  "top",
  "top-left",
  "top-right",
  "left",
  "left-top",
  "left-bottom",
  "bottom",
  "bottom-left",
  "bottom-right"
];
var PO_TOOLTIP_POSITION_DEFAULT = "bottom";
var PoTooltipBaseDirective = class _PoTooltipBaseDirective {
  /**
   * @optional
   *
   * @description
   *
   * Define que o po-tooltip será incluido no body e não dentro do elemento ao qual o tooltip foi especificado.
   * Opção necessária para o caso de uso de tooltip em um elemento SVG.
   *
   * @default `false`
   */
  appendInBody = false;
  _tooltipPosition = "bottom";
  tooltipContent;
  _displayTooltip = false;
  _tooltip = "";
  /**
   * @description
   *
   * Habilita e atribui um texto ao po-tooltip.
   *
   * **Como boa prática, indica-se utilizar um texto com até 140 caracteres.**
   */
  set tooltip(tooltip) {
    this._tooltip = tooltip;
  }
  get tooltip() {
    return this._tooltip;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a posição que o po-tooltip abrirá em relação ao componente alvo. Sugere-se que seja
   * usada a orientação "bottom" (abaixo), porém o mesmo é flexível e será rotacionado
   * automaticamente para se adequar a tela, caso necessário.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-tooltip no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-tooltip no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-tooltip no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-tooltip abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-tooltip abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-tooltip abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-tooltip no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-tooltip no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-tooltip no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-tooltip acima do componente alvo.
   * - `top-right`: Posiciona o po-tooltip acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-tooltip acima e à esquerda do componente alvo.
   *
   * @default bottom
   */
  set tooltipPosition(position) {
    this._tooltipPosition = PO_CONTROL_POSITIONS.includes(position) ? position : PO_TOOLTIP_POSITION_DEFAULT;
  }
  get tooltipPosition() {
    return this._tooltipPosition;
  }
  set displayTooltip(value) {
    this._displayTooltip = value;
    this._displayTooltip ? this.addTooltipAction() : this.removeTooltipAction();
  }
  get displayTooltip() {
    return this._displayTooltip;
  }
  static ɵfac = function PoTooltipBaseDirective_Factory(t) {
    return new (t || _PoTooltipBaseDirective)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTooltipBaseDirective, inputs: { appendInBody: [InputFlags.HasDecoratorInputTransform, "p-append-in-body", "appendInBody", convertToBoolean], tooltip: [InputFlags.None, "p-tooltip", "tooltip"], tooltipPosition: [InputFlags.None, "p-tooltip-position", "tooltipPosition"], displayTooltip: [InputFlags.HasDecoratorInputTransform, "p-display-tooltip", "displayTooltip", convertToBoolean] }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipBaseDirective, [{
    type: Directive
  }], null, { appendInBody: [{
    type: Input,
    args: [{ alias: "p-append-in-body", transform: convertToBoolean }]
  }], tooltip: [{
    type: Input,
    args: ["p-tooltip"]
  }], tooltipPosition: [{
    type: Input,
    args: ["p-tooltip-position"]
  }], displayTooltip: [{
    type: Input,
    args: [{ alias: "p-display-tooltip", transform: convertToBoolean }]
  }] });
})();
var poControlPositionSidesDefault = [
  "bottom",
  "bottom-left",
  "bottom-right",
  "left",
  "left-top",
  "left-bottom",
  "top",
  "top-right",
  "top-left",
  "right",
  "right-bottom",
  "right-top"
];
var PoControlPositionService = class _PoControlPositionService {
  arrowDirection;
  customPositions;
  differenceDiagonalToWidthArrow = 3;
  element;
  elementOffset;
  isCornerAligned;
  isSetElementWidth = false;
  // offset da seta em relação ao canto do componente
  offsetArrow = 12;
  targetElement;
  /**
   * @description Ajusta a posição do elemento, caso não couber em tela irá para próxima posição.
   *
   * @param value posição para exibição do elemento
   */
  adjustPosition(value) {
    const position = value || "bottom";
    this.elementPosition(position);
    this.customPositions && this.customPositions.length ? this.adjustCustomPosition(position) : this.adjustDefaultPosition(position);
  }
  /**
   * @description Retorna a direção da seta, conforme a posição do elemento.
   */
  getArrowDirection() {
    return this.arrowDirection;
  }
  /**
   * @description Método responsável por definir as propriedades utilizadas para exibir o elemento na posição correta.
   *
   * @param element elemento que será exibido
   * @param elementOffset offSet do elemento
   * @param targetElement elemento de onde deve partir a exibição
   * @param customPositions posições que sobrescreve as posições padrões
   * @param isSetElementWidth indica se deve definir o tamanho do elemento a ser exibido, caso for verdadeiro será igual do targetElement
   * @param isCornerAligned indica se o elemento filho será alinhado nos cantos do elemneto pai.
   */
  setElements(element, elementOffset, targetElement, customPositions, isSetElementWidth = false, isCornerAligned = false) {
    this.element = element instanceof ElementRef ? element.nativeElement : element;
    this.targetElement = targetElement instanceof ElementRef ? targetElement.nativeElement : targetElement;
    this.elementOffset = elementOffset;
    this.customPositions = customPositions;
    this.isSetElementWidth = isSetElementWidth;
    this.isCornerAligned = isCornerAligned;
  }
  adjustCustomPosition(position) {
    const positionLength = this.customPositions.length;
    let sidesCount = 0;
    while (sidesCount++ < positionLength) {
      if (this.overflowAllSides(position)) {
        position = this.nextPosition(position, this.customPositions);
        this.elementPosition(position);
      }
    }
  }
  adjustDefaultPosition(position) {
    const mainPositions = this.getMainPositions();
    const mainPositionLength = mainPositions.length;
    let mainSidesCount = 0;
    while (mainSidesCount++ < mainPositionLength) {
      const mainPosition = this.getMainPosition(position);
      this.elementPosition(position);
      if (this.overflowMain(mainPosition)) {
        position = this.nextPosition(mainPosition, mainPositions);
        continue;
      } else if (this.overflowAllSides(position)) {
        this.verifySubPositions(position);
        return;
      }
      return;
    }
  }
  elementPosition(position) {
    this.isCornerAligned ? this.setAlignedElementPosition(position) : this.setElementPosition(position);
  }
  getMainPosition(position) {
    return position.indexOf("-") > -1 ? position.substring(0, position.indexOf("-")) : position;
  }
  getMainPositions() {
    const defaultMainPositions = ["top", "right", "bottom", "left"];
    return this.customPositions && this.customPositions.length ? this.getMainPositionsByCustomPositions(this.customPositions) : defaultMainPositions;
  }
  getMainPositionsByCustomPositions(customPositions) {
    const mainPositions = [];
    const customPositionsLength = customPositions.length;
    for (let i = 0; i < customPositionsLength; i++) {
      const position = customPositions[i];
      const mainPosition = this.getMainPosition(position);
      if (!mainPositions.includes(mainPosition)) {
        mainPositions.push(mainPosition);
      }
    }
    return mainPositions;
  }
  getOverflows() {
    const sizesAndPositions = this.getSizesAndPositions();
    return {
      right: sizesAndPositions.element.right > sizesAndPositions.window.innerWidth,
      top: sizesAndPositions.element.top <= 0,
      left: sizesAndPositions.element.left <= 0,
      bottom: sizesAndPositions.element.bottom > sizesAndPositions.window.innerHeight
    };
  }
  getSizesAndPositions() {
    return {
      window: {
        scrollY: window.scrollY,
        scrollX: window.scrollX,
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight
      },
      element: this.element.getBoundingClientRect(),
      target: this.targetElement ? this.targetElement.getBoundingClientRect() : { top: 0, bottom: 0, right: 0, left: 0 }
    };
  }
  nextPosition(position, positions = []) {
    const index = positions.indexOf(position);
    const nextIndex = index + 1;
    if (index > -1 && nextIndex < positions.length) {
      return positions[nextIndex];
    } else {
      return positions[0];
    }
  }
  overflowAllSides(position) {
    const overflows = this.getOverflows();
    switch (position) {
      case "top":
        return overflows.top || overflows.right || overflows.left;
      case "top-right":
        return overflows.top || overflows.right || overflows.left;
      case "top-left":
        return overflows.top || overflows.left || overflows.right;
      case "right":
        return overflows.right || overflows.top || overflows.bottom;
      case "right-top":
        return overflows.right || overflows.top;
      case "right-bottom":
        return overflows.right || overflows.bottom;
      case "bottom":
        return overflows.bottom || overflows.right || overflows.left;
      case "bottom-right":
        return overflows.bottom || overflows.right || overflows.left;
      case "bottom-left":
        return overflows.bottom || overflows.left || overflows.right;
      case "left":
        return overflows.left || overflows.top || overflows.bottom;
      case "left-top":
        return overflows.left || overflows.top;
      case "left-bottom":
        return overflows.left || overflows.bottom;
    }
  }
  overflowMain(position) {
    const overflows = this.getOverflows();
    switch (position) {
      case "top":
        return overflows.top;
      case "right":
        return overflows.right;
      case "bottom":
        return overflows.bottom;
      case "left":
        return overflows.left;
    }
  }
  setAlignedArrowDirection(elementPosition) {
    switch (elementPosition) {
      case "top-left":
        return "bottom-left";
      case "top-right":
        return "bottom-right";
      case "bottom-right":
        return "top-right";
      case "bottom-left":
        return "top-left";
    }
  }
  setAlignedBottomPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left - displacement + "px";
  }
  setAlignedElementPosition(position) {
    this.setElementWidth();
    const sizesAndPositions = this.getSizesAndPositions();
    switch (position) {
      case "bottom-left":
        this.setAlignedBottomPositions(0, sizesAndPositions);
        break;
      case "bottom-right":
        this.setAlignedBottomPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
        break;
      case "top-left":
        this.setAlignedTopPositions(0, sizesAndPositions);
        break;
      case "top-right":
        this.setAlignedTopPositions(sizesAndPositions.element.width - sizesAndPositions.target.width, sizesAndPositions);
        break;
    }
    this.arrowDirection = this.setAlignedArrowDirection(position);
  }
  setAlignedTopPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left - displacement + "px";
  }
  setArrowDirection(elementPosition) {
    switch (elementPosition) {
      case "top":
        return "bottom";
      case "top-left":
        return "bottom-right";
      case "top-right":
        return "bottom-left";
      case "right":
        return "left";
      case "right-top":
        return "left-bottom";
      case "right-bottom":
        return "left-top";
      case "bottom":
        return "top";
      case "bottom-right":
        return "top-left";
      case "bottom-left":
        return "top-right";
      case "left":
        return "right";
      case "left-bottom":
        return "right-top";
      case "left-top":
        return "right-bottom";
    }
  }
  setBottomPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.bottom + this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left + sizesAndPositions.target.width / 2 - displacement + "px";
  }
  setElementPosition(position) {
    this.setElementWidth();
    const sizesAndPositions = this.getSizesAndPositions();
    switch (position) {
      case "top":
        this.setTopPositions(sizesAndPositions.element.width / 2, sizesAndPositions);
        break;
      case "top-left":
        this.setTopPositions(sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "top-right":
        this.setTopPositions(this.offsetArrow + this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "right":
        this.setRightPositions(sizesAndPositions.element.height / 2, sizesAndPositions);
        break;
      case "right-top":
        this.setRightPositions(sizesAndPositions.element.height - this.offsetArrow - this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "right-bottom":
        this.setRightPositions(this.offsetArrow, sizesAndPositions);
        break;
      case "bottom":
        this.setBottomPositions(sizesAndPositions.element.width / 2, sizesAndPositions);
        break;
      case "bottom-right":
        this.setBottomPositions(this.offsetArrow + this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "bottom-left":
        this.setBottomPositions(sizesAndPositions.element.width - this.offsetArrow - this.differenceDiagonalToWidthArrow, sizesAndPositions);
        break;
      case "left":
        this.setLeftPositions(sizesAndPositions.element.height / 2, sizesAndPositions);
        break;
      case "left-bottom":
        this.setLeftPositions(this.offsetArrow, sizesAndPositions);
        break;
      case "left-top":
        this.setLeftPositions(sizesAndPositions.element.height - this.offsetArrow, sizesAndPositions);
        break;
    }
    this.arrowDirection = this.setArrowDirection(position);
  }
  setElementWidth() {
    if (this.isSetElementWidth && this.targetElement) {
      this.element.style.width = `${this.targetElement.clientWidth}px`;
    }
  }
  setLeftPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - displacement + sizesAndPositions.target.height / 2 + "px";
    this.element.style.left = sizesAndPositions.target.left - sizesAndPositions.element.width - this.elementOffset + "px";
  }
  setRightPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - displacement + sizesAndPositions.target.height / 2 + "px";
    this.element.style.left = sizesAndPositions.target.right + this.elementOffset + "px";
  }
  setTopPositions(displacement, sizesAndPositions) {
    this.element.style.top = sizesAndPositions.target.top - sizesAndPositions.element.height - this.elementOffset + "px";
    this.element.style.left = sizesAndPositions.target.left + sizesAndPositions.target.width / 2 - displacement + "px";
  }
  verifySubPositions(position) {
    if (position.indexOf("-") > -1) {
      position = position.substring(0, position.indexOf("-"));
      this.elementPosition(position);
    }
    let align = 0;
    while (align++ < 3) {
      if (this.overflowAllSides(position)) {
        position = this.nextPosition(position, poControlPositionSidesDefault);
        this.elementPosition(position);
      } else {
        return null;
      }
    }
  }
  static ɵfac = function PoControlPositionService_Factory(t) {
    return new (t || _PoControlPositionService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoControlPositionService, factory: _PoControlPositionService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoControlPositionService, [{
    type: Injectable
  }], null, null);
})();
var PoTooltipControlPositionService = class _PoTooltipControlPositionService extends PoControlPositionService {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoTooltipControlPositionService_BaseFactory;
    return function PoTooltipControlPositionService_Factory(t) {
      return (ɵPoTooltipControlPositionService_BaseFactory || (ɵPoTooltipControlPositionService_BaseFactory = ɵɵgetInheritedFactory(_PoTooltipControlPositionService)))(t || _PoTooltipControlPositionService);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({ token: _PoTooltipControlPositionService, factory: _PoTooltipControlPositionService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipControlPositionService, [{
    type: Injectable
  }], null, null);
})();
var nativeElements = ["input", "button"];
var PoTooltipDirective = class _PoTooltipDirective extends PoTooltipBaseDirective {
  elementRef;
  renderer;
  poControlPosition;
  arrowDirection;
  divArrow;
  divContent;
  isHidden;
  lastTooltipText;
  textContent;
  tooltipOffset = 8;
  eventListenerFunction;
  constructor(elementRef, renderer, poControlPosition) {
    super();
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.poControlPosition = poControlPosition;
  }
  ngOnDestroy() {
    this.hideTooltip();
  }
  ngOnInit() {
    this.initScrollEventListenerFunction();
  }
  onMouseEnter() {
    if (!this.displayTooltip) {
      this.addTooltipAction();
    }
  }
  onMouseLeave() {
    if (!this.displayTooltip) {
      this.removeTooltipAction();
    }
  }
  onMouseClick() {
    if (!this.displayTooltip) {
      this.removeTooltipAction();
    }
  }
  onFocusOut() {
    if (!this.displayTooltip) {
      this.removeTooltipAction();
    }
  }
  onFocusIn() {
    if (!this.displayTooltip) {
      this.addTooltipAction();
    }
  }
  onKeyDown(event) {
    if (!this.displayTooltip && (event.code === "Escape" || event.keyCode === 27)) {
      this.removeTooltipAction();
    }
  }
  addTooltipAction() {
    setTimeout(() => {
      if (this.tooltip) {
        this.tooltipContent ? this.showTooltip() : this.createTooltip();
        this.removeArrow(this.arrowDirection);
        this.poControlPosition.adjustPosition(this.tooltipPosition);
        this.arrowDirection = this.poControlPosition.getArrowDirection();
        this.addArrow(this.arrowDirection);
        this.lastTooltipText = this.tooltip;
      }
    });
  }
  removeTooltipAction() {
    setTimeout(() => {
      if (this.appendInBody && this.tooltipContent) {
        this.renderer.removeChild(document.body, this.tooltipContent);
        this.tooltipContent = void 0;
      } else {
        this.hideTooltip();
      }
    });
  }
  addArrow(arrowDirection) {
    this.renderer.addClass(this.divArrow, `po-arrow-${arrowDirection}`);
  }
  addScrollEventListener() {
    window.addEventListener("scroll", this.eventListenerFunction, true);
  }
  // Monta a estrutura do tooltip
  createTooltip() {
    this.tooltipContent = this.renderer.createElement("div");
    this.renderer.addClass(this.tooltipContent, "po-tooltip");
    this.renderer.setStyle(this.tooltipContent, "transition", "visibility .3s, opacity .3s linear");
    this.renderer.setStyle(this.tooltipContent, "opacity", 0.9);
    this.insertAriaLabelTooltip();
    this.divArrow = this.renderer.createElement("div");
    this.renderer.addClass(this.divArrow, "po-tooltip-arrow");
    this.divContent = this.renderer.createElement("div");
    this.renderer.addClass(this.divContent, "po-tooltip-content");
    this.textContent = this.renderer.createText(this.tooltip);
    this.renderer.appendChild(this.divContent, this.textContent);
    this.renderer.appendChild(this.tooltipContent, this.divArrow);
    this.renderer.appendChild(this.tooltipContent, this.divContent);
    const parentTarget = this.appendInBody ? document.body : this.elementRef.nativeElement;
    this.renderer.appendChild(parentTarget, this.tooltipContent);
    this.poControlPosition.setElements(this.tooltipContent, this.tooltipOffset, this.elementRef);
    this.addScrollEventListener();
  }
  initScrollEventListenerFunction() {
    this.eventListenerFunction = () => {
      if (!this.isHidden) {
        setTimeout(() => {
          this.poControlPosition.adjustPosition(this.tooltipPosition);
        });
      }
    };
  }
  hideTooltip() {
    if (this.tooltipContent) {
      this.renderer.setStyle(this.tooltipContent, "opacity", 0);
      this.renderer.setStyle(this.tooltipContent, "visibility", "hidden");
      this.isHidden = true;
      this.removeScrollEventListener();
    }
  }
  removeArrow(arrowDirection) {
    if (this.elementRef.nativeElement.querySelector(`.po-arrow-${arrowDirection}`)) {
      this.renderer.removeClass(this.divArrow, `po-arrow-${arrowDirection}`);
    }
  }
  removeScrollEventListener() {
    window.removeEventListener("scroll", this.eventListenerFunction, true);
  }
  showTooltip() {
    this.renderer.setStyle(this.tooltipContent, "opacity", 0.9);
    this.renderer.setStyle(this.tooltipContent, "visibility", "visible");
    this.updateTextContent();
    this.isHidden = false;
    this.addScrollEventListener();
  }
  updateTextContent() {
    const checkRepeatedText = this.tooltip.split("\n");
    if (this.lastTooltipText !== this.tooltip && checkRepeatedText[0] !== this.lastTooltipText) {
      this.renderer.removeChild(this.divContent, this.textContent);
      this.textContent = this.renderer.createText(this.tooltip);
      this.renderer.appendChild(this.divContent, this.textContent);
    }
  }
  insertAriaLabelTooltip() {
    const nativeTextContent = this.elementRef.nativeElement.textContent;
    let targetElement = "";
    nativeElements.forEach((el) => {
      if (this.elementRef.nativeElement.getElementsByTagName(el)[0] !== void 0) {
        targetElement = el;
      }
    });
    if (this.elementRef.nativeElement.getElementsByTagName(targetElement)[0] && this.tooltip) {
      this.renderer.setAttribute(this.elementRef.nativeElement.getElementsByTagName(targetElement)[0], "aria-label", nativeTextContent + " " + this.tooltip);
    }
  }
  static ɵfac = function PoTooltipDirective_Factory(t) {
    return new (t || _PoTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoTooltipControlPositionService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTooltipDirective, selectors: [["", "p-tooltip", ""]], hostBindings: function PoTooltipDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function PoTooltipDirective_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function PoTooltipDirective_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      })("click", function PoTooltipDirective_click_HostBindingHandler() {
        return ctx.onMouseClick();
      })("focusout", function PoTooltipDirective_focusout_HostBindingHandler() {
        return ctx.onFocusOut();
      })("focusin", function PoTooltipDirective_focusin_HostBindingHandler() {
        return ctx.onFocusIn();
      })("keydown", function PoTooltipDirective_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
  }, features: [ɵɵProvidersFeature([PoTooltipControlPositionService]), ɵɵInheritDefinitionFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[p-tooltip]",
      providers: [PoTooltipControlPositionService]
    }]
  }], () => [{ type: ElementRef }, { type: Renderer2 }, { type: PoTooltipControlPositionService }], { onMouseEnter: [{
    type: HostListener,
    args: ["mouseenter"]
  }], onMouseLeave: [{
    type: HostListener,
    args: ["mouseleave"]
  }], onMouseClick: [{
    type: HostListener,
    args: ["click"]
  }], onFocusOut: [{
    type: HostListener,
    args: ["focusout"]
  }], onFocusIn: [{
    type: HostListener,
    args: ["focusin"]
  }], onKeyDown: [{
    type: HostListener,
    args: ["keydown", ["$event"]]
  }] });
})();
var _c0$1H = ["tagContainer"];
var _c1$G = ["tagClose"];
var _c2$k = ["poTag"];
function PoTagComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.tagOrientation ? ctx_r0.label + ":" : ctx_r0.label);
  }
}
var _c3$e = (a0) => ({ "color": a0 });
function PoTagComponent_po_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 14);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-icon", !ctx_r3.type ? ctx_r3.icon : ctx_r3.iconFromType)("ngStyle", !ctx_r3.tagColor && ctx_r3.inverse && !ctx_r3.customTextColor ? ɵɵpureFunction1(2, _c3$e, ctx_r3.customColor) : !ctx_r3.type && ctx_r3.customTextColor ? ɵɵpureFunction1(4, _c3$e, ctx_r3.customTextColor) : "");
  }
}
function PoTagComponent_span_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 15, 16);
    ɵɵlistener("click", function PoTagComponent_span_12_Template_span_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onClose());
    })("keydown.enter", function PoTagComponent_span_12_Template_span_keydown_enter_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.onClose("enter"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", !ctx_r5.disabled);
    ɵɵproperty("p-tooltip", ctx_r5.literals.remove)("tabindex", !ctx_r5.disabled ? 0 : -1);
    ɵɵattribute("aria-label", ctx_r5.setAriaLabel())("role", !ctx_r5.disabled ? "button" : "");
  }
}
var poTagTypeDefault = "po-tag-" + PoTagType.Info;
var PoTagComponent = class _PoTagComponent extends PoTagBaseComponent {
  el;
  tagContainer;
  tagClose;
  poTag;
  isClickable;
  constructor(el, languageService) {
    super(languageService);
    this.el = el;
  }
  ngOnInit() {
    this.isClickable = this.click.observers.length > 0;
  }
  get iconFromType() {
    switch (this.type) {
      case PoTagType.Danger:
        return PoTagIcon.Danger;
      case PoTagType.Info:
        return PoTagIcon.Info;
      case PoTagType.Success:
        return PoTagIcon.Success;
      case PoTagType.Warning:
        return PoTagIcon.Warning;
    }
  }
  get tagColor() {
    if (this.type && !this.removable) {
      return this.inverse ? `po-tag-${this.type}-inverse` : `po-tag-${this.type}`;
    }
    if (this.color && !this.removable) {
      return this.inverse ? `po-text-${this.color}` : `po-${this.color}`;
    }
    if (!this.customColor && !this.removable) {
      return this.inverse ? `${poTagTypeDefault}-inverse` : poTagTypeDefault;
    }
  }
  get tagOrientation() {
    return this.orientation === this.poTagOrientation.Horizontal;
  }
  onClick(event = "click") {
    if (!this.removable && !this.disabled) {
      const submittedTagItem = { value: this.value, type: this.type, event };
      this.click.emit(submittedTagItem);
      if (this.poTag && this.poTag.nativeElement) {
        this.poTag.nativeElement.focus();
      }
    }
  }
  onClose(event = "click") {
    if (!this.disabled) {
      this.onRemove();
      this.remove.emit(event);
    }
  }
  onKeyPressed(event) {
    event.preventDefault();
    event.stopPropagation();
    this.onClick("enter");
  }
  styleTag() {
    if (!this.tagColor && !this.inverse && !this.removable) {
      return { "background-color": this.customColor, "color": "white" };
    } else if (!this.tagColor && this.inverse && !this.customTextColor) {
      return { "border": "1px solid " + this.customColor };
    } else if (!this.tagColor && this.inverse && this.customTextColor) {
      return { "border": "1px solid " + this.customTextColor, "background-color": this.customColor };
    } else {
      return {};
    }
  }
  getWidthTag() {
    return this.tagContainer.nativeElement.offsetWidth > 155;
  }
  setAriaLabel() {
    return this.label ? this.label + " " + this.literals.remove : this.value + " " + this.literals.remove;
  }
  onRemove() {
    if (!this.disabled) {
      this.el.nativeElement.remove();
    }
  }
  static ɵfac = function PoTagComponent_Factory(t) {
    return new (t || _PoTagComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTagComponent, selectors: [["po-tag"]], viewQuery: function PoTagComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1H, 7);
      ɵɵviewQuery(_c1$G, 7);
      ɵɵviewQuery(_c2$k, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagClose = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poTag = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 13, vars: 26, consts: [[1, "po-tag-container"], ["class", "po-tag-title po-text-nowrap", 4, "ngIf"], [1, "po-tag-sub-container"], [1, "po-tag-wrapper", 3, "tabindex", "keydown.enter", "keydown.space", "keyup.space", "click"], ["poTagWrapper", ""], [1, "po-tag", 3, "ngClass", "ngStyle"], ["poTag", ""], ["class", "po-tag-icon", 3, "p-icon", "ngStyle", 4, "ngIf"], ["p-tooltip-position", "top", 1, "po-tag-value", 3, "p-tooltip"], ["tagContainer", ""], [3, "ngStyle"], ["p-tooltip-position", "top", "class", "po-tag-remove po-icon po-icon-close", 3, "p-tooltip", "po-clickable", "tabindex", "click", "keydown.enter", 4, "ngIf"], [1, "po-tag-title", "po-text-nowrap"], [1, "po-tag-label"], [1, "po-tag-icon", 3, "p-icon", "ngStyle"], ["p-tooltip-position", "top", 1, "po-tag-remove", "po-icon", "po-icon-close", 3, "p-tooltip", "tabindex", "click", "keydown.enter"], ["tagClose", ""]], template: function PoTagComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoTagComponent_div_1_Template, 3, 1, "div", 1);
      ɵɵelementStart(2, "div", 2)(3, "div", 3, 4);
      ɵɵlistener("keydown.enter", function PoTagComponent_Template_div_keydown_enter_3_listener($event) {
        return ctx.onKeyPressed($event);
      })("keydown.space", function PoTagComponent_Template_div_keydown_space_3_listener($event) {
        return $event.preventDefault();
      })("keyup.space", function PoTagComponent_Template_div_keyup_space_3_listener($event) {
        return ctx.onKeyPressed($event);
      })("click", function PoTagComponent_Template_div_click_3_listener() {
        return ctx.onClick();
      });
      ɵɵelementStart(5, "div", 5, 6);
      ɵɵtemplate(7, PoTagComponent_po_icon_7_Template, 1, 6, "po-icon", 7);
      ɵɵelementStart(8, "div", 8, 9)(10, "span", 10);
      ɵɵtext(11);
      ɵɵelementEnd()();
      ɵɵtemplate(12, PoTagComponent_span_12_Template, 2, 6, "span", 11);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵclassProp("po-tag-container-horizontal", ctx.tagOrientation);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance(2);
      ɵɵclassProp("po-clickable", ctx.isClickable && !ctx.disabled && !ctx.removable);
      ɵɵproperty("tabindex", ctx.isClickable && !ctx.removable ? 0 : -1);
      ɵɵattribute("role", ctx.isClickable && !ctx.disabled && !ctx.removable ? "button" : "");
      ɵɵadvance(2);
      ɵɵclassProp("po-clickable", ctx.isClickable && !ctx.disabled && !ctx.removable)("po-tag-inverse", ctx.inverse && !ctx.type && !ctx.customTextColor && !ctx.removable)("po-tag-removable", ctx.removable)("po-tag-disabled", ctx.disabled && ctx.removable);
      ɵɵproperty("ngClass", ctx.tagColor)("ngStyle", ctx.styleTag());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon && !ctx.removable);
      ɵɵadvance();
      ɵɵproperty("p-tooltip", ctx.getWidthTag() ? ctx.value : "");
      ɵɵadvance(2);
      ɵɵproperty("ngStyle", !ctx.tagColor && ctx.inverse && !ctx.customTextColor ? ɵɵpureFunction1(22, _c3$e, ctx.customColor) : !ctx.type && ctx.customTextColor && !ctx.removable ? ɵɵpureFunction1(24, _c3$e, ctx.customTextColor) : "");
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.value);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.removable);
    }
  }, dependencies: [NgClass, NgIf, NgStyle, PoIconComponent, PoTooltipDirective], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTagComponent, [{
    type: Component,
    args: [{ selector: "po-tag", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div class="po-tag-container" [class.po-tag-container-horizontal]="tagOrientation">
  <div *ngIf="label" class="po-tag-title po-text-nowrap">
    <span class="po-tag-label">{{ tagOrientation ? label + ':' : label }}</span>
  </div>

  <div class="po-tag-sub-container">
    <div
      #poTagWrapper
      class="po-tag-wrapper"
      [class.po-clickable]="isClickable && !disabled && !removable"
      [attr.role]="isClickable && !disabled && !removable ? 'button' : ''"
      (keydown.enter)="onKeyPressed($event)"
      (keydown.space)="$event.preventDefault()"
      (keyup.space)="onKeyPressed($event)"
      (click)="onClick()"
      [tabindex]="isClickable && !removable ? 0 : -1"
    >
      <div
        #poTag
        class="po-tag"
        [class.po-clickable]="isClickable && !disabled && !removable"
        [class.po-tag-inverse]="inverse && !type && !customTextColor && !removable"
        [class.po-tag-removable]="removable"
        [class.po-tag-disabled]="disabled && removable"
        [ngClass]="tagColor"
        [ngStyle]="styleTag()"
      >
        <po-icon
          *ngIf="icon && !removable"
          class="po-tag-icon"
          [p-icon]="!type ? icon : iconFromType"
          [ngStyle]="
            !tagColor && inverse && !customTextColor
              ? { 'color': customColor }
              : !type && customTextColor
                ? { 'color': customTextColor }
                : ''
          "
        >
        </po-icon>

        <div #tagContainer class="po-tag-value" [p-tooltip]="getWidthTag() ? value : ''" p-tooltip-position="top">
          <span
            [ngStyle]="
              !tagColor && inverse && !customTextColor
                ? { 'color': customColor }
                : !type && customTextColor && !removable
                  ? { 'color': customTextColor }
                  : ''
            "
            >{{ value }}</span
          >
        </div>

        <span
          #tagClose
          *ngIf="removable"
          p-tooltip-position="top"
          [p-tooltip]="literals.remove"
          [attr.aria-label]="setAriaLabel()"
          class="po-tag-remove po-icon po-icon-close"
          [class.po-clickable]="!disabled"
          [tabindex]="!disabled ? 0 : -1"
          [attr.role]="!disabled ? 'button' : ''"
          (click)="onClose()"
          (keydown.enter)="onClose('enter')"
        >
        </span>
      </div>
    </div>
  </div>
</div>
` }]
  }], () => [{ type: ElementRef }, { type: PoLanguageService }], { tagContainer: [{
    type: ViewChild,
    args: ["tagContainer", { static: true }]
  }], tagClose: [{
    type: ViewChild,
    args: ["tagClose", { static: true }]
  }], poTag: [{
    type: ViewChild,
    args: ["poTag", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTagComponent, { className: "PoTagComponent", filePath: "lib/components/po-tag/po-tag.component.ts", lineNumber: 36 });
})();
var PoTooltipModule = class _PoTooltipModule {
  static ɵfac = function PoTooltipModule_Factory(t) {
    return new (t || _PoTooltipModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoTooltipModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoTooltipDirective],
      exports: [PoTooltipDirective]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTooltipModule, { declarations: [PoTooltipDirective], imports: [CommonModule], exports: [PoTooltipDirective] });
})();
var PoTagModule = class _PoTagModule {
  static ɵfac = function PoTagModule_Factory(t) {
    return new (t || _PoTagModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoTagModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoIconModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule, PoTooltipModule],
      declarations: [PoTagComponent],
      exports: [PoTagComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTagModule, { declarations: [PoTagComponent], imports: [CommonModule, PoIconModule, PoTooltipModule], exports: [PoTagComponent] });
})();
function PoAccordionItemBodyComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵprojection(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵproperty("@toggleBody", void 0);
  }
}
var _c0$1G = ["*"];
var PoAccordionItemBodyComponent = class _PoAccordionItemBodyComponent {
  expanded = false;
  static ɵfac = function PoAccordionItemBodyComponent_Factory(t) {
    return new (t || _PoAccordionItemBodyComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoAccordionItemBodyComponent, selectors: [["po-accordion-item-body"]], inputs: { expanded: [InputFlags.None, "p-expanded", "expanded"] }, ngContentSelectors: _c0$1G, decls: 1, vars: 1, consts: [["class", "po-accordion-item-body", 4, "ngIf"], [1, "po-accordion-item-body"], [1, "po-accordion-item-body-content"]], template: function PoAccordionItemBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, PoAccordionItemBodyComponent_div_0_Template, 3, 1, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.expanded);
    }
  }, dependencies: [NgIf], encapsulation: 2, data: { animation: [
    trigger("toggleBody", [
      transition("* => void", [style({ height: "*" }), animate(200, style({ height: 0 }))]),
      transition("void => *", [style({ height: "0" }), animate(200, style({ height: "*" }))])
    ])
  ] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionItemBodyComponent, [{
    type: Component,
    args: [{ selector: "po-accordion-item-body", animations: [
      trigger("toggleBody", [
        transition("* => void", [style({ height: "*" }), animate(200, style({ height: 0 }))]),
        transition("void => *", [style({ height: "0" }), animate(200, style({ height: "*" }))])
      ])
    ], template: '<div class="po-accordion-item-body" *ngIf="expanded" @toggleBody>\n  <div class="po-accordion-item-body-content">\n    <ng-content></ng-content>\n  </div>\n</div>\n' }]
  }], null, { expanded: [{
    type: Input,
    args: ["p-expanded"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionItemBodyComponent, { className: "PoAccordionItemBodyComponent", filePath: "lib/components/po-accordion/po-accordion-item-body/po-accordion-item-body.component.ts", lineNumber: 14 });
})();
var PoLanguageModule = class _PoLanguageModule {
  static ɵfac = function PoLanguageModule_Factory(t) {
    return new (t || _PoLanguageModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoLanguageModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoLanguageService] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLanguageModule, [{
    type: NgModule,
    args: [{
      providers: [PoLanguageService]
    }]
  }], null, null);
})();
var _c0$1F = ["accordionElement"];
function PoAccordionItemHeaderComponent_po_tag_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tag", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-value", ctx_r1.labelTag)("p-type", ctx_r1.typeTag);
  }
}
var PoAccordionItemHeaderComponent = class _PoAccordionItemHeaderComponent {
  language = poLocaleDefault;
  accordionElement;
  expanded = false;
  label;
  labelTag;
  typeTag;
  disabledItem;
  toggle = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  onClick() {
    this.expanded = !this.expanded;
    this.toggle.emit(this.expanded);
  }
  static ɵfac = function PoAccordionItemHeaderComponent_Factory(t) {
    return new (t || _PoAccordionItemHeaderComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoAccordionItemHeaderComponent, selectors: [["po-accordion-item-header"]], viewQuery: function PoAccordionItemHeaderComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1F, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionElement = _t.first);
    }
  }, inputs: { expanded: [InputFlags.None, "p-expanded", "expanded"], label: [InputFlags.None, "p-label", "label"], labelTag: [InputFlags.None, "p-label-tag", "labelTag"], typeTag: [InputFlags.None, "p-type-tag", "typeTag"], disabledItem: [InputFlags.None, "p-disabled", "disabledItem"] }, outputs: { toggle: "p-toggle" }, decls: 8, vars: 5, consts: [[1, "po-accordion-item-header"], [1, "po-accordion-item-header-button", "po-clickable", 3, "disabled", "click"], ["accordionElement", ""], [1, "po-accordion-item-header-button-content"], [1, "po-text-ellipsis", "po-accordion-item-header-title"], ["class", "po-accordion-item-header-tag", 3, "p-value", "p-type", 4, "ngIf"], ["p-icon", "po-icon-arrow-down", 1, "po-icon", "po-accordion-item-header-icon"], [1, "po-accordion-item-header-tag", 3, "p-value", "p-type"]], template: function PoAccordionItemHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "button", 1, 2);
      ɵɵlistener("click", function PoAccordionItemHeaderComponent_Template_button_click_1_listener() {
        return ctx.onClick();
      });
      ɵɵelementStart(3, "div", 3)(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵtemplate(6, PoAccordionItemHeaderComponent_po_tag_6_Template, 1, 2, "po-tag", 5);
      ɵɵelementEnd();
      ɵɵelement(7, "po-icon", 6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabledItem);
      ɵɵattribute("aria-label", ctx.label)("aria-expanded", ctx.expanded || false);
      ɵɵadvance(4);
      ɵɵtextInterpolate(ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.labelTag);
    }
  }, dependencies: [NgIf, PoTagComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionItemHeaderComponent, [{
    type: Component,
    args: [{ selector: "po-accordion-item-header", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-accordion-item-header">\n  <button\n    #accordionElement\n    [disabled]="disabledItem"\n    [attr.aria-label]="label"\n    [attr.aria-expanded]="expanded || false"\n    class="po-accordion-item-header-button po-clickable"\n    (click)="onClick()"\n  >\n    <div class="po-accordion-item-header-button-content">\n      <div class="po-text-ellipsis po-accordion-item-header-title">{{ label }}</div>\n      <po-tag *ngIf="labelTag" class="po-accordion-item-header-tag" [p-value]="labelTag" [p-type]="typeTag"> </po-tag>\n    </div>\n    <po-icon p-icon="po-icon-arrow-down" class="po-icon po-accordion-item-header-icon"></po-icon>\n  </button>\n</div>\n' }]
  }], () => [{ type: PoLanguageService }], { accordionElement: [{
    type: ViewChild,
    args: ["accordionElement", { read: ElementRef, static: true }]
  }], expanded: [{
    type: Input,
    args: ["p-expanded"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], labelTag: [{
    type: Input,
    args: ["p-label-tag"]
  }], typeTag: [{
    type: Input,
    args: ["p-type-tag"]
  }], disabledItem: [{
    type: Input,
    args: ["p-disabled"]
  }], toggle: [{
    type: Output,
    args: ["p-toggle"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionItemHeaderComponent, { className: "PoAccordionItemHeaderComponent", filePath: "lib/components/po-accordion/po-accordion-item-header/po-accordion-item-header.component.ts", lineNumber: 10 });
})();
var PoAccordionService = class _PoAccordionService {
  subjectChild = new Subject();
  // Recebe o accordionItem
  receiveFromChildAccordionClicked() {
    return this.subjectChild.asObservable();
  }
  // Envia accordionItem colapsado/expadido do accordion
  sendToParentAccordionItemClicked(accordionItem) {
    this.subjectChild.next(accordionItem);
  }
  static ɵfac = function PoAccordionService_Factory(t) {
    return new (t || _PoAccordionService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoAccordionService, factory: _PoAccordionService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionService, [{
    type: Injectable
  }], null, null);
})();
function PoAccordionItemComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c0$1E = ["*"];
var PoAccordionItemComponent = class _PoAccordionItemComponent {
  accordionService;
  _type;
  /** Título do item. */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Label da Tag.
   *
   */
  labelTag;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita item.
   *
   * @default `false`
   */
  disabledItem = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o tipo da *tag* caso ela esteja sendo exibida.
   *
   * Valores válidos:
   *  - `success`: cor verde utilizada para simbolizar sucesso ou êxito.
   *  - `warning`: cor amarela que representa aviso ou advertência.
   *  - `danger`: cor vermelha para erro ou aviso crítico.
   *  - `info`: cor cinza escuro que caracteriza conteúdo informativo.
   *
   *
   * @default `info`
   */
  set typeTag(value) {
    this._type = Object.values(PoTagType).includes(value) ? value : void 0;
  }
  get typeTag() {
    return this._type;
  }
  /** Evento disparado ao expandir o item, seja manualmente ou programaticamente. */
  expandEvent = new EventEmitter();
  /** Evento disparado ao retrair o item, seja manualmente ou programaticamente. */
  collapseEvent = new EventEmitter();
  templateRef;
  expanded;
  expandSubscription;
  collapseSubscription;
  constructor(accordionService) {
    this.accordionService = accordionService;
    this.expandSubscription = this.accordionService.receiveFromChildAccordionClicked().pipe(filter((poAccordionItem) => poAccordionItem === this && poAccordionItem.expanded)).subscribe(() => {
      this.expandEvent.emit();
    });
    this.collapseSubscription = this.accordionService.receiveFromChildAccordionClicked().pipe(filter((poAccordionItem) => poAccordionItem === this && !poAccordionItem.expanded)).subscribe(() => {
      this.collapseEvent.emit();
    });
  }
  ngOnDestroy() {
    this.expandSubscription.unsubscribe();
    this.collapseSubscription.unsubscribe();
  }
  /**
   * Método para colapsar o `po-accordion-item`.
   */
  collapse() {
    if (!this.disabledItem) {
      this.expanded = false;
      this.accordionService.sendToParentAccordionItemClicked(this);
    }
  }
  /**
   * Método para expandir o `po-accordion-item`.
   */
  expand() {
    if (!this.disabledItem) {
      this.expanded = true;
      this.accordionService.sendToParentAccordionItemClicked(this);
    }
  }
  static ɵfac = function PoAccordionItemComponent_Factory(t) {
    return new (t || _PoAccordionItemComponent)(ɵɵdirectiveInject(PoAccordionService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoAccordionItemComponent, selectors: [["po-accordion-item"]], viewQuery: function PoAccordionItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  }, inputs: { label: [InputFlags.None, "p-label", "label"], labelTag: [InputFlags.None, "p-label-tag", "labelTag"], disabledItem: [InputFlags.HasDecoratorInputTransform, "p-disabled", "disabledItem", convertToBoolean], typeTag: [InputFlags.None, "p-type-tag", "typeTag"] }, outputs: { expandEvent: "p-expand", collapseEvent: "p-collapse" }, features: [ɵɵInputTransformsFeature], ngContentSelectors: _c0$1E, decls: 1, vars: 0, template: function PoAccordionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, PoAccordionItemComponent_ng_template_0_Template, 1, 0, "ng-template");
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionItemComponent, [{
    type: Component,
    args: [{ selector: "po-accordion-item", template: "<ng-template>\n  <ng-content></ng-content>\n</ng-template>\n" }]
  }], () => [{ type: PoAccordionService }], { label: [{
    type: Input,
    args: ["p-label"]
  }], labelTag: [{
    type: Input,
    args: ["p-label-tag"]
  }], disabledItem: [{
    type: Input,
    args: [{ alias: "p-disabled", transform: convertToBoolean }]
  }], typeTag: [{
    type: Input,
    args: ["p-type-tag"]
  }], expandEvent: [{
    type: Output,
    args: ["p-expand"]
  }], collapseEvent: [{
    type: Output,
    args: ["p-collapse"]
  }], templateRef: [{
    type: ViewChild,
    args: [TemplateRef, { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionItemComponent, { className: "PoAccordionItemComponent", filePath: "lib/components/po-accordion/po-accordion-item/po-accordion-item.component.ts", lineNumber: 43 });
})();
var PoAccordionManagerComponent = class _PoAccordionManagerComponent {
  expandedAllItems = false;
  literals;
  clickManager = new EventEmitter();
  onClick() {
    this.clickManager.emit();
  }
  static ɵfac = function PoAccordionManagerComponent_Factory(t) {
    return new (t || _PoAccordionManagerComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoAccordionManagerComponent, selectors: [["po-accordion-manager"]], inputs: { expandedAllItems: [InputFlags.None, "p-expanded-all-items", "expandedAllItems"], literals: [InputFlags.None, "p-literals", "literals"] }, outputs: { clickManager: "p-click" }, decls: 5, vars: 3, consts: [[1, "po-accordion-manager-header"], [1, "po-accordion-manager-button", "po-clickable", 3, "click"], [1, "po-text-ellipsis", "po-accordion-manager-button-content"], ["p-icon", "po-icon-last-page", 1, "po-icon", "po-accordion-manager-icon", 3, "ngClass"]], template: function PoAccordionManagerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "button", 1);
      ɵɵlistener("click", function PoAccordionManagerComponent_Template_button_click_1_listener() {
        return ctx.onClick();
      });
      ɵɵelementStart(2, "div", 2);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelement(4, "po-icon", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵattribute("aria-expanded", ctx.expandedAllItems);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.expandedAllItems ? ctx.literals.closeAllItems : ctx.literals.expandAllItems, " ");
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.expandedAllItems ? "icon-down" : "icon-up");
    }
  }, dependencies: [NgClass, PoIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionManagerComponent, [{
    type: Component,
    args: [{ selector: "po-accordion-manager", template: `<div class="po-accordion-manager-header">
  <button class="po-accordion-manager-button po-clickable" (click)="onClick()" [attr.aria-expanded]="expandedAllItems">
    <div class="po-text-ellipsis po-accordion-manager-button-content">
      {{ expandedAllItems ? literals.closeAllItems : literals.expandAllItems }}
    </div>
    <po-icon
      p-icon="po-icon-last-page"
      [ngClass]="expandedAllItems ? 'icon-down' : 'icon-up'"
      class="po-icon po-accordion-manager-icon"
    >
    </po-icon>
  </button>
</div>
` }]
  }], null, { expandedAllItems: [{
    type: Input,
    args: ["p-expanded-all-items"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], clickManager: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionManagerComponent, { className: "PoAccordionManagerComponent", filePath: "lib/components/po-accordion/po-accordion-manager/po-accordion-manager.component.ts", lineNumber: 8 });
})();
var poAccordionLiteralsDefault = {
  en: {
    closeAllItems: "Close all items",
    expandAllItems: "Open all items"
  },
  es: {
    closeAllItems: "Cerrar todos los elementos",
    expandAllItems: "Abrir todos los elementos"
  },
  pt: {
    closeAllItems: "Fechar todos os itens",
    expandAllItems: "Abrir todos os itens"
  },
  ru: {
    closeAllItems: "Закрыть все элементы",
    expandAllItems: "Открыть все элементы"
  }
};
var PoAccordionBaseComponent = class _PoAccordionBaseComponent {
  language = poLocaleDefault;
  _literals;
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-accordion`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoAccordionLiterals = {
   *    closeAllItems: 'Fechar todos os itens',
   *    expandAllItems: 'Expandir todos os itens'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoAccordionLiterals = {
   *    expandAllItems: 'Expandir todos os itens'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-accordion
   *   [p-literals]="customLiterals">
   * </po-accordion>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poAccordionLiteralsDefault[poLocaleDefault]), poAccordionLiteralsDefault[this.language]), value);
    } else {
      this._literals = poAccordionLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poAccordionLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Exibe o Gerenciador de Accordion.
   *
   * @default `false`
   */
  showManagerAccordion = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite expandir mais de um `<po-accordion-item></po-accordion-item>` ao mesmo tempo.
   * Sempre habilitada caso a propriedade `p-show-manager-accordion` esteja como `true`.
   *
   * @default `false`
   */
  allowExpandItems = false;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao expandir o gerenciador de accordion, seja manualmente ou programaticamente.
   *
   */
  expandAllEvent = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao retrair o gerenciador de accordion, seja manualmente ou programaticamente.
   *
   */
  collapseAllEvent = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoAccordionBaseComponent_Factory(t) {
    return new (t || _PoAccordionBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoAccordionBaseComponent, inputs: { literals: [InputFlags.None, "p-literals", "literals"], showManagerAccordion: [InputFlags.HasDecoratorInputTransform, "p-show-manager-accordion", "showManagerAccordion", convertToBoolean], allowExpandItems: [InputFlags.HasDecoratorInputTransform, "p-allow-expand-all-items", "allowExpandItems", convertToBoolean] }, outputs: { expandAllEvent: "p-expand-all", collapseAllEvent: "p-collapse-all" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { literals: [{
    type: Input,
    args: ["p-literals"]
  }], showManagerAccordion: [{
    type: Input,
    args: [{ alias: "p-show-manager-accordion", transform: convertToBoolean }]
  }], allowExpandItems: [{
    type: Input,
    args: [{ alias: "p-allow-expand-all-items", transform: convertToBoolean }]
  }], expandAllEvent: [{
    type: Output,
    args: ["p-expand-all"]
  }], collapseAllEvent: [{
    type: Output,
    args: ["p-collapse-all"]
  }] });
})();
function PoAccordionComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "po-accordion-manager", 4);
    ɵɵlistener("p-click", function PoAccordionComponent_div_1_Template_po_accordion_manager_p_click_1_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.changeVisibleAllItems(ctx_r2.expandedAllItems));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-expanded-all-items", ctx_r0.expandedAllItems)("p-literals", ctx_r0.literals);
  }
}
function PoAccordionComponent_li_3_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoAccordionComponent_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 5)(1, "po-accordion-item-header", 6);
    ɵɵlistener("p-toggle", function PoAccordionComponent_li_3_Template_po_accordion_item_header_p_toggle_1_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r7);
      const poAccordionItem_r4 = restoredCtx.$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.headerToggle($event, poAccordionItem_r4));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "po-accordion-item-body", 7);
    ɵɵtemplate(3, PoAccordionComponent_li_3_ng_container_3_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const poAccordionItem_r4 = ctx.$implicit;
    ɵɵclassProp("po-accordion-item-active", poAccordionItem_r4.expanded);
    ɵɵadvance();
    ɵɵproperty("p-disabled", poAccordionItem_r4.disabledItem)("p-expanded", poAccordionItem_r4.expanded)("p-label", poAccordionItem_r4.label)("p-label-tag", poAccordionItem_r4.labelTag)("p-type-tag", poAccordionItem_r4.typeTag);
    ɵɵadvance();
    ɵɵproperty("p-expanded", poAccordionItem_r4.expanded);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", poAccordionItem_r4.templateRef);
  }
}
var PoAccordionComponent = class _PoAccordionComponent extends PoAccordionBaseComponent {
  accordionService;
  accordionsHeader;
  poAccordionItems;
  expandedAllItems = false;
  accordionServiceSubscription;
  expandedActiveAccordionItem;
  constructor(accordionService, languageService) {
    super(languageService);
    this.accordionService = accordionService;
    this.receiveFromChildAccordionSubscription();
  }
  ngOnDestroy() {
    this.accordionServiceSubscription.unsubscribe();
  }
  changeVisibleAllItems(event) {
    this.expandedAllItems = !event;
    this.poAccordionItems.forEach((item) => {
      if (!item.disabledItem) {
        item.expanded = this.expandedAllItems;
        this.toggle(item, false);
      }
    });
    if (this.expandedAllItems) {
      this.expandAllEvent.emit();
    } else {
      this.collapseAllEvent.emit();
    }
  }
  /**
   * Método para colapsar todos os itens.
   * Só pode ser utilizado quando a propriedade `p-show-manager-accordion` estiver como `true`.
   */
  collapseAllItems() {
    if (this.showManagerAccordion) {
      this.changeVisibleAllItems(true);
    }
  }
  /**
   * Método para expandir todos os itens.
   * Só pode ser utilizado quando a propriedade `p-show-manager-accordion` estiver como `true`.
   */
  expandAllItems() {
    if (this.showManagerAccordion) {
      this.changeVisibleAllItems(false);
    }
  }
  headerToggle(event, poAccordionItem) {
    poAccordionItem.expanded = event;
    this.accordionService.sendToParentAccordionItemClicked(poAccordionItem);
  }
  checkVisibleAllItems(event) {
    if (this.showManagerAccordion) {
      const accordionList = this.poAccordionItems.toArray();
      const accordionsValids = accordionList.filter((item) => !item.disabledItem);
      const allItemsExpanded = accordionsValids.every((item) => item.expanded === true);
      if (allItemsExpanded) {
        this.expandedAllItems = event;
      } else {
        this.expandedAllItems = false;
      }
    }
  }
  receiveFromChildAccordionSubscription() {
    this.accordionServiceSubscription = this.accordionService.receiveFromChildAccordionClicked().subscribe((poAccordionItem) => this.toggle(poAccordionItem));
  }
  toggle(poAccordionItem, checkAllItems = true) {
    const isCurrentAccordionCollapsed = !poAccordionItem.expanded;
    if (checkAllItems) {
      this.checkVisibleAllItems(poAccordionItem.expanded);
    }
    if (isCurrentAccordionCollapsed) {
      this.expandedActiveAccordionItem = null;
      return;
    }
    if (!this.showManagerAccordion && !this.allowExpandItems && this.expandedActiveAccordionItem) {
      this.expandedActiveAccordionItem.collapse();
    }
    this.expandedActiveAccordionItem = poAccordionItem;
  }
  static ɵfac = function PoAccordionComponent_Factory(t) {
    return new (t || _PoAccordionComponent)(ɵɵdirectiveInject(PoAccordionService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoAccordionComponent, selectors: [["po-accordion"]], contentQueries: function PoAccordionComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoAccordionItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poAccordionItems = _t);
    }
  }, viewQuery: function PoAccordionComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoAccordionItemHeaderComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionsHeader = _t);
    }
  }, features: [ɵɵProvidersFeature([PoAccordionService]), ɵɵInheritDefinitionFeature], decls: 4, vars: 2, consts: [[1, "po-accordion"], ["class", "po-accordion-manager", 4, "ngIf"], ["class", "po-accordion-item", 3, "po-accordion-item-active", 4, "ngFor", "ngForOf"], [1, "po-accordion-manager"], [3, "p-expanded-all-items", "p-literals", "p-click"], [1, "po-accordion-item"], [3, "p-disabled", "p-expanded", "p-label", "p-label-tag", "p-type-tag", "p-toggle"], [3, "p-expanded"], [4, "ngTemplateOutlet"]], template: function PoAccordionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoAccordionComponent_div_1_Template, 2, 2, "div", 1);
      ɵɵelementStart(2, "ul");
      ɵɵtemplate(3, PoAccordionComponent_li_3_Template, 4, 9, "li", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showManagerAccordion && ctx.poAccordionItems.length > 1);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.poAccordionItems);
    }
  }, dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoAccordionItemBodyComponent, PoAccordionItemHeaderComponent, PoAccordionManagerComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionComponent, [{
    type: Component,
    args: [{ selector: "po-accordion", providers: [PoAccordionService], template: '<div class="po-accordion">\n  <div *ngIf="showManagerAccordion && poAccordionItems.length > 1" class="po-accordion-manager">\n    <po-accordion-manager\n      [p-expanded-all-items]="expandedAllItems"\n      [p-literals]="literals"\n      (p-click)="changeVisibleAllItems(expandedAllItems)"\n    ></po-accordion-manager>\n  </div>\n  <ul>\n    <li\n      *ngFor="let poAccordionItem of poAccordionItems"\n      class="po-accordion-item"\n      [class.po-accordion-item-active]="poAccordionItem.expanded"\n    >\n      <po-accordion-item-header\n        [p-disabled]="poAccordionItem.disabledItem"\n        [p-expanded]="poAccordionItem.expanded"\n        [p-label]="poAccordionItem.label"\n        [p-label-tag]="poAccordionItem.labelTag"\n        [p-type-tag]="poAccordionItem.typeTag"\n        (p-toggle)="headerToggle($event, poAccordionItem)"\n      >\n      </po-accordion-item-header>\n\n      <po-accordion-item-body [p-expanded]="poAccordionItem.expanded">\n        <ng-container *ngTemplateOutlet="poAccordionItem.templateRef"></ng-container>\n      </po-accordion-item-body>\n    </li>\n  </ul>\n</div>\n' }]
  }], () => [{ type: PoAccordionService }, { type: PoLanguageService }], { accordionsHeader: [{
    type: ViewChildren,
    args: [PoAccordionItemHeaderComponent]
  }], poAccordionItems: [{
    type: ContentChildren,
    args: [PoAccordionItemComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAccordionComponent, { className: "PoAccordionComponent", filePath: "lib/components/po-accordion/po-accordion.component.ts", lineNumber: 38 });
})();
var PoAccordionModule = class _PoAccordionModule {
  static ɵfac = function PoAccordionModule_Factory(t) {
    return new (t || _PoAccordionModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoAccordionModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoTagModule, PoIconModule, PoDividerModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTagModule, PoIconModule, PoDividerModule],
      declarations: [
        PoAccordionComponent,
        PoAccordionItemBodyComponent,
        PoAccordionItemComponent,
        PoAccordionItemHeaderComponent,
        PoAccordionManagerComponent
      ],
      exports: [PoAccordionComponent, PoAccordionItemComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoAccordionModule, { declarations: [
    PoAccordionComponent,
    PoAccordionItemBodyComponent,
    PoAccordionItemComponent,
    PoAccordionItemHeaderComponent,
    PoAccordionManagerComponent
  ], imports: [CommonModule, PoTagModule, PoIconModule, PoDividerModule], exports: [PoAccordionComponent, PoAccordionItemComponent] });
})();
var PO_AVATAR_SIZES = ["xs", "sm", "md", "lg", "xl"];
var PO_AVATAR_SIZE_DEFAULT = "md";
var PoAvatarBaseComponent = class _PoAvatarBaseComponent {
  /**
   * Fonte da imagem que pode ser um caminho local (`./assets/images/logo-black-small.png`)
   * ou um servidor externo (`https://po-ui.io/assets/images/logo-black-small.png`).
   */
  src;
  /**
   * @optional
   *
   * @description
   *
   * Indica como o navegador deve carregar a imagem.
   *
   * Valores válidos:
   *  - `eager` (a imagem é carregada imediatamente, independente de estar visível ou não)
   *  - `lazy` (a imagem só é carregada quando estiver próxima de ser renderizada)
   *
   * @default `eager`
   */
  loading = "eager";
  /** Evento disparado ao clicar na imagem do *avatar*. */
  click = new EventEmitter();
  _size = "md";
  /**
   * @optional
   *
   * @description
   *
   * Tamanho de exibição do componente.
   *
   * Valores válidos:
   *  - `xs` (24x24)
   *  - `sm` (32x32)
   *  - `md` (64x64)
   *  - `lg` (96x96)
   *  - `xl` (144x144)
   *
   * @default `md`
   */
  set size(value) {
    this._size = PO_AVATAR_SIZES.includes(value) ? value : PO_AVATAR_SIZE_DEFAULT;
  }
  get size() {
    return this._size;
  }
  get hasClickEvent() {
    return !!this.click.observers.length;
  }
  static ɵfac = function PoAvatarBaseComponent_Factory(t) {
    return new (t || _PoAvatarBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoAvatarBaseComponent, inputs: { src: [InputFlags.None, "p-src", "src"], loading: [InputFlags.None, "p-loading", "loading"], size: [InputFlags.None, "p-size", "size"] }, outputs: { click: "p-click" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAvatarBaseComponent, [{
    type: Directive
  }], null, { src: [{
    type: Input,
    args: ["p-src"]
  }], loading: [{
    type: Input,
    args: ["p-loading"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
function PoAvatarComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoAvatarComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "img", 4);
    ɵɵlistener("error", function PoAvatarComponent_ng_template_2_Template_img_error_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onError());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("src", ctx_r1.src, ɵɵsanitizeUrl);
    ɵɵattribute("loading", ctx_r1.loading);
  }
}
function PoAvatarComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
  }
}
var PoAvatarComponent = class _PoAvatarComponent extends PoAvatarBaseComponent {
  ngOnInit() {
    if (!this.src) {
      this.src = void 0;
    }
  }
  onError() {
    this.src = void 0;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoAvatarComponent_BaseFactory;
    return function PoAvatarComponent_Factory(t) {
      return (ɵPoAvatarComponent_BaseFactory || (ɵPoAvatarComponent_BaseFactory = ɵɵgetInheritedFactory(_PoAvatarComponent)))(t || _PoAvatarComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoAvatarComponent, selectors: [["po-avatar"]], features: [ɵɵInheritDefinitionFeature], decls: 6, vars: 8, consts: [[3, "click"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["sourceImage", ""], ["defaultIcon", ""], ["alt", "", 1, "po-avatar-image", 3, "src", "error"], [1, "po-icon", "po-icon-user", "po-avatar-default-icon"]], template: function PoAvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoAvatarComponent_Template_div_click_0_listener() {
        return ctx.click.emit();
      });
      ɵɵtemplate(1, PoAvatarComponent_ng_container_1_Template, 1, 0, "ng-container", 1);
      ɵɵelementEnd();
      ɵɵtemplate(2, PoAvatarComponent_ng_template_2_Template, 1, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor)(4, PoAvatarComponent_ng_template_4_Template, 1, 0, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(3);
      const _r4 = ɵɵreference(5);
      ɵɵclassMapInterpolate1("po-avatar po-avatar-", ctx.size, "");
      ɵɵclassProp("po-clickable", ctx.hasClickEvent);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.src)("ngIfThen", _r2)("ngIfElse", _r4);
    }
  }, dependencies: [NgIf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAvatarComponent, [{
    type: Component,
    args: [{ selector: "po-avatar", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-avatar po-avatar-{{ size }}" [class.po-clickable]="hasClickEvent" (click)="click.emit()">\n  <ng-container *ngIf="src; then sourceImage; else defaultIcon"></ng-container>\n</div>\n\n<ng-template #sourceImage>\n  <img class="po-avatar-image" [src]="src" alt="" [attr.loading]="loading" (error)="onError()" />\n</ng-template>\n\n<ng-template #defaultIcon>\n  <span class="po-icon po-icon-user po-avatar-default-icon"></span>\n</ng-template>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoAvatarComponent, { className: "PoAvatarComponent", filePath: "lib/components/po-avatar/po-avatar.component.ts", lineNumber: 32 });
})();
var PoAvatarModule = class _PoAvatarModule {
  static ɵfac = function PoAvatarModule_Factory(t) {
    return new (t || _PoAvatarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoAvatarModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoAvatarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoAvatarComponent],
      exports: [PoAvatarComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoAvatarModule, { declarations: [PoAvatarComponent], imports: [CommonModule], exports: [PoAvatarComponent] });
})();
var PoBreadcrumbBaseComponent = class _PoBreadcrumbBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Permite definir uma URL no componente `po-breadcrumb` para favoritar ou desfavoritar.
   * > Para utilizar esta propriedade, o último `PoBreadcrumbItem` da lista de items da propriedade `p-items` deve ter um link informado.
   *
   * > A API deve estar preparada para retornar um objeto no formato `{ isFavorite: boolean }`.
   *
   * Ao iniciar, o `po-breadcrumb` faz um GET na URL definida na propriedade `p-favorite-service` e deve retornar a propriedade
   * `{ isFavorite: boolean }` do último `PoBreadcrumbItem` definido na lista de itens da propriedade `p-items`.
   *
   * Ao clicar em favoritar ou desfavoritar o `po-breadcrumb` faz um POST com o link e a propriedade `{ isFavorite: boolean }`
   * definidos no último item da propriedade `p-items`.
   *
   * > Caso algum parâmetro seja definido na propriedade `p-params-service`, o mesmo será enviado para a API e retornará
   * após fazer um GET ou POST.
   *
   * Exemplo de URL contendo o serviço de favoritar ou desfavoritar:
   *
   * ```
   * https://po-ui.io/sample/api/favorite
   * ```
   *
   * Ao fazer o GET o `po-breadcrumb` concatena o link com a URL de serviço. Exemplo:
   *
   * ```
   * GET http://<domain>/api/favorite?url=/example
   * ```
   *
   * ```
   * GET http://po.com.br/sample/api/favorite?url=/example
   * ```
   *
   * ```
   * POST
   * payload: { isFavorite: true, url: '/example' }
   * ```
   *
   * Caso possua parâmetros definidos na propriedade `p-params-service`:
   *
   * ```
   * POST
   * payload: { isFavorite: true, url: "/example", params: "{ id: 14, user: 'dev.po' }" }
   * ```
   *
   * Exemplos de retorno:
   *
   * ```
   * { isFavorite: true, url: "/example" }
   * ```
   *
   * ```
   * { isFavorite: false, url: "/example" }
   * ```
   *
   * ```
   * { isFavorite: false, url: "/example", params: "{ id: 14, user: 'dev.po' }" }
   * ```
   */
  favoriteService;
  /**
   * @optional
   *
   * @description
   *
   * Objeto que possibilita o envio de parâmetros adicionais à requisição.
   */
  paramsService;
  itemsView = [];
  itemsViewPopup = [];
  clickoutListener;
  resizeListener;
  _items = [];
  /**
   * @description
   *
   * Lista de itens do _breadcrumb_.
   *
   * **Exemplo:**
   * ```
   * { label: 'Po Portal', link: 'portal' }
   * ```
   */
  set items(items) {
    this._items = items;
    this.itemsView = [].concat(items);
    if (this.itemsView.length >= 4) {
      this.transformToArrayPopup(items);
    }
  }
  get items() {
    return this._items;
  }
  transformToArrayPopup(items) {
    const itemsCopy = items.map((obj) => __spreadValues({}, obj));
    itemsCopy.shift();
    itemsCopy.splice(-2, 1);
    itemsCopy.pop();
    this.itemsViewPopup = this.transformArrayToActionPopUp(itemsCopy);
  }
  transformArrayToActionPopUp(items) {
    return items.map((obj) => {
      if (obj.hasOwnProperty("link")) {
        obj["url"] = obj.link;
        delete obj.link;
        if (obj.hasOwnProperty("action")) {
          delete obj.action;
        }
      }
      return obj;
    });
  }
  static ɵfac = function PoBreadcrumbBaseComponent_Factory(t) {
    return new (t || _PoBreadcrumbBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoBreadcrumbBaseComponent, inputs: { favoriteService: [InputFlags.None, "p-favorite-service", "favoriteService"], paramsService: [InputFlags.None, "p-params-service", "paramsService"], items: [InputFlags.None, "p-items", "items"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbBaseComponent, [{
    type: Directive
  }], null, { favoriteService: [{
    type: Input,
    args: ["p-favorite-service"]
  }], paramsService: [{
    type: Input,
    args: ["p-params-service"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }] });
})();
var PoLinkBaseComponent = class _PoLinkBaseComponent {
  /** Valor do rótulo a ser exibido. */
  label;
  /** Indica se o link deverá ser aberto em uma nova aba. Sempre que utilizar essa propriedade, é importante informar isso ao usuário através da label. */
  openNewTab = false;
  /** Url que será aberta ao clicar no link. */
  url;
  get type() {
    if (!this.url && this.action.observed) {
      return "action";
    }
    return isExternalLink(this.url) ? "externalLink" : "internalLink";
  }
  /** Ação que será executada quando o usuário clicar sobre o `po-link`.
   * > Ao utilizar junto da propriedade `p-url` a ação será ignorada.
   */
  action = new EventEmitter();
  static ɵfac = function PoLinkBaseComponent_Factory(t) {
    return new (t || _PoLinkBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoLinkBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], openNewTab: [InputFlags.HasDecoratorInputTransform, "p-open-new-tab", "openNewTab", convertToBoolean], url: [InputFlags.None, "p-url", "url"] }, outputs: { action: "p-action" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLinkBaseComponent, [{
    type: Directive
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], openNewTab: [{
    type: Input,
    args: [{ alias: "p-open-new-tab", transform: convertToBoolean }]
  }], url: [{
    type: Input,
    args: ["p-url"]
  }], action: [{
    type: Output,
    args: ["p-action"]
  }] });
})();
function PoLinkComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function PoLinkComponent_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onClick());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function PoLinkComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r1.url, ɵɵsanitizeUrl)("target", ctx_r1.openNewTab ? "_blank" : "_self");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
function PoLinkComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("routerLink", ctx_r2.url);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.label);
  }
}
function PoLinkComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r3.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.label);
  }
}
var PoLinkComponent = class _PoLinkComponent extends PoLinkBaseComponent {
  onClick() {
    if (this.url) {
      return;
    } else {
      this.action.emit(null);
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoLinkComponent_BaseFactory;
    return function PoLinkComponent_Factory(t) {
      return (ɵPoLinkComponent_BaseFactory || (ɵPoLinkComponent_BaseFactory = ɵɵgetInheritedFactory(_PoLinkComponent)))(t || _PoLinkComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoLinkComponent, selectors: [["po-link"]], features: [ɵɵInheritDefinitionFeature], decls: 5, vars: 4, consts: [[3, "ngSwitch"], ["class", "po-link", "type", "button", 3, "click", 4, "ngSwitchCase"], ["class", "po-link", 3, "href", "target", 4, "ngSwitchCase"], ["class", "po-link", 3, "routerLink", 4, "ngSwitchCase"], ["class", "po-link", 3, "href", 4, "ngSwitchDefault"], ["type", "button", 1, "po-link", 3, "click"], [1, "po-link", 3, "href", "target"], [1, "po-link", 3, "routerLink"], [1, "po-link", 3, "href"]], template: function PoLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 0);
      ɵɵtemplate(1, PoLinkComponent_button_1_Template, 2, 1, "button", 1)(2, PoLinkComponent_a_2_Template, 2, 3, "a", 2)(3, PoLinkComponent_a_3_Template, 2, 2, "a", 3)(4, PoLinkComponent_a_4_Template, 2, 2, "a", 4);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngSwitch", ctx.type);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "action");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "externalLink");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "internalLink");
    }
  }, dependencies: [NgSwitch, NgSwitchCase, NgSwitchDefault, RouterLink], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLinkComponent, [{
    type: Component,
    args: [{ selector: "po-link", template: `<ng-container [ngSwitch]="type">
  <button *ngSwitchCase="'action'" class="po-link" type="button" (click)="onClick()">{{ label }}</button>

  <a *ngSwitchCase="'externalLink'" class="po-link" [href]="url" [target]="openNewTab ? '_blank' : '_self'">{{
    label
  }}</a>

  <a *ngSwitchCase="'internalLink'" class="po-link" [routerLink]="url">{{ label }}</a>

  <a *ngSwitchDefault class="po-link" [href]="url">{{ label }}</a>
</ng-container>
` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLinkComponent, { className: "PoLinkComponent", filePath: "lib/components/po-link/po-link.component.ts", lineNumber: 29 });
})();
var poPopupDefaultPosition = "bottom-left";
var PoPopupBaseComponent = class _PoPopupBaseComponent {
  arrowDirection = "top-right";
  showPopup = false;
  oldTarget;
  param;
  clickoutListener;
  resizeListener;
  _actions;
  _customPositions;
  _hideArrow = false;
  _isCornerAlign = false;
  _position = poPopupDefaultPosition;
  _target;
  /** Lista de ações que serão exibidas no componente. */
  set actions(value) {
    this._actions = Array.isArray(value) ? value : [];
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta a seta do componente *popup*.
   *
   * @default `false`
   */
  set hideArrow(value) {
    this._hideArrow = convertToBoolean(value);
  }
  get hideArrow() {
    return this._hideArrow;
  }
  // Define se o `po-popup` será alinhado pelos cantos do elemento target.
  set isCornerAlign(value) {
    this._isCornerAlign = convertToBoolean(value);
  }
  get isCornerAlign() {
    return this._isCornerAlign;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a posição inicial que o `po-popup` abrirá em relação ao componente alvo. Sugere-se que seja
   * usada a orientação `bottom-left` (abaixo e a esquerda), porém o mesmo é flexível e será rotacionado
   * automaticamente para se adequar a tela, caso necessário.
   *
   * > Caso seja definido um `p-custom-positions` o componente irá abrir na posição definida na propriedade `p-position`
   * e caso não caiba na posição inicial ele irá rotacionar seguindo a ordem de posições definidas no `p-custom-positions`.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-popup no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-popup no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-popup no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-popup abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-popup abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-popup abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-popup no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-popup no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-popup no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-popup acima do componente alvo.
   * - `top-right`: Posiciona o po-popup acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-popup acima e à esquerda do componente alvo.
   *
   * @default `bottom-left`
   */
  set position(value) {
    this._position = PO_CONTROL_POSITIONS.includes(value) ? value : poPopupDefaultPosition;
  }
  get position() {
    return this._position;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define as posições e a sequência que o `po-popup` poderá rotacionar. A sequência será definida pela ordem passada
   * no *array*. Caso não seja definido, o `po-popup` irá rotacionar em todas as posições válidas.
   *
   * > O componente sempre irá abrir na posição definida no `p-position` e caso não caiba na posição definida o mesmo
   * irá rotacionar seguindo a ordem definida pelo `p-custom-position`.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-popup no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-popup no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-popup no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-popup abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-popup abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-popup abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-popup no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-popup no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-popup no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-popup acima do componente alvo.
   * - `top-right`: Posiciona o po-popup acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-popup acima e à esquerda do componente alvo.
   */
  set customPositions(value) {
    this._customPositions = Array.isArray(value) ? value : [];
  }
  get customPositions() {
    return this._customPositions;
  }
  /**
   * @description
   *
   * Para utilizar o `po-popup` deve-se colocar uma variável local no componente que disparará o evento
   * de abertura no mesmo e com isso, invocará a função `toggle`, por exemplo:
   *
   * ```
   * <span #icon class="po-icon po-icon-credit-payment" (click)="popup.toggle()">
   *   Credit Actions
   * </span>
   *
   * <po-popup #popup
   *   [p-actions]="actions"
   *   [p-target]="icon">
   * </po-popup>
   * ```
   *
   * Caso o elemento alvo for um componente, será preciso obter o `ElementRef` do mesmo e passá-lo à propriedade, por exemplo:
   *
   * ```
   * // component.html
   *
   * <po-button #poButton
   *   p-label="Open Popover"
   *   (p-click)="popup.toggle()">
   * </po-button>
   *
   * <po-popup #popup
   *   [p-actions]="actions"
   *   [p-target]="poButtonRef">
   * </po-popup>
   *
   * // component.ts
   *
   * @ViewChild('poButton', { read: ElementRef }) poButtonRef: ElementRef;
   * ```
   */
  set target(value) {
    this._target = value instanceof ElementRef ? value.nativeElement : value;
  }
  get target() {
    return this._target;
  }
  closeEvent = new EventEmitter();
  static ɵfac = function PoPopupBaseComponent_Factory(t) {
    return new (t || _PoPopupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPopupBaseComponent, inputs: { actions: [InputFlags.None, "p-actions", "actions"], hideArrow: [InputFlags.None, "p-hide-arrow", "hideArrow"], isCornerAlign: [InputFlags.None, "p-is-corner-align", "isCornerAlign"], position: [InputFlags.None, "p-position", "position"], customPositions: [InputFlags.None, "p-custom-positions", "customPositions"], target: [InputFlags.None, "p-target", "target"] }, outputs: { closeEvent: "p-close" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopupBaseComponent, [{
    type: Directive
  }], null, { actions: [{
    type: Input,
    args: ["p-actions"]
  }], hideArrow: [{
    type: Input,
    args: ["p-hide-arrow"]
  }], isCornerAlign: [{
    type: Input,
    args: ["p-is-corner-align"]
  }], position: [{
    type: Input,
    args: ["p-position"]
  }], customPositions: [{
    type: Input,
    args: ["p-custom-positions"]
  }], target: [{
    type: Input,
    args: ["p-target"]
  }], closeEvent: [{
    type: Output,
    args: ["p-close"]
  }] });
})();
var PoItemListType;
(function(PoItemListType2) {
  PoItemListType2["action"] = "action";
  PoItemListType2["check"] = "check";
  PoItemListType2["option"] = "option";
  PoItemListType2["danger"] = "danger";
})(PoItemListType || (PoItemListType = {}));
var PoItemListFilterMode;
(function(PoItemListFilterMode2) {
  PoItemListFilterMode2[PoItemListFilterMode2["startsWith"] = 0] = "startsWith";
  PoItemListFilterMode2[PoItemListFilterMode2["contains"] = 1] = "contains";
  PoItemListFilterMode2[PoItemListFilterMode2["endsWith"] = 2] = "endsWith";
})(PoItemListFilterMode || (PoItemListFilterMode = {}));
var poListBoxLiteralsDefault = {
  en: {
    noItems: "No items found"
  },
  es: {
    noItems: "No se encontraron artículos"
  },
  pt: {
    noItems: "Nenhum item encontrado"
  },
  ru: {
    noItems: "ничего не найдено"
  }
};
var PoListBoxBaseComponent = class _PoListBoxBaseComponent {
  _items = [];
  _type;
  _literals;
  language = poLocaleDefault;
  visible = false;
  set type(value) {
    this._type = PoItemListType[value] ?? "action";
  }
  get type() {
    return this._type;
  }
  set items(items) {
    this._items = Array.isArray(items) ? items : [];
  }
  get items() {
    return this._items;
  }
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poListBoxLiteralsDefault[poLocaleDefault]), poListBoxLiteralsDefault[this.language]), value);
    } else {
      this._literals = poListBoxLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poListBoxLiteralsDefault[this.language];
  }
  get isItemListGroup() {
    return this.items.length && this.items[0].hasOwnProperty("options");
  }
  isTabs = false;
  // parâmetro que pode ser passado para o popup ao clicar em um item
  param;
  selectItem = new EventEmitter();
  closeEvent = new EventEmitter();
  // MULTISELECT PROPERTIES
  //output para evento do checkbox
  change = new EventEmitter();
  //output para evento do checkbox
  selectCombo = new EventEmitter();
  //output para evento do checkbox de selecionar todos
  changeAll = new EventEmitter();
  UpdateInfiniteScroll = new EventEmitter();
  //valor do checkbox de selecionar todos
  checkboxAllValue;
  // Propriedade que recebe a lista de opções selecionadas.
  selectedOptions = [];
  // Propriedade que recebe um item selecionado.
  selectedOption;
  fieldValue = "value";
  fieldLabel = "label";
  // Evento disparado a cada tecla digitada na pesquisa.
  changeSearch = new EventEmitter();
  // Propriedade que recebe as literais definidas no componente `po-multiselect`.
  literalSearch;
  // Propriedade que recebe o valor de comparação de pesquisa
  fieldValueSearch = "value";
  // Propriedade que indica se o campo de pesquisa deverá ser escondido.
  hideSearch = false;
  // Propriedade que indica se o campo "Selecionar todos" deverá ser escondido.
  hideSelectAll = false;
  //Propriedades relacionados ao template customizado do multiselect
  multiselectTemplate;
  template;
  placeholderSearch;
  searchValue;
  isServerSearching = false;
  infiniteLoading = false;
  infiniteScroll = false;
  cache = false;
  infiniteScrollDistance = 100;
  filterMode = PoItemListFilterMode.contains;
  isFiltering = false;
  shouldMarkLetters = true;
  compareCache = false;
  comboService;
  // Evento disparado quando uma tab é ativada
  activatedTab = new EventEmitter();
  // Evento disparado no click de uma aba do tabs
  clickTab = new EventEmitter();
  changeStateTabs = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoListBoxBaseComponent_Factory(t) {
    return new (t || _PoListBoxBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoListBoxBaseComponent, inputs: { visible: [InputFlags.HasDecoratorInputTransform, "p-visible", "visible", convertToBoolean], type: [InputFlags.None, "p-type", "type"], items: [InputFlags.None, "p-items", "items"], literals: [InputFlags.None, "p-literals", "literals"], isTabs: [InputFlags.HasDecoratorInputTransform, "p-is-tabs", "isTabs", convertToBoolean], param: [InputFlags.None, "p-param", "param"], checkboxAllValue: [InputFlags.None, "p-checkboxAllValue", "checkboxAllValue"], selectedOptions: [InputFlags.None, "p-selected-options", "selectedOptions"], selectedOption: [InputFlags.None, "p-selected-option", "selectedOption"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], literalSearch: [InputFlags.None, "p-literal-search", "literalSearch"], fieldValueSearch: [InputFlags.None, "p-field-value-search", "fieldValueSearch"], hideSearch: [InputFlags.None, "p-hide-search", "hideSearch"], hideSelectAll: [InputFlags.None, "p-hide-select-all", "hideSelectAll"], multiselectTemplate: [InputFlags.None, "p-multiselect-template", "multiselectTemplate"], template: [InputFlags.None, "p-template", "template"], placeholderSearch: [InputFlags.None, "p-placeholder-search", "placeholderSearch"], searchValue: [InputFlags.None, "p-search-value", "searchValue"], isServerSearching: [InputFlags.HasDecoratorInputTransform, "p-is-searching", "isServerSearching", convertToBoolean], infiniteLoading: [InputFlags.HasDecoratorInputTransform, "p-infinite-loading", "infiniteLoading", convertToBoolean], infiniteScroll: [InputFlags.HasDecoratorInputTransform, "p-infinite-scroll", "infiniteScroll", convertToBoolean], cache: [InputFlags.HasDecoratorInputTransform, "p-cache", "cache", convertToBoolean], infiniteScrollDistance: [InputFlags.None, "p-infinite-scroll-distance", "infiniteScrollDistance"], filterMode: [InputFlags.None, "p-filter-mode", "filterMode"], isFiltering: [InputFlags.None, "p-filtering", "isFiltering"], shouldMarkLetters: [InputFlags.None, "p-should-mark-letter", "shouldMarkLetters"], compareCache: [InputFlags.None, "p-compare-cache", "compareCache"], comboService: [InputFlags.None, "p-combo-service", "comboService"] }, outputs: { selectItem: "p-select-item", closeEvent: "p-close", change: "p-change", selectCombo: "p-selectcombo-item", changeAll: "p-change-all", UpdateInfiniteScroll: "p-update-infinite-scroll", changeSearch: "p-change-search", activatedTab: "p-activated-tabs", clickTab: "p-click-tabs", changeStateTabs: "p-change-state-tabs" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListBoxBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { visible: [{
    type: Input,
    args: [{ alias: "p-visible", transform: convertToBoolean }]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], isTabs: [{
    type: Input,
    args: [{ alias: "p-is-tabs", transform: convertToBoolean }]
  }], param: [{
    type: Input,
    args: ["p-param"]
  }], selectItem: [{
    type: Output,
    args: ["p-select-item"]
  }], closeEvent: [{
    type: Output,
    args: ["p-close"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], selectCombo: [{
    type: Output,
    args: ["p-selectcombo-item"]
  }], changeAll: [{
    type: Output,
    args: ["p-change-all"]
  }], UpdateInfiniteScroll: [{
    type: Output,
    args: ["p-update-infinite-scroll"]
  }], checkboxAllValue: [{
    type: Input,
    args: ["p-checkboxAllValue"]
  }], selectedOptions: [{
    type: Input,
    args: ["p-selected-options"]
  }], selectedOption: [{
    type: Input,
    args: ["p-selected-option"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], changeSearch: [{
    type: Output,
    args: ["p-change-search"]
  }], literalSearch: [{
    type: Input,
    args: ["p-literal-search"]
  }], fieldValueSearch: [{
    type: Input,
    args: ["p-field-value-search"]
  }], hideSearch: [{
    type: Input,
    args: ["p-hide-search"]
  }], hideSelectAll: [{
    type: Input,
    args: ["p-hide-select-all"]
  }], multiselectTemplate: [{
    type: Input,
    args: ["p-multiselect-template"]
  }], template: [{
    type: Input,
    args: ["p-template"]
  }], placeholderSearch: [{
    type: Input,
    args: ["p-placeholder-search"]
  }], searchValue: [{
    type: Input,
    args: ["p-search-value"]
  }], isServerSearching: [{
    type: Input,
    args: [{ alias: "p-is-searching", transform: convertToBoolean }]
  }], infiniteLoading: [{
    type: Input,
    args: [{ alias: "p-infinite-loading", transform: convertToBoolean }]
  }], infiniteScroll: [{
    type: Input,
    args: [{ alias: "p-infinite-scroll", transform: convertToBoolean }]
  }], cache: [{
    type: Input,
    args: [{ alias: "p-cache", transform: convertToBoolean }]
  }], infiniteScrollDistance: [{
    type: Input,
    args: ["p-infinite-scroll-distance"]
  }], filterMode: [{
    type: Input,
    args: ["p-filter-mode"]
  }], isFiltering: [{
    type: Input,
    args: ["p-filtering"]
  }], shouldMarkLetters: [{
    type: Input,
    args: ["p-should-mark-letter"]
  }], compareCache: [{
    type: Input,
    args: ["p-compare-cache"]
  }], comboService: [{
    type: Input,
    args: ["p-combo-service"]
  }], activatedTab: [{
    type: Output,
    args: ["p-activated-tabs"]
  }], clickTab: [{
    type: Output,
    args: ["p-click-tabs"]
  }], changeStateTabs: [{
    type: Output,
    args: ["p-change-state-tabs"]
  }] });
})();
var poLoadingOverlayLiteralsDefault = {
  en: {
    loading: "Loading"
  },
  es: {
    loading: "Cargando"
  },
  pt: {
    loading: "Carregando"
  },
  ru: {
    loading: "Загрузка"
  }
};
var PoLoadingOverlayBaseComponent = class _PoLoadingOverlayBaseComponent {
  languageService;
  _screenLock = false;
  _text;
  _size;
  /**
   * @optional
   *
   * @description
   *
   * Define se o *overlay* será aplicado a um *container* ou a página inteira.
   *
   * Para utilizar o componente como um *container*, o elemento pai deverá receber uma posição relativa, por exemplo:
   *
   * ```
   * <div style="position: relative">
   *
   *  <po-chart [p-series]="[{ value: 10, category: 'Example' }]">
   *  </po-chart>
   *
   *  <po-loading-overlay>
   *  </po-loading-overlay>
   * </div>
   * ```
   *
   * @default `false`
   */
  set screenLock(screenLock2) {
    this._screenLock = convertToBoolean(screenLock2);
  }
  get screenLock() {
    return this._screenLock;
  }
  /**
   * @optional
   *
   * @description
   *
   * Texto a ser exibido no componente.
   *
   * > O valor padrão será traduzido acordo com o idioma configurado no [**PoI18n**](/documentation/po-i18n) ou navegador.
   *
   * @default `Carregando`
   */
  set text(value) {
    this._text = value || this.getTextDefault();
  }
  get text() {
    return this._text;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tamnho do componente.
   *
   * @default `lg`
   */
  set size(value) {
    this._size = value === "" || !value ? "lg" : value;
  }
  get size() {
    return this._size;
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.text = this.getTextDefault();
  }
  getTextDefault() {
    const language = this.languageService.getShortLanguage();
    return poLoadingOverlayLiteralsDefault[language].loading;
  }
  static ɵfac = function PoLoadingOverlayBaseComponent_Factory(t) {
    return new (t || _PoLoadingOverlayBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoLoadingOverlayBaseComponent, inputs: { screenLock: [InputFlags.None, "p-screen-lock", "screenLock"], text: [InputFlags.None, "p-text", "text"], size: [InputFlags.None, "p-size", "size"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingOverlayBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { screenLock: [{
    type: Input,
    args: ["p-screen-lock"]
  }], text: [{
    type: Input,
    args: ["p-text"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
var PoOverlayBaseComponent = class _PoOverlayBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define se o *overlay* será aplicado a um *container* ou a página inteira.
   *
   * Para utilizar o componente como um *container*, o elemento pai deverá receber uma posição relativa, por exemplo:
   *
   * ```
   * <div style="position: relative">
   *
   *  <po-chart [p-series]="[{ value: 10, category: 'Example' }]">
   *  </po-chart>
   *
   *  <po-overlay>
   *  </po-overlay>
   * </div>
   * ```
   *
   * @default `false`
   */
  screenLock = false;
  static ɵfac = function PoOverlayBaseComponent_Factory(t) {
    return new (t || _PoOverlayBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoOverlayBaseComponent, inputs: { screenLock: [InputFlags.HasDecoratorInputTransform, "p-screen-lock", "screenLock", convertToBoolean] }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoOverlayBaseComponent, [{
    type: Directive
  }], null, { screenLock: [{
    type: Input,
    args: [{ alias: "p-screen-lock", transform: convertToBoolean }]
  }] });
})();
var _c0$1D = ["*"];
var PoOverlayComponent = class _PoOverlayComponent extends PoOverlayBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoOverlayComponent_BaseFactory;
    return function PoOverlayComponent_Factory(t) {
      return (ɵPoOverlayComponent_BaseFactory || (ɵPoOverlayComponent_BaseFactory = ɵɵgetInheritedFactory(_PoOverlayComponent)))(t || _PoOverlayComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoOverlayComponent, selectors: [["po-overlay"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$1D, decls: 3, vars: 2, consts: [["role", "alert", "aria-busy", "true", 1, "po-overlay"], [1, "po-overlay-content"]], template: function PoOverlayComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵclassProp("po-overlay-fixed", ctx.screenLock);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoOverlayComponent, [{
    type: Component,
    args: [{ selector: "po-overlay", template: '<div class="po-overlay" [class.po-overlay-fixed]="screenLock" role="alert" aria-busy="true">\n  <div class="po-overlay-content">\n    <ng-content></ng-content>\n  </div>\n</div>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoOverlayComponent, { className: "PoOverlayComponent", filePath: "lib/components/po-overlay/po-overlay.component.ts", lineNumber: 8 });
})();
var PoLoadingIconSize;
(function(PoLoadingIconSize2) {
  PoLoadingIconSize2["xs"] = "xs";
  PoLoadingIconSize2["sm"] = "sm";
  PoLoadingIconSize2["md"] = "md";
  PoLoadingIconSize2["lg"] = "lg";
})(PoLoadingIconSize || (PoLoadingIconSize = {}));
var poLoadingLiteralsDefault = {
  en: {
    loading: "Loading"
  },
  es: {
    loading: "Cargando"
  },
  pt: {
    loading: "Carregando"
  },
  ru: {
    loading: "Загрузка"
  }
};
var PoLoadingBaseComponent = class _PoLoadingBaseComponent {
  languageService;
  _text;
  _size;
  /**
   * Texto a ser exibido no componente.
   */
  set text(value) {
    this._text = value || (value === "" ? "" : this.getTextDefault());
  }
  get text() {
    return this._text;
  }
  /**
   * Define o tamanho do ícone.
   *
   * @default `lg`
   *
   * Valores válidos:
   *  - `xs`: tamanho `extra small`
   *  - `sm`: tamanho `small`
   *  - `md`: tamanho `medium`
   *  - `lg`: tamanho `large`
   */
  set size(value) {
    this._size = PoLoadingIconSize[value] ? PoLoadingIconSize[value] : PoLoadingIconSize.lg;
  }
  get size() {
    return this._size;
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.text = this.getTextDefault();
  }
  getTextDefault() {
    const language = this.languageService.getShortLanguage();
    return poLoadingLiteralsDefault[language].loading;
  }
  static ɵfac = function PoLoadingBaseComponent_Factory(t) {
    return new (t || _PoLoadingBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoLoadingBaseComponent, inputs: { text: [InputFlags.None, "p-text", "text"], size: [InputFlags.None, "p-size", "size"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { text: [{
    type: Input,
    args: ["p-text"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
var PoLoadingIconComponent = class _PoLoadingIconComponent {
  _neutralColor;
  _size = "md";
  id = uuid();
  /**
   * @optional
   *
   * @description
   *
   * Definição para cor neutra (cinza) para o ícone de carregamento.
   *
   * @default `false`
   */
  set neutralColor(value) {
    this._neutralColor = convertToBoolean(value);
  }
  get neutralColor() {
    return this._neutralColor;
  }
  /**
   * @optional
   *
   * @description
   *
   * Definição do tamanho do ícone.
   *
   * Valores válidos:
   *  - `xs`: tamanho `extra small`
   *  - `sm`: tamanho `small`
   *  - `md`: tamanho `medium`
   *  - `lg`: tamanho `large`
   *
   * @default `md`
   */
  set size(value) {
    this._size = PoLoadingIconSize[value] ? PoLoadingIconSize[value] : PoLoadingIconSize.md;
  }
  get size() {
    return this._size;
  }
  static ɵfac = function PoLoadingIconComponent_Factory(t) {
    return new (t || _PoLoadingIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLoadingIconComponent, selectors: [["po-loading-icon"]], inputs: { neutralColor: [InputFlags.None, "p-neutral-color", "neutralColor"], size: [InputFlags.None, "p-size", "size"] }, decls: 14, vars: 8, consts: [["viewBox", "0 0 200 200", "fill", "none", "xmlns", "http://www.w3.org/2000/svg", 3, "ngClass"], [3, "id"], ["offset", "0", "stop-opacity", "0", "stop-color", "currentColor"], ["offset", "1", "stop-opacity", "0.5", "stop-color", "currentColor"], ["offset", "0", "stop-opacity", "1", "stop-color", "currentColor"], ["stroke-width", "24", "transform", "matrix(0.876218, 0, 0, 0.87855, 12.377892, 12.144993)"], ["d", "M 4 100 A 96 96 0 0 1 196 100"], ["d", "M 196 100 A 96 96 0 0 1 4 100"], ["stroke", "currentColor", "d", "M 4 100 A 96 96 0 0 1 4 98"], ["from", "0 0 0", "to", "360 0 0", "attributeName", "transform", "type", "rotate", "repeatCount", "indefinite", "dur", "1200ms"]], template: function PoLoadingIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div");
      ɵɵnamespaceSVG();
      ɵɵelementStart(1, "svg", 0)(2, "defs")(3, "linearGradient", 1);
      ɵɵelement(4, "stop", 2)(5, "stop", 3);
      ɵɵelementEnd();
      ɵɵelementStart(6, "linearGradient", 1);
      ɵɵelement(7, "stop", 4)(8, "stop", 3);
      ɵɵelementEnd()();
      ɵɵelementStart(9, "g", 5);
      ɵɵelement(10, "path", 6)(11, "path", 7)(12, "path", 8);
      ɵɵelementEnd();
      ɵɵelement(13, "animateTransform", 9);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("po-loading-icon-container po-loading-svg-", ctx.size, "");
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.neutralColor ? "po-loading-icon-neutral" : "po-loading-icon");
      ɵɵadvance(2);
      ɵɵproperty("id", "first" + ctx.id);
      ɵɵadvance(3);
      ɵɵproperty("id", "second" + ctx.id);
      ɵɵadvance(4);
      ɵɵattribute("stroke", "url(#second" + ctx.id + ")");
      ɵɵadvance();
      ɵɵattribute("stroke", "url(#first" + ctx.id + ")");
    }
  }, dependencies: [NgClass], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingIconComponent, [{
    type: Component,
    args: [{ selector: "po-loading-icon", template: `<div class="po-loading-icon-container po-loading-svg-{{ size }}">
  <svg
    [ngClass]="neutralColor ? 'po-loading-icon-neutral' : 'po-loading-icon'"
    viewBox="0 0 200 200"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <defs>
      <linearGradient [id]="'first' + id">
        <stop offset="0" stop-opacity="0" stop-color="currentColor" />
        <stop offset="1" stop-opacity="0.5" stop-color="currentColor" />
      </linearGradient>
      <linearGradient [id]="'second' + id">
        <stop offset="0" stop-opacity="1" stop-color="currentColor" />
        <stop offset="1" stop-opacity="0.5" stop-color="currentColor" />
      </linearGradient>
    </defs>
    <g stroke-width="24" transform="matrix(0.876218, 0, 0, 0.87855, 12.377892, 12.144993)">
      <path [attr.stroke]="'url(#' + 'second' + id + ')'" d="M 4 100 A 96 96 0 0 1 196 100" />
      <path [attr.stroke]="'url(#' + 'first' + id + ')'" d="M 196 100 A 96 96 0 0 1 4 100" />
      <path stroke="currentColor" d="M 4 100 A 96 96 0 0 1 4 98" />
    </g>

    <animateTransform
      from="0 0 0"
      to="360 0 0"
      attributeName="transform"
      type="rotate"
      repeatCount="indefinite"
      dur="1200ms"
    />
  </svg>
</div>
` }]
  }], null, { neutralColor: [{
    type: Input,
    args: ["p-neutral-color"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoadingIconComponent, { className: "PoLoadingIconComponent", filePath: "lib/components/po-loading/po-loading-icon/po-loading-icon.component.ts", lineNumber: 18 });
})();
function PoLoadingComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementStart(2, "div", 3);
    ɵɵtext(3, ".");
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 3);
    ɵɵtext(5, ".");
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 3);
    ɵɵtext(7, ".");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.text, " ");
  }
}
var PoLoadingComponent = class _PoLoadingComponent extends PoLoadingBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoLoadingComponent_BaseFactory;
    return function PoLoadingComponent_Factory(t) {
      return (ɵPoLoadingComponent_BaseFactory || (ɵPoLoadingComponent_BaseFactory = ɵɵgetInheritedFactory(_PoLoadingComponent)))(t || _PoLoadingComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoLoadingComponent, selectors: [["po-loading"]], features: [ɵɵInheritDefinitionFeature], decls: 3, vars: 5, consts: [[3, "p-size"], ["class", "po-loading-label po-text-ellipsis", 4, "ngIf"], [1, "po-loading-label", "po-text-ellipsis"], ["aria-hidden", "true", 1, "po-loading-dot"]], template: function PoLoadingComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div");
      ɵɵelement(1, "po-loading-icon", 0);
      ɵɵtemplate(2, PoLoadingComponent_span_2_Template, 8, 1, "span", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("po-loading po-loading-", ctx.size, "");
      ɵɵadvance();
      ɵɵproperty("p-size", ctx.size);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.text);
    }
  }, dependencies: [NgIf, PoLoadingIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingComponent, [{
    type: Component,
    args: [{ selector: "po-loading", template: '<div class="po-loading po-loading-{{ size }}">\n  <po-loading-icon [p-size]="size"></po-loading-icon>\n\n  <span *ngIf="text" class="po-loading-label po-text-ellipsis"\n    >{{ text }}\n    <div class="po-loading-dot" aria-hidden="true">.</div>\n    <div class="po-loading-dot" aria-hidden="true">.</div>\n    <div class="po-loading-dot" aria-hidden="true">.</div>\n  </span>\n</div>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoadingComponent, { className: "PoLoadingComponent", filePath: "lib/components/po-loading/po-loading.component.ts", lineNumber: 14 });
})();
var PoLoadingOverlayComponent = class _PoLoadingOverlayComponent extends PoLoadingOverlayBaseComponent {
  changeDetector;
  constructor(changeDetector, languageService) {
    super(languageService);
    this.changeDetector = changeDetector;
  }
  static ɵfac = function PoLoadingOverlayComponent_Factory(t) {
    return new (t || _PoLoadingOverlayComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLoadingOverlayComponent, selectors: [["po-loading-overlay"]], features: [ɵɵInheritDefinitionFeature], decls: 2, vars: 3, consts: [[3, "p-screen-lock"], [3, "p-text", "p-size"]], template: function PoLoadingOverlayComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-overlay", 0);
      ɵɵelement(1, "po-loading", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-screen-lock", ctx.screenLock);
      ɵɵadvance();
      ɵɵproperty("p-text", ctx.text)("p-size", ctx.size);
    }
  }, dependencies: [PoOverlayComponent, PoLoadingComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingOverlayComponent, [{
    type: Component,
    args: [{ selector: "po-loading-overlay", template: '<po-overlay [p-screen-lock]="screenLock">\n  <po-loading [p-text]="text" [p-size]="size"></po-loading>\n</po-overlay>\n' }]
  }], () => [{ type: ChangeDetectorRef }, { type: PoLanguageService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoadingOverlayComponent, { className: "PoLoadingOverlayComponent", filePath: "lib/components/po-loading/po-loading-overlay/po-loading-overlay.component.ts", lineNumber: 32 });
})();
var PoItemListBaseComponent = class _PoItemListBaseComponent {
  _label;
  _value;
  _type;
  _visible = true;
  _disabled = false;
  _activeTabs = false;
  set type(value) {
    this._type = PoItemListType[value] ?? "action";
  }
  get type() {
    return this._type;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o estado como visível.
   *
   * @default `true`
   */
  set visible(value) {
    if (value === true || value === null || value === void 0) {
      this._visible = true;
    } else {
      this._visible = false;
    }
  }
  get visible() {
    return this._visible;
  }
  item;
  /** Texto de exibição do item. */
  label;
  /** Valor do item. */
  value;
  danger = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o estado como desabilitado.
   *
   * @default `false`
   */
  set disabled(value) {
    if (value === false || value === null || value === void 0) {
      this._disabled = false;
    } else {
      this._disabled = true;
    }
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se a ação está selecionada.
   *
   * @default `false`
   */
  selected = false;
  /**
   * @optional
   *
   * @description
   *
   * Atribui uma linha separadora acima do item.
   *
   * @default `false`
   */
  separator = false;
  /**
   * @optional
   *
   * @description
   *
   * Define um ícone que será exibido ao lado esquerdo do rótulo.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Ação a ser realizada ao clicar no item do tipo `option`.
   */
  clickItem = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação a ser realizada ao selecionar no item do type `check`.
   */
  selectItem = new EventEmitter();
  // MULTISELECT PROPERTIES
  //emissao de evento do checkbox
  checkboxItem = new EventEmitter();
  comboItem = new EventEmitter();
  //valor do checkbox de selecionar todos
  checkboxValue;
  fieldValue = "value";
  fieldLabel = "label";
  template;
  templateContext;
  searchValue = "";
  filterMode = PoItemListFilterMode.contains;
  isFiltering = false;
  shouldMarkLetters = true;
  compareCache = false;
  comboService;
  // TABS PROPERTIES
  isTabs = false;
  tabHide = false;
  tabsItem = new EventEmitter();
  activatedTab = new EventEmitter();
  // Ativa o botão
  set activeTabs(value) {
    this._activeTabs = value;
    this.emitActiveTabs(this.item);
  }
  get activeTabs() {
    return this._activeTabs;
  }
  emitActiveTabs(tab) {
    if (tab?.active) {
      this.activatedTab.emit(tab);
    }
  }
  static ɵfac = function PoItemListBaseComponent_Factory(t) {
    return new (t || _PoItemListBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoItemListBaseComponent, hostVars: 1, hostBindings: function PoItemListBaseComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("p-type", ctx.type);
    }
  }, inputs: { type: [InputFlags.None, "p-type", "type"], visible: [InputFlags.None, "p-visible", "visible"], item: [InputFlags.None, "p-item", "item"], label: [InputFlags.None, "p-label", "label"], value: [InputFlags.None, "p-value", "value"], danger: [InputFlags.HasDecoratorInputTransform, "p-danger", "danger", convertToBoolean], disabled: [InputFlags.None, "p-disabled", "disabled"], selected: [InputFlags.HasDecoratorInputTransform, "p-selected", "selected", convertToBoolean], separator: [InputFlags.HasDecoratorInputTransform, "p-separator", "separator", convertToBoolean], icon: [InputFlags.None, "p-icon", "icon"], checkboxValue: [InputFlags.None, "p-checkbox-value", "checkboxValue"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], template: [InputFlags.None, "p-template", "template"], templateContext: [InputFlags.None, "p-template-context", "templateContext"], searchValue: [InputFlags.None, "p-search-value", "searchValue"], filterMode: [InputFlags.None, "p-filter-mode", "filterMode"], isFiltering: [InputFlags.None, "p-filtering", "isFiltering"], shouldMarkLetters: [InputFlags.None, "p-should-mark-letter", "shouldMarkLetters"], compareCache: [InputFlags.None, "p-compare-cache", "compareCache"], comboService: [InputFlags.None, "p-combo-service", "comboService"], isTabs: [InputFlags.None, "p-is-tabs", "isTabs"], tabHide: [InputFlags.None, "p-tab-hide", "tabHide"], activeTabs: [InputFlags.None, "p-active-tabs", "activeTabs"] }, outputs: { clickItem: "p-click-item", selectItem: "p-select-item", checkboxItem: "p-selectcheckbox-item", comboItem: "p-selectcombo-item", tabsItem: "p-emit-item-tabs", activatedTab: "p-activated-tabs" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoItemListBaseComponent, [{
    type: Directive
  }], null, { type: [{
    type: HostBinding,
    args: ["attr.p-type"]
  }, {
    type: Input,
    args: ["p-type"]
  }], visible: [{
    type: Input,
    args: ["p-visible"]
  }], item: [{
    type: Input,
    args: ["p-item"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], danger: [{
    type: Input,
    args: [{ alias: "p-danger", transform: convertToBoolean }]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], selected: [{
    type: Input,
    args: [{ alias: "p-selected", transform: convertToBoolean }]
  }], separator: [{
    type: Input,
    args: [{ alias: "p-separator", transform: convertToBoolean }]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], clickItem: [{
    type: Output,
    args: ["p-click-item"]
  }], selectItem: [{
    type: Output,
    args: ["p-select-item"]
  }], checkboxItem: [{
    type: Output,
    args: ["p-selectcheckbox-item"]
  }], comboItem: [{
    type: Output,
    args: ["p-selectcombo-item"]
  }], checkboxValue: [{
    type: Input,
    args: ["p-checkbox-value"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], template: [{
    type: Input,
    args: ["p-template"]
  }], templateContext: [{
    type: Input,
    args: ["p-template-context"]
  }], searchValue: [{
    type: Input,
    args: ["p-search-value"]
  }], filterMode: [{
    type: Input,
    args: ["p-filter-mode"]
  }], isFiltering: [{
    type: Input,
    args: ["p-filtering"]
  }], shouldMarkLetters: [{
    type: Input,
    args: ["p-should-mark-letter"]
  }], compareCache: [{
    type: Input,
    args: ["p-compare-cache"]
  }], comboService: [{
    type: Input,
    args: ["p-combo-service"]
  }], isTabs: [{
    type: Input,
    args: ["p-is-tabs"]
  }], tabHide: [{
    type: Input,
    args: ["p-tab-hide"]
  }], tabsItem: [{
    type: Output,
    args: ["p-emit-item-tabs"]
  }], activatedTab: [{
    type: Output,
    args: ["p-activated-tabs"]
  }], activeTabs: [{
    type: Input,
    args: ["p-active-tabs"]
  }] });
})();
var PoKeyCodeEnum;
(function(PoKeyCodeEnum2) {
  PoKeyCodeEnum2[PoKeyCodeEnum2["arrowDown"] = 40] = "arrowDown";
  PoKeyCodeEnum2[PoKeyCodeEnum2["arrowUp"] = 38] = "arrowUp";
  PoKeyCodeEnum2[PoKeyCodeEnum2["backspace"] = 8] = "backspace";
  PoKeyCodeEnum2[PoKeyCodeEnum2["delete"] = 46] = "delete";
  PoKeyCodeEnum2[PoKeyCodeEnum2["enter"] = 13] = "enter";
  PoKeyCodeEnum2[PoKeyCodeEnum2["esc"] = 27] = "esc";
  PoKeyCodeEnum2[PoKeyCodeEnum2["keyK"] = 75] = "keyK";
  PoKeyCodeEnum2[PoKeyCodeEnum2["keyL"] = 76] = "keyL";
  PoKeyCodeEnum2[PoKeyCodeEnum2["space"] = 32] = "space";
  PoKeyCodeEnum2[PoKeyCodeEnum2["tab"] = 9] = "tab";
  PoKeyCodeEnum2[PoKeyCodeEnum2["left"] = 37] = "left";
  PoKeyCodeEnum2[PoKeyCodeEnum2["right"] = 39] = "right";
})(PoKeyCodeEnum || (PoKeyCodeEnum = {}));
var PoCheckboxSize;
(function(PoCheckboxSize2) {
  PoCheckboxSize2["medium"] = "medium";
  PoCheckboxSize2["large"] = "large";
})(PoCheckboxSize || (PoCheckboxSize = {}));
var PoCheckboxBaseComponent = class _PoCheckboxBaseComponent {
  /** Define o nome do *checkbox*. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Texto de exibição do *checkbox*. */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado quando o valor do *checkbox* for alterado.
   */
  change = new EventEmitter();
  //propriedade interna recebida do checkbox-group para verificar se o checkbox está ativo, inativo ou indeterminate
  checkboxValue;
  //propriedade interna recebida do checkbox-group para verificar se o checkbox é required
  checkBoxRequired;
  //propriedade interna recebida para desabilitar o tabindex do checkbox na utilização dentro de um list-box
  disabladTabindex = false;
  id = uuid();
  propagateChange;
  onTouched;
  _disabled = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o estado do *checkbox* como desabilitado.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  _size = PoCheckboxSize.medium;
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do *checkbox*
   *
   * Valores válidos:
   * - `medium`: o `po-checkbox` fica do tamanho padrão, com 24px de altura.;
   * - `large`: o `po-checkbox` fica maior, com 32px de altura.;
   *
   * @default `medium`
   *
   */
  set size(value) {
    this._size = PoCheckboxSize[value] ? PoCheckboxSize[value] : PoCheckboxSize.medium;
  }
  get size() {
    return this._size;
  }
  changeValue() {
    if (this.propagateChange) {
      this.propagateChange(this.checkboxValue);
    }
    this.change.emit(this.checkboxValue);
  }
  checkOption(value) {
    if (!this.disabled) {
      value === "mixed" ? this.changeModelValue(true) : this.changeModelValue(!value);
      this.changeValue();
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    if (value !== this.checkboxValue) {
      this.changeModelValue(value);
    }
  }
  static ɵfac = function PoCheckboxBaseComponent_Factory(t) {
    return new (t || _PoCheckboxBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoCheckboxBaseComponent, inputs: { name: "name", autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], label: [InputFlags.None, "p-label", "label"], checkboxValue: [InputFlags.None, "p-checkboxValue", "checkboxValue"], checkBoxRequired: [InputFlags.HasDecoratorInputTransform, "p-required", "checkBoxRequired", convertToBoolean], disabladTabindex: [InputFlags.HasDecoratorInputTransform, "p-disabled-tabindex", "disabladTabindex", convertToBoolean], disabled: [InputFlags.None, "p-disabled", "disabled"], size: [InputFlags.None, "p-size", "size"] }, outputs: { change: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxBaseComponent, [{
    type: Directive
  }], null, { name: [{
    type: Input,
    args: ["name"]
  }], autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], checkboxValue: [{
    type: Input,
    args: ["p-checkboxValue"]
  }], checkBoxRequired: [{
    type: Input,
    args: [{ alias: "p-required", transform: convertToBoolean }]
  }], disabladTabindex: [{
    type: Input,
    args: [{ alias: "p-disabled-tabindex", transform: convertToBoolean }]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
function PoLabelComponent_label_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-label-disabled", ctx_r0.disabled);
    ɵɵattribute("for", ctx_r0.field && ctx_r0.for ? ctx_r0.for : void 0)("p-field", ctx_r0.field);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function PoLabelComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.requirement);
  }
}
var PoLabelComponent = class _PoLabelComponent {
  _disabled = false;
  _field = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o label está desativado.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = value === "" ? true : convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica se o label será de um field.
   *
   * @default `false`
   */
  set field(value) {
    this._field = value === "" ? true : convertToBoolean(value);
  }
  get field() {
    return this._field;
  }
  /** Indica o campo vinculado ao label */
  for;
  /** Label do campo. */
  label;
  /** Indica o tipo do campo vinculado ao label */
  requirement;
  static ɵfac = function PoLabelComponent_Factory(t) {
    return new (t || _PoLabelComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLabelComponent, selectors: [["po-label"]], inputs: { disabled: [InputFlags.None, "p-disabled", "disabled"], field: [InputFlags.None, "p-field", "field"], for: [InputFlags.None, "p-for", "for"], label: [InputFlags.None, "p-label", "label"], requirement: [InputFlags.None, "p-requirement", "requirement"] }, decls: 2, vars: 2, consts: [["class", "po-label", 3, "po-label-disabled", 4, "ngIf"], ["class", "po-label-requirement", 4, "ngIf"], [1, "po-label"], [1, "po-label-requirement"]], template: function PoLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoLabelComponent_label_0_Template, 2, 5, "label", 0)(1, PoLabelComponent_span_1_Template, 2, 1, "span", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.field && ctx.requirement);
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLabelComponent, [{
    type: Component,
    args: [{ selector: "po-label", template: '<label\n  *ngIf="label"\n  class="po-label"\n  [attr.for]="field && for ? for : undefined"\n  [attr.p-field]="field"\n  [class.po-label-disabled]="disabled"\n  >{{ label }}</label\n>\n<span *ngIf="field && requirement" class="po-label-requirement">{{ requirement }}</span>\n' }]
  }], null, { disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], field: [{
    type: Input,
    args: ["p-field"]
  }], for: [{
    type: Input,
    args: ["p-for"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], requirement: [{
    type: Input,
    args: ["p-requirement"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLabelComponent, { className: "PoLabelComponent", filePath: "lib/components/po-label/po-label.component.ts", lineNumber: 14 });
})();
var _c0$1C = ["checkboxLabel"];
function PoCheckboxComponent_po_label_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-label", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r1.disabled)("p-for", ctx_r1.id)("p-label", ctx_r1.label);
  }
}
var PoCheckboxComponent = class _PoCheckboxComponent extends PoCheckboxBaseComponent {
  changeDetector;
  checkboxLabel;
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  /**
   * Função que atribui foco ao *checkbox*.
   *
   * Para utilizá-la é necessário capturar a referência do componente no DOM através do `ViewChild`, como por exemplo:
   *
   * ```
   * ...
   * import { ViewChild } from '@angular/core';
   * import { PoCheckboxComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoCheckboxComponent, { static: true }) checkbox: PoCheckboxComponent;
   *
   * focusCheckbox() {
   *   this.checkbox.focus();
   * }
   * ```
   */
  focus() {
    if (this.checkboxLabel && !this.disabled) {
      this.checkboxLabel.nativeElement.focus();
    }
  }
  onBlur() {
    this.onTouched?.();
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  onKeyDown(event, value) {
    if (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space) {
      this.checkOption(value);
      event.preventDefault();
    }
  }
  changeModelValue(value) {
    if (value === null) {
      this.checkboxValue = "mixed";
    } else {
      this.checkboxValue = typeof value === "boolean" || value === null ? value : false;
    }
    this.changeDetector.detectChanges();
  }
  static ɵfac = function PoCheckboxComponent_Factory(t) {
    return new (t || _PoCheckboxComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoCheckboxComponent, selectors: [["po-checkbox"]], viewQuery: function PoCheckboxComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1C, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxLabel = _t.first);
    }
  }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoCheckboxComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 5, vars: 9, consts: [[1, "container-po-checkbox", 3, "click", "keydown"], ["role", "checkbox", 1, "po-checkbox-outline", 3, "tabindex"], ["checkboxLabel", ""], ["aria-label", " ", 1, "po-checkbox", 3, "id"], ["class", "po-checkbox-label", "tabindex", "-1", 3, "p-disabled", "p-for", "p-label", 4, "ngIf"], ["tabindex", "-1", 1, "po-checkbox-label", 3, "p-disabled", "p-for", "p-label"]], template: function PoCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoCheckboxComponent_Template_div_click_0_listener() {
        return ctx.checkOption(ctx.checkboxValue);
      })("keydown", function PoCheckboxComponent_Template_div_keydown_0_listener($event) {
        return ctx.onKeyDown($event, ctx.checkboxValue);
      });
      ɵɵelementStart(1, "div", 1, 2);
      ɵɵelement(3, "span", 3);
      ɵɵtemplate(4, PoCheckboxComponent_po_label_4_Template, 1, 3, "po-label", 4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵattribute("checked", ctx.checkboxValue);
      ɵɵadvance();
      ɵɵproperty("tabindex", ctx.disabled || ctx.disabladTabindex ? -1 : 0);
      ɵɵattribute("p-size", ctx.size)("aria-checked", ctx.checkboxValue);
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.id);
      ɵɵattribute("aria-checked", ctx.checkboxValue)("aria-disabled", ctx.disabled)("required", ctx.checkBoxRequired);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label);
    }
  }, dependencies: [NgIf, PoLabelComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxComponent, [{
    type: Component,
    args: [{ selector: "po-checkbox", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoCheckboxComponent),
        multi: true
      }
    ], template: '<div\n  class="container-po-checkbox"\n  [attr.checked]="checkboxValue"\n  (click)="checkOption(checkboxValue)"\n  (keydown)="onKeyDown($event, checkboxValue)"\n>\n  <div\n    #checkboxLabel\n    role="checkbox"\n    class="po-checkbox-outline"\n    [attr.p-size]="size"\n    [tabindex]="disabled || disabladTabindex ? -1 : 0"\n    [attr.aria-checked]="checkboxValue"\n  >\n    <span\n      [attr.aria-checked]="checkboxValue"\n      aria-label=" "\n      [id]="id"\n      class="po-checkbox"\n      [attr.aria-disabled]="disabled"\n      [attr.required]="checkBoxRequired"\n    >\n    </span>\n\n    <po-label\n      *ngIf="label"\n      class="po-checkbox-label"\n      tabindex="-1"\n      [p-disabled]="disabled"\n      [p-for]="id"\n      [p-label]="label"\n    >\n    </po-label>\n  </div>\n</div>\n' }]
  }], () => [{ type: ChangeDetectorRef }], { checkboxLabel: [{
    type: ViewChild,
    args: ["checkboxLabel", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCheckboxComponent, { className: "PoCheckboxComponent", filePath: "lib/components/po-field/po-checkbox/po-checkbox.component.ts", lineNumber: 48 });
})();
var _c0$1B = ["itemList"];
function PoItemListComponent_div_1_po_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 8);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r4.icon);
  }
}
function PoItemListComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4, 5);
    ɵɵtemplate(2, PoItemListComponent_div_1_po_icon_2_Template, 1, 1, "po-icon", 6);
    ɵɵelementStart(3, "span", 7);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-item-list__separator", ctx_r0.separator)("po-item-list__disabled", ctx_r0.disabled || !ctx_r0.visible)("po-item-list__selected", (ctx_r0.selected || ctx_r0.activeTabs) && !ctx_r0.disabled)("po-item-list__hidden", ctx_r0.tabHide)("po-item-list__danger", ctx_r0.danger);
    ɵɵattribute("aria-disabled", ctx_r0.disabled || !ctx_r0.visible)("aria-label", ctx_r0.label);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function PoItemListComponent_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 12);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("innerHTML", ctx_r6.getLabelFormatted(ctx_r6.label), ɵɵsanitizeHtml);
  }
}
function PoItemListComponent_div_2_ng_template_3_Template(rf, ctx) {
}
var _c1$F = (a0) => ({ $implicit: a0 });
function PoItemListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9, 5);
    ɵɵlistener("click", function PoItemListComponent_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.onComboItem(ctx_r8.item, $event));
    });
    ɵɵtemplate(2, PoItemListComponent_div_2_span_2_Template, 1, 1, "span", 10)(3, PoItemListComponent_div_2_ng_template_3_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-item-list__separator", ctx_r1.separator)("po-item-list__selected", ctx_r1.selected && !ctx_r1.disabled);
    ɵɵattribute("aria-disabled", ctx_r1.disabled)("aria-label", ctx_r1.label);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.template);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.template == null ? null : ctx_r1.template.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c1$F, ctx_r1.templateContext));
  }
}
function PoItemListComponent_div_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r10.label);
  }
}
function PoItemListComponent_div_3_ng_template_3_Template(rf, ctx) {
}
function PoItemListComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13);
    ɵɵlistener("click", function PoItemListComponent_div_3_Template_div_click_0_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext();
      return ɵɵresetView(ctx_r12.onCheckboxItem());
    })("keydown", function PoItemListComponent_div_3_Template_div_keydown_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.onCheckboxItemEmit($event));
    })("keyup", function PoItemListComponent_div_3_Template_div_keyup_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15.onCheckboxItemEmit($event));
    });
    ɵɵelementStart(1, "po-checkbox", 14);
    ɵɵlistener("click", function PoItemListComponent_div_3_Template_po_checkbox_click_1_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.onCheckboxItem());
    })("p-change", function PoItemListComponent_div_3_Template_po_checkbox_p_change_1_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r17 = ɵɵnextContext();
      return ɵɵresetView(ctx_r17.onSelectItem({ label: ctx_r17.label }));
    });
    ɵɵelementEnd();
    ɵɵtemplate(2, PoItemListComponent_div_3_span_2_Template, 2, 1, "span", 15)(3, PoItemListComponent_div_3_ng_template_3_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-item-list__separator", ctx_r2.separator)("po-item-list__selected", ctx_r2.selected && !ctx_r2.disabled)("po-item-list__disabled", ctx_r2.disabled);
    ɵɵattribute("aria-disabled", ctx_r2.disabled)("aria-label", ctx_r2.label);
    ɵɵadvance();
    ɵɵproperty("p-disabled-tabindex", true)("p-checkboxValue", ctx_r2.checkboxValue === null ? "mixed" : ctx_r2.checkboxValue)("p-disabled", ctx_r2.disabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.template);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.template == null ? null : ctx_r2.template.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(14, _c1$F, ctx_r2.templateContext));
  }
}
var PoItemListComponent = class _PoItemListComponent extends PoItemListBaseComponent {
  sanitized;
  itemList;
  selectedView;
  param;
  clickListener;
  constructor(sanitized) {
    super();
    this.sanitized = sanitized;
  }
  ngOnChanges(changes) {
    if (this.isTabs) {
      if (changes.tabHide?.currentValue || changes.disabled?.currentValue) {
        this.tabsItem.emit(this.item);
      } else if (changes.activeTabs?.currentValue) {
        this.emitActiveTabs(this.item);
      }
    }
  }
  onSelectItem(itemListOption) {
    this.selectedView = itemListOption;
    this.selectItem.emit(itemListOption);
  }
  onCheckboxItem() {
    const option = { [this.fieldValue]: this.value, [this.fieldLabel]: this.label };
    const selected = !this.checkboxValue;
    this.checkboxItem.emit({ option, selected });
  }
  onComboItem(options, event) {
    const option = { [this.fieldValue]: this.value, [this.fieldLabel]: this.label };
    this.selectedView = options;
    this.comboItem.emit(__spreadProps(__spreadValues({}, option), { event }));
  }
  compareObjects(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
  onCheckboxItemEmit(event) {
    if (event && event.code === "Enter" || event.code === "Space") {
      this.onCheckboxItem();
    }
  }
  getLabelFormatted(label) {
    const sanitizedLabel = this.sanitizeTagHTML(label);
    let format = sanitizedLabel;
    if (this.isFiltering || this.validateForOptionsLabel()) {
      const labelInput = this.sanitizeTagHTML(this.searchValue.toString().toLowerCase());
      const labelLowerCase = sanitizedLabel.toLowerCase();
      const openTagBold = '<span class="po-font-text-large-bold">';
      const closeTagBold = "</span>";
      let startString;
      let middleString;
      let endString;
      switch (this.filterMode) {
        case PoItemListFilterMode.startsWith:
        case PoItemListFilterMode.contains:
          const indexOfLabelInput = labelLowerCase.indexOf(labelInput);
          if (indexOfLabelInput > -1) {
            startString = sanitizedLabel.substring(0, indexOfLabelInput);
            middleString = sanitizedLabel.substring(indexOfLabelInput, indexOfLabelInput + labelInput.length);
            endString = sanitizedLabel.substring(indexOfLabelInput + labelInput.length);
            format = startString + openTagBold + middleString + closeTagBold + endString;
          }
          break;
        case PoItemListFilterMode.endsWith:
          const lastIndexOfLabelInput = labelLowerCase.lastIndexOf(labelInput);
          if (lastIndexOfLabelInput > -1) {
            startString = sanitizedLabel.substring(0, lastIndexOfLabelInput);
            middleString = sanitizedLabel.substring(lastIndexOfLabelInput);
            format = startString + openTagBold + middleString + closeTagBold;
          }
          break;
      }
    }
    return this.safeHtml(format);
  }
  validateForOptionsLabel() {
    return this.comboService && this.searchValue && !this.compareCache && this.shouldMarkLetters;
  }
  safeHtml(value) {
    return this.sanitized.bypassSecurityTrustHtml(value);
  }
  sanitizeTagHTML(value = "") {
    return value.replace(/\</gm, "&lt;").replace(/\>/g, "&gt;");
  }
  static ɵfac = function PoItemListComponent_Factory(t) {
    return new (t || _PoItemListComponent)(ɵɵdirectiveInject(DomSanitizer));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoItemListComponent, selectors: [["po-item-list"]], viewQuery: function PoItemListComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1B, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemList = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 4, vars: 3, consts: [[3, "ngSwitch", "keydown"], ["class", "po-item-list po-item-list__action", 3, "po-item-list__separator", "po-item-list__disabled", "po-item-list__selected", "po-item-list__hidden", "po-item-list__danger", 4, "ngSwitchDefault"], ["class", "po-item-list po-item-list__option", 3, "po-item-list__separator", "po-item-list__selected", "click", 4, "ngSwitchCase"], ["class", "po-item-list po-item-list__check", 3, "po-item-list__separator", "po-item-list__selected", "po-item-list__disabled", "click", "keydown", "keyup", 4, "ngSwitchCase"], [1, "po-item-list", "po-item-list__action"], ["itemList", ""], ["class", "po-popup-icon-item po-icon", 3, "p-icon", 4, "ngIf"], [1, "po-item-list-label"], [1, "po-popup-icon-item", "po-icon", 3, "p-icon"], [1, "po-item-list", "po-item-list__option", 3, "click"], ["class", "po-item-list-label", 3, "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-item-list-label", 3, "innerHTML"], [1, "po-item-list", "po-item-list__check", 3, "click", "keydown", "keyup"], [3, "p-disabled-tabindex", "p-checkboxValue", "p-disabled", "click", "p-change"], ["class", "po-item-list__label", 4, "ngIf"], [1, "po-item-list__label"]], template: function PoItemListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 0);
      ɵɵlistener("keydown", function PoItemListComponent_Template_ng_container_keydown_0_listener($event) {
        return ctx.onCheckboxItemEmit($event);
      });
      ɵɵtemplate(1, PoItemListComponent_div_1_Template, 5, 14, "div", 1)(2, PoItemListComponent_div_2_Template, 4, 11, "div", 2)(3, PoItemListComponent_div_3_Template, 4, 16, "div", 3);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngSwitch", ctx.type);
      ɵɵadvance(2);
      ɵɵproperty("ngSwitchCase", "option");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "check");
    }
  }, dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, PoCheckboxComponent, PoIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoItemListComponent, [{
    type: Component,
    args: [{ selector: "po-item-list", template: `<ng-container [ngSwitch]="type" (keydown)="onCheckboxItemEmit($event)">
  <div
    *ngSwitchDefault
    #itemList
    [class.po-item-list__separator]="separator"
    [class.po-item-list__disabled]="disabled || !visible"
    [class.po-item-list__selected]="(selected || activeTabs) && !disabled"
    [class.po-item-list__hidden]="tabHide"
    [attr.aria-disabled]="disabled || !visible"
    [attr.aria-label]="label"
    [class.po-item-list__danger]="danger"
    class="po-item-list po-item-list__action"
  >
    <po-icon *ngIf="icon" class="po-popup-icon-item po-icon" [p-icon]="icon"></po-icon>
    <span class="po-item-list-label">{{ label }}</span>
  </div>

  <div
    *ngSwitchCase="'option'"
    #itemList
    class="po-item-list po-item-list__option"
    [class.po-item-list__separator]="separator"
    [class.po-item-list__selected]="selected && !disabled"
    [attr.aria-disabled]="disabled"
    [attr.aria-label]="label"
    (click)="onComboItem(item, $event)"
  >
    <span *ngIf="!template" class="po-item-list-label" [innerHTML]="getLabelFormatted(label)"></span>

    <ng-template [ngTemplateOutlet]="template?.templateRef" [ngTemplateOutletContext]="{ $implicit: templateContext }">
    </ng-template>
  </div>

  <div
    *ngSwitchCase="'check'"
    class="po-item-list po-item-list__check"
    [class.po-item-list__separator]="separator"
    [class.po-item-list__selected]="selected && !disabled"
    [class.po-item-list__disabled]="disabled"
    [attr.aria-disabled]="disabled"
    [attr.aria-label]="label"
    (click)="onCheckboxItem()"
    (keydown)="onCheckboxItemEmit($event)"
    (keyup)="onCheckboxItemEmit($event)"
  >
    <po-checkbox
      [p-disabled-tabindex]="true"
      [p-checkboxValue]="checkboxValue === null ? 'mixed' : checkboxValue"
      [p-disabled]="disabled"
      (click)="onCheckboxItem()"
      (p-change)="onSelectItem({ label })"
    ></po-checkbox>

    <span class="po-item-list__label" *ngIf="!template">{{ label }}</span>

    <ng-template [ngTemplateOutlet]="template?.templateRef" [ngTemplateOutletContext]="{ $implicit: templateContext }">
    </ng-template>
  </div>
</ng-container>
` }]
  }], () => [{ type: DomSanitizer }], { itemList: [{
    type: ViewChild,
    args: ["itemList", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoItemListComponent, { className: "PoItemListComponent", filePath: "lib/components/po-listbox/po-item-list/po-item-list.component.ts", lineNumber: 13 });
})();
var _c0$1A = ["inputElement"];
var PoSearchListComponent = class _PoSearchListComponent {
  cd;
  inputElement;
  /** Propriedade que recebe as literais definidas no `po-listbox`. */
  literals;
  fieldValue;
  /** Evento que será disparado a cada tecla digitada no campo de busca. */
  change = new EventEmitter();
  _placeholder;
  constructor(cd) {
    this.cd = cd;
  }
  /**
   * @optional
   *
   * @description
   *
   * Placeholder do campo de pesquisa.
   *
   * > Caso o mesmo não seja informado, o valor padrão será traduzido com base no idioma do navegador (pt, es e en).
   *
   * @default `Buscar`
   */
  set placeholder(placeholder) {
    this._placeholder = placeholder && this.isTypeof(placeholder, "string") ? placeholder : this.literals.placeholderSearch;
  }
  get placeholder() {
    return this._placeholder || this.literals.placeholderSearch;
  }
  get inputValue() {
    return this.inputElement.nativeElement.value;
  }
  onChange(event) {
    this.change.emit({ event, [this.fieldValue]: this.inputElement.nativeElement.value });
  }
  setFocus() {
    this.inputElement.nativeElement.focus();
  }
  clean() {
    this.inputElement.nativeElement.value = "";
    this.cd.markForCheck();
  }
  isTypeof(object, type) {
    return typeof object === type;
  }
  static ɵfac = function PoSearchListComponent_Factory(t) {
    return new (t || _PoSearchListComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSearchListComponent, selectors: [["po-search-list"]], viewQuery: function PoSearchListComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1A, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    }
  }, inputs: { literals: [InputFlags.None, "p-literals", "literals"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"] }, outputs: { change: "p-change" }, decls: 5, vars: 1, consts: [[1, "po-field-container-content", "po-listbox-container-search"], [1, "po-field-icon-container-left"], [1, "po-icon", "po-icon-search", "po-field-icon", "po-icon-input"], ["type", "text", 1, "po-input", "po-input-icon-left", "po-listbox-search-input", 3, "placeholder", "keyup"], ["inputElement", ""]], template: function PoSearchListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵelement(2, "span", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "input", 3, 4);
      ɵɵlistener("keyup", function PoSearchListComponent_Template_input_keyup_3_listener($event) {
        return ctx.onChange($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("placeholder", ctx.placeholder);
    }
  }, encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchListComponent, [{
    type: Component,
    args: [{ selector: "po-search-list", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-field-container-content po-listbox-container-search">\n  <div class="po-field-icon-container-left">\n    <span class="po-icon po-icon-search po-field-icon po-icon-input"></span>\n  </div>\n\n  <input\n    #inputElement\n    class="po-input po-input-icon-left po-listbox-search-input"\n    type="text"\n    [placeholder]="placeholder"\n    (keyup)="onChange($event)"\n  />\n</div>\n' }]
  }], () => [{ type: ChangeDetectorRef }], { inputElement: [{
    type: ViewChild,
    args: ["inputElement", { read: ElementRef, static: true }]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSearchListComponent, { className: "PoSearchListComponent", filePath: "lib/components/po-listbox/po-search-list/po-search-list.component.ts", lineNumber: 25 });
})();
var _c0$1z = ["listbox"];
var _c1$E = ["listboxItemList"];
var _c2$j = ["searchElement"];
function PoListBoxComponent_po_search_list_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-search-list", 6, 7);
    ɵɵlistener("p-change", function PoListBoxComponent_po_search_list_3_Template_po_search_list_p_change_0_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.callChangeSearch($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-literals", ctx_r1.literalSearch)("p-field-value", ctx_r1.fieldValueSearch)("p-placeholder", ctx_r1.placeholderSearch);
  }
}
function PoListBoxComponent_ng_container_4_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 12);
    ɵɵlistener("click", function PoListBoxComponent_ng_container_4_li_3_Template_li_click_0_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r12.changeAll.emit());
    })("keydown", function PoListBoxComponent_ng_container_4_li_3_Template_li_keydown_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r14 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r14.changeAllEmit($event));
    })("keydown", function PoListBoxComponent_ng_container_4_li_3_Template_li_keydown_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r15 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r15.onSelectAllCheckboxKeyDown($event));
    });
    ɵɵelement(1, "po-item-list", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(2);
    ɵɵattribute("aria-checked", ctx_r10.checkboxAllValue === null ? "mixed" : ctx_r10.checkboxAllValue);
    ɵɵadvance();
    ɵɵproperty("p-selected", ctx_r10.checkboxAllValue)("p-label", ctx_r10.literals.selectAll)("p-checkbox-value", ctx_r10.checkboxAllValue);
  }
}
function PoListBoxComponent_ng_container_4_li_4_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r16 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r16.label, " ");
  }
}
function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-item-list", 18);
    ɵɵlistener("p-selectcheckbox-item", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_selectcheckbox_item_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r20 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r20.checkboxClicked($event));
    })("p-selectcombo-item", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_selectcombo_item_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r22 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r22.optionClicked($event));
    })("p-select-item", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_select_item_0_listener() {
      ɵɵrestoreView(_r21);
      const item_r16 = ɵɵnextContext().$implicit;
      const ctx_r23 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r23.onSelectCheckBoxItem(item_r16));
    })("p-emit-item-tabs", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_emit_item_tabs_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r25 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r25.onSelectTabs($event));
    })("p-activated-tabs", function PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template_po_item_list_p_activated_tabs_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r26 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r26.onActivatedTabs($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r16 = ɵɵnextContext().$implicit;
    const ctx_r18 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r18.returnBooleanValue(item_r16, "disabled"))("p-visible", ctx_r18.returnBooleanValue(item_r16, "visible"))("p-checkbox-value", ctx_r18.isSelectedItem(item_r16))("p-label", item_r16[ctx_r18.fieldLabel])("p-value", item_r16[ctx_r18.fieldValue])("p-selected", ctx_r18.isSelectedItem(item_r16) || item_r16.selected)("p-active-tabs", item_r16.active)("p-separator", item_r16.separator)("p-danger", item_r16.danger || item_r16.type === "danger")("p-icon", item_r16.icon)("p-type", ctx_r18.type)("p-item", item_r16)("p-tab-hide", item_r16.hide)("p-is-tabs", ctx_r18.isTabs)("p-field-value", ctx_r18.fieldValue)("p-field-label", ctx_r18.fieldLabel)("p-template", ctx_r18.template)("p-template-context", item_r16)("p-search-value", ctx_r18.searchValue)("p-filter-mode", ctx_r18.filterMode)("p-filtering", ctx_r18.isFiltering)("p-should-mark-letter", ctx_r18.shouldMarkLetters)("p-compare-cache", ctx_r18.compareCache)("p-combo-service", ctx_r18.comboService);
    ɵɵattribute("data-item-list", ctx_r18.formatItemList(item_r16));
  }
}
function PoListBoxComponent_ng_container_4_li_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 14);
    ɵɵlistener("click", function PoListBoxComponent_ng_container_4_li_4_Template_li_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r29);
      const item_r16 = restoredCtx.$implicit;
      const ctx_r28 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r28.onSelectItem(item_r16));
    })("keydown", function PoListBoxComponent_ng_container_4_li_4_Template_li_keydown_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r29);
      const item_r16 = restoredCtx.$implicit;
      const ctx_r30 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r30.onKeyDown(item_r16, $event));
    });
    ɵɵtemplate(1, PoListBoxComponent_ng_container_4_li_4_label_1_Template, 2, 1, "label", 15)(2, PoListBoxComponent_ng_container_4_li_4_po_item_list_2_Template, 1, 25, "po-item-list", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r16 = ctx.$implicit;
    const ctx_r11 = ɵɵnextContext(2);
    ɵɵclassProp("po-listbox-item", ctx_r11.visible);
    ɵɵproperty("cdkOption", item_r16[ctx_r11.fieldLabel])("cdkOptionDisabled", ctx_r11.returnBooleanValue(item_r16, "disabled") || ctx_r11.returnBooleanValue(item_r16, "visible") === false || item_r16.options);
    ɵɵattribute("aria-selected", ctx_r11.isSelectedItem(item_r16) || item_r16.selected);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r16.options);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r11.returnBooleanValue(item_r16, "visible") !== false && !item_r16.options);
  }
}
function PoListBoxComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "ul", 8, 9);
    ɵɵtemplate(3, PoListBoxComponent_ng_container_4_li_3_Template, 2, 4, "li", 10)(4, PoListBoxComponent_ng_container_4_li_4_Template, 3, 7, "li", 11);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("cdkListboxMultiple", ctx_r2.type === "check");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.type === "check" && ctx_r2.items.length && !(ctx_r2.searchElement == null ? null : ctx_r2.searchElement.inputValue) && !ctx_r2.hideSelectAll);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.items);
  }
}
function PoListBoxComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "po-loading-overlay", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("po-listbox-container-loading-default", !ctx_r3.infiniteLoading);
  }
}
function PoListBoxComponent_ng_template_6_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r31 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r31.literals.noItems, "");
  }
}
function PoListBoxComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoListBoxComponent_ng_template_6_div_0_Template, 3, 1, "div", 20);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("ngIf", !ctx_r4.items.length && !ctx_r4.isServerSearching && ctx_r4.type !== "action");
  }
}
var _c3$d = [[["", "p-popup-header-template", ""]]];
var _c4$5 = ["[p-popup-header-template]"];
var PoListBoxComponent = class _PoListBoxComponent extends PoListBoxBaseComponent {
  element;
  renderer;
  router;
  changeDetector;
  listbox;
  listboxItemList;
  searchElement;
  scrollEvent$;
  subscriptionScrollEvent;
  constructor(element, renderer, languageService, router, changeDetector) {
    super(languageService);
    this.element = element;
    this.renderer = renderer;
    this.router = router;
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    this.setListBoxMaxHeight();
    this.listboxItemList?.nativeElement.focus();
  }
  ngOnChanges(changes) {
    if (changes?.items) {
      this.setListBoxMaxHeight();
    }
    if (this.visible && this.infiniteScroll) {
      this.checkInfiniteScroll();
    }
  }
  ngOnDestroy() {
    if (this.subscriptionScrollEvent && this.subscriptionScrollEvent.unsubscribe) {
      this.subscriptionScrollEvent.unsubscribe();
    }
  }
  onSelectItem(itemListAction) {
    const isDisabled = itemListAction.hasOwnProperty("disabled") && itemListAction.disabled !== null && itemListAction.disabled !== void 0 ? this.returnBooleanValue(itemListAction, "disabled") : false;
    const isVisible = itemListAction.hasOwnProperty("visible") && itemListAction.visible !== null && itemListAction.visible !== void 0 ? this.returnBooleanValue(itemListAction, "visible") : true;
    if (this.isTabs && !itemListAction.disabled && !itemListAction.hide) {
      this.onClickTabs(itemListAction);
    }
    if (itemListAction && itemListAction.action && !isDisabled && isVisible) {
      itemListAction.action(this.param || itemListAction);
    }
    if (itemListAction && itemListAction.url && !isDisabled && isVisible) {
      return this.openUrl(itemListAction.url);
    }
  }
  onSelectAllCheckboxKeyDown(event) {
    if (event.code === "Tab") {
      this.closeEvent.emit();
    }
  }
  onKeyDown(itemListAction, event) {
    event.preventDefault();
    if (event && event.code === "Enter" || event.code === "Space") {
      switch (this.type) {
        case "check":
          this.onSelectCheckBoxItem(itemListAction);
          break;
        case "option":
          this.optionClicked(itemListAction);
          break;
        case "action":
          this.onSelectItem(itemListAction);
          break;
      }
    }
    if (event && event.code === "Escape" || event.code === "Tab") {
      this.closeEvent.emit();
    }
  }
  checkboxClicked({ option, selected }) {
    if (this.type === "check") {
      this.change.emit({ selected, option });
    }
  }
  optionClicked(option) {
    if (this.type === "option") {
      this.items.filter((item) => item[this.fieldValue] === option[this.fieldValue] ? item["selected"] = true : item["selected"] = false);
      this.selectCombo.emit(__spreadValues({}, option));
    }
  }
  onSelectCheckBoxItem(option) {
    const selected = !this.isSelectedItem(option);
    this.checkboxClicked({ option, selected });
  }
  isSelectedItem(option) {
    return this.selectedOptions.some((selectedItem) => selectedItem[this.fieldValue] === option[this.fieldValue]);
  }
  changeAllEmit(event) {
    if (event && event.code === "Enter" || event.code === "Space") {
      this.changeAll.emit();
    }
  }
  onSelectTabs(tab) {
    if (this.isTabs && tab) {
      this.changeStateTabs.emit(tab);
    }
  }
  onActivatedTabs(tab) {
    this.activatedTab.emit(tab);
  }
  callChangeSearch(event) {
    this.changeSearch.emit(event);
  }
  showMoreInfiniteScroll({ target }) {
    const scrollPosition = target.offsetHeight + target.scrollTop;
    if (scrollPosition >= target.scrollHeight * (this.infiniteScrollDistance / 110)) {
      this.UpdateInfiniteScroll.emit();
    }
  }
  scrollListener(componentListner) {
    return fromEvent(componentListner, "scroll").pipe(debounceTime(100));
  }
  setFocus() {
    this.listboxItemList.nativeElement.focus();
  }
  checkInfiniteScroll() {
    if (this.hasInfiniteScroll()) {
      this.includeInfiniteScroll();
    }
  }
  hasInfiniteScroll() {
    this.changeDetector.detectChanges();
    return this.infiniteScroll && this.listboxItemList?.nativeElement.scrollHeight;
  }
  checkTemplate() {
    if (this.cache || this.infiniteScroll) {
      return this.items.length;
    } else {
      return !this.isServerSearching && this.items.length;
    }
  }
  includeInfiniteScroll() {
    this.scrollEvent$ = this.scrollListener(this.listboxItemList?.nativeElement);
    this.subscriptionScrollEvent = this.scrollEvent$.subscribe((event) => {
      this.showMoreInfiniteScroll(event);
    });
  }
  returnBooleanValue(itemListAction, property) {
    return isTypeof(itemListAction[property], "function") ? itemListAction[property](this.param || itemListAction) : itemListAction[property];
  }
  setListBoxMaxHeight() {
    const itemsLength = this.items.length;
    if (itemsLength > 6) {
      if (this.type === "check" && !this.hideSearch) {
        this.renderer.setStyle(this.listbox.nativeElement, "maxHeight", `${44 * 6 - 44 / 3 + 60}px`);
      } else {
        this.renderer.setStyle(this.listbox.nativeElement, "maxHeight", `${44 * 6 - 44 / 3}px`);
      }
    }
  }
  openUrl(url) {
    if (isExternalLink(url)) {
      return openExternalLink(url);
    }
    if (url) {
      return this.router.navigate([url]);
    }
  }
  onClickTabs(tab) {
    if (!tab.disabled) {
      this.clickTab.emit(tab);
    }
  }
  formatItemList(item) {
    if (this.isTabs) {
      return item.id;
    } else {
      try {
        return JSON.stringify(item);
      } catch (error) {
        return item;
      }
    }
  }
  static ɵfac = function PoListBoxComponent_Factory(t) {
    return new (t || _PoListBoxComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoListBoxComponent, selectors: [["po-listbox"]], viewQuery: function PoListBoxComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1z, 7);
      ɵɵviewQuery(_c1$E, 5);
      ɵɵviewQuery(_c2$j, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listboxItemList = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchElement = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], ngContentSelectors: _c4$5, decls: 8, vars: 8, consts: [[1, "po-listbox", 3, "hidden"], ["listbox", ""], [3, "p-literals", "p-field-value", "p-placeholder", "p-change", 4, "ngIf"], [4, "ngIf", "ngIfElse"], [3, "po-listbox-container-loading-default", 4, "ngIf"], ["noDataTemplate", ""], [3, "p-literals", "p-field-value", "p-placeholder", "p-change"], ["searchElement", ""], ["cdkListbox", "", 1, "po-listbox-list", 3, "cdkListboxMultiple"], ["listboxItemList", ""], ["cdkOption", "selectAll", 3, "click", "keydown", 4, "ngIf"], [3, "po-listbox-item", "cdkOption", "cdkOptionDisabled", "click", "keydown", 4, "ngFor", "ngForOf"], ["cdkOption", "selectAll", 3, "click", "keydown"], ["p-type", "check", "p-value", "selectAll", 3, "p-selected", "p-label", "p-checkbox-value"], [3, "cdkOption", "cdkOptionDisabled", "click", "keydown"], ["class", "po-combo-item-title", 4, "ngIf"], [3, "p-disabled", "p-visible", "p-checkbox-value", "p-label", "p-value", "p-selected", "p-active-tabs", "p-separator", "p-danger", "p-icon", "p-type", "p-item", "p-tab-hide", "p-is-tabs", "p-field-value", "p-field-label", "p-template", "p-template-context", "p-search-value", "p-filter-mode", "p-filtering", "p-should-mark-letter", "p-compare-cache", "p-combo-service", "p-selectcheckbox-item", "p-selectcombo-item", "p-select-item", "p-emit-item-tabs", "p-activated-tabs", 4, "ngIf"], [1, "po-combo-item-title"], [3, "p-disabled", "p-visible", "p-checkbox-value", "p-label", "p-value", "p-selected", "p-active-tabs", "p-separator", "p-danger", "p-icon", "p-type", "p-item", "p-tab-hide", "p-is-tabs", "p-field-value", "p-field-label", "p-template", "p-template-context", "p-search-value", "p-filter-mode", "p-filtering", "p-should-mark-letter", "p-compare-cache", "p-combo-service", "p-selectcheckbox-item", "p-selectcombo-item", "p-select-item", "p-emit-item-tabs", "p-activated-tabs"], ["p-size", "md"], ["class", "po-listbox-container-no-data po-text-center", 4, "ngIf"], [1, "po-listbox-container-no-data", "po-text-center"]], template: function PoListBoxComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c3$d);
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, PoListBoxComponent_po_search_list_3_Template, 2, 3, "po-search-list", 2)(4, PoListBoxComponent_ng_container_4_Template, 5, 3, "ng-container", 3)(5, PoListBoxComponent_div_5_Template, 2, 2, "div", 4)(6, PoListBoxComponent_ng_template_6_Template, 1, 1, "ng-template", null, 5, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r5 = ɵɵreference(7);
      ɵɵclassProp("po-listbox-check", ctx.type === "check" || ctx.type === "option");
      ɵɵproperty("hidden", ctx.visible);
      ɵɵattribute("data-type", ctx.type);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.hideSearch && ctx.type === "check");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.checkTemplate())("ngIfElse", _r5);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isServerSearching && ctx.type !== "action");
    }
  }, dependencies: [NgForOf, NgIf, PoLoadingOverlayComponent, CdkListbox, CdkOption, PoItemListComponent, PoSearchListComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListBoxComponent, [{
    type: Component,
    args: [{ selector: "po-listbox", template: `<div
  #listbox
  class="po-listbox"
  [class.po-listbox-check]="type === 'check' || type === 'option'"
  [attr.data-type]="type"
  [hidden]="visible"
>
  <ng-content select="[p-popup-header-template]"></ng-content>

  <po-search-list
    #searchElement
    *ngIf="!hideSearch && type === 'check'"
    (p-change)="callChangeSearch($event)"
    [p-literals]="literalSearch"
    [p-field-value]="fieldValueSearch"
    [p-placeholder]="placeholderSearch"
  ></po-search-list>

  <ng-container *ngIf="checkTemplate(); else noDataTemplate">
    <ul #listboxItemList cdkListbox [cdkListboxMultiple]="type === 'check'" class="po-listbox-list">
      <li
        cdkOption="selectAll"
        *ngIf="type === 'check' && items.length && !searchElement?.inputValue && !hideSelectAll"
        [attr.aria-checked]="checkboxAllValue === null ? 'mixed' : checkboxAllValue"
        (click)="changeAll.emit()"
        (keydown)="changeAllEmit($event)"
        (keydown)="onSelectAllCheckboxKeyDown($event)"
      >
        <po-item-list
          [p-selected]="checkboxAllValue"
          p-type="check"
          [p-label]="literals.selectAll"
          p-value="selectAll"
          [p-checkbox-value]="checkboxAllValue"
        >
        </po-item-list>
      </li>
      <li
        [class.po-listbox-item]="visible"
        *ngFor="let item of items"
        [cdkOption]="item[fieldLabel]"
        [cdkOptionDisabled]="
          returnBooleanValue(item, 'disabled') || returnBooleanValue(item, 'visible') === false || item.options
        "
        [attr.aria-selected]="isSelectedItem(item) || item.selected"
        (click)="onSelectItem(item)"
        (keydown)="onKeyDown(item, $event)"
      >
        <label *ngIf="item.options" class="po-combo-item-title">
          {{ item.label }}
        </label>
        <po-item-list
          *ngIf="returnBooleanValue(item, 'visible') !== false && !item.options"
          [p-disabled]="returnBooleanValue(item, 'disabled')"
          [p-visible]="returnBooleanValue(item, 'visible')"
          [p-checkbox-value]="isSelectedItem(item)"
          [attr.data-item-list]="formatItemList(item)"
          [p-label]="item[fieldLabel]"
          [p-value]="item[fieldValue]"
          [p-selected]="isSelectedItem(item) || item.selected"
          [p-active-tabs]="item.active"
          [p-separator]="item.separator"
          [p-danger]="item.danger || item.type === 'danger'"
          [p-icon]="item.icon"
          [p-type]="type"
          [p-item]="item"
          [p-tab-hide]="item.hide"
          [p-is-tabs]="isTabs"
          [p-field-value]="fieldValue"
          [p-field-label]="fieldLabel"
          [p-template]="template"
          [p-template-context]="item"
          (p-selectcheckbox-item)="checkboxClicked($event)"
          (p-selectcombo-item)="optionClicked($event)"
          (p-select-item)="onSelectCheckBoxItem(item)"
          (p-emit-item-tabs)="onSelectTabs($event)"
          (p-activated-tabs)="onActivatedTabs($event)"
          [p-search-value]="searchValue"
          [p-filter-mode]="filterMode"
          [p-filtering]="isFiltering"
          [p-should-mark-letter]="shouldMarkLetters"
          [p-compare-cache]="compareCache"
          [p-combo-service]="comboService"
        ></po-item-list>
      </li>
    </ul>
  </ng-container>

  <div *ngIf="isServerSearching && type !== 'action'" [class.po-listbox-container-loading-default]="!infiniteLoading">
    <po-loading-overlay p-size="md"></po-loading-overlay>
  </div>

  <ng-template #noDataTemplate>
    <div
      *ngIf="!items.length && !isServerSearching && type !== 'action'"
      class="po-listbox-container-no-data po-text-center"
    >
      <span> {{ literals.noItems }}</span>
    </div>
  </ng-template>
</div>
` }]
  }], () => [{ type: ElementRef }, { type: Renderer2 }, { type: PoLanguageService }, { type: Router }, { type: ChangeDetectorRef }], { listbox: [{
    type: ViewChild,
    args: ["listbox", { static: true }]
  }], listboxItemList: [{
    type: ViewChild,
    args: ["listboxItemList", { static: false }]
  }], searchElement: [{
    type: ViewChild,
    args: ["searchElement"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoListBoxComponent, { className: "PoListBoxComponent", filePath: "lib/components/po-listbox/po-listbox.component.ts", lineNumber: 29 });
})();
var _c0$1y = ["popupRef"];
var _c1$D = ["listbox"];
var _c2$i = ["poListBoxRef"];
function PoPopupComponent_div_0_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMapInterpolate1("po-popup-arrow po-arrow-", ctx_r2.arrowDirection, "");
  }
}
function PoPopupComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1, 2);
    ɵɵtemplate(2, PoPopupComponent_div_0_div_2_Template, 1, 3, "div", 3);
    ɵɵelementStart(3, "div", 4)(4, "po-listbox", 5, 6);
    ɵɵlistener("p-close", function PoPopupComponent_div_0_Template_po_listbox_p_close_4_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.close());
    });
    ɵɵelementStart(7, "div", 7);
    ɵɵprojection(8);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.hideArrow);
    ɵɵadvance(2);
    ɵɵproperty("p-items", ctx_r0.actions)("p-param", ctx_r0.param);
  }
}
var _c3$c = [[["", "p-popup-header-template", ""]]];
var _c4$4 = ["[p-popup-header-template]"];
var PoPopupComponent = class _PoPopupComponent extends PoPopupBaseComponent {
  renderer;
  router;
  poControlPosition;
  changeDetector;
  popupRef;
  listbox;
  //utilizado apenas no theme builder
  poListBoxRef;
  constructor(viewContainerRef, renderer, router, poControlPosition, changeDetector) {
    super();
    this.renderer = renderer;
    this.router = router;
    this.poControlPosition = poControlPosition;
    this.changeDetector = changeDetector;
  }
  /**
   * Fecha o componente *popup*.
   *
   * > Por padrão, este comportamento é acionado somente ao clicar fora do componente ou em determinada ação / url.
   */
  close() {
    this.removeListeners();
    this.showPopup = false;
    this.closeEvent.emit();
  }
  onActionClick(popupAction) {
    const actionNoDisabled = popupAction && !this.returnBooleanValue(popupAction, "disabled");
    if (popupAction && popupAction.action && actionNoDisabled) {
      this.close();
      popupAction.action(this.param || popupAction);
    }
    if (popupAction && popupAction.url && actionNoDisabled) {
      this.close();
      return this.openUrl(popupAction.url);
    }
  }
  /**
   * Abre o componente *popup*.
   *
   * > É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
   */
  open(param) {
    this.oldTarget = this.target;
    this.param = param;
    this.showPopup = true;
    this.changeDetector.detectChanges();
    this.validateInitialContent();
  }
  returnBooleanValue(popupAction, property) {
    return isTypeof(popupAction[property], "function") ? popupAction[property](this.param || popupAction) : popupAction[property];
  }
  /**
   * Responsável por abrir e fechar o *popup*.
   *
   * Quando disparado abrirá o *popup* e caso o mesmo já estiver aberto e possuir o mesmo `target` irá fecha-lo.
   *
   * É possível informar um parâmetro que será utilizado na execução da ação do item e na função de desabilitar.
   */
  toggle(param) {
    this.showPopup && this.oldTarget === this.target ? this.close() : this.open(param);
  }
  checkAllActionIsInvisible() {
    if (this.actions.every((item) => item.visible === false)) {
      return true;
    }
    return false;
  }
  clickedOutDisabledItem(event) {
    const containsItemDisabled = this.elementContains(event.target, "po-popup-item-disabled") || this.elementContains(event.target.parentElement, "po-popup-item-disabled");
    return !containsItemDisabled;
  }
  clickedOutHeaderTemplate(event) {
    const popupHeaderTemplate = this.popupRef && this.popupRef.nativeElement.querySelector("[p-popup-header-template]");
    return !(popupHeaderTemplate && popupHeaderTemplate.contains(event.target));
  }
  clickedOutTarget(event) {
    return this.target && !this.target.contains(event.target);
  }
  closePopupOnClickout(event) {
    if (this.clickedOutTarget(event) && this.clickedOutDisabledItem(event) && this.clickedOutHeaderTemplate(event)) {
      this.close();
    }
  }
  elementContains(element, className) {
    return element && element.classList.contains(className);
  }
  hasContentToShow() {
    return !!(this.popupRef?.nativeElement && this.listbox?.nativeElement);
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.close();
    });
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.closePopupOnClickout(event);
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onScroll = ({ target }) => {
    const { showPopup, popupRef } = this;
    if (showPopup && popupRef?.nativeElement && !popupRef.nativeElement.contains(target)) {
      this.close();
    }
  };
  openUrl(url) {
    if (isExternalLink(url)) {
      return openExternalLink(url);
    }
    if (url) {
      return this.router.navigate([url]);
    }
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.resizeListener) {
      this.resizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setPosition() {
    if (this.listbox.nativeElement.querySelector(".po-listbox")) {
      this.poControlPosition.setElements(this.popupRef.nativeElement, 8, this.target, this.customPositions, false, this.isCornerAlign);
      this.poControlPosition.adjustPosition(this.position);
      this.arrowDirection = this.poControlPosition.getArrowDirection();
    }
  }
  validateInitialContent() {
    if (this.hasContentToShow()) {
      this.setPosition();
      this.initializeListeners();
    } else {
      this.close();
    }
  }
  static ɵfac = function PoPopupComponent_Factory(t) {
    return new (t || _PoPopupComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPopupComponent, selectors: [["po-popup"]], viewQuery: function PoPopupComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1y, 5, ElementRef);
      ɵɵviewQuery(_c1$D, 5, ElementRef);
      ɵɵviewQuery(_c2$i, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListBoxRef = _t.first);
    }
  }, features: [ɵɵProvidersFeature([PoControlPositionService]), ɵɵInheritDefinitionFeature], ngContentSelectors: _c4$4, decls: 1, vars: 1, consts: [["class", "po-popup", 4, "ngIf"], [1, "po-popup"], ["popupRef", ""], [3, "class", 4, "ngIf"], [1, "po-popup-container"], ["p-type", "action", 3, "p-items", "p-param", "p-close"], ["listbox", "", "poListBoxRef", ""], ["p-popup-header-template", ""]], template: function PoPopupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c3$c);
      ɵɵtemplate(0, PoPopupComponent_div_0_Template, 9, 3, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showPopup && ctx.actions.length && !ctx.checkAllActionIsInvisible());
    }
  }, dependencies: [NgIf, PoListBoxComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopupComponent, [{
    type: Component,
    args: [{ selector: "po-popup", providers: [PoControlPositionService], template: '<div #popupRef class="po-popup" *ngIf="showPopup && actions.length && !checkAllActionIsInvisible()">\n  <div *ngIf="!hideArrow" class="po-popup-arrow po-arrow-{{ arrowDirection }}"></div>\n\n  <div class="po-popup-container">\n    <po-listbox #listbox #poListBoxRef p-type="action" [p-items]="actions" [p-param]="param" (p-close)="close()">\n      <div p-popup-header-template>\n        <ng-content select="[p-popup-header-template]"></ng-content>\n      </div>\n    </po-listbox>\n  </div>\n</div>\n' }]
  }], () => [{ type: ViewContainerRef }, { type: Renderer2 }, { type: Router }, { type: PoControlPositionService }, { type: ChangeDetectorRef }], { popupRef: [{
    type: ViewChild,
    args: ["popupRef", { read: ElementRef }]
  }], listbox: [{
    type: ViewChild,
    args: ["listbox", { read: ElementRef }]
  }], poListBoxRef: [{
    type: ViewChild,
    args: ["poListBoxRef"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPopupComponent, { className: "PoPopupComponent", filePath: "lib/components/po-popup/po-popup.component.ts", lineNumber: 38 });
})();
var PoBreadcrumbFavoriteService = class _PoBreadcrumbFavoriteService {
  http;
  _url;
  _bodyParams;
  get url() {
    return this._url;
  }
  get bodyParams() {
    return this._bodyParams;
  }
  constructor(http) {
    this.http = http;
  }
  configService(url, params, item) {
    this._url = url;
    this._bodyParams = {
      isFavorite: false,
      url: item.link,
      params
    };
  }
  sendStatusFavorite(status) {
    this.bodyParams["isFavorite"] = status;
    return this.http.post(this.url, this.bodyParams);
  }
  getFavorite() {
    return this.http.get(this.url, { responseType: "json", params: { url: this.bodyParams["url"] } });
  }
  static ɵfac = function PoBreadcrumbFavoriteService_Factory(t) {
    return new (t || _PoBreadcrumbFavoriteService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoBreadcrumbFavoriteService, factory: _PoBreadcrumbFavoriteService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbFavoriteService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
function PoBreadcrumbFavoriteComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.literals == null ? null : ctx_r0.literals.unfavorite);
  }
}
function PoBreadcrumbFavoriteComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.literals == null ? null : ctx_r1.literals.favorite);
  }
}
var PoBreadcrumbLiterals = {
  en: {
    favorite: "Favorite",
    unfavorite: "Unfavorite"
  },
  es: {
    favorite: "Favor",
    unfavorite: "Desfavorecer"
  },
  pt: {
    favorite: "Favoritar",
    unfavorite: "Desfavoritar"
  },
  ru: {
    favorite: "Любимый",
    unfavorite: "Немилость"
  }
};
var PoBreadcrumbFavoriteComponent = class _PoBreadcrumbFavoriteComponent {
  service;
  languageService;
  // URL do serviço.
  favoriteService;
  // Item do breadcrumb ativo.
  itemActive;
  // Parâmetro que será enviado junto com o serviço de favoritar.
  paramsService;
  // Esconde literal e mantém apenas icone
  hiddenLiteral = false;
  favorite = false;
  literals;
  getSubscription;
  setSubscription;
  constructor(service, languageService) {
    this.service = service;
    this.languageService = languageService;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, PoBreadcrumbLiterals[language]);
  }
  ngOnInit() {
    this.service.configService(this.favoriteService, this.paramsService, this.itemActive);
    this.getStatusFavorite();
  }
  ngOnDestroy() {
    if (this.getSubscription) {
      this.getSubscription.unsubscribe();
    }
    if (this.setSubscription) {
      this.setSubscription.unsubscribe();
    }
  }
  toggleFavoriteAction() {
    this.favorite ? this.setStatusFavorite(false) : this.setStatusFavorite(true);
  }
  getStatusFavorite() {
    this.getSubscription = this.service.getFavorite().subscribe((result) => this.favorite = result.isFavorite);
  }
  setStatusFavorite(status) {
    this.setSubscription = this.service.sendStatusFavorite(status).subscribe((result) => this.favorite = result.isFavorite);
  }
  static ɵfac = function PoBreadcrumbFavoriteComponent_Factory(t) {
    return new (t || _PoBreadcrumbFavoriteComponent)(ɵɵdirectiveInject(PoBreadcrumbFavoriteService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoBreadcrumbFavoriteComponent, selectors: [["po-breadcrumb-favorite"]], inputs: { favoriteService: [InputFlags.None, "p-favorite-service", "favoriteService"], itemActive: [InputFlags.None, "p-item-active", "itemActive"], paramsService: [InputFlags.None, "p-params-service", "paramsService"], hiddenLiteral: [InputFlags.None, "p-hidden-literal", "hiddenLiteral"] }, features: [ɵɵProvidersFeature([PoBreadcrumbFavoriteService])], decls: 4, vars: 4, consts: [["tabindex", "0", "role", "button", 1, "po-breadcrumb-favorite", "po-clickable", 3, "click", "keyup.enter"], [1, "po-icon", "po-icon-star", "po-breadcrumb-favorite-star", "po-clickable"], ["class", "po-hidden-sm po-breadcrumb-favorite-label", 4, "ngIf"], [1, "po-hidden-sm", "po-breadcrumb-favorite-label"]], template: function PoBreadcrumbFavoriteComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoBreadcrumbFavoriteComponent_Template_div_click_0_listener() {
        return ctx.toggleFavoriteAction();
      })("keyup.enter", function PoBreadcrumbFavoriteComponent_Template_div_keyup_enter_0_listener() {
        return ctx.toggleFavoriteAction();
      });
      ɵɵelement(1, "span", 1);
      ɵɵtemplate(2, PoBreadcrumbFavoriteComponent_span_2_Template, 2, 1, "span", 2)(3, PoBreadcrumbFavoriteComponent_span_3_Template, 2, 1, "span", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵclassProp("po-breadcrumb-favorite-star-active", ctx.favorite);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.favorite && !ctx.hiddenLiteral);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.favorite && !ctx.hiddenLiteral);
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbFavoriteComponent, [{
    type: Component,
    args: [{ selector: "po-breadcrumb-favorite", providers: [PoBreadcrumbFavoriteService], template: '<div\n  tabindex="0"\n  role="button"\n  class="po-breadcrumb-favorite po-clickable"\n  (click)="toggleFavoriteAction()"\n  (keyup.enter)="toggleFavoriteAction()"\n>\n  <span\n    class="po-icon po-icon-star po-breadcrumb-favorite-star po-clickable"\n    [class.po-breadcrumb-favorite-star-active]="favorite"\n  >\n  </span>\n\n  <span class="po-hidden-sm po-breadcrumb-favorite-label" *ngIf="favorite && !hiddenLiteral">{{\n    literals?.unfavorite\n  }}</span>\n  <span class="po-hidden-sm po-breadcrumb-favorite-label" *ngIf="!favorite && !hiddenLiteral">{{\n    literals?.favorite\n  }}</span>\n</div>\n' }]
  }], () => [{ type: PoBreadcrumbFavoriteService }, { type: PoLanguageService }], { favoriteService: [{
    type: Input,
    args: ["p-favorite-service"]
  }], itemActive: [{
    type: Input,
    args: ["p-item-active"]
  }], paramsService: [{
    type: Input,
    args: ["p-params-service"]
  }], hiddenLiteral: [{
    type: Input,
    args: ["p-hidden-literal"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoBreadcrumbFavoriteComponent, { className: "PoBreadcrumbFavoriteComponent", filePath: "lib/components/po-breadcrumb/po-breadcrumb-favorite/po-breadcrumb-favorite.component.ts", lineNumber: 41 });
})();
var _c0$1x = ["breadcrumb"];
var _c1$C = ["dropdownIcon"];
var _c2$h = ["target"];
var _c3$b = ["popup"];
function PoBreadcrumbComponent_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "ul", 6, 7)(2, "li")(3, "po-link", 8);
    ɵɵlistener("p-action", function PoBreadcrumbComponent_ul_3_Template_po_link_p_action_3_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.emitAction(ctx_r7.itemsView[0]));
    });
    ɵɵelementEnd()();
    ɵɵelement(4, "po-icon", 9);
    ɵɵelementStart(5, "li", 10, 11);
    ɵɵlistener("click", function PoBreadcrumbComponent_ul_3_Template_li_click_5_listener() {
      ɵɵrestoreView(_r8);
      const _r6 = ɵɵreference(16);
      return ɵɵresetView(_r6.toggle());
    })("keyup", function PoBreadcrumbComponent_ul_3_Template_li_keyup_5_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.openPopup($event));
    });
    ɵɵelement(7, "po-icon", 12);
    ɵɵelementEnd();
    ɵɵelement(8, "po-icon", 9);
    ɵɵelementStart(9, "li")(10, "po-link", 8);
    ɵɵlistener("p-action", function PoBreadcrumbComponent_ul_3_Template_po_link_p_action_10_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.emitAction(ctx_r11.itemsView[ctx_r11.itemsView.length - 2]));
    });
    ɵɵelementEnd()();
    ɵɵelement(11, "po-icon", 9);
    ɵɵelementStart(12, "li")(13, "span", 13);
    ɵɵtext(14);
    ɵɵelementEnd()();
    ɵɵelementStart(15, "po-popup", 14, 15);
    ɵɵlistener("p-close", function PoBreadcrumbComponent_ul_3_Template_po_popup_p_close_15_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r12 = ɵɵnextContext();
      return ɵɵresetView(ctx_r12.closePopUp());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const _r5 = ɵɵreference(6);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("p-label", ctx_r1.itemsView[0].label)("p-url", ctx_r1.itemsView[0].link);
    ɵɵadvance(2);
    ɵɵattribute("aria-label", ctx_r1.literals.literalButtonPopup);
    ɵɵadvance(5);
    ɵɵproperty("p-label", ctx_r1.itemsView[ctx_r1.itemsView.length - 2].label)("p-url", ctx_r1.itemsView[ctx_r1.itemsView.length - 2].link);
    ɵɵadvance(3);
    ɵɵattribute("aria-current", ctx_r1.itemsView[ctx_r1.itemsView.length - 1].label);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.itemsView[ctx_r1.itemsView.length - 1].label);
    ɵɵadvance();
    ɵɵproperty("p-hide-arrow", true)("p-actions", ctx_r1.itemsViewPopup)("p-target", _r5);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_po_link_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-link", 8);
    ɵɵlistener("p-action", function PoBreadcrumbComponent_ul_4_li_1_po_link_1_Template_po_link_p_action_0_listener() {
      ɵɵrestoreView(_r21);
      const item_r14 = ɵɵnextContext().$implicit;
      const ctx_r19 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r19.emitAction(item_r14));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r14 = ɵɵnextContext().$implicit;
    ɵɵproperty("p-label", item_r14.label)("p-url", item_r14.link);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r14 = ɵɵnextContext().$implicit;
    ɵɵattribute("aria-current", item_r14.label);
    ɵɵadvance();
    ɵɵtextInterpolate(item_r14.label);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_po_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 9);
  }
}
function PoBreadcrumbComponent_ul_4_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 18);
    ɵɵtemplate(1, PoBreadcrumbComponent_ul_4_li_1_po_link_1_Template, 1, 2, "po-link", 19)(2, PoBreadcrumbComponent_ul_4_li_1_span_2_Template, 2, 2, "span", 20)(3, PoBreadcrumbComponent_ul_4_li_1_po_icon_3_Template, 1, 0, "po-icon", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const itemIndex_r15 = ctx.index;
    const ctx_r13 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(itemIndex_r15 === ctx_r13.itemsView.length - 1));
    ɵɵadvance();
    ɵɵproperty("ngIf", itemIndex_r15 === ctx_r13.itemsView.length - 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(itemIndex_r15 === ctx_r13.itemsView.length - 1));
  }
}
function PoBreadcrumbComponent_ul_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 16);
    ɵɵtemplate(1, PoBreadcrumbComponent_ul_4_li_1_Template, 4, 3, "li", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.itemsView);
  }
}
function PoBreadcrumbComponent_po_breadcrumb_favorite_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-breadcrumb-favorite", 22);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-favorite-service", ctx_r3.favoriteService)("p-item-active", ctx_r3.items[ctx_r3.items.length - 1])("p-params-service", ctx_r3.paramsService)("p-hidden-literal", ctx_r3.hiddenLiteralFavorite);
  }
}
var poBreadcrumbLiterals = {
  en: {
    literalButtonPopup: "Menu pop up collapsed"
  },
  es: {
    literalButtonPopup: "Menú pop up colapsado"
  },
  pt: {
    literalButtonPopup: "Menu pop up colapsado"
  },
  ru: {
    literalButtonPopup: "меню свернуто"
  }
};
var PoBreadcrumbComponent = class _PoBreadcrumbComponent extends PoBreadcrumbBaseComponent {
  element;
  renderer;
  languageService;
  breadcrumbElement;
  dropdownIcon;
  svgTarget;
  popupContainer;
  showDropdown = false;
  showDropdownToggle = false;
  dropdownItems;
  literals;
  hiddenLiteralFavorite = false;
  _breadcrumbItemsLenght = 0;
  calculatedElement = false;
  differ;
  hiddenWithoutResize = false;
  initialized = false;
  timeoutResize;
  constructor(differs, element, renderer, languageService) {
    super();
    this.element = element;
    this.renderer = renderer;
    this.languageService = languageService;
    this.differ = differs.find([]).create(null);
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, poBreadcrumbLiterals[language]);
  }
  ngAfterViewInit() {
    this.initialized = true;
    this.initializeResizeListener();
  }
  ngDoCheck() {
    const breadcrumbWidth = this.breadcrumbElement.nativeElement.offsetWidth;
    if (breadcrumbWidth && !this.calculatedElement && this.initialized) {
      this.initBreadcrumbSize();
    }
    if (this.hiddenWithoutResize) {
      this.debounceResize();
      this.hiddenWithoutResize = false;
    }
    this.checkChangeOnItems();
  }
  ngOnDestroy() {
    this.removeResizeListener();
  }
  emitAction(item) {
    if (item.action) {
      item.action();
    }
  }
  openPopup(event) {
    if (event.code === "Enter" || event.code === "Space") {
      this.popupContainer.open();
    }
  }
  closePopUp() {
    this.svgTarget.nativeElement.focus();
  }
  checkChangeOnItems() {
    if (this.differ) {
      const changes = this.differ.diff(this.items);
      if (changes) {
        this.calcBreadcrumbItemsWidth();
        this.calculatedElement = false;
      }
    }
  }
  calcBreadcrumb() {
    const breadcrumbFavorite = this.getBreadcrumbFavoriteWidth();
    const existLabel = this.existsFavoritelabel();
    const breadcrumb = this.getBreadcrumbWidth(breadcrumbFavorite, existLabel);
    const breadcrumbTooltip = this.getBreadcrumbTooltipWidth();
    if (breadcrumb <= this._breadcrumbItemsLenght) {
      this.enableBreadcrumbResponsive();
    } else {
      this.disableBreadcrumbResponsive();
    }
    if (breadcrumbTooltip && breadcrumb <= breadcrumbTooltip) {
      this.hiddenLiteralFavorite = true;
    } else {
      this.hiddenLiteralFavorite = false;
    }
  }
  getBreadcrumbFavoriteWidth() {
    return this.favoriteService ? this.element.nativeElement.querySelector(".po-breadcrumb-favorite").offsetWidth + 20 : 0;
  }
  getBreadcrumbTooltipWidth() {
    return this.favoriteService ? this.element.nativeElement.querySelector(".po-breadcrumb-tooltip")?.offsetWidth : 0;
  }
  existsFavoritelabel() {
    return !!this.element.nativeElement.querySelector(".po-breadcrumb-favorite-label");
  }
  getBreadcrumbWidth(breadcrumbFavorite, existLabel) {
    const widthSpan = !existLabel ? 95 : 0;
    return this.element.nativeElement.querySelector(".po-breadcrumb").offsetWidth - (breadcrumbFavorite + widthSpan);
  }
  calcBreadcrumbItemsWidth() {
    const breadcrumbItem = this.element.nativeElement.querySelectorAll(".po-breadcrumb-item");
    this._breadcrumbItemsLenght = Array.from(breadcrumbItem).map((breadcrumb) => breadcrumb["offsetWidth"]).reduce((a, b) => a + b, 16);
  }
  enableBreadcrumbResponsive() {
    this.showDropdownToggle = true;
  }
  disableBreadcrumbResponsive() {
    this.showDropdownToggle = false;
    this.itemsView = [].concat(this.items);
    this.showDropdown = false;
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      if (this.calculatedElement && !this.hiddenWithoutResize && this.breadcrumbElement.nativeElement.offsetWidth === 0) {
        this.hiddenWithoutResize = true;
      } else {
        this.calcBreadcrumb();
      }
    }, 50);
  }
  initBreadcrumbSize() {
    this.calcBreadcrumbItemsWidth();
    this.calcBreadcrumb();
    this.calculatedElement = true;
  }
  initializeResizeListener() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  removeResizeListener() {
    this.resizeListener();
  }
  static ɵfac = function PoBreadcrumbComponent_Factory(t) {
    return new (t || _PoBreadcrumbComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoBreadcrumbComponent, selectors: [["po-breadcrumb"]], viewQuery: function PoBreadcrumbComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1x, 7, ElementRef);
      ɵɵviewQuery(_c1$C, 5, ElementRef);
      ɵɵviewQuery(_c2$h, 5, ElementRef);
      ɵɵviewQuery(_c3$b, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.breadcrumbElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownIcon = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgTarget = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupContainer = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 6, vars: 3, consts: [[1, "po-breadcrumb"], ["breadcrumb", ""], [1, "po-breadcrumb-items"], ["class", "po-breadcrumb-item po-clickable po-breadcrumb-tooltip", 4, "ngIf"], ["class", "po-breadcrumb-item-container", 4, "ngIf"], [3, "p-favorite-service", "p-item-active", "p-params-service", "p-hidden-literal", 4, "ngIf"], [1, "po-breadcrumb-item", "po-clickable", "po-breadcrumb-tooltip"], ["dropdownIcon", ""], [3, "p-label", "p-url", "p-action"], ["p-icon", "po-icon-arrow-right po-breadcrumb-icon-arrow"], ["role", "button", "tabindex", "0", 1, "po-breadcrumb-icon-more", 3, "click", "keyup"], ["target", ""], ["p-icon", "po-icon-more-vert"], ["role", "link", "tabindex", "0", 1, "po-breadcrumb-item-activate"], ["p-position", "bottom-right", 3, "p-hide-arrow", "p-actions", "p-target", "p-close"], ["popup", ""], [1, "po-breadcrumb-item-container"], ["class", "po-breadcrumb-item", 4, "ngFor", "ngForOf"], [1, "po-breadcrumb-item"], [3, "p-label", "p-url", "p-action", 4, "ngIf"], ["class", "po-breadcrumb-item-activate", "role", "link", "tabindex", "0", 4, "ngIf"], ["p-icon", "po-icon-arrow-right po-breadcrumb-icon-arrow", 4, "ngIf"], [3, "p-favorite-service", "p-item-active", "p-params-service", "p-hidden-literal"]], template: function PoBreadcrumbComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nav", 0, 1)(2, "div", 2);
      ɵɵtemplate(3, PoBreadcrumbComponent_ul_3_Template, 17, 10, "ul", 3)(4, PoBreadcrumbComponent_ul_4_Template, 2, 1, "ul", 4);
      ɵɵelementEnd();
      ɵɵtemplate(5, PoBreadcrumbComponent_po_breadcrumb_favorite_5_Template, 1, 4, "po-breadcrumb-favorite", 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showDropdownToggle && ctx.itemsView.length >= 4);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.showDropdownToggle || ctx.itemsView.length < 4);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.favoriteService);
    }
  }, dependencies: [NgForOf, NgIf, PoLinkComponent, PoPopupComponent, PoIconComponent, PoBreadcrumbFavoriteComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbComponent, [{
    type: Component,
    args: [{ selector: "po-breadcrumb", template: '<nav class="po-breadcrumb" #breadcrumb>\n  <div class="po-breadcrumb-items">\n    <ul\n      #dropdownIcon\n      *ngIf="showDropdownToggle && itemsView.length >= 4"\n      class="po-breadcrumb-item po-clickable po-breadcrumb-tooltip"\n    >\n      <li>\n        <po-link\n          [p-label]="itemsView[0].label"\n          [p-url]="itemsView[0].link"\n          (p-action)="emitAction(itemsView[0])"\n        ></po-link>\n      </li>\n\n      <po-icon p-icon="po-icon-arrow-right po-breadcrumb-icon-arrow"></po-icon>\n\n      <li\n        #target\n        class="po-breadcrumb-icon-more"\n        [attr.aria-label]="literals.literalButtonPopup"\n        role="button"\n        tabindex="0"\n        (click)="popup.toggle()"\n        (keyup)="openPopup($event)"\n      >\n        <po-icon p-icon="po-icon-more-vert"></po-icon>\n      </li>\n      <po-icon p-icon="po-icon-arrow-right po-breadcrumb-icon-arrow"></po-icon>\n\n      <li>\n        <po-link\n          [p-label]="itemsView[itemsView.length - 2].label"\n          [p-url]="itemsView[itemsView.length - 2].link"\n          (p-action)="emitAction(itemsView[itemsView.length - 2])"\n        ></po-link>\n      </li>\n      <po-icon p-icon="po-icon-arrow-right po-breadcrumb-icon-arrow"></po-icon>\n\n      <li>\n        <span\n          class="po-breadcrumb-item-activate"\n          role="link"\n          tabindex="0"\n          [attr.aria-current]="itemsView[itemsView.length - 1].label"\n          >{{ itemsView[itemsView.length - 1].label }}</span\n        >\n      </li>\n      <po-popup\n        #popup\n        p-position="bottom-right"\n        (p-close)="closePopUp()"\n        [p-hide-arrow]="true"\n        [p-actions]="itemsViewPopup"\n        [p-target]="target"\n      >\n      </po-popup>\n    </ul>\n\n    <ul *ngIf="!showDropdownToggle || itemsView.length < 4" class="po-breadcrumb-item-container">\n      <li *ngFor="let item of itemsView; let itemIndex = index" class="po-breadcrumb-item">\n        <po-link\n          *ngIf="!(itemIndex === itemsView.length - 1)"\n          [p-label]="item.label"\n          [p-url]="item.link"\n          (p-action)="emitAction(item)"\n        ></po-link>\n        <span\n          class="po-breadcrumb-item-activate"\n          role="link"\n          tabindex="0"\n          *ngIf="itemIndex === itemsView.length - 1"\n          [attr.aria-current]="item.label"\n          >{{ item.label }}</span\n        >\n        <po-icon\n          *ngIf="!(itemIndex === itemsView.length - 1)"\n          p-icon="po-icon-arrow-right po-breadcrumb-icon-arrow"\n        ></po-icon>\n      </li>\n    </ul>\n  </div>\n\n  <po-breadcrumb-favorite\n    *ngIf="favoriteService"\n    [p-favorite-service]="favoriteService"\n    [p-item-active]="items[items.length - 1]"\n    [p-params-service]="paramsService"\n    [p-hidden-literal]="hiddenLiteralFavorite"\n  >\n  </po-breadcrumb-favorite>\n</nav>\n' }]
  }], () => [{ type: IterableDiffers }, { type: ElementRef }, { type: Renderer2 }, { type: PoLanguageService }], { breadcrumbElement: [{
    type: ViewChild,
    args: ["breadcrumb", { read: ElementRef, static: true }]
  }], dropdownIcon: [{
    type: ViewChild,
    args: ["dropdownIcon", { read: ElementRef }]
  }], svgTarget: [{
    type: ViewChild,
    args: ["target", { read: ElementRef }]
  }], popupContainer: [{
    type: ViewChild,
    args: ["popup"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoBreadcrumbComponent, { className: "PoBreadcrumbComponent", filePath: "lib/components/po-breadcrumb/po-breadcrumb.component.ts", lineNumber: 51 });
})();
var PoLinkModule = class _PoLinkModule {
  static ɵfac = function PoLinkModule_Factory(t) {
    return new (t || _PoLinkModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoLinkModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLinkModule, [{
    type: NgModule,
    args: [{
      declarations: [PoLinkComponent],
      imports: [CommonModule, RouterModule],
      exports: [PoLinkComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLinkModule, { declarations: [PoLinkComponent], imports: [CommonModule, RouterModule], exports: [PoLinkComponent] });
})();
var PoLabelModule = class _PoLabelModule {
  static ɵfac = function PoLabelModule_Factory(t) {
    return new (t || _PoLabelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoLabelModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLabelModule, [{
    type: NgModule,
    args: [{
      declarations: [PoLabelComponent],
      exports: [PoLabelComponent],
      imports: [CommonModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLabelModule, { declarations: [PoLabelComponent], imports: [CommonModule], exports: [PoLabelComponent] });
})();
var PoCheckboxModule = class _PoCheckboxModule {
  static ɵfac = function PoCheckboxModule_Factory(t) {
    return new (t || _PoCheckboxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoCheckboxModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoLabelModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxModule, [{
    type: NgModule,
    args: [{
      declarations: [PoCheckboxComponent],
      exports: [PoCheckboxComponent],
      imports: [CommonModule, FormsModule, PoLabelModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCheckboxModule, { declarations: [PoCheckboxComponent], imports: [CommonModule, FormsModule, PoLabelModule], exports: [PoCheckboxComponent] });
})();
var PoOverlayModule = class _PoOverlayModule {
  static ɵfac = function PoOverlayModule_Factory(t) {
    return new (t || _PoOverlayModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoOverlayModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoOverlayModule, [{
    type: NgModule,
    args: [{
      declarations: [PoOverlayComponent],
      imports: [CommonModule],
      exports: [PoOverlayComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoOverlayModule, { declarations: [PoOverlayComponent], imports: [CommonModule], exports: [PoOverlayComponent] });
})();
var PoLoadingModule = class _PoLoadingModule {
  static ɵfac = function PoLoadingModule_Factory(t) {
    return new (t || _PoLoadingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoLoadingModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoLanguageModule, PoOverlayModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoadingModule, [{
    type: NgModule,
    args: [{
      declarations: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent],
      exports: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent],
      imports: [CommonModule, PoLanguageModule, PoOverlayModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLoadingModule, { declarations: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent], imports: [CommonModule, PoLanguageModule, PoOverlayModule], exports: [PoLoadingComponent, PoLoadingIconComponent, PoLoadingOverlayComponent] });
})();
var PoListBoxModule = class _PoListBoxModule {
  static ɵfac = function PoListBoxModule_Factory(t) {
    return new (t || _PoListBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoListBoxModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoCheckboxModule, PoIconModule, PoLoadingModule, CdkListboxModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListBoxModule, [{
    type: NgModule,
    args: [{
      declarations: [PoListBoxComponent, PoItemListComponent, PoSearchListComponent],
      exports: [PoListBoxComponent],
      imports: [CommonModule, PoCheckboxModule, PoIconModule, PoLoadingModule, CdkListboxModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoListBoxModule, { declarations: [PoListBoxComponent, PoItemListComponent, PoSearchListComponent], imports: [CommonModule, PoCheckboxModule, PoIconModule, PoLoadingModule, CdkListboxModule], exports: [PoListBoxComponent] });
})();
var PoPopupModule = class _PoPopupModule {
  static ɵfac = function PoPopupModule_Factory(t) {
    return new (t || _PoPopupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoPopupModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoListBoxModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoListBoxModule],
      declarations: [PoPopupComponent],
      exports: [PoPopupComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPopupModule, { declarations: [PoPopupComponent], imports: [CommonModule, PoListBoxModule], exports: [PoPopupComponent] });
})();
var PoBreadcrumbModule = class _PoBreadcrumbModule {
  static ɵfac = function PoBreadcrumbModule_Factory(t) {
    return new (t || _PoBreadcrumbModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoBreadcrumbModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule, PoLinkModule, PoPopupModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBreadcrumbModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoLinkModule, PoPopupModule, PoIconModule],
      declarations: [PoBreadcrumbComponent, PoBreadcrumbFavoriteComponent],
      exports: [PoBreadcrumbComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoBreadcrumbModule, { declarations: [PoBreadcrumbComponent, PoBreadcrumbFavoriteComponent], imports: [CommonModule, RouterModule, PoLinkModule, PoPopupModule, PoIconModule], exports: [PoBreadcrumbComponent] });
})();
var PoButtonKind;
(function(PoButtonKind2) {
  PoButtonKind2["primary"] = "primary";
  PoButtonKind2["secondary"] = "secondary";
  PoButtonKind2["tertiary"] = "tertiary";
})(PoButtonKind || (PoButtonKind = {}));
var PoButtonSize;
(function(PoButtonSize2) {
  PoButtonSize2["medium"] = "medium";
  PoButtonSize2["large"] = "large";
})(PoButtonSize || (PoButtonSize = {}));
var PoButtonBaseComponent = class _PoButtonBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Label do botão.
   */
  label;
  /**
   * @optional
   *
   * @description
   * Ícone exibido ao lado esquerdo do label do botão.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-button p-icon="po-icon-user" p-label="PO button"></po-button>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-button p-icon="fa fa-podcast" p-label="PO button"></po-button>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-button [p-icon]="template" p-label="button template ionic"></po-button>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  icon;
  /** Ação que será executada quando o usuário clicar sobre o `po-button`. */
  click = new EventEmitter();
  _danger = false;
  _disabled = false;
  _loading = false;
  _kind = PoButtonKind.secondary;
  _size = PoButtonSize.medium;
  hasSize = false;
  /**
   * @optional
   *
   * @description
   *
   * Exibe um ícone de carregamento à esquerda do _label_ do botão.
   *
   * > Quando esta propriedade estiver habilitada, desabilitará o botão.
   *
   * @default `false`
   */
  set loading(value) {
    this._loading = convertToBoolean(value);
  }
  get loading() {
    return this._loading;
  }
  /**
   * @optional
   *
   * @description
   *
   * Deve ser usado em ações irreversíveis que o usuário precisa ter cuidado ao executá-la, como a exclusão de um registro.
   *
   * > A propriedade `p-kind="tertiary"` será inativada ao utilizar esta propriedade.
   */
  set danger(value) {
    this._danger = this.kind !== PoButtonKind.tertiary ? value : false;
  }
  get danger() {
    return this._danger;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do `po-button`.
   *
   * Valores válidos:
   * - `medium`: o `po-button` fica do tamanho padrão, com 44px de altura.;
   * - `large`: o `po-button` fica maior, com 56px de altura.;
   *
   * @default `medium`
   *
   */
  set size(value) {
    this._size = PoButtonSize[value] ? PoButtonSize[value] : PoButtonSize.medium;
    this.hasSize = true;
  }
  get size() {
    return this._size;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o estilo do `po-button`.
   *
   * Valores válidos:
   *  - `primary`: deixa o `po-button` com destaque, deve ser usado para ações primárias.
   *  - `secondary`: estilo padrão do `po-button`.
   *  - `tertiary`: o `po-button` é exibido sem cor do fundo, recebendo menos destaque entre as ações.
   *
   * @default `secondary`
   */
  set kind(value) {
    this._kind = PoButtonKind[value] ? PoButtonKind[value] : PoButtonKind.secondary;
  }
  get kind() {
    return this._kind;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o `po-button` e não permite que o usuário interaja com o mesmo.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = value === "" ? true : convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define um `aria-label` para o `po-button`.
   *
   * Caso esta propriedade não seja informada será considerada a label do botão.
   *
   * > Em caso de botões com apenas ícone a atribuição de valor à esta propriedade é muito importante para acessibilidade.
   */
  ariaLabel;
  static ɵfac = function PoButtonBaseComponent_Factory(t) {
    return new (t || _PoButtonBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoButtonBaseComponent, hostVars: 3, hostBindings: function PoButtonBaseComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("p-danger", ctx.danger)("p-size", ctx.size)("p-kind", ctx.kind);
    }
  }, inputs: { label: [InputFlags.None, "p-label", "label"], icon: [InputFlags.None, "p-icon", "icon"], loading: [InputFlags.None, "p-loading", "loading"], danger: [InputFlags.HasDecoratorInputTransform, "p-danger", "danger", convertToBoolean], size: [InputFlags.None, "p-size", "size"], kind: [InputFlags.None, "p-kind", "kind"], disabled: [InputFlags.None, "p-disabled", "disabled"], ariaLabel: [InputFlags.None, "p-aria-label", "ariaLabel"] }, outputs: { click: "p-click" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonBaseComponent, [{
    type: Directive
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], loading: [{
    type: Input,
    args: ["p-loading"]
  }], danger: [{
    type: HostBinding,
    args: ["attr.p-danger"]
  }, {
    type: Input,
    args: [{ alias: "p-danger", transform: convertToBoolean }]
  }], size: [{
    type: HostBinding,
    args: ["attr.p-size"]
  }, {
    type: Input,
    args: ["p-size"]
  }], kind: [{
    type: HostBinding,
    args: ["attr.p-kind"]
  }, {
    type: Input,
    args: ["p-kind"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], ariaLabel: [{
    type: Input,
    args: ["p-aria-label"]
  }] });
})();
var _c0$1w = ["button"];
function PoButtonComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "po-loading-icon", 7);
    ɵɵelementEnd();
  }
}
function PoButtonComponent_po_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 8);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r2.icon);
  }
}
function PoButtonComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.label);
  }
}
var PoButtonComponent = class _PoButtonComponent extends PoButtonBaseComponent {
  buttonElement;
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoButtonComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoButtonComponent, { static: true }) button: PoButtonComponent;
   *
   * focusButton() {
   *   this.button.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.buttonElement.nativeElement.focus();
    }
  }
  onClick() {
    this.click.emit(null);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoButtonComponent_BaseFactory;
    return function PoButtonComponent_Factory(t) {
      return (ɵPoButtonComponent_BaseFactory || (ɵPoButtonComponent_BaseFactory = ɵɵgetInheritedFactory(_PoButtonComponent)))(t || _PoButtonComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoButtonComponent, selectors: [["po-button"]], viewQuery: function PoButtonComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1w, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttonElement = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 6, vars: 8, consts: [["type", "button", 1, "po-button", 3, "disabled", "click"], ["button", ""], ["class", "po-button-loading-icon", 4, "ngIf"], [1, "po-button-container"], ["class", "po-button-icon", 3, "p-icon", 4, "ngIf"], ["class", "po-button-label", 4, "ngIf"], [1, "po-button-loading-icon"], ["p-neutral-color", "", "p-size", "sm"], [1, "po-button-icon", 3, "p-icon"], [1, "po-button-label"]], template: function PoButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0, 1);
      ɵɵlistener("click", function PoButtonComponent_Template_button_click_0_listener() {
        return ctx.onClick();
      });
      ɵɵtemplate(2, PoButtonComponent_div_2_Template, 2, 0, "div", 2);
      ɵɵelementStart(3, "div", 3);
      ɵɵtemplate(4, PoButtonComponent_po_icon_4_Template, 1, 1, "po-icon", 4)(5, PoButtonComponent_span_5_Template, 2, 1, "span", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("disabled", ctx.disabled || ctx.loading);
      ɵɵattribute("p-size", ctx.size)("p-kind", ctx.kind)("p-danger", ctx.danger)("aria-label", ctx.ariaLabel);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.loading);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label);
    }
  }, dependencies: [NgIf, PoLoadingIconComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonComponent, [{
    type: Component,
    args: [{ selector: "po-button", changeDetection: ChangeDetectionStrategy.OnPush, template: '<button\n  #button\n  class="po-button"\n  type="button"\n  [attr.p-size]="size"\n  [attr.p-kind]="kind"\n  [attr.p-danger]="danger"\n  [disabled]="disabled || loading"\n  [attr.aria-label]="ariaLabel"\n  (click)="onClick()"\n>\n  <div *ngIf="loading" class="po-button-loading-icon">\n    <po-loading-icon p-neutral-color p-size="sm"></po-loading-icon>\n  </div>\n\n  <div class="po-button-container">\n    <po-icon *ngIf="icon" class="po-button-icon" [p-icon]="icon"></po-icon>\n    <span *ngIf="label" class="po-button-label">{{ label }}</span>\n  </div>\n</button>\n' }]
  }], null, { buttonElement: [{
    type: ViewChild,
    args: ["button", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoButtonComponent, { className: "PoButtonComponent", filePath: "lib/components/po-button/po-button.component.ts", lineNumber: 34 });
})();
var PoButtonModule = class _PoButtonModule {
  static ɵfac = function PoButtonModule_Factory(t) {
    return new (t || _PoButtonModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoButtonModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoLoadingModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoLoadingModule, PoIconModule],
      declarations: [PoButtonComponent],
      exports: [PoButtonComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoButtonModule, { declarations: [PoButtonComponent], imports: [CommonModule, PoLoadingModule, PoIconModule], exports: [PoButtonComponent] });
})();
var PoButtonGroupToggle;
(function(PoButtonGroupToggle2) {
  PoButtonGroupToggle2["Multiple"] = "multiple";
  PoButtonGroupToggle2["None"] = "none";
  PoButtonGroupToggle2["Single"] = "single";
})(PoButtonGroupToggle || (PoButtonGroupToggle = {}));
var PO_TOGGLE_TYPE_DEFAULT = "none";
var PoButtonGroupBaseComponent = class _PoButtonGroupBaseComponent {
  /** Lista de botões. */
  buttons = [];
  _toggle = PO_TOGGLE_TYPE_DEFAULT;
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de seleção de botões.
   *
   * > Veja os valores válidos no *enum* `PoButtonGroupToggle`.
   *
   * @default `none`
   */
  set toggle(value) {
    this._toggle = Object.values(PoButtonGroupToggle).includes(value) ? value : PO_TOGGLE_TYPE_DEFAULT;
    this.checkSelecteds(this._toggle);
  }
  get toggle() {
    return this._toggle;
  }
  onButtonClick(buttonClicked, buttonIndex) {
    if (this.toggle === PoButtonGroupToggle.Single) {
      this.buttons.forEach((button, index) => button.selected = index === buttonIndex ? !buttonClicked.selected : false);
    } else if (this.toggle === PoButtonGroupToggle.Multiple) {
      buttonClicked.selected = !buttonClicked.selected;
    }
  }
  checkSelecteds(toggleMode) {
    if (toggleMode === PoButtonGroupToggle.None) {
      this.deselectAllButtons();
    } else if (toggleMode === PoButtonGroupToggle.Single) {
      const hasMoreOneSelected = this.buttons.filter((button) => button.selected).length > 1;
      if (hasMoreOneSelected) {
        this.deselectAllButtons();
      }
    }
  }
  deselectAllButtons() {
    this.buttons.forEach((button) => button.selected = false);
  }
  static ɵfac = function PoButtonGroupBaseComponent_Factory(t) {
    return new (t || _PoButtonGroupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoButtonGroupBaseComponent, inputs: { buttons: [InputFlags.None, "p-buttons", "buttons"], toggle: [InputFlags.None, "p-toggle", "toggle"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonGroupBaseComponent, [{
    type: Directive
  }], null, { buttons: [{
    type: Input,
    args: ["p-buttons"]
  }], toggle: [{
    type: Input,
    args: ["p-toggle"]
  }] });
})();
function PoButtonGroupComponent_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 2);
    ɵɵlistener("p-click", function PoButtonGroupComponent_po_button_1_Template_po_button_p_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r4);
      const button_r1 = restoredCtx.$implicit;
      const i_r2 = restoredCtx.index;
      const ctx_r3 = ɵɵnextContext();
      ctx_r3.onButtonClick(button_r1, i_r2);
      return ɵɵresetView(button_r1.action(button_r1));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const button_r1 = ctx.$implicit;
    ɵɵclassProp("po-button-group-button-selected", button_r1.selected)("po-button-group-disabled", button_r1.disabled);
    ɵɵproperty("p-disabled", button_r1.disabled)("p-icon", button_r1.icon)("p-label", button_r1.label)("p-tooltip", !button_r1.disabled ? button_r1.tooltip : void 0);
  }
}
var PoButtonGroupComponent = class _PoButtonGroupComponent extends PoButtonGroupBaseComponent {
  constructor(viewRef) {
    super();
  }
  static ɵfac = function PoButtonGroupComponent_Factory(t) {
    return new (t || _PoButtonGroupComponent)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoButtonGroupComponent, selectors: [["po-button-group"]], features: [ɵɵInheritDefinitionFeature], decls: 2, vars: 1, consts: [[1, "po-button-group-container"], ["class", "po-sm-12 po-button-group", "p-tooltip-position", "bottom", 3, "po-button-group-button-selected", "po-button-group-disabled", "p-disabled", "p-icon", "p-label", "p-tooltip", "p-click", 4, "ngFor", "ngForOf"], ["p-tooltip-position", "bottom", 1, "po-sm-12", "po-button-group", 3, "p-disabled", "p-icon", "p-label", "p-tooltip", "p-click"]], template: function PoButtonGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoButtonGroupComponent_po_button_1_Template, 1, 8, "po-button", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.buttons);
    }
  }, dependencies: [NgForOf, PoButtonComponent, PoTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonGroupComponent, [{
    type: Component,
    args: [{ selector: "po-button-group", template: '<div class="po-button-group-container">\n  <po-button\n    *ngFor="let button of buttons; index as i"\n    class="po-sm-12 po-button-group"\n    [class.po-button-group-button-selected]="button.selected"\n    [class.po-button-group-disabled]="button.disabled"\n    p-tooltip-position="bottom"\n    [p-disabled]="button.disabled"\n    [p-icon]="button.icon"\n    [p-label]="button.label"\n    [p-tooltip]="!button.disabled ? button.tooltip : undefined"\n    (p-click)="onButtonClick(button, i); button.action(button)"\n  >\n  </po-button>\n</div>\n' }]
  }], () => [{ type: ViewContainerRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoButtonGroupComponent, { className: "PoButtonGroupComponent", filePath: "lib/components/po-button-group/po-button-group.component.ts", lineNumber: 35 });
})();
var PoButtonGroupModule = class _PoButtonGroupModule {
  static ɵfac = function PoButtonGroupModule_Factory(t) {
    return new (t || _PoButtonGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoButtonGroupModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoButtonModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoButtonGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoButtonModule, PoTooltipModule],
      declarations: [PoButtonGroupComponent],
      exports: [PoButtonGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoButtonGroupModule, { declarations: [PoButtonGroupComponent], imports: [CommonModule, PoButtonModule, PoTooltipModule], exports: [PoButtonGroupComponent] });
})();
var PoCalendarMode;
(function(PoCalendarMode2) {
  PoCalendarMode2["Range"] = "range";
})(PoCalendarMode || (PoCalendarMode = {}));
var PoDateService = class _PoDateService {
  dateRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])$");
  isoRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])(?:|:?[0-5]\\d)$");
  /**
   * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
   *
   * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
   * @param minDate Definir `true` caso seja `minDate`.
   * @param maxDate Definir `true` caso seja `maxDate`.
   */
  convertIsoToDate(dateString, minDate, maxDate) {
    if (dateString) {
      const { year, month, day } = this.getDateFromIso(dateString);
      if (minDate) {
        const date = new Date(year, month - 1, day, 0, 0, 0);
        this.setYearFrom0To100(date, year);
        return date;
      } else if (maxDate) {
        const date = new Date(year, month - 1, day, 23, 59, 59);
        this.setYearFrom0To100(date, year);
        return date;
      } else {
        const miliseconds = Date.parse(dateString);
        const timezone = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 6e4;
        return new Date(miliseconds + timezone);
      }
    }
  }
  /**
   * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
   *
   * @param date Data no formato `Date`.
   */
  convertDateToISO(date) {
    if (date) {
      const fullYear = date.getFullYear();
      const getMonth = date.getMonth() + 1;
      const day = date.getDate() < 10 ? "0" + date.getDate() : date.getDate();
      const month = getMonth < 10 ? "0" + getMonth : getMonth;
      const year = this.formatYear(fullYear);
      return year + "-" + month + "-" + day;
    } else {
      return null;
    }
  }
  /**
   * Método responsável por adicionar zeros a esquerda do anos em formato string.
   *
   * @param year Ano a ser validado.
   */
  formatYear(year) {
    if (year > 999) {
      return year.toString();
    }
    if (year > 99 && year < 1e3) {
      return `0${year}`;
    }
    if (year > 9 && year < 100) {
      return `00${year}`;
    }
    if (year >= 0 && year < 10) {
      return `000${year}`;
    }
  }
  /**
   * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
   *
   * @param isoDate Ano em formato string.
   */
  getDateFromIso(isoDate) {
    const day = parseInt(isoDate.substring(8, 10), 10);
    const month = parseInt(isoDate.substring(5, 7), 10);
    const year = parseInt(isoDate.substring(0, 4), 10);
    return { year, month, day };
  }
  /**
   * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
   * caso `isMindate` seja igual a `false` .
   *
   * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
   * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
   */
  getDateForDateRange(date, isMinDate) {
    const lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
    if (date instanceof Date) {
      const { year, month, day } = this.splitDate(date);
      const validDate = new Date(year, month, day, ...lastHour);
      this.setYearFrom0To100(validDate, year);
      return validDate;
    } else if (this.isValidIso(date)) {
      return this.convertIsoToDate(date, isMinDate, !isMinDate);
    }
  }
  /**
   * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
   *
   * @param dateA primeira data
   * @param dateB segunda data
   */
  isDateRangeValid(dateA = "", dateB = "") {
    const dateASplitted = dateA.split("-").map((item) => parseInt(item, 10));
    const dateBSplitted = dateB.split("-").map((item) => parseInt(item, 10));
    for (let index = 0; index <= dateASplitted.length; index++) {
      if (dateASplitted[index] > dateBSplitted[index]) {
        return true;
      } else if (dateASplitted[index] < dateBSplitted[index]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
   *
   * @param stringDate Data.
   */
  isValidIso(stringDate) {
    return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
  }
  /**
   * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
   *
   * @param date Data.
   * @param year .
   */
  setYearFrom0To100(date, year) {
    if (year >= 0 && year < 100) {
      date.setFullYear(year);
    }
  }
  /**
   * Método responsável por retornar o dia , mês e ano de uma data informada.
   *
   * @param date Valor da data.
   */
  splitDate(date) {
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    return { year, month, day };
  }
  /**
   * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
   *
   * @param date Data a ser validada.
   * @param minDate Data inicial.
   * @param maxDate Data final.
   */
  validateDateRange(date, minDate, maxDate) {
    if (minDate && maxDate) {
      return date >= minDate && date <= maxDate;
    } else if (minDate && !maxDate) {
      return date >= minDate;
    } else if (!minDate && maxDate) {
      return date <= maxDate;
    } else {
      return true;
    }
  }
  /**
   * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
   * 'Date' padrão do javascript.
   *
   * @param date Data que será validada.
   */
  validateDate(date) {
    const validDate = date instanceof Date ? this.convertDateToISO(date) : date;
    return this.isValidIso(validDate) ? validDate : void 0;
  }
  static ɵfac = function PoDateService_Factory(t) {
    return new (t || _PoDateService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoDateService, factory: _PoDateService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoDateTimeModule = class _PoDateTimeModule {
  static ɵfac = function PoDateTimeModule_Factory(t) {
    return new (t || _PoDateTimeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDateTimeModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoDateService] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDateTimeModule, [{
    type: NgModule,
    args: [{
      providers: [PoDateService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoCalendarBaseComponent = class _PoCalendarBaseComponent {
  poDate;
  languageService;
  /** Evento disparado ao selecionar um dia do calendário. */
  change = new EventEmitter();
  activateDate;
  value;
  onTouched = null;
  propagateChange = null;
  today = /* @__PURE__ */ new Date();
  shortLanguage;
  _locale;
  _maxDate;
  _minDate;
  _mode;
  /**
   * @optional
   *
   * @description
   *
   * Idioma do calendário.
   *
   * > O locale padrão sera recuperado com base no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set locale(locale) {
    this._locale = poLocales.includes(locale) ? locale : this.shortLanguage;
  }
  get locale() {
    return this._locale;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a data máxima possível de ser selecionada.
   *
   * Pode receber os seguintes formatos de data:
   *
   * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
   * ```
   * this.date = '2017-11-28T00:00:00-02:00';
   * ```
   *
   * - **Data (E8601DAw.): yyyy-mm-dd**
   * ```
   * this.date = '2017-11-28';
   * ```
   *
   * - **JavaScript Date Object:**
   * ```
   * this.date = new Date(2017, 10, 28);
   * ```
   */
  set maxDate(maxDate) {
    this._maxDate = this.poDate.getDateForDateRange(maxDate, false);
  }
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a data mínima possível de ser selecionada.
   *
   * Pode receber os seguintes formatos de data:
   *
   * - **Data e hora combinados (E8601DZw): yyyy-mm-ddThh:mm:ss+|-hh:mm**
   * ```
   * this.date = '2017-11-28T00:00:00-02:00';
   * ```
   *
   * - **Data (E8601DAw.): yyyy-mm-dd**
   * ```
   * this.date = '2017-11-28';
   * ```
   *
   * - **JavaScript Date Object:**
   * ```
   * this.date = new Date(2017, 10, 28);
   * ```
   */
  set minDate(minDate) {
    this._minDate = this.poDate.getDateForDateRange(minDate, true);
  }
  get minDate() {
    return this._minDate;
  }
  /**
   * Propriedade que permite informar o modo de exibição do calendar.
   *
   * Implementa o enum `PoCalendarMode`.
   */
  set mode(value) {
    this._mode = value;
    this.setActivateDate();
  }
  get mode() {
    return this._mode;
  }
  get isRange() {
    return this.mode === PoCalendarMode.Range;
  }
  constructor(poDate, languageService) {
    this.poDate = poDate;
    this.languageService = languageService;
    this.shortLanguage = languageService.getShortLanguage();
    this._locale = this.languageService.getShortLanguage();
  }
  setActivateDate(date) {
    let newData;
    if (typeof date !== "string") {
      const temporaryDate = new Date(date);
      const year = temporaryDate.getFullYear();
      const month = ("0" + (temporaryDate.getMonth() + 1)).slice(-2);
      const day = ("0" + temporaryDate.getDate()).slice(-2);
      const formattedDate = `${year}-${month}-${day}`;
      newData = formattedDate + "T00:00:00";
    } else {
      newData = date + "T00:00:00";
    }
    const activateDate = date ? date : this.verifyActivateDate();
    let checkedStart;
    let checkedEnd;
    if (this.isRange) {
      if (new Date(newData).getDate() > 28) {
        checkedStart = new Date(activateDate);
        checkedEnd = new Date(checkedStart.getFullYear(), checkedStart.getMonth() + 1, 0, 23, 59, 59, 999);
        checkedEnd.setMilliseconds(checkedEnd.getMilliseconds() + 1);
      } else {
        checkedStart = typeof activateDate === "string" ? this.poDate.convertIsoToDate(activateDate) : new Date(activateDate);
        checkedEnd = new Date(new Date(checkedStart).setMonth(checkedStart.getMonth() + 1));
      }
      this.activateDate = { start: checkedStart, end: checkedEnd };
    } else {
      this.activateDate = new Date(activateDate);
    }
  }
  verifyActivateDate() {
    let today = this.today;
    if (this.minDate && this.minDate > this.today) {
      today = this.minDate;
    } else if (this.maxDate && this.maxDate < this.today) {
      today = this.maxDate;
    }
    return today;
  }
  static ɵfac = function PoCalendarBaseComponent_Factory(t) {
    return new (t || _PoCalendarBaseComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoCalendarBaseComponent, inputs: { locale: [InputFlags.None, "p-locale", "locale"], maxDate: [InputFlags.None, "p-max-date", "maxDate"], minDate: [InputFlags.None, "p-min-date", "minDate"], mode: [InputFlags.None, "p-mode", "mode"] }, outputs: { change: "p-change" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarBaseComponent, [{
    type: Directive
  }], () => [{ type: PoDateService }, { type: PoLanguageService }], { change: [{
    type: Output,
    args: ["p-change"]
  }], locale: [{
    type: Input,
    args: ["p-locale"]
  }], maxDate: [{
    type: Input,
    args: ["p-max-date"]
  }], minDate: [{
    type: Input,
    args: ["p-min-date"]
  }], mode: [{
    type: Input,
    args: ["p-mode"]
  }] });
})();
var poCalendarServiceFirstWeekDayDefault = 0;
var PoCalendarService = class _PoCalendarService {
  monthDates(year, month, dayFormatter = null, weekFormatter = null) {
    if (typeof month !== "number" || month < 0 || month > 11) {
      throw Error("month must be a number (Jan is 0)");
    }
    const weeks = [];
    let week = [];
    let i = 0;
    let date = new Date(year, month, 1);
    if (year >= 0 && year < 100) {
      date.setFullYear(year);
    }
    date = this.weekStartDate(date);
    do {
      for (i = 0; i < 7; i++) {
        week.push(dayFormatter ? dayFormatter(date) : date);
        date = new Date(date.getTime());
        date.setDate(date.getDate() + 1);
      }
      weeks.push(weekFormatter ? weekFormatter(week) : week);
      week = [];
    } while (date.getMonth() <= month && date.getFullYear() === year);
    return weeks;
  }
  monthDays(year, month) {
    const getDayOrZero = function(date) {
      return date.getMonth() === month ? date : 0;
    };
    return this.monthDates(year, month, getDayOrZero);
  }
  weekStartDate(date) {
    const startDate = new Date(date.getTime());
    while (startDate.getDay() !== poCalendarServiceFirstWeekDayDefault) {
      startDate.setDate(startDate.getDate() - 1);
    }
    return startDate;
  }
  static ɵfac = function PoCalendarService_Factory(t) {
    return new (t || _PoCalendarService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoCalendarService, factory: _PoCalendarService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarService, [{
    type: Injectable
  }], null, null);
})();
var PoCalendarLangService = class _PoCalendarLangService {
  language = poLocaleDefault;
  months = [
    {
      pt: "Janeiro",
      en: "January",
      es: "Enero",
      ru: "Январь"
    },
    {
      pt: "Fevereiro",
      en: "February",
      es: "Febrero",
      ru: "Февраль"
    },
    {
      pt: "Março",
      en: "March",
      es: "Marzo",
      ru: "Март"
    },
    {
      pt: "Abril",
      en: "April",
      es: "Abril",
      ru: "Апрель"
    },
    {
      pt: "Maio",
      en: "May",
      es: "Mayo",
      ru: "Май"
    },
    {
      pt: "Junho",
      en: "June",
      es: "Junio",
      ru: "Июнь"
    },
    {
      pt: "Julho",
      en: "July",
      es: "Julio",
      ru: "Июль"
    },
    {
      pt: "Agosto",
      en: "August",
      es: "Agosto",
      ru: "Август"
    },
    {
      pt: "Setembro",
      en: "September",
      es: "Setiembre",
      ru: "Сентябрь"
    },
    {
      pt: "Outubro",
      en: "October",
      es: "Octubre",
      ru: "Октябрь"
    },
    {
      pt: "Novembro",
      en: "November",
      es: "Noviembre",
      ru: "Ноябрь"
    },
    {
      pt: "Dezembro",
      en: "December",
      es: "Diciembre",
      ru: "Декабрь"
    }
  ];
  shortWeekDays = [
    {
      pt: "Dom",
      en: "Sun",
      es: "Dom",
      ru: "Вс"
    },
    {
      pt: "Seg",
      en: "Mon",
      es: "Lun",
      ru: "Пн"
    },
    {
      pt: "Ter",
      en: "Tue",
      es: "Mar",
      ru: "Вт"
    },
    {
      pt: "Qua",
      en: "Wed",
      es: "Mié",
      ru: "Ср"
    },
    {
      pt: "Qui",
      en: "Thu",
      es: "Jue",
      ru: "Чт"
    },
    {
      pt: "Sex",
      en: "Fri",
      es: "Vie",
      ru: "Пт"
    },
    {
      pt: "Sáb",
      en: "Sat",
      es: "Sáb",
      ru: "Сб"
    }
  ];
  monthLabel = {
    pt: "Mês",
    en: "Month",
    es: "Mes",
    ru: "Месяц"
  };
  yearLabel = {
    pt: "Ano",
    en: "Year",
    es: "Año",
    ru: "Год"
  };
  todayLabel = {
    pt: "Hoje",
    en: "Today",
    es: "Hoy",
    ru: "Сегодня"
  };
  getMonth(month) {
    return this.months[month][this.language];
  }
  getMonthLabel() {
    return this.monthLabel[this.language];
  }
  getMonthsArray() {
    const arrMonths = Array();
    for (let i = 0; i < this.months.length; i++) {
      arrMonths.push(this.months[i][this.language]);
    }
    return arrMonths;
  }
  getWeekDays(day) {
    return this.shortWeekDays[day][this.language];
  }
  getWeekDaysArray() {
    const arrWeekDays = Array();
    for (let i = 0; i < this.shortWeekDays.length; i++) {
      const weekDay = this.shortWeekDays[i][this.language];
      arrWeekDays.push(weekDay.toLowerCase());
    }
    return arrWeekDays;
  }
  getYearLabel() {
    return this.yearLabel[this.language];
  }
  getTodayLabel() {
    return this.todayLabel[this.language];
  }
  setLanguage(language) {
    if (language && language.length >= 2) {
      language = language.toLowerCase().slice(0, 2);
      this.language = poLocales.includes(language) ? language : poLocaleDefault;
    }
  }
  static ɵfac = function PoCalendarLangService_Factory(t) {
    return new (t || _PoCalendarLangService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoCalendarLangService, factory: _PoCalendarLangService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarLangService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function PoCalendarHeaderComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 4);
    ɵɵlistener("click", function PoCalendarHeaderComponent_span_1_Template_span_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.previous.emit());
    });
    ɵɵelementEnd();
  }
}
function PoCalendarHeaderComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 5);
    ɵɵlistener("click", function PoCalendarHeaderComponent_span_4_Template_span_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.next.emit());
    });
    ɵɵelementEnd();
  }
}
var _c0$1v = ["*"];
var PoCalendarHeaderComponent = class _PoCalendarHeaderComponent {
  hidePrevious = false;
  hideNext = false;
  previous = new EventEmitter();
  next = new EventEmitter();
  constructor() {
  }
  static ɵfac = function PoCalendarHeaderComponent_Factory(t) {
    return new (t || _PoCalendarHeaderComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoCalendarHeaderComponent, selectors: [["po-calendar-header"]], inputs: { hidePrevious: [InputFlags.None, "p-hide-previous", "hidePrevious"], hideNext: [InputFlags.None, "p-hide-next", "hideNext"] }, outputs: { previous: "p-previous", next: "p-next" }, ngContentSelectors: _c0$1v, decls: 5, vars: 2, consts: [[1, "po-calendar-header"], ["class", "po-calendar-header-left po-icon po-icon-arrow-left", 3, "click", 4, "ngIf"], ["attr-calendar", "", 1, "po-calendar-header-title"], ["class", "po-calendar-header-right po-icon po-icon-arrow-right", 3, "click", 4, "ngIf"], [1, "po-calendar-header-left", "po-icon", "po-icon-arrow-left", 3, "click"], [1, "po-calendar-header-right", "po-icon", "po-icon-arrow-right", 3, "click"]], template: function PoCalendarHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoCalendarHeaderComponent_span_1_Template, 1, 0, "span", 1);
      ɵɵelementStart(2, "div", 2);
      ɵɵprojection(3);
      ɵɵelementEnd();
      ɵɵtemplate(4, PoCalendarHeaderComponent_span_4_Template, 1, 0, "span", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.previous == null ? null : ctx.previous.observers) && !ctx.hidePrevious);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", (ctx.next == null ? null : ctx.next.observers.length) && !ctx.hideNext);
    }
  }, dependencies: [NgIf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarHeaderComponent, [{
    type: Component,
    args: [{ selector: "po-calendar-header", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-calendar-header">\n  <span\n    *ngIf="previous?.observers && !hidePrevious"\n    class="po-calendar-header-left po-icon po-icon-arrow-left"\n    (click)="previous.emit()"\n  >\n  </span>\n\n  <div class="po-calendar-header-title" attr-calendar>\n    <ng-content></ng-content>\n  </div>\n\n  <span\n    *ngIf="next?.observers.length && !hideNext"\n    class="po-calendar-header-right po-icon po-icon-arrow-right"\n    (click)="next.emit()"\n  >\n  </span>\n</div>\n' }]
  }], () => [], { hidePrevious: [{
    type: Input,
    args: ["p-hide-previous"]
  }], hideNext: [{
    type: Input,
    args: ["p-hide-next"]
  }], previous: [{
    type: Output,
    args: ["p-previous"]
  }], next: [{
    type: Output,
    args: ["p-next"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCalendarHeaderComponent, { className: "PoCalendarHeaderComponent", filePath: "lib/components/po-calendar/po-calendar-header/po-calendar-header.component.ts", lineNumber: 8 });
})();
function PoCalendarWrapperComponent_ng_container_1_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const weekDay_r6 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", weekDay_r6, " ");
  }
}
function PoCalendarWrapperComponent_ng_container_1_div_10_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r7 = ɵɵnextContext().$implicit;
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r8.getDayForegroundColor(day_r7));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", day_r7.getDate(), " ");
  }
}
function PoCalendarWrapperComponent_ng_container_1_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 11);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_1_div_10_Template_div_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r11);
      const day_r7 = restoredCtx.$implicit;
      const ctx_r10 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r10.onSelectDate(day_r7));
    })("mouseenter", function PoCalendarWrapperComponent_ng_container_1_div_10_Template_div_mouseenter_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r11);
      const day_r7 = restoredCtx.$implicit;
      const ctx_r12 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r12.onMouseEnter(day_r7));
    })("mouseleave", function PoCalendarWrapperComponent_ng_container_1_div_10_Template_div_mouseleave_0_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r13 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r13.onMouseLeave());
    });
    ɵɵtemplate(1, PoCalendarWrapperComponent_ng_container_1_div_10_span_1_Template, 2, 2, "span", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r7 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r5.getDayBackgroundColor(day_r7));
    ɵɵadvance();
    ɵɵproperty("ngIf", day_r7 !== 0);
  }
}
function PoCalendarWrapperComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-calendar-header", 2);
    ɵɵlistener("p-previous", function PoCalendarWrapperComponent_ng_container_1_Template_po_calendar_header_p_previous_1_listener() {
      ɵɵrestoreView(_r15);
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.onPreviousMonth());
    })("p-next", function PoCalendarWrapperComponent_ng_container_1_Template_po_calendar_header_p_next_1_listener() {
      ɵɵrestoreView(_r15);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.onNextMonth());
    });
    ɵɵelementStart(2, "span", 3);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_1_Template_span_click_2_listener() {
      ɵɵrestoreView(_r15);
      const ctx_r17 = ɵɵnextContext();
      return ɵɵresetView(ctx_r17.selectDisplayMode("month"));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "span", 4);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_1_Template_span_click_4_listener() {
      ɵɵrestoreView(_r15);
      const ctx_r18 = ɵɵnextContext();
      return ɵɵresetView(ctx_r18.selectDisplayMode("year"));
    });
    ɵɵtext(5);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 5)(7, "div", 6);
    ɵɵtemplate(8, PoCalendarWrapperComponent_ng_container_1_div_8_Template, 2, 1, "div", 7);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 8);
    ɵɵtemplate(10, PoCalendarWrapperComponent_ng_container_1_div_10_Template, 2, 2, "div", 9);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-hide-previous", ctx_r0.isEndPart)("p-hide-next", ctx_r0.isStartPart && !ctx_r0.responsive);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.displayMonth);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.displayYear);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r0.displayWeekDays);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.displayDays);
  }
}
function PoCalendarWrapperComponent_ng_container_2_div_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_2_div_9_Template_div_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r23);
      const i_r21 = restoredCtx.index;
      const ctx_r22 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r22.onSelectMonth(ctx_r22.displayYear, i_r21));
    });
    ɵɵelementStart(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const month_r20 = ctx.$implicit;
    const i_r21 = ctx.index;
    const ctx_r19 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r19.getBackgroundColor(i_r21, ctx_r19.displayMonthNumber));
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r19.getForegroundColor(i_r21, ctx_r19.displayMonthNumber));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", month_r20, " ");
  }
}
function PoCalendarWrapperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-calendar-header", 14);
    ɵɵlistener("p-previous", function PoCalendarWrapperComponent_ng_container_2_Template_po_calendar_header_p_previous_1_listener() {
      ɵɵrestoreView(_r25);
      const ctx_r24 = ɵɵnextContext();
      return ɵɵresetView(ctx_r24.updateYear(-1));
    })("p-next", function PoCalendarWrapperComponent_ng_container_2_Template_po_calendar_header_p_next_1_listener() {
      ɵɵrestoreView(_r25);
      const ctx_r26 = ɵɵnextContext();
      return ɵɵresetView(ctx_r26.updateYear(1));
    });
    ɵɵelementStart(2, "span", 4);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_2_Template_span_click_2_listener() {
      ɵɵrestoreView(_r25);
      const ctx_r27 = ɵɵnextContext();
      return ɵɵresetView(ctx_r27.selectDisplayMode("year"));
    });
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 5)(5, "div", 6)(6, "div", 10);
    ɵɵtext(7);
    ɵɵelementEnd()();
    ɵɵelementStart(8, "div", 15);
    ɵɵtemplate(9, PoCalendarWrapperComponent_ng_container_2_div_9_Template, 3, 3, "div", 16);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.displayYear, " ");
    ɵɵadvance(4);
    ɵɵtextInterpolate1(" ", ctx_r1.monthLabel, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1.displayMonths);
  }
}
function PoCalendarWrapperComponent_ng_container_3_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r32 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_3_div_8_Template_div_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r32);
      const year_r29 = restoredCtx.$implicit;
      const ctx_r31 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r31.onSelectYear(year_r29, ctx_r31.displayMonthNumber));
    });
    ɵɵelementStart(1, "span", 13);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const year_r29 = ctx.$implicit;
    const ctx_r28 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r28.getBackgroundColor(year_r29, ctx_r28.currentYear));
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r28.getForegroundColor(year_r29, ctx_r28.currentYear));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", year_r29, " ");
  }
}
function PoCalendarWrapperComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-calendar-header", 14);
    ɵɵlistener("p-previous", function PoCalendarWrapperComponent_ng_container_3_Template_po_calendar_header_p_previous_1_listener() {
      ɵɵrestoreView(_r34);
      const ctx_r33 = ɵɵnextContext();
      return ɵɵresetView(ctx_r33.updateYear(-10));
    })("p-next", function PoCalendarWrapperComponent_ng_container_3_Template_po_calendar_header_p_next_1_listener() {
      ɵɵrestoreView(_r34);
      const ctx_r35 = ɵɵnextContext();
      return ɵɵresetView(ctx_r35.updateYear(10));
    });
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 5)(4, "div", 6)(5, "div", 10);
    ɵɵtext(6);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 18);
    ɵɵtemplate(8, PoCalendarWrapperComponent_ng_container_3_div_8_Template, 3, 3, "div", 19);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate2(" ", ctx_r2.displayStartDecade, " - ", ctx_r2.displayFinalDecade, " ");
    ɵɵadvance(4);
    ɵɵtextInterpolate1(" ", ctx_r2.yearLabel, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r2.displayDecade);
  }
}
function PoCalendarWrapperComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 21)(2, "div", 22)(3, "button", 23);
    ɵɵlistener("click", function PoCalendarWrapperComponent_ng_container_4_Template_button_click_3_listener() {
      ɵɵrestoreView(_r37);
      const ctx_r36 = ɵɵnextContext();
      return ɵɵresetView(ctx_r36.onSelectDate(ctx_r36.today));
    });
    ɵɵtext(4);
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("disabled", ctx_r3.isTodayUnavailable());
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.displayToday, " ");
  }
}
var PoCalendarWrapperComponent = class _PoCalendarWrapperComponent {
  poCalendarService;
  poCalendarLangService;
  poDate;
  value;
  mode = "day";
  responsive = false;
  partType;
  range = false;
  activateDate = /* @__PURE__ */ new Date();
  selectedValue;
  minDate;
  maxDate;
  hoverValue;
  headerChange = new EventEmitter();
  selectDate = new EventEmitter();
  hoverDate = new Subject().pipe(debounceTime(100));
  currentYear;
  displayDays;
  displayDecade;
  displayFinalDecade;
  displayMonth;
  displayMonthNumber;
  displayMonths = Array();
  displayStartDecade;
  displayWeekDays = Array();
  displayYear;
  displayToday;
  today = /* @__PURE__ */ new Date();
  currentMonthNumber;
  date;
  lastDisplay;
  _locale;
  set locale(value) {
    this._locale = value;
    this.initializeLanguage();
  }
  get locale() {
    return this._locale;
  }
  get monthLabel() {
    return this.poCalendarLangService.getMonthLabel();
  }
  get yearLabel() {
    return this.poCalendarLangService.getYearLabel();
  }
  get isDayVisible() {
    return this.mode === "day";
  }
  get isMonthVisible() {
    return this.mode === "month";
  }
  get isYearVisible() {
    return this.mode === "year";
  }
  get isStartPart() {
    return this.partType === "start";
  }
  get isEndPart() {
    return this.partType === "end";
  }
  constructor(poCalendarService, poCalendarLangService, poDate) {
    this.poCalendarService = poCalendarService;
    this.poCalendarLangService = poCalendarLangService;
    this.poDate = poDate;
  }
  ngOnInit() {
    this.init();
  }
  ngOnChanges(changes) {
    const { activateDate } = changes;
    if (activateDate) {
      this.updateDate(activateDate.currentValue);
    }
  }
  getBackgroundColor(displayValue, propertyValue) {
    return displayValue === propertyValue ? "po-calendar-box-background-selected" : "po-calendar-box-background";
  }
  getDayBackgroundColor(date) {
    return this.getDayColor(date, "background");
  }
  getDayForegroundColor(date) {
    return this.getDayColor(date, "foreground");
  }
  getForegroundColor(displayValue, propertyValue) {
    return displayValue === propertyValue ? "po-calendar-box-foreground-selected" : "po-calendar-box-foreground";
  }
  isTodayUnavailable() {
    return this.minDate > this.today || this.maxDate < this.today;
  }
  onNextMonth() {
    this.displayMonthNumber < 11 ? this.updateDisplay(this.displayYear, this.displayMonthNumber + 1) : this.updateDisplay(this.displayYear + 1, 0);
    this.headerChange.emit({ month: this.displayMonthNumber, year: this.displayYear });
  }
  onPreviousMonth() {
    if (this.displayMonthNumber > 0) {
      this.updateDisplay(this.displayYear, this.displayMonthNumber - 1);
    } else {
      this.updateDisplay(this.displayYear - 1, 11);
    }
    this.headerChange.emit({ month: this.displayMonthNumber, year: this.displayYear });
  }
  onMouseEnter(day) {
    this.hoverDate.next(day);
  }
  onMouseLeave() {
    this.hoverDate.next(null);
  }
  // Ao selecionar uma data
  onSelectDate(date) {
    this.selectDate.emit(date);
  }
  // Ao selecionar um mês
  onSelectMonth(year, month) {
    this.selectDisplayMode("day");
    this.updateDisplay(year, month);
    this.headerChange.emit({ month, year });
  }
  // Ao selecionar um ano
  onSelectYear(year, month) {
    this.selectDisplayMode(this.lastDisplay === "month" ? "month" : "day");
    this.currentYear = year;
    this.updateDisplay(year, month);
    this.headerChange.emit({ month, year });
  }
  selectDisplayMode(mode) {
    this.lastDisplay = this.mode;
    this.mode = mode;
  }
  updateYear(value) {
    this.updateDisplay(this.displayYear + value, this.displayMonthNumber);
  }
  addAllYearsInDecade(year) {
    let i;
    for (i = year; i < year + 10; i++) {
      this.displayDecade.push(i);
    }
  }
  equalsDate(date1, date2) {
    try {
      return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
    } catch (error) {
      return false;
    }
  }
  // Obtém um array de todos os anos desta década
  getDecadeArray(year) {
    this.displayDecade = Array();
    if (year % 10 !== 0) {
      while (year % 10 !== 0) {
        year--;
      }
    }
    this.updateDecade(year);
  }
  getColorForDate(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}-selected` : `po-calendar-box-${local}-selected-disabled`;
  }
  getColorForDefaultDate(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}` : `po-calendar-box-${local}-disabled`;
  }
  getColorForToday(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}-today` : `po-calendar-box-${local}-today-disabled`;
  }
  getColorForDateRange(date, local) {
    return this.poDate.validateDateRange(date, this.minDate, this.maxDate) ? `po-calendar-box-${local}-in-range` : `po-calendar-box-${local}-in-range-disabled`;
  }
  getDayColor(date, local) {
    const start = this.selectedValue?.start;
    const end = this.selectedValue?.end;
    if (this.range && (this.equalsDate(date, start) || this.equalsDate(date, end))) {
      return this.getColorForDate(date, local);
    } else if (this.range && start && end && date > start && date < end) {
      return this.getColorForDateRange(date, local);
    } else if (this.range && start && !end && date > start && date < this.hoverValue) {
      return `po-calendar-box-${local}-hover`;
    } else if (!this.range && this.equalsDate(date, this.value)) {
      return this.getColorForDate(date, local);
    } else if (this.equalsDate(date, this.today)) {
      return this.getColorForToday(date, local);
    } else {
      return this.getColorForDefaultDate(date, local);
    }
  }
  init() {
    this.updateDate(this.activateDate);
    this.initializeLanguage();
    this.selectDisplayMode("day");
  }
  initializeLanguage() {
    this.poCalendarLangService.setLanguage(this.locale);
    this.displayWeekDays = this.poCalendarLangService.getWeekDaysArray();
    this.displayMonths = this.poCalendarLangService.getMonthsArray();
    this.displayMonth = this.displayMonths[this.displayMonthNumber];
    this.displayToday = this.poCalendarLangService.getTodayLabel();
  }
  updateDate(value = /* @__PURE__ */ new Date()) {
    const date = new Date(value);
    this.currentMonthNumber = date.getMonth();
    this.currentYear = date.getFullYear();
    this.updateDisplay(this.currentYear, this.currentMonthNumber);
  }
  updateDecade(year) {
    this.addAllYearsInDecade(year);
    this.displayStartDecade = year;
    this.displayFinalDecade = year + 9;
  }
  updateDisplay(year, month) {
    const calendarArray = this.poCalendarService.monthDays(year, month);
    this.displayDays = [].concat.apply([], calendarArray);
    this.displayMonthNumber = month;
    this.displayMonth = this.displayMonths[month];
    this.displayYear = year;
    this.getDecadeArray(year);
  }
  static ɵfac = function PoCalendarWrapperComponent_Factory(t) {
    return new (t || _PoCalendarWrapperComponent)(ɵɵdirectiveInject(PoCalendarService), ɵɵdirectiveInject(PoCalendarLangService), ɵɵdirectiveInject(PoDateService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoCalendarWrapperComponent, selectors: [["po-calendar-wrapper"]], inputs: { value: [InputFlags.None, "p-value", "value"], mode: [InputFlags.None, "p-mode", "mode"], responsive: [InputFlags.None, "p-responsive", "responsive"], partType: [InputFlags.None, "p-part-type", "partType"], range: [InputFlags.None, "p-range", "range"], activateDate: [InputFlags.None, "p-activate-date", "activateDate"], selectedValue: [InputFlags.None, "p-selected-value", "selectedValue"], minDate: [InputFlags.None, "p-min-date", "minDate"], maxDate: [InputFlags.None, "p-max-date", "maxDate"], hoverValue: [InputFlags.None, "p-hover-value", "hoverValue"], locale: [InputFlags.None, "p-locale", "locale"] }, outputs: { headerChange: "p-header-change", selectDate: "p-select-date", hoverDate: "p-hover-date" }, features: [ɵɵProvidersFeature([PoCalendarService]), ɵɵNgOnChangesFeature], decls: 5, vars: 4, consts: [[1, "po-calendar-wrapper"], [4, "ngIf"], [3, "p-hide-previous", "p-hide-next", "p-previous", "p-next"], [1, "po-clickable", "po-mr-1", 3, "click"], [1, "po-clickable", 3, "click"], [1, "po-calendar-content"], [1, "po-calendar-labels"], ["class", "po-calendar-label", 4, "ngFor", "ngForOf"], [1, "po-calendar-content-list-day"], ["class", "po-calendar-day", "attr-calendar", "", 3, "ngClass", "click", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf"], [1, "po-calendar-label"], ["attr-calendar", "", 1, "po-calendar-day", 3, "ngClass", "click", "mouseenter", "mouseleave"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"], [3, "p-previous", "p-next"], [1, "po-calendar-content-list-month"], ["class", "po-calendar-month", "attr-calendar", "", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["attr-calendar", "", 1, "po-calendar-month", 3, "ngClass", "click"], [1, "po-calendar-content-list-year"], ["class", "po-calendar-year", "attr-calendar", "", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], ["attr-calendar", "", 1, "po-calendar-year", 3, "ngClass", "click"], [1, "po-calendar-footer"], [1, "po-calendar-footer-today"], ["type", "button", 1, "po-calendar-footer-today-button", 3, "disabled", "click"]], template: function PoCalendarWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoCalendarWrapperComponent_ng_container_1_Template, 11, 6, "ng-container", 1)(2, PoCalendarWrapperComponent_ng_container_2_Template, 10, 3, "ng-container", 1)(3, PoCalendarWrapperComponent_ng_container_3_Template, 9, 4, "ng-container", 1)(4, PoCalendarWrapperComponent_ng_container_4_Template, 5, 2, "ng-container", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isDayVisible);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isMonthVisible);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isYearVisible);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.range);
    }
  }, dependencies: [NgClass, NgForOf, NgIf, PoCalendarHeaderComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarWrapperComponent, [{
    type: Component,
    args: [{ selector: "po-calendar-wrapper", providers: [PoCalendarService], changeDetection: ChangeDetectionStrategy.OnPush, template: `<div class="po-calendar-wrapper">
  <ng-container *ngIf="isDayVisible">
    <po-calendar-header
      [p-hide-previous]="isEndPart"
      [p-hide-next]="isStartPart && !responsive"
      (p-previous)="onPreviousMonth()"
      (p-next)="onNextMonth()"
    >
      <span class="po-clickable po-mr-1" (click)="selectDisplayMode('month')">{{ displayMonth }}</span>
      <span class="po-clickable" (click)="selectDisplayMode('year')">{{ displayYear }}</span>
    </po-calendar-header>

    <div class="po-calendar-content">
      <div class="po-calendar-labels">
        <div class="po-calendar-label" *ngFor="let weekDay of displayWeekDays">
          {{ weekDay }}
        </div>
      </div>

      <div class="po-calendar-content-list-day">
        <div
          *ngFor="let day of displayDays"
          class="po-calendar-day"
          [ngClass]="getDayBackgroundColor(day)"
          (click)="onSelectDate(day)"
          (mouseenter)="onMouseEnter(day)"
          (mouseleave)="onMouseLeave()"
          attr-calendar
        >
          <span *ngIf="day !== 0" [ngClass]="getDayForegroundColor(day)">
            {{ day.getDate() }}
          </span>
        </div>
      </div>
    </div>
  </ng-container>

  <ng-container *ngIf="isMonthVisible">
    <po-calendar-header (p-previous)="updateYear(-1)" (p-next)="updateYear(1)">
      <span class="po-clickable" (click)="selectDisplayMode('year')">
        {{ displayYear }}
      </span>
    </po-calendar-header>

    <div class="po-calendar-content">
      <div class="po-calendar-labels">
        <div class="po-calendar-label">
          {{ monthLabel }}
        </div>
      </div>
      <div class="po-calendar-content-list-month">
        <div
          *ngFor="let month of displayMonths; let i = index"
          class="po-calendar-month"
          [ngClass]="getBackgroundColor(i, displayMonthNumber)"
          (click)="onSelectMonth(displayYear, i)"
          attr-calendar
        >
          <span [ngClass]="getForegroundColor(i, displayMonthNumber)">
            {{ month }}
          </span>
        </div>
      </div>
    </div>
  </ng-container>

  <ng-container *ngIf="isYearVisible">
    <po-calendar-header (p-previous)="updateYear(-10)" (p-next)="updateYear(10)">
      {{ displayStartDecade }} - {{ displayFinalDecade }}
    </po-calendar-header>

    <div class="po-calendar-content">
      <div class="po-calendar-labels">
        <div class="po-calendar-label">
          {{ yearLabel }}
        </div>
      </div>

      <div class="po-calendar-content-list-year">
        <div
          *ngFor="let year of displayDecade; let i = index"
          class="po-calendar-year"
          [ngClass]="getBackgroundColor(year, currentYear)"
          (click)="onSelectYear(year, displayMonthNumber)"
          attr-calendar
        >
          <span [ngClass]="getForegroundColor(year, currentYear)">
            {{ year }}
          </span>
        </div>
      </div>
    </div>
  </ng-container>

  <ng-container *ngIf="!range">
    <div class="po-calendar-footer">
      <div class="po-calendar-footer-today">
        <button
          type="button"
          class="po-calendar-footer-today-button"
          (click)="onSelectDate(today)"
          [disabled]="isTodayUnavailable()"
        >
          {{ displayToday }}
        </button>
      </div>
    </div>
  </ng-container>
</div>
` }]
  }], () => [{ type: PoCalendarService }, { type: PoCalendarLangService }, { type: PoDateService }], { value: [{
    type: Input,
    args: ["p-value"]
  }], mode: [{
    type: Input,
    args: ["p-mode"]
  }], responsive: [{
    type: Input,
    args: ["p-responsive"]
  }], partType: [{
    type: Input,
    args: ["p-part-type"]
  }], range: [{
    type: Input,
    args: ["p-range"]
  }], activateDate: [{
    type: Input,
    args: ["p-activate-date"]
  }], selectedValue: [{
    type: Input,
    args: ["p-selected-value"]
  }], minDate: [{
    type: Input,
    args: ["p-min-date"]
  }], maxDate: [{
    type: Input,
    args: ["p-max-date"]
  }], hoverValue: [{
    type: Input,
    args: ["p-hover-value"]
  }], headerChange: [{
    type: Output,
    args: ["p-header-change"]
  }], selectDate: [{
    type: Output,
    args: ["p-select-date"]
  }], hoverDate: [{
    type: Output,
    args: ["p-hover-date"]
  }], locale: [{
    type: Input,
    args: ["p-locale"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCalendarWrapperComponent, { className: "PoCalendarWrapperComponent", filePath: "lib/components/po-calendar/po-calendar-wrapper/po-calendar-wrapper.component.ts", lineNumber: 16 });
})();
function PoCalendarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoCalendarComponent_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoCalendarComponent_ng_template_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c0$1u = () => ({ partType: "end" });
function PoCalendarComponent_ng_template_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoCalendarComponent_ng_template_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r6 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", ɵɵpureFunction0(2, _c0$1u));
  }
}
var _c1$B = () => ({ partType: "start" });
function PoCalendarComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, PoCalendarComponent_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 5)(2, PoCalendarComponent_ng_template_1_ng_container_2_Template, 2, 3, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6)("ngTemplateOutletContext", ɵɵpureFunction0(3, _c1$B));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isResponsive);
  }
}
function PoCalendarComponent_ng_template_3_ng_template_1_Template(rf, ctx) {
}
function PoCalendarComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, PoCalendarComponent_ng_template_3_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
  }
}
function PoCalendarComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-calendar-wrapper", 9);
    ɵɵlistener("p-header-change", function PoCalendarComponent_ng_template_5_Template_po_calendar_wrapper_p_header_change_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r13);
      const partType_r11 = restoredCtx.partType;
      const ctx_r12 = ɵɵnextContext();
      return ɵɵresetView(ctx_r12.onHeaderChange($event, partType_r11));
    })("p-select-date", function PoCalendarComponent_ng_template_5_Template_po_calendar_wrapper_p_select_date_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r13);
      const partType_r11 = restoredCtx.partType;
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.onSelectDate($event, partType_r11));
    })("p-hover-date", function PoCalendarComponent_ng_template_5_Template_po_calendar_wrapper_p_hover_date_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15.onHoverDate($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const partType_r11 = ctx.partType;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("p-value", ctx_r5.getValue(partType_r11))("p-activate-date", ctx_r5.getActivateDate(partType_r11))("p-locale", ctx_r5.locale)("p-min-date", ctx_r5.minDate)("p-max-date", ctx_r5.maxDate)("p-part-type", partType_r11)("p-range", ctx_r5.isRange)("p-responsive", ctx_r5.isResponsive)("p-selected-value", ctx_r5.value)("p-hover-value", ctx_r5.hoverValue);
  }
}
var providers$6 = [
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoCalendarComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoCalendarComponent),
    multi: true
  }
];
var poCalendarRangeWidth = 600;
var PoCalendarComponent = class _PoCalendarComponent extends PoCalendarBaseComponent {
  changeDetector;
  hoverValue;
  constructor(changeDetector, poDate, languageService) {
    super(poDate, languageService);
    this.changeDetector = changeDetector;
  }
  get isResponsive() {
    return window.innerWidth < poCalendarRangeWidth;
  }
  ngOnInit() {
    this.setActivateDate();
  }
  ngOnChanges(changes) {
    if (changes.minDate || changes.maxDate) {
      this.setActivateDate();
    }
  }
  getActivateDate(partType) {
    if (this.isRange && this.activateDate) {
      return this.activateDate[partType];
    } else {
      return this.activateDate;
    }
  }
  getValue(partType) {
    if (this.isRange && this.value) {
      return this.value[partType];
    } else {
      return this.value;
    }
  }
  onSelectDate(selectedDate, partType) {
    let newValue;
    if (this.isRange) {
      newValue = this.getValueFromSelectedDate(selectedDate);
      if (partType === "end" && (!this.value?.start || this.value.start && this.value.end)) {
        this.setActivateDate(selectedDate);
      }
    } else {
      newValue = selectedDate;
      this.setActivateDate(selectedDate);
    }
    this.value = newValue;
    const newModel = this.convertDateToISO(this.value);
    this.updateModel(newModel);
    this.change.emit(newModel);
  }
  onHoverDate(date) {
    this.hoverValue = date;
  }
  onHeaderChange({ month, year }, partType) {
    if (this.isRange) {
      let newStart;
      let newEnd;
      const { start, end } = this.activateDate;
      if (partType === "end") {
        const newYear = month === 0 ? year - 1 : year;
        const daysInMonth = new Date(newYear, month, 0).getDate();
        if (year !== newYear) {
          newStart = new Date(year, month - 1, Math.min(start.getDate(), daysInMonth));
          newEnd = new Date(year, month, Math.min(end.getDate(), daysInMonth));
        } else {
          newStart = new Date(newYear, month - 1, Math.min(start.getDate(), daysInMonth));
          newEnd = new Date(newYear, month, Math.min(end.getDate(), daysInMonth));
        }
      } else {
        const newYear = month === 11 ? year + 1 : year;
        const daysInMonth = new Date(newYear, month + 1, 0).getDate();
        if (year !== newYear) {
          newEnd = new Date(year, month + 1, Math.min(end.getDate(), daysInMonth));
          newStart = new Date(year, month, Math.min(start.getDate(), daysInMonth));
        } else {
          newEnd = new Date(newYear, month + 1, Math.min(end.getDate(), daysInMonth));
          newStart = new Date(newYear, month, Math.min(start.getDate(), daysInMonth));
        }
      }
      this.activateDate = { start: newStart, end: newEnd };
    }
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(func) {
    this.onTouched = func;
  }
  validate(c) {
    return null;
  }
  writeValue(value) {
    if (value) {
      this.writeDate(value);
    } else {
      this.value = null;
    }
    const activateDate = this.getValidateStartDate(value);
    this.setActivateDate(activateDate);
    this.changeDetector.markForCheck();
  }
  getValidateStartDate(value) {
    if (this.isRange) {
      return value?.start || null;
    } else if (value instanceof Date || typeof value === "string") {
      return value;
    }
    return null;
  }
  getValueFromSelectedDate(selectedDate) {
    if (!this.value?.start || this.value.start > selectedDate || this.value.end && this.value.start) {
      return { start: new Date(selectedDate), end: null };
    }
    return { start: new Date(this.value.start), end: new Date(selectedDate) };
  }
  convertDateToISO(date) {
    if (this.isRange) {
      const start = date?.start instanceof Date ? this.poDate.convertDateToISO(date.start) : null;
      const end = date?.end instanceof Date ? this.poDate.convertDateToISO(date.end) : null;
      return { start, end };
    } else {
      return this.poDate.convertDateToISO(date);
    }
  }
  convertDateFromIso(stringDate) {
    if (stringDate && typeof stringDate === "string") {
      const { year, month, day } = this.poDate.getDateFromIso(stringDate);
      const date = new Date(year, month - 1, day);
      this.poDate.setYearFrom0To100(date, year);
      return date;
    }
    return null;
  }
  updateModel(value) {
    if (this.propagateChange) {
      this.propagateChange(value);
    }
  }
  writeDate(value) {
    if (this.isRange) {
      const start = value?.start;
      const end = value?.end;
      const newStart = start instanceof Date ? new Date(start) : this.convertDateFromIso(start);
      const newEnd = end instanceof Date ? new Date(end) : this.convertDateFromIso(end);
      this.value = { start: newStart, end: newEnd };
    } else {
      this.value = value instanceof Date ? new Date(value) : this.convertDateFromIso(value);
    }
  }
  static ɵfac = function PoCalendarComponent_Factory(t) {
    return new (t || _PoCalendarComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoCalendarComponent, selectors: [["po-calendar"]], features: [ɵɵProvidersFeature(providers$6), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 7, vars: 3, consts: [[4, "ngIf", "ngIfThen", "ngIfElse"], ["rangeTemplate", ""], ["calendarTemplate", ""], ["calendarWrapper", ""], [1, "po-calendar-range"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], [1, "po-calendar"], [3, "ngTemplateOutlet"], [3, "p-value", "p-activate-date", "p-locale", "p-min-date", "p-max-date", "p-part-type", "p-range", "p-responsive", "p-selected-value", "p-hover-value", "p-header-change", "p-select-date", "p-hover-date"]], template: function PoCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoCalendarComponent_ng_container_0_Template, 1, 0, "ng-container", 0)(1, PoCalendarComponent_ng_template_1_Template, 3, 4, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, PoCalendarComponent_ng_template_3_Template, 2, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor)(5, PoCalendarComponent_ng_template_5_Template, 1, 10, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(2);
      const _r4 = ɵɵreference(4);
      ɵɵproperty("ngIf", ctx.isRange)("ngIfThen", _r2)("ngIfElse", _r4);
    }
  }, dependencies: [NgIf, NgTemplateOutlet, PoCalendarWrapperComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarComponent, [{
    type: Component,
    args: [{ selector: "po-calendar", changeDetection: ChangeDetectionStrategy.OnPush, providers: providers$6, template: `<ng-container *ngIf="isRange; then rangeTemplate; else calendarTemplate"></ng-container>

<ng-template #rangeTemplate>
  <div class="po-calendar-range">
    <ng-container *ngTemplateOutlet="calendarWrapper; context: { partType: 'start' }"></ng-container>
    <ng-container *ngIf="!isResponsive">
      <ng-container *ngTemplateOutlet="calendarWrapper; context: { partType: 'end' }"></ng-container>
    </ng-container>
  </div>
</ng-template>
<ng-template #calendarTemplate>
  <div class="po-calendar">
    <ng-template [ngTemplateOutlet]="calendarWrapper"></ng-template>
  </div>
</ng-template>

<ng-template #calendarWrapper let-partType="partType">
  <po-calendar-wrapper
    [p-value]="getValue(partType)"
    [p-activate-date]="getActivateDate(partType)"
    [p-locale]="locale"
    [p-min-date]="minDate"
    [p-max-date]="maxDate"
    [p-part-type]="partType"
    [p-range]="isRange"
    [p-responsive]="isResponsive"
    [p-selected-value]="value"
    [p-hover-value]="hoverValue"
    (p-header-change)="onHeaderChange($event, partType)"
    (p-select-date)="onSelectDate($event, partType)"
    (p-hover-date)="onHoverDate($event)"
  >
  </po-calendar-wrapper>
</ng-template>
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: PoDateService }, { type: PoLanguageService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCalendarComponent, { className: "PoCalendarComponent", filePath: "lib/components/po-calendar/po-calendar.component.ts", lineNumber: 61 });
})();
var PoCalendarModule = class _PoCalendarModule {
  static ɵfac = function PoCalendarModule_Factory(t) {
    return new (t || _PoCalendarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoCalendarModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoCalendarComponent, PoCalendarHeaderComponent, PoCalendarWrapperComponent],
      exports: [PoCalendarComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCalendarModule, { declarations: [PoCalendarComponent, PoCalendarHeaderComponent, PoCalendarWrapperComponent], imports: [CommonModule], exports: [PoCalendarComponent] });
})();
var PoChartType;
(function(PoChartType2) {
  PoChartType2["Area"] = "area";
  PoChartType2["Donut"] = "donut";
  PoChartType2["Pie"] = "pie";
  PoChartType2["Line"] = "line";
  PoChartType2["Column"] = "column";
  PoChartType2["Bar"] = "bar";
})(PoChartType || (PoChartType = {}));
var PoChartPadding = 24;
var PoChartAxisXLabelArea = 56;
var PoChartGridLines = 5;
var PoChartPlotAreaPaddingTop = 8;
var PoChartStartAngle = -Math.PI / 2;
var PoChartDonutDefaultThickness = 40;
var PoChartCompleteCircle = 1e-4;
var durationTime = 1500;
var PoChartAngleStepInterval = Math.PI * 2 / Math.floor(durationTime / 60);
var PoChartMathsService = class _PoChartMathsService {
  /**
   * Calcula e retorna os válores mínimo e máximo das séries.
   *
   * @param series Lista de séries.
   * @param acceptNegativeValues boolean.
   */
  calculateMinAndMaxValues(series, acceptNegativeValues = true) {
    const minValue = this.getDomain(series, "min");
    const maxValue = this.getDomain(series, "max");
    return {
      minValue: !acceptNegativeValues && minValue < 0 ? 0 : minValue,
      maxValue: acceptNegativeValues && maxValue < 0 ? 0 : maxValue
    };
  }
  /**
   * Retorna o valor com maior quantidade de dígitos entre todas as séries.
   * Pode receber uma lista de categorias para o caso de gráfico de barra, ou então a lista de séries se o tipo de gráfico for linha ou coluna.
   *
   * @param data Lista de séries.
   * @param type O tipo do gráfico'.
   * @param options As opções para validação de número de linhas do eixo X'.
   */
  getLongestDataValue(data = [], type, options) {
    if (type === PoChartType.Bar) {
      return this.getLongestData(data);
    } else {
      return this.getAxisXLabelLongestValue(data, this.amountOfGridLines(options?.axis));
    }
  }
  /**
   * Retorna o tamanho da série que tiver mais itens.
   *
   * @param series Lista de séries.
   */
  seriesGreaterLength(series) {
    return series.reduce((result, serie) => result > serie.data.length ? result : serie.data.length, 0);
  }
  /**
   * Retorna o percentual em decimal da série passada pela distância entre os valores mínimos e máximos da série.
   *
   * Se o valor mínimo for negativo o alcance partirá dele como sendo zero %.
   *
   * Por exemplo:
   *    minValue = -10;
   *    maxValue = 0;
   *    serieValue = -8
   *    O resultado será de 0.20;
   *
   * @param minMaxValues Objeto contendo os valores mínimo e máximo de todas as séries.
   * @param serieValue O valor da série.
   */
  getSeriePercentage(minMaxValues, serieValue) {
    const { minValue, maxValue } = minMaxValues;
    const range = maxValue - minValue;
    const displacement = serieValue - minValue;
    const result = displacement / range;
    return isNaN(result) ? 0 : result;
  }
  /**
   * Calcula e retorna uma lista de valores referentes aos textos dos eixos X em relação à quantidade de linhas horizontais.
   *
   * @param minMaxValues Objeto contendo os valores mínimo e máximo de todas as séries.
   * @param gridLines Quantidade de linhas horizontais. Valor default é 5.
   */
  range(minMaxValues, gridLines = 5) {
    const { minValue, maxValue } = minMaxValues;
    const result = [];
    const step = this.getGridLineArea(minMaxValues, gridLines);
    for (let index = minValue; index <= maxValue; index = (index * 10 + step * 10) / 10) {
      result.push(index);
    }
    return result;
  }
  /**
   *
   * Verifica se o valor passado é um Integer ou Float.
   *
   * @param number O valor a ser validado
   */
  verifyIfFloatOrInteger(number) {
    const notABoolean = typeof number !== "boolean";
    const notInfinity = number !== Infinity;
    const isInteger = Number(number) === number && number % 1 === 0 && notInfinity;
    const isFloat = Number(number) === number && number % 1 !== 0 && notInfinity;
    return notABoolean && isInteger || notABoolean && isFloat;
  }
  amountOfGridLines(options) {
    const gridLines = options?.gridLines ?? PoChartGridLines;
    return gridLines && gridLines >= 2 && gridLines <= 10 ? gridLines : PoChartGridLines;
  }
  getAxisXLabelLongestValue(data, gridLines) {
    const allowNegativeData = data.every((dataItem) => dataItem.type === PoChartType.Line);
    const domain = this.calculateMinAndMaxValues(data, allowNegativeData);
    const axisXLabelsList = this.range(domain, gridLines);
    return this.getLongestData(axisXLabelsList);
  }
  // Cálculo que retorna o valor obtido de gridLines em relação ao alcance dos valores mínimos e máximos das séries (maxMinValues)
  getGridLineArea(minMaxValues, gridLines) {
    const percentageValue = this.getFractionFromInt(gridLines - 1);
    const { minValue, maxValue } = minMaxValues;
    const result = percentageValue * (maxValue - minValue) / 100;
    return result === 0 ? 1 : result;
  }
  // Retorna o valor máximo ou mínimo das séries baseado no tipo passado(type).
  getDomain(series, type) {
    const result = Math[type](...series.map((serie) => {
      if (Array.isArray(serie.data)) {
        return Math[type](...serie.data);
      }
    }));
    return isNaN(result) ? 0 : result;
  }
  // Retorna a fração do número passado referente à quantidade de linhas no eixo X (gridLines)
  getFractionFromInt(value) {
    return 1 / value * (100 / 1);
  }
  getLongestData(serie) {
    const newSerie = [...serie];
    return newSerie.sort((longest, current) => current.toString().length - longest.toString().length)["0"];
  }
  static ɵfac = function PoChartMathsService_Factory(t) {
    return new (t || _PoChartMathsService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoChartMathsService, factory: _PoChartMathsService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartMathsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$1t = ["chartLine"];
var PoChartLineBaseComponent = class _PoChartLineBaseComponent {
  mathsService;
  renderer;
  elementRef;
  alignByTheCorners = false;
  categories;
  categoriesCoordinates;
  svgSpace;
  pointClick = new EventEmitter();
  pointHover = new EventEmitter();
  chartLine;
  activeTooltip;
  animate = true;
  chartType;
  seriesPathsCoordinates;
  seriesPointsCoordinates = [];
  firstValidItemFromSerieArray;
  seriesLength;
  _containerSize = {};
  _range = {};
  _series = [];
  set range(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._range = value;
      this.seriePathPointsDefinition(this.containerSize, this._series, this._range);
    }
  }
  get range() {
    return this._range;
  }
  set containerSize(value) {
    this._containerSize = value;
    this.seriePathPointsDefinition(this._containerSize, this.series, this.range);
  }
  get containerSize() {
    return this._containerSize;
  }
  set series(seriesList) {
    const seriesDataArrayFilter = seriesList.filter((serie) => Array.isArray(serie.data));
    if (seriesDataArrayFilter.length) {
      this._series = seriesDataArrayFilter;
      this.animate = true;
      this.seriesLength = this.mathsService.seriesGreaterLength(this.series);
      this.chartType = this._series[0].type;
      this.seriePathPointsDefinition(this.containerSize, seriesDataArrayFilter, this.range);
    } else {
      this._series = [];
    }
  }
  get series() {
    return this._series;
  }
  constructor(mathsService, renderer, elementRef) {
    this.mathsService = mathsService;
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  onSeriePointClick(selectedItem) {
    this.pointClick.emit(selectedItem);
  }
  trackBy(index) {
    return index;
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = data.toString();
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  svgPathCommand() {
    const command = this.firstValidItemFromSerieArray ? "M" : "L";
    this.firstValidItemFromSerieArray = false;
    return command;
  }
  xCoordinate(index, containerSize) {
    const halfCategoryWidth = !this.alignByTheCorners ? (containerSize.svgWidth - containerSize.axisXLabelWidth) / this.seriesLength / 2 : 0;
    const divideIndexBySeriesLength = index / (this.alignByTheCorners ? this.seriesLength - 1 : this.seriesLength);
    const xRatio = isNaN(divideIndexBySeriesLength) ? 0 : divideIndexBySeriesLength;
    return Math.floor(containerSize.axisXLabelWidth + halfCategoryWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio);
  }
  serieCategory(index, categories = []) {
    return categories[index] ?? void 0;
  }
  seriePathPointsDefinition(containerSize, series, range) {
    this.seriesPointsCoordinates = [];
    this.seriesPathsCoordinates = series.map((serie) => {
      if (Array.isArray(serie.data)) {
        let pathCoordinates = "";
        let pointCoordinates = [];
        const color = serie.color;
        this.firstValidItemFromSerieArray = true;
        serie.data.forEach((data, index) => {
          if (this.mathsService.verifyIfFloatOrInteger(data)) {
            const svgPathCommand = this.svgPathCommand();
            const xCoordinate = this.xCoordinate(index, containerSize);
            const yCoordinate = this.yCoordinate(range, data, containerSize);
            const category = this.serieCategory(index, this.categories);
            const label = serie.label;
            const tooltip = serie.tooltip;
            const tooltipLabel = this.getTooltipLabel(data, label, tooltip);
            const isActive = this.chartType === PoChartType.Line;
            pointCoordinates = [
              ...pointCoordinates,
              { category, label, tooltipLabel, data, xCoordinate, yCoordinate, color, isActive }
            ];
            pathCoordinates += ` ${svgPathCommand}${xCoordinate} ${yCoordinate}`;
          }
        });
        pathCoordinates = this.verifyIfClosePath(pathCoordinates, serie.data.length - 1, range, 0, containerSize);
        this.seriesPointsCoordinates = [...this.seriesPointsCoordinates, pointCoordinates];
        return { coordinates: pathCoordinates, color, isActive: true };
      }
    });
  }
  verifyIfClosePath(pathCoordinates, lastIndex, range, data, containerSize) {
    const { axisXLabelWidth, svgWidth } = containerSize;
    if (this.chartType === PoChartType.Area) {
      const xLastPosition = this.xCoordinate(lastIndex, containerSize);
      const baseYCoordinate = this.yCoordinate(range, data, containerSize);
      const xInitialPosition = Math.floor(this.alignByTheCorners ? axisXLabelWidth : axisXLabelWidth + (svgWidth - axisXLabelWidth) / this.seriesLength / 2);
      return `${pathCoordinates} ${xLastPosition} ${baseYCoordinate} L${xInitialPosition} ${baseYCoordinate} Z`;
    }
    return pathCoordinates;
  }
  yCoordinate(range, data, containerSize) {
    const yRratio = this.mathsService.getSeriePercentage(range, data);
    const yCoordinate = containerSize.svgPlottingAreaHeight - containerSize.svgPlottingAreaHeight * yRratio + PoChartPlotAreaPaddingTop;
    return Math.floor(yCoordinate);
  }
  static ɵfac = function PoChartLineBaseComponent_Factory(t) {
    return new (t || _PoChartLineBaseComponent)(ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoChartLineBaseComponent, viewQuery: function PoChartLineBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1t, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartLine = _t.first);
    }
  }, inputs: { alignByTheCorners: [InputFlags.None, "p-align-by-the-corners", "alignByTheCorners"], categories: [InputFlags.None, "p-categories", "categories"], categoriesCoordinates: [InputFlags.None, "p-categories-coordinates", "categoriesCoordinates"], svgSpace: [InputFlags.None, "p-svg-space", "svgSpace"], range: [InputFlags.None, "p-range", "range"], containerSize: [InputFlags.None, "p-container-size", "containerSize"], series: [InputFlags.None, "p-series", "series"] }, outputs: { pointClick: "p-point-click", pointHover: "p-point-hover" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartLineBaseComponent, [{
    type: Directive
  }], () => [{ type: PoChartMathsService }, { type: Renderer2 }, { type: ElementRef }], { alignByTheCorners: [{
    type: Input,
    args: ["p-align-by-the-corners"]
  }], categories: [{
    type: Input,
    args: ["p-categories"]
  }], categoriesCoordinates: [{
    type: Input,
    args: ["p-categories-coordinates"]
  }], svgSpace: [{
    type: Input,
    args: ["p-svg-space"]
  }], pointClick: [{
    type: Output,
    args: ["p-point-click"]
  }], pointHover: [{
    type: Output,
    args: ["p-point-hover"]
  }], chartLine: [{
    type: ViewChild,
    args: ["chartLine"]
  }], range: [{
    type: Input,
    args: ["p-range"]
  }], containerSize: [{
    type: Input,
    args: ["p-container-size"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }] });
})();
var _c0$1s = ["chartPath"];
var _c1$A = ["po-chart-path", ""];
var pathDashoffsetDefaultWidth = 0;
var PoChartPathComponent = class _PoChartPathComponent {
  changeDetector;
  isActive = true;
  chartLine = false;
  coordinates;
  chartPath;
  pathWidth;
  _animate;
  _color;
  set color(value) {
    this._color = value.includes("po-color") && this.chartLine ? value.replace("po-color", "po-border-color") : value;
  }
  get color() {
    return this._color;
  }
  set animate(value) {
    this._animate = value;
    if (!this.animate) {
      this.pathWidth = pathDashoffsetDefaultWidth;
    }
  }
  get animate() {
    return this._animate;
  }
  constructor(changeDetector) {
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    if (!isIE()) {
      this.pathAnimation();
    }
  }
  pathAnimation() {
    this.pathWidth = this.chartPath.nativeElement.getTotalLength();
    this.changeDetector.detectChanges();
    setTimeout(this.preventsAnimatingAgain.bind(this), 700);
  }
  // Redefine pathWidth para zero após o período da animação para que a linha se expanda normalmente on resize.
  preventsAnimatingAgain() {
    this.pathWidth = pathDashoffsetDefaultWidth;
  }
  static ɵfac = function PoChartPathComponent_Factory(t) {
    return new (t || _PoChartPathComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartPathComponent, selectors: [["", "po-chart-path", ""]], viewQuery: function PoChartPathComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1s, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartPath = _t.first);
    }
  }, inputs: { isActive: [InputFlags.HasDecoratorInputTransform, "p-is-active", "isActive", convertToBoolean], chartLine: [InputFlags.HasDecoratorInputTransform, "p-chart-line", "chartLine", convertToBoolean], coordinates: [InputFlags.None, "p-coordinates", "coordinates"], color: [InputFlags.None, "p-color", "color"], animate: [InputFlags.None, "p-animate", "animate"] }, features: [ɵɵInputTransformsFeature], attrs: _c1$A, decls: 2, vars: 11, consts: [[1, "po-chart-path"], ["chartPath", ""]], template: function PoChartPathComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelement(0, "path", 0, 1);
    }
    if (rf & 2) {
      ɵɵclassMap((ctx.color == null ? null : ctx.color.includes("po-border-color")) || (ctx.color == null ? null : ctx.color.includes("po-color")) ? ctx.color : "");
      ɵɵclassProp("po-chart-active-path", ctx.isActive)("po-chart-line-path", ctx.chartLine);
      ɵɵattribute("fill", ctx.chartLine ? "none" : ctx.color)("stroke-dasharray", ctx.pathWidth)("stroke-dashoffset", ctx.pathWidth)("stroke", ctx.chartLine ? ctx.color : "")("d", ctx.coordinates);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartPathComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-path]", template: `<svg:path #chartPath
  class="po-chart-path"
  [class.po-chart-active-path]="isActive"
  [class.po-chart-line-path]="chartLine"
  [class]="color?.includes('po-border-color') || color?.includes('po-color') ? color : ''"
  [attr.fill]="chartLine ? 'none' : color"
  [attr.stroke-dasharray]="pathWidth"
  [attr.stroke-dashoffset]="pathWidth"
  [attr.stroke]="chartLine ? color : ''"
  [attr.d]="coordinates">
</svg:path> ` }]
  }], () => [{ type: ChangeDetectorRef }], { isActive: [{
    type: Input,
    args: [{ alias: "p-is-active", transform: convertToBoolean }]
  }], chartLine: [{
    type: Input,
    args: [{ alias: "p-chart-line", transform: convertToBoolean }]
  }], coordinates: [{
    type: Input,
    args: ["p-coordinates"]
  }], chartPath: [{
    type: ViewChild,
    args: ["chartPath", { static: true }]
  }], color: [{
    type: Input,
    args: ["p-color"]
  }], animate: [{
    type: Input,
    args: ["p-animate"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartPathComponent, { className: "PoChartPathComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-path/po-chart-path.component.ts", lineNumber: 11 });
})();
var _c0$1r = ["po-chart-series-point", ""];
function PoChartSeriesPointComponent__svg_circle_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "circle", 1);
    ɵɵlistener("click", function PoChartSeriesPointComponent__svg_circle_0_Template__svg_circle_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r3);
      const item_r1 = restoredCtx.$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onClick(item_r1));
    })("mouseenter", function PoChartSeriesPointComponent__svg_circle_0_Template__svg_circle_mouseenter_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r3);
      const item_r1 = restoredCtx.$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onMouseEnter($event, item_r1));
    })("mouseleave", function PoChartSeriesPointComponent__svg_circle_0_Template__svg_circle_mouseleave_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onMouseLeave($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap((ctx_r0.strokeColor == null ? null : ctx_r0.strokeColor.includes("po-border-color")) ? ctx_r0.strokeColor : "");
    ɵɵclassProp("po-chart-active-point", item_r1.isActive);
    ɵɵproperty("p-tooltip", item_r1.tooltipLabel)("p-append-in-body", true)("p-display-tooltip", !ctx_r0.chartLine && item_r1.isActive);
    ɵɵattribute("cx", item_r1.xCoordinate)("cy", item_r1.yCoordinate)("r", ctx_r0.radius)("stroke", ctx_r0.strokeColor);
  }
}
var RADIUS_DEFAULT_SIZE = 5;
var RADIUS_HOVER_SIZE = 10;
var ANIMATION_DURATION_TIME = 700;
var PoChartSeriesPointComponent = class _PoChartSeriesPointComponent {
  renderer;
  elementRef;
  animate;
  isActive;
  chartLine = false;
  // Referência para o svgPathGroup ao qual pertence o ponto. Necessário para reordenação dos svgElements no DOM para tratamento onHover
  relativeTo;
  pointClick = new EventEmitter();
  pointHover = new EventEmitter();
  coordinates$;
  radius = RADIUS_DEFAULT_SIZE;
  strokeColor;
  _color;
  _coordinates = [];
  animationState = true;
  set color(value) {
    this.strokeColor = value.includes("po-color") ? value.replace("po-color", "po-border-color") : value;
    this._color = value;
  }
  get color() {
    return this._color;
  }
  set coordinates(value) {
    this._coordinates = value;
    this.coordinates$ = this.displayPointsWithDelay(this._coordinates);
  }
  get coordinates() {
    return this._coordinates;
  }
  constructor(renderer, elementRef) {
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  trackBy(index) {
    return index;
  }
  onClick(point) {
    const selectedItem = { label: point.label, data: point.data, category: point.category };
    this.pointClick.emit(selectedItem);
  }
  onMouseEnter(event, point) {
    this.setPointAttribute(event.target, true);
    const selectedItem = { label: point.label, data: point.data, category: point.category };
    this.pointHover.emit(__spreadValues({ relativeTo: this.relativeTo }, selectedItem));
  }
  onMouseLeave(event) {
    this.setPointAttribute(event.target, false);
  }
  displayPointsWithDelay(coordinates) {
    if (this.animationState && !isIE()) {
      const animationTimer = ANIMATION_DURATION_TIME / coordinates.length;
      return from(coordinates).pipe(concatMap((item, index) => timer(index === 0 || !this.animate ? 0 : animationTimer).pipe(mapTo(item))), scan((acc, curr) => acc.concat(curr), []), tap(() => this.animationState = false));
    } else {
      return from([coordinates]);
    }
  }
  setPointAttribute(target, isHover) {
    this.renderer.setAttribute(target, "r", isHover ? RADIUS_HOVER_SIZE.toString() : RADIUS_DEFAULT_SIZE.toString());
    if (this.color.includes("po-color")) {
      this.renderer.setAttribute(target, "class", isHover ? `${this.strokeColor} ${this.color}` : `po-chart-line-point po-chart-active-point ${this.strokeColor}`);
    } else {
      this.renderer[isHover ? "setStyle" : "removeStyle"](target, "fill", isHover ? this.color : void 0);
    }
  }
  static ɵfac = function PoChartSeriesPointComponent_Factory(t) {
    return new (t || _PoChartSeriesPointComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartSeriesPointComponent, selectors: [["", "po-chart-series-point", ""]], inputs: { animate: [InputFlags.None, "p-animate", "animate"], isActive: [InputFlags.HasDecoratorInputTransform, "p-is-active", "isActive", convertToBoolean], chartLine: [InputFlags.HasDecoratorInputTransform, "p-chart-line", "chartLine", convertToBoolean], relativeTo: [InputFlags.None, "p-relative-to", "relativeTo"], color: [InputFlags.None, "p-color", "color"], coordinates: [InputFlags.None, "p-coordinates", "coordinates"] }, outputs: { pointClick: "p-point-click", pointHover: "p-point-hover" }, features: [ɵɵInputTransformsFeature], attrs: _c0$1r, decls: 2, vars: 4, consts: [["p-tooltip-position", "top", "class", "po-chart-line-point", 3, "p-tooltip", "p-append-in-body", "p-display-tooltip", "class", "po-chart-active-point", "click", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["p-tooltip-position", "top", 1, "po-chart-line-point", 3, "p-tooltip", "p-append-in-body", "p-display-tooltip", "click", "mouseenter", "mouseleave"]], template: function PoChartSeriesPointComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoChartSeriesPointComponent__svg_circle_0_Template, 1, 11, "circle", 0);
      ɵɵpipe(1, "async");
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ɵɵpipeBind1(1, 2, ctx.coordinates$))("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, PoTooltipDirective, AsyncPipe], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartSeriesPointComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-series-point]", template: `<svg:circle *ngFor="let item of coordinates$ | async; trackBy: trackBy" 
  [p-tooltip]="item.tooltipLabel"
  [p-append-in-body]='true'
  [p-display-tooltip]="!chartLine && item.isActive"
  p-tooltip-position="top"
  class="po-chart-line-point"
  [class]="strokeColor?.includes('po-border-color') ? strokeColor : ''"
  [class.po-chart-active-point]="item.isActive"
  [attr.cx]="item.xCoordinate"
  [attr.cy]="item.yCoordinate"
  [attr.r]="radius"
  [attr.stroke]="strokeColor"
  (click)="onClick(item)"
  (mouseenter)="onMouseEnter($event, item)"
  (mouseleave)="onMouseLeave($event)"
  >
</svg:circle>
` }]
  }], () => [{ type: Renderer2 }, { type: ElementRef }], { animate: [{
    type: Input,
    args: ["p-animate"]
  }], isActive: [{
    type: Input,
    args: [{ alias: "p-is-active", transform: convertToBoolean }]
  }], chartLine: [{
    type: Input,
    args: [{ alias: "p-chart-line", transform: convertToBoolean }]
  }], relativeTo: [{
    type: Input,
    args: ["p-relative-to"]
  }], pointClick: [{
    type: Output,
    args: ["p-point-click"]
  }], pointHover: [{
    type: Output,
    args: ["p-point-hover"]
  }], color: [{
    type: Input,
    args: ["p-color"]
  }], coordinates: [{
    type: Input,
    args: ["p-coordinates"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartSeriesPointComponent, { className: "PoChartSeriesPointComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-series-point/po-chart-series-point.component.ts", lineNumber: 17 });
})();
var _c0$1q = ["po-chart-area", ""];
function PoChartAreaComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 2);
    ɵɵlistener("mouseenter", function PoChartAreaComponent__svg_g_2_Template__svg_g_mouseenter_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const i_r3 = restoredCtx.index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onEnter(i_r3));
    })("mouseleave", function PoChartAreaComponent__svg_g_2_Template__svg_g_mouseleave_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const i_r3 = restoredCtx.index;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.onLeave(i_r3));
    });
    ɵɵelement(1, "g", 3);
    ɵɵelementStart(2, "g", 4);
    ɵɵlistener("p-point-click", function PoChartAreaComponent__svg_g_2_Template__svg_g_p_point_click_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onSeriePointClick($event));
    })("p-point-hover", function PoChartAreaComponent__svg_g_2_Template__svg_g_p_point_hover_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.onSeriePointHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("po-chart-line-path-group-" + i_r3);
    ɵɵadvance();
    ɵɵproperty("p-chart-line", ctx_r1.chartType === "line")("p-animate", ctx_r1.animate)("p-color", item_r2.color)("p-coordinates", item_r2 == null ? null : item_r2.coordinates)("p-is-active", item_r2.isActive);
    ɵɵattribute("key", "po-chart-line-path-" + i_r3);
    ɵɵadvance();
    ɵɵproperty("p-animate", ctx_r1.animate)("p-chart-line", ctx_r1.chartType === "line")("p-color", item_r2.color)("p-coordinates", ctx_r1.seriesPointsCoordinates[i_r3])("p-is-active", ctx_r1.activeTooltip)("p-relative-to", "po-chart-line-path-group-" + i_r3);
    ɵɵattribute("key", "po-chart-line-path-points-group-" + i_r3);
  }
}
var PoChartAreaComponent = class _PoChartAreaComponent extends PoChartLineBaseComponent {
  mathsService;
  renderer;
  elementRef;
  currentActiveSerieIndex;
  mouseMoveSubscription$;
  previousActiveSerieIndex;
  constructor(mathsService, renderer, elementRef) {
    super(mathsService, renderer, elementRef);
    this.mathsService = mathsService;
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  onEnter(serieIndex) {
    this.applyActiveItem(this.seriesPathsCoordinates, serieIndex);
    this.initializeListener(serieIndex);
    this.activeTooltip = true;
  }
  onLeave(serieIndex) {
    this.removeListener();
    this.applyActiveItem(this.seriesPathsCoordinates);
    this.applyActiveItem(this.seriesPointsCoordinates[serieIndex], null);
  }
  onSeriePointHover(selectedItem) {
    const _a = selectedItem, { relativeTo } = _a, item = __objRest(_a, ["relativeTo"]);
    this.pointHover.emit(item);
  }
  applyActiveItem(list, index) {
    list.forEach((serie, seriesIndex) => {
      serie["isActive"] = index === void 0 ? true : index === seriesIndex;
    });
  }
  getMouseCoordinates(event) {
    event.preventDefault();
    const { svgDomMatrix, svgPoint } = this.svgSpace;
    svgPoint.x = event.clientX;
    svgPoint.y = event.clientY;
    return svgPoint.matrixTransform(svgDomMatrix);
  }
  initializeListener(serieIndex) {
    let pointPosition;
    this.previousActiveSerieIndex = void 0;
    this.mouseMoveSubscription$ = fromEvent(this.elementRef.nativeElement, "mousemove").pipe(debounceTime(10), tap((event) => pointPosition = this.getMouseCoordinates(event)), switchMap(() => of(this.verifyActiveArea(pointPosition)))).subscribe((activeObjIndex) => {
      if (activeObjIndex !== void 0) {
        this.applyActiveItem(this.seriesPointsCoordinates[serieIndex], activeObjIndex);
      }
    });
  }
  removeListener() {
    this.mouseMoveSubscription$.unsubscribe();
  }
  verifyActiveArea(pointPosition) {
    const { x } = pointPosition;
    this.currentActiveSerieIndex = this.categoriesCoordinates.findIndex((category, index) => x >= category && index === this.categoriesCoordinates.length - 1 || x >= category && x <= this.categoriesCoordinates[index + 1]);
    if (this.currentActiveSerieIndex >= 0 && this.currentActiveSerieIndex !== this.previousActiveSerieIndex) {
      this.previousActiveSerieIndex = this.currentActiveSerieIndex;
      return this.currentActiveSerieIndex;
    }
    return void 0;
  }
  static ɵfac = function PoChartAreaComponent_Factory(t) {
    return new (t || _PoChartAreaComponent)(ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartAreaComponent, selectors: [["", "po-chart-area", ""]], features: [ɵɵInheritDefinitionFeature], attrs: _c0$1q, decls: 3, vars: 2, consts: [["chartLine", ""], [3, "class", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseenter", "mouseleave"], ["po-chart-path", "", 3, "p-chart-line", "p-animate", "p-color", "p-coordinates", "p-is-active"], ["po-chart-series-point", "", 3, "p-animate", "p-chart-line", "p-color", "p-coordinates", "p-is-active", "p-relative-to", "p-point-click", "p-point-hover"]], template: function PoChartAreaComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g", null, 0);
      ɵɵtemplate(2, PoChartAreaComponent__svg_g_2_Template, 3, 15, "g", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, PoChartPathComponent, PoChartSeriesPointComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAreaComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-area]", template: `<svg:g #chartLine>

  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    [class]="'po-chart-line-path-group-' + i"
    (mouseenter)="onEnter(i)"
    (mouseleave)="onLeave(i)"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-path
      [p-chart-line]="chartType === 'line'"
      [attr.key]="'po-chart-line-path-' + i"
      [p-animate]="animate"
      [p-color]="item.color" 
      [p-coordinates]="item?.coordinates"
      [p-is-active]="item.isActive"
      >
      </svg:g>

    <!-- SERIES POINTS -->
    <svg:g po-chart-series-point
      [p-animate]="animate"
      [p-chart-line]="chartType === 'line'"
      [p-color]="item.color"
      [p-coordinates]="seriesPointsCoordinates[i]"
      [p-is-active]="activeTooltip"
      [p-relative-to]="'po-chart-line-path-group-' + i" 
      [attr.key]="'po-chart-line-path-points-group-' + i"
      (p-point-click)="onSeriePointClick($event)"
      (p-point-hover)="onSeriePointHover($event)"
      ></svg:g>
  </svg:g>

</svg:g>` }]
  }], () => [{ type: PoChartMathsService }, { type: Renderer2 }, { type: ElementRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAreaComponent, { className: "PoChartAreaComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-area/po-chart-area.component.ts", lineNumber: 15 });
})();
var _c0$1p = ["po-chart-axis-path", ""];
function PoChartAxisPathComponent__svg_path_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 1);
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    ɵɵattribute("d", item_r2.coordinates);
  }
}
function PoChartAxisPathComponent__svg_path_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 1);
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    ɵɵattribute("d", item_r3.coordinates);
  }
}
var PoChartAxisPathComponent = class _PoChartAxisPathComponent {
  axisXCoordinates;
  axisYCoordinates;
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  static ɵfac = function PoChartAxisPathComponent_Factory(t) {
    return new (t || _PoChartAxisPathComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartAxisPathComponent, selectors: [["", "po-chart-axis-path", ""]], inputs: { axisXCoordinates: [InputFlags.None, "p-axis-x-coordinates", "axisXCoordinates"], axisYCoordinates: [InputFlags.None, "p-axis-y-coordinates", "axisYCoordinates"] }, attrs: _c0$1p, decls: 4, vars: 4, consts: [["class", "po-chart-axis-path", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-chart-axis-path"]], template: function PoChartAxisPathComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵtemplate(1, PoChartAxisPathComponent__svg_path_1_Template, 1, 1, "path", 0);
      ɵɵelementEnd();
      ɵɵelementStart(2, "g");
      ɵɵtemplate(3, PoChartAxisPathComponent__svg_path_3_Template, 1, 1, "path", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.axisXCoordinates)("ngForTrackBy", ctx.trackBy);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.axisYCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAxisPathComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-axis-path]", template: '<svg:g>\n  <svg:path *ngFor="let item of axisXCoordinates; trackBy: trackBy"\n    class="po-chart-axis-path" \n    [attr.d]="item.coordinates">\n  </svg:path> \n</svg:g>\n\n<svg:g>\n  <svg:path *ngFor="let item of axisYCoordinates; trackBy: trackBy"\n    class="po-chart-axis-path" \n    [attr.d]="item.coordinates">\n  </svg:path> \n</svg:g>' }]
  }], () => [], { axisXCoordinates: [{
    type: Input,
    args: ["p-axis-x-coordinates"]
  }], axisYCoordinates: [{
    type: Input,
    args: ["p-axis-y-coordinates"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAxisPathComponent, { className: "PoChartAxisPathComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-axis/po-chart-axis-path/po-chart-axis-path.component.ts", lineNumber: 9 });
})();
var _c0$1o = ["po-chart-axis-label", ""];
function PoChartAxisLabelComponent__svg_text_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "text", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    ɵɵattribute("x", item_r2.xCoordinate)("y", item_r2.yCoordinate);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r2.label, " ");
  }
}
function PoChartAxisLabelComponent__svg_text_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "text", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-chart-centered-label", !ctx_r1.alignByTheCorners);
    ɵɵattribute("x", item_r3.xCoordinate)("y", item_r3.yCoordinate);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r3.label, " ");
  }
}
var PoChartAxisLabelComponent = class _PoChartAxisLabelComponent {
  alignByTheCorners = false;
  axisXLabelCoordinates;
  axisYLabelCoordinates;
  type;
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  static ɵfac = function PoChartAxisLabelComponent_Factory(t) {
    return new (t || _PoChartAxisLabelComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartAxisLabelComponent, selectors: [["", "po-chart-axis-label", ""]], inputs: { alignByTheCorners: [InputFlags.None, "p-align-by-the-corners", "alignByTheCorners"], axisXLabelCoordinates: [InputFlags.None, "p-axis-x-label-coordinates", "axisXLabelCoordinates"], axisYLabelCoordinates: [InputFlags.None, "p-axis-y-label-coordinates", "axisYLabelCoordinates"], type: [InputFlags.None, "p-type", "type"] }, attrs: _c0$1o, decls: 4, vars: 4, consts: [["class", "po-chart-axis-x-label", "dominant-baseline", "middle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-chart-axis-y-label", 3, "po-chart-centered-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["dominant-baseline", "middle", 1, "po-chart-axis-x-label"], [1, "po-chart-axis-y-label"]], template: function PoChartAxisLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵtemplate(1, PoChartAxisLabelComponent__svg_text_1_Template, 2, 3, "text", 0);
      ɵɵelementEnd();
      ɵɵelementStart(2, "g");
      ɵɵtemplate(3, PoChartAxisLabelComponent__svg_text_3_Template, 2, 5, "text", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.axisXLabelCoordinates)("ngForTrackBy", ctx.trackBy);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.axisYLabelCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAxisLabelComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-axis-label]", template: '<svg:g>\n  <svg:text *ngFor="let item of axisXLabelCoordinates; trackBy: trackBy"\n    class="po-chart-axis-x-label" \n    dominant-baseline="middle"\n    [attr.x]="item.xCoordinate"\n    [attr.y]="item.yCoordinate">\n    {{ item.label }}\n  </svg:text> \n</svg:g>\n\n<svg:g>\n  <svg:text *ngFor="let item of axisYLabelCoordinates; let first = first; let last = last; trackBy: trackBy"\n    class="po-chart-axis-y-label" \n    [class.po-chart-centered-label]="!alignByTheCorners"\n    [attr.x]="item.xCoordinate"\n    [attr.y]="item.yCoordinate">\n    {{ item.label }}\n  </svg:text> \n</svg:g>' }]
  }], () => [], { alignByTheCorners: [{
    type: Input,
    args: ["p-align-by-the-corners"]
  }], axisXLabelCoordinates: [{
    type: Input,
    args: ["p-axis-x-label-coordinates"]
  }], axisYLabelCoordinates: [{
    type: Input,
    args: ["p-axis-y-label-coordinates"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAxisLabelComponent, { className: "PoChartAxisLabelComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-axis/po-chart-axis-label/po-chart-axis-label.component.ts", lineNumber: 10 });
})();
var _c0$1n = ["po-chart-axis", ""];
var PoChartAxisComponent = class _PoChartAxisComponent {
  mathsService;
  alignByTheCorners = false;
  type;
  range;
  categoriesCoordinates = new EventEmitter();
  axisXCoordinates;
  axisXLabelCoordinates;
  axisYCoordinates;
  axisYLabelCoordinates;
  axisXLabels = [];
  axisYLabels = [];
  gridLines = PoChartGridLines;
  seriesLength = 0;
  _axisOptions;
  _categories = [];
  _containerSize = {};
  _series = [];
  set series(seriesList) {
    const seriesDataArrayFilter = seriesList.filter((serie) => Array.isArray(serie.data));
    if (seriesDataArrayFilter.length) {
      this._series = seriesDataArrayFilter;
      this.seriesLength = this.mathsService.seriesGreaterLength(this.series);
      this.checkAxisOptions(this.axisOptions);
      this.setAxisXCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
      this.setAxisYCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    } else {
      this._series = [];
      this.cleanUpCoordinates();
    }
  }
  get series() {
    return this._series;
  }
  set categories(value) {
    this._categories = value;
    if (this.type === PoChartType.Bar) {
      this.setAxisXCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    } else {
      this.setAxisYCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    }
  }
  get categories() {
    return this._categories;
  }
  set containerSize(value) {
    this._containerSize = value;
    this.checkAxisOptions(this.axisOptions);
    this.setAxisXCoordinates(this.gridLines, this.seriesLength, this._containerSize, this.range, this.type);
    this.setAxisYCoordinates(this.gridLines, this.seriesLength, this._containerSize, this.range, this.type);
  }
  get containerSize() {
    return this._containerSize;
  }
  set axisOptions(value) {
    this._axisOptions = value;
    this.checkAxisOptions(this._axisOptions);
    if (this.type === PoChartType.Bar) {
      this.setAxisYCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    } else {
      this.setAxisXCoordinates(this.gridLines, this.seriesLength, this.containerSize, this.range, this.type);
    }
  }
  get axisOptions() {
    return this._axisOptions;
  }
  constructor(mathsService) {
    this.mathsService = mathsService;
  }
  setAxisXCoordinates(gridLines, seriesLength, containerSize, minMaxAxisValues, type) {
    if (seriesLength) {
      const amountOfAxisLabels = type === PoChartType.Bar ? seriesLength : gridLines;
      this.calculateAxisXLabelCoordinates(amountOfAxisLabels, containerSize, minMaxAxisValues, type);
    }
    const amountOfAxisXLines = this.amountOfAxisXLines(seriesLength, gridLines, type);
    this.calculateAxisXCoordinates(amountOfAxisXLines, containerSize, minMaxAxisValues);
  }
  amountOfAxisXLines(seriesLength, gridLines, type) {
    if (type === PoChartType.Bar) {
      return seriesLength <= 1 ? 2 : seriesLength + 1;
    }
    return gridLines === 0 ? 1 : gridLines;
  }
  setAxisYCoordinates(gridLines, seriesLength, containerSize, minMaxAxisValues, type) {
    const amountOfAxisY = type === PoChartType.Bar ? gridLines : seriesLength;
    if (seriesLength) {
      this.calculateAxisYLabelCoordinates(amountOfAxisY, containerSize, minMaxAxisValues, type);
    }
    if (type === PoChartType.Area) {
      this.getCategoriesRangeForMouseMove(amountOfAxisY, containerSize);
    }
    this.calculateAxisYCoordinates(amountOfAxisY, containerSize, type, minMaxAxisValues);
  }
  calculateAxisXCoordinates(amountOfAxisX, containerSize, range) {
    const startX = containerSize.axisXLabelWidth;
    const endX = containerSize.svgWidth;
    let coordinatesReferedToZero;
    let coordinatesList = [...Array(amountOfAxisX)].map((_, index) => {
      const yCoordinate = this.calculateAxisXCoordinateY(amountOfAxisX, containerSize, index);
      const coordinates = `M${startX} ${yCoordinate} L${endX}, ${yCoordinate}`;
      return { coordinates };
    });
    if (this.type !== PoChartType.Bar && range.minValue < 0 && !this.axisXLabels.includes("0")) {
      coordinatesReferedToZero = this.getCoordinatesRelatedToZero(containerSize, range, startX, endX);
      coordinatesList = [...coordinatesList, coordinatesReferedToZero];
    }
    this.axisXCoordinates = coordinatesList;
  }
  getCoordinatesRelatedToZero(containerSize, range, start, end, isAxisY = false) {
    const type = isAxisY ? PoChartType.Bar : PoChartType.Column;
    const basePosition = this.axisCoordinatesForValueZero(range, 0, containerSize, isAxisY);
    const coordinates = {
      column: {
        startX: start,
        endX: end,
        startY: basePosition,
        endY: basePosition
      },
      bar: {
        startX: basePosition,
        endX: basePosition,
        startY: start,
        endY: end
      }
    };
    return {
      coordinates: `M${coordinates[type].startX} ${coordinates[type].startY} L${coordinates[type].endX} ${coordinates[type].endY}`
    };
  }
  axisCoordinatesForValueZero(range, data, containerSize, isAxisY) {
    const { axisXLabelWidth, svgWidth, svgPlottingAreaHeight } = containerSize;
    const ratio = this.mathsService.getSeriePercentage(range, data);
    return Math.floor(isAxisY ? axisXLabelWidth + (svgWidth - axisXLabelWidth) * ratio : svgPlottingAreaHeight - svgPlottingAreaHeight * ratio + PoChartPlotAreaPaddingTop);
  }
  calculateAxisXLabelCoordinates(amountOfAxisX, containerSize, minMaxAxisValues, type) {
    this.axisXLabels = this.getAxisXLabels(type, minMaxAxisValues, amountOfAxisX);
    this.axisXLabelCoordinates = [...Array(amountOfAxisX)].map((_, index) => {
      const label = this.axisXLabels[index];
      const xCoordinate = this.calculateAxisXLabelXCoordinate(containerSize.axisXLabelWidth);
      const yCoordinate = this.calculateAxisXLabelYCoordinate(amountOfAxisX, containerSize, type, index);
      return { label, xCoordinate, yCoordinate };
    });
  }
  calculateAxisYCoordinates(amountOfAxisY, containerSize, type, range) {
    const startY = PoChartPlotAreaPaddingTop;
    const endY = containerSize.svgPlottingAreaHeight + PoChartPlotAreaPaddingTop;
    const length = amountOfAxisY === 0 || type === PoChartType.Bar ? amountOfAxisY : amountOfAxisY + 1;
    let coordinatesReferedToZero;
    let coordinatesList = [...Array(length)].map((_, index) => {
      const xCoordinate = this.calculateAxisYCoordinateX(containerSize, amountOfAxisY, index);
      const coordinates = `M${xCoordinate} ${startY} L${xCoordinate}, ${endY}`;
      return { coordinates };
    });
    if (type === PoChartType.Bar && range.minValue < 0 && !this.axisYLabels.includes("0")) {
      coordinatesReferedToZero = this.getCoordinatesRelatedToZero(containerSize, range, startY, endY, true);
      coordinatesList = [...coordinatesList, coordinatesReferedToZero];
    }
    this.axisYCoordinates = [...coordinatesList];
  }
  calculateAxisYLabelCoordinates(amountOfAxisY, containerSize, minMaxAxisValues, type) {
    this.axisYLabels = this.getAxisYLabels(type, minMaxAxisValues, amountOfAxisY);
    this.axisYLabelCoordinates = [...Array(amountOfAxisY)].map((_, index) => {
      const label = this.axisYLabels[index];
      const xCoordinate = this.getAxisXCoordinates(containerSize, amountOfAxisY, type, index);
      const yCoordinate = this.calculateAxisYLabelYCoordinate(containerSize);
      return { label, xCoordinate, yCoordinate };
    });
  }
  calculateAxisXLabelXCoordinate(axisXLabelWidth) {
    const labelPoChartPadding = PoChartPadding / 3;
    return axisXLabelWidth - labelPoChartPadding;
  }
  calculateAxisXLabelYCoordinate(amountOfAxisX, containerSize, type, index) {
    const amountOfLines = type === PoChartType.Bar ? amountOfAxisX : amountOfAxisX - 1;
    const yRatio = index / amountOfLines;
    if (type !== PoChartType.Bar) {
      return containerSize.svgPlottingAreaHeight - containerSize.svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop;
    }
    const halfCategoryHeight = containerSize.svgPlottingAreaHeight / amountOfAxisX / 2;
    return containerSize.svgPlottingAreaHeight - halfCategoryHeight - containerSize.svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop;
  }
  calculateAxisXCoordinateY(amountOfAxisX, containerSize, index) {
    const yRatio = index / (amountOfAxisX - 1);
    return containerSize.svgPlottingAreaHeight - containerSize.svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop;
  }
  calculateAxisYLabelYCoordinate(containerSize) {
    const textPoChartPadding = PoChartPadding / 3;
    return containerSize.svgHeight - textPoChartPadding;
  }
  centeredInCategoryArea(containerSize, amountOfAxisY, type, index) {
    const amountOfLines = type === PoChartType.Bar ? amountOfAxisY - 1 : amountOfAxisY;
    const xRatio = index / amountOfLines;
    if (type === PoChartType.Bar) {
      return Math.round(containerSize.axisXLabelWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio);
    }
    const halfCategoryWidth = (containerSize.svgWidth - containerSize.axisXLabelWidth) / amountOfAxisY / 2;
    return Math.round(containerSize.axisXLabelWidth + halfCategoryWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio);
  }
  calculateAxisYCoordinateX(containerSize, amountOfAxisY, index, subtractCategoryWidth = false) {
    const amountOfLines = this.alignByTheCorners ? amountOfAxisY - 1 : amountOfAxisY;
    const halfCategoryWidth = this.alignByTheCorners && subtractCategoryWidth ? (containerSize.svgWidth - containerSize.axisXLabelWidth) / (amountOfAxisY - 1) / 2 : 0;
    const divideIndexByAmountOfLines = index / amountOfLines;
    const xRatio = divideIndexByAmountOfLines === Infinity ? 0 : divideIndexByAmountOfLines;
    return Math.round(containerSize.axisXLabelWidth + (containerSize.svgWidth - containerSize.axisXLabelWidth) * xRatio - halfCategoryWidth);
  }
  checkAxisOptions(options = {}) {
    this.gridLines = options.gridLines && this.isValidGridLinesLengthOption(options.gridLines) ? options.gridLines : PoChartGridLines;
  }
  cleanUpCoordinates() {
    this.axisXCoordinates = [];
    this.axisYCoordinates = [];
    this.axisXLabelCoordinates = [];
    this.axisYLabelCoordinates = [];
    this.seriesLength = 0;
  }
  getAxisXCoordinates(containerSize, amountOfAxisY, type, index) {
    return this.alignByTheCorners ? this.calculateAxisYCoordinateX(containerSize, amountOfAxisY, index) : this.centeredInCategoryArea(containerSize, amountOfAxisY, type, index);
  }
  getCategoriesRangeForMouseMove(amountOfAxisY, containerSize) {
    const categoriesCoordinates = [...Array(amountOfAxisY)].map((_, index) => this.calculateAxisYCoordinateX(containerSize, amountOfAxisY, index, true));
    this.categoriesCoordinates.emit(categoriesCoordinates);
  }
  isValidGridLinesLengthOption(gridLines) {
    return gridLines >= 2 && gridLines <= 10;
  }
  getAxisXLabels(type, minMaxAxisValues, amountOfAxisX) {
    if (type === PoChartType.Bar) {
      const axisXLabelsList = this.formatCategoriesLabels(amountOfAxisX, this.categories);
      return axisXLabelsList.reverse();
    }
    return this.generateAverageOfLabels(minMaxAxisValues, amountOfAxisX);
  }
  getAxisYLabels(type, minMaxAxisValues, amountOfAxisX) {
    return type === PoChartType.Bar ? this.generateAverageOfLabels(minMaxAxisValues, amountOfAxisX) : this.formatCategoriesLabels(amountOfAxisX, this.categories);
  }
  formatCategoriesLabels(amountOfAxisX, categories = []) {
    return [...Array(amountOfAxisX)].map((_, index) => categories[index] ?? "-");
  }
  generateAverageOfLabels(minMaxAxisValues, amountOfAxisLines) {
    const averageLabelsList = this.mathsService.range(minMaxAxisValues, amountOfAxisLines);
    return averageLabelsList.map((label) => {
      const formattedDigit = label.toFixed(label % 1 && 2);
      const removeZeroDigits = formattedDigit.replace(/\.00$/, "").replace(/\-0$/, 0);
      return removeZeroDigits.toString();
    });
  }
  static ɵfac = function PoChartAxisComponent_Factory(t) {
    return new (t || _PoChartAxisComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartAxisComponent, selectors: [["", "po-chart-axis", ""]], inputs: { alignByTheCorners: [InputFlags.None, "p-align-by-the-corners", "alignByTheCorners"], type: [InputFlags.None, "p-type", "type"], range: [InputFlags.None, "p-range", "range"], series: [InputFlags.None, "p-series", "series"], categories: [InputFlags.None, "p-categories", "categories"], containerSize: [InputFlags.None, "p-container-size", "containerSize"], axisOptions: [InputFlags.None, "p-options", "axisOptions"] }, outputs: { categoriesCoordinates: "p-categories-coordinates" }, attrs: _c0$1n, decls: 2, vars: 6, consts: [["po-chart-axis-path", "", 3, "p-axis-x-coordinates", "p-axis-y-coordinates"], ["po-chart-axis-label", "", 3, "p-align-by-the-corners", "p-axis-x-label-coordinates", "p-axis-y-label-coordinates", "p-type"]], template: function PoChartAxisComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelement(0, "g", 0)(1, "g", 1);
    }
    if (rf & 2) {
      ɵɵproperty("p-axis-x-coordinates", ctx.axisXCoordinates)("p-axis-y-coordinates", ctx.axisYCoordinates);
      ɵɵadvance();
      ɵɵproperty("p-align-by-the-corners", ctx.alignByTheCorners)("p-axis-x-label-coordinates", ctx.axisXLabelCoordinates)("p-axis-y-label-coordinates", ctx.axisYLabelCoordinates)("p-type", ctx.type);
    }
  }, dependencies: [PoChartAxisPathComponent, PoChartAxisLabelComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartAxisComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-axis]", template: '<svg:g po-chart-axis-path [p-axis-x-coordinates]="axisXCoordinates" [p-axis-y-coordinates]="axisYCoordinates"></svg:g>\n\n<svg:g po-chart-axis-label \n  [p-align-by-the-corners]="alignByTheCorners" \n  [p-axis-x-label-coordinates]="axisXLabelCoordinates" \n  [p-axis-y-label-coordinates]="axisYLabelCoordinates" \n  [p-type]="type"\n  >\n</svg:g>' }]
  }], () => [{ type: PoChartMathsService }], { alignByTheCorners: [{
    type: Input,
    args: ["p-align-by-the-corners"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }], range: [{
    type: Input,
    args: ["p-range"]
  }], categoriesCoordinates: [{
    type: Output,
    args: ["p-categories-coordinates"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }], categories: [{
    type: Input,
    args: ["p-categories"]
  }], containerSize: [{
    type: Input,
    args: ["p-container-size"]
  }], axisOptions: [{
    type: Input,
    args: ["p-options"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartAxisComponent, { className: "PoChartAxisComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-axis/po-chart-axis.component.ts", lineNumber: 21 });
})();
var PoChartBarBaseComponent = class _PoChartBarBaseComponent {
  mathsService;
  categories;
  barClick = new EventEmitter();
  barHover = new EventEmitter();
  seriesPathsCoordinates;
  seriesGreaterLength;
  _containerSize = {};
  _range = {};
  _series = [];
  set range(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._range = value;
      this.calculateSeriesPathsCoordinates(this.containerSize, this._series, this._range);
    }
  }
  get range() {
    return this._range;
  }
  set containerSize(value) {
    this._containerSize = value;
    this.calculateSeriesPathsCoordinates(this._containerSize, this.series, this.range);
  }
  get containerSize() {
    return this._containerSize;
  }
  set series(seriesList) {
    const seriesDataArrayFilter = seriesList.filter((serie) => Array.isArray(serie.data));
    if (seriesDataArrayFilter.length) {
      this._series = seriesDataArrayFilter;
      this.seriesGreaterLength = this.mathsService.seriesGreaterLength(this.series);
      this.calculateSeriesPathsCoordinates(this.containerSize, seriesDataArrayFilter, this.range);
    } else {
      this._series = [];
    }
  }
  get series() {
    return this._series;
  }
  constructor(mathsService) {
    this.mathsService = mathsService;
  }
  onSerieBarClick(selectedItem) {
    this.barClick.emit(selectedItem);
  }
  onSerieBarHover(selectedItem) {
    this.barHover.emit(selectedItem);
  }
  trackBy(index) {
    return index;
  }
  calculateSeriesPathsCoordinates(containerSize, series, range) {
    this.seriesPathsCoordinates = series.map((serie, seriesIndex) => {
      if (Array.isArray(serie.data)) {
        let pathCoordinates = [];
        serie.data.forEach((data, serieDataIndex) => {
          if (this.mathsService.verifyIfFloatOrInteger(data)) {
            const coordinates = this.barCoordinates(seriesIndex, serieDataIndex, containerSize, range, data);
            const category = this.serieCategory(serieDataIndex, this.categories);
            const label = serie["label"];
            const color = serie["color"];
            const tooltip = serie["tooltip"];
            const tooltipLabel = this.getTooltipLabel(data, label, tooltip);
            pathCoordinates = [...pathCoordinates, { category, color, label, tooltipLabel, data, coordinates }];
          }
        });
        return pathCoordinates;
      }
    });
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = data.toString();
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  serieCategory(index, categories = []) {
    return categories[index] ?? void 0;
  }
  static ɵfac = function PoChartBarBaseComponent_Factory(t) {
    return new (t || _PoChartBarBaseComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoChartBarBaseComponent, inputs: { categories: [InputFlags.None, "p-categories", "categories"], range: [InputFlags.None, "p-range", "range"], containerSize: [InputFlags.None, "p-container-size", "containerSize"], series: [InputFlags.None, "p-series", "series"] }, outputs: { barClick: "p-bar-click", barHover: "p-bar-hover" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBarBaseComponent, [{
    type: Directive
  }], () => [{ type: PoChartMathsService }], { categories: [{
    type: Input,
    args: ["p-categories"]
  }], barClick: [{
    type: Output,
    args: ["p-bar-click"]
  }], barHover: [{
    type: Output,
    args: ["p-bar-hover"]
  }], range: [{
    type: Input,
    args: ["p-range"]
  }], containerSize: [{
    type: Input,
    args: ["p-container-size"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }] });
})();
var _c0$1m = ["po-chart-bar-path", ""];
function PoChartBarPathComponent__svg_path_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "path", 1);
    ɵɵlistener("mouseenter", function PoChartBarPathComponent__svg_path_0_Template__svg_path_mouseenter_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r3);
      const item_r1 = restoredCtx.$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onMouseEnter(item_r1));
    })("click", function PoChartBarPathComponent__svg_path_0_Template__svg_path_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r3);
      const item_r1 = restoredCtx.$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onClick(item_r1));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap((ctx_r0.color == null ? null : ctx_r0.color.includes("po-color")) ? ctx_r0.color : "");
    ɵɵproperty("p-tooltip", item_r1.tooltipLabel)("p-tooltip-position", ctx_r0.tooltipPosition)("p-append-in-body", true);
    ɵɵattribute("fill", ctx_r0.color)("d", item_r1.coordinates);
  }
}
var PoChartBarPathComponent = class _PoChartBarPathComponent {
  color;
  coordinates;
  tooltipPosition;
  barClick = new EventEmitter();
  barHover = new EventEmitter();
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  onClick(item) {
    const selectedItem = { label: item.label, data: item.data, category: item.category };
    this.barClick.emit(selectedItem);
  }
  onMouseEnter(item) {
    const selectedItem = { label: item.label, data: item.data, category: item.category };
    this.barHover.emit(selectedItem);
  }
  static ɵfac = function PoChartBarPathComponent_Factory(t) {
    return new (t || _PoChartBarPathComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartBarPathComponent, selectors: [["", "po-chart-bar-path", ""]], inputs: { color: [InputFlags.None, "p-color", "color"], coordinates: [InputFlags.None, "p-coordinates", "coordinates"], tooltipPosition: [InputFlags.None, "p-tooltip-position", "tooltipPosition"] }, outputs: { barClick: "p-bar-click", barHover: "p-bar-hover" }, attrs: _c0$1m, decls: 1, vars: 2, consts: [["class", "po-chart-bar-path", 3, "p-tooltip", "p-tooltip-position", "p-append-in-body", "class", "mouseenter", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-chart-bar-path", 3, "p-tooltip", "p-tooltip-position", "p-append-in-body", "mouseenter", "click"]], template: function PoChartBarPathComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoChartBarPathComponent__svg_path_0_Template, 1, 7, "path", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.coordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, PoTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBarPathComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-bar-path]", template: `<svg:path *ngFor="let item of coordinates; trackBy: trackBy"
  [p-tooltip]="item.tooltipLabel"
  [p-tooltip-position]="tooltipPosition"
  [p-append-in-body]='true'
  class="po-chart-bar-path"
  [class]="color?.includes('po-color') ? color : ''"
  [attr.fill]="color"
  [attr.d]="item.coordinates"
  (mouseenter)="onMouseEnter(item)"
  (click)="onClick(item)">
</svg:path> 
` }]
  }], () => [], { color: [{
    type: Input,
    args: ["p-color"]
  }], coordinates: [{
    type: Input,
    args: ["p-coordinates"]
  }], tooltipPosition: [{
    type: Input,
    args: ["p-tooltip-position"]
  }], barClick: [{
    type: Output,
    args: ["p-bar-click"]
  }], barHover: [{
    type: Output,
    args: ["p-bar-hover"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartBarPathComponent, { className: "PoChartBarPathComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-bar-path/po-chart-bar-path.component.ts", lineNumber: 9 });
})();
var _c0$1l = ["po-chart-bar", ""];
function PoChartBarComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 1);
    ɵɵlistener("p-bar-click", function PoChartBarComponent__svg_g_1_Template__svg_g_p_bar_click_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onSerieBarClick($event));
    })("p-bar-hover", function PoChartBarComponent__svg_g_1_Template__svg_g_p_bar_hover_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onSerieBarHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("po-chart-bar-group-" + i_r2);
    ɵɵadvance();
    ɵɵproperty("p-color", item_r1[0] == null ? null : item_r1[0].color)("p-coordinates", item_r1)("p-tooltip-position", ctx_r0.tooltipPosition);
    ɵɵattribute("key", "po-chart-bar-path-" + i_r2);
  }
}
var PoChartBarComponent = class _PoChartBarComponent extends PoChartBarBaseComponent {
  mathsService;
  tooltipPosition = "right";
  constructor(mathsService) {
    super(mathsService);
    this.mathsService = mathsService;
  }
  barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
    const { svgPlottingAreaWidth, barHeight, spaceBetweenBars } = this.calculateElementsMeasurements(containerSize);
    const { x1, x2 } = this.xCoordinates(minMaxSeriesValues, svgPlottingAreaWidth, containerSize.axisXLabelWidth, containerSize.svgWidth, serieValue);
    const { y1, y2 } = this.yCoordinates(seriesIndex, serieItemDataIndex, containerSize.svgPlottingAreaHeight, barHeight, spaceBetweenBars);
    return ["M", x1, y2, "L", x2, y2, "L", x2, y1, "L", x1, y1, "z"].join(" ");
  }
  calculateElementsMeasurements(containerSize) {
    const { svgWidth, svgPlottingAreaHeight, axisXLabelWidth } = containerSize;
    const svgPlottingAreaWidth = svgWidth - axisXLabelWidth;
    const categoryHeight = svgPlottingAreaHeight / this.seriesGreaterLength;
    const columnFraction = categoryHeight / (this.series.length + 2);
    const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
    const barHeight = columnFraction - spaceBetweenBars * (this.series.length - 1) / (this.series.length + 2);
    return { svgPlottingAreaWidth, barHeight, spaceBetweenBars };
  }
  xCoordinates(minMaxSeriesValues, svgPlottingAreaWidth, axisXLabelWidth, svgWidth, serieValue) {
    const { minValue } = minMaxSeriesValues;
    const valueZeroPercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
    const x1 = axisXLabelWidth + (svgWidth - axisXLabelWidth) * valueZeroPercentage;
    const xRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
    const x2 = Math.round(svgPlottingAreaWidth * xRatio + axisXLabelWidth);
    return { x1, x2 };
  }
  yCoordinates(seriesIndex, serieItemDataIndex, svgPlottingAreaHeight, barHeight, spaceBetweenBars) {
    const spaceBetweenAxisAndBars = barHeight;
    const yRatio = serieItemDataIndex / this.seriesGreaterLength;
    const y1 = Math.round(PoChartPlotAreaPaddingTop + svgPlottingAreaHeight * yRatio + spaceBetweenAxisAndBars + barHeight * seriesIndex + spaceBetweenBars * seriesIndex);
    const y2 = Math.round(y1 + barHeight);
    return { y1, y2 };
  }
  static ɵfac = function PoChartBarComponent_Factory(t) {
    return new (t || _PoChartBarComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartBarComponent, selectors: [["", "po-chart-bar", ""]], features: [ɵɵInheritDefinitionFeature], attrs: _c0$1l, decls: 2, vars: 2, consts: [[3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["po-chart-bar-path", "", 3, "p-color", "p-coordinates", "p-tooltip-position", "p-bar-click", "p-bar-hover"]], template: function PoChartBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵtemplate(1, PoChartBarComponent__svg_g_1_Template, 2, 6, "g", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, PoChartBarPathComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBarComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-bar]", template: `<svg:g>
  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    [class]="'po-chart-bar-group-' + i"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-bar-path
      [attr.key]="'po-chart-bar-path-' + i"
      [p-color]="item[0]?.color" 
      [p-coordinates]="item"
      [p-tooltip-position]="tooltipPosition"
      (p-bar-click)="onSerieBarClick($event)"
      (p-bar-hover)="onSerieBarHover($event)"
      >
      </svg:g>
  </svg:g>
</svg:g>` }]
  }], () => [{ type: PoChartMathsService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartBarComponent, { className: "PoChartBarComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-bar.component.ts", lineNumber: 15 });
})();
var _c0$1k = ["po-chart-column", ""];
function PoChartColumnComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 1);
    ɵɵlistener("p-bar-click", function PoChartColumnComponent__svg_g_1_Template__svg_g_p_bar_click_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onSerieBarClick($event));
    })("p-bar-hover", function PoChartColumnComponent__svg_g_1_Template__svg_g_p_bar_hover_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onSerieBarHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("po-chart-bar-group-" + i_r2);
    ɵɵadvance();
    ɵɵproperty("p-color", item_r1[0] == null ? null : item_r1[0].color)("p-coordinates", item_r1)("p-tooltip-position", ctx_r0.tooltipPosition);
    ɵɵattribute("key", "po-chart-bar-path-" + i_r2);
  }
}
var PoChartColumnComponent = class _PoChartColumnComponent extends PoChartBarBaseComponent {
  mathsService;
  tooltipPosition = "top";
  constructor(mathsService) {
    super(mathsService);
    this.mathsService = mathsService;
  }
  barCoordinates(seriesIndex, serieItemDataIndex, containerSize, minMaxSeriesValues, serieValue) {
    const { svgWidth, axisXLabelWidth, svgPlottingAreaHeight } = containerSize;
    const { chartBarPlotArea, barWidth, spaceBetweenBars } = this.calculateElementsMeasurements(svgWidth, axisXLabelWidth);
    const { x1, x2 } = this.xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth);
    const { y1, y2 } = this.yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue);
    return ["M", x1, y2, "L", x2, y2, "L", x2, y1, "L", x1, y1, "z"].join(" ");
  }
  calculateElementsMeasurements(svgWidth, axisXLabelWidth) {
    const chartBarPlotArea = svgWidth - axisXLabelWidth;
    const categoryWidth = chartBarPlotArea / this.seriesGreaterLength;
    const columnFraction = categoryWidth / (this.series.length + 2);
    const spaceBetweenBars = this.series.length > 1 ? columnFraction / (this.series.length + 2) : 0;
    const barWidth = columnFraction - spaceBetweenBars * (this.series.length - 1) / (this.series.length + 2);
    return { chartBarPlotArea, barWidth, spaceBetweenBars };
  }
  xCoordinates(seriesIndex, serieItemDataIndex, chartBarPlotArea, barWidth, spaceBetweenBars, axisXLabelWidth) {
    const spaceBetweenAxisAndBars = barWidth;
    const xRatio = serieItemDataIndex / this.seriesGreaterLength;
    const x1 = Math.round(axisXLabelWidth + chartBarPlotArea * xRatio + spaceBetweenAxisAndBars + barWidth * seriesIndex + spaceBetweenBars * seriesIndex);
    const x2 = Math.round(x1 + barWidth);
    return { x1, x2 };
  }
  yCoordinates(minMaxSeriesValues, svgPlottingAreaHeight, serieValue) {
    const { minValue } = minMaxSeriesValues;
    const minValuePercentage = this.mathsService.getSeriePercentage(minMaxSeriesValues, minValue < 0 ? 0 : minValue);
    const y1 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * minValuePercentage + PoChartPlotAreaPaddingTop);
    const yRatio = this.mathsService.getSeriePercentage(minMaxSeriesValues, serieValue);
    const y2 = Math.round(svgPlottingAreaHeight - svgPlottingAreaHeight * yRatio + PoChartPlotAreaPaddingTop);
    return { y1, y2 };
  }
  static ɵfac = function PoChartColumnComponent_Factory(t) {
    return new (t || _PoChartColumnComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartColumnComponent, selectors: [["", "po-chart-column", ""]], features: [ɵɵInheritDefinitionFeature], attrs: _c0$1k, decls: 2, vars: 2, consts: [[3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["po-chart-bar-path", "", 3, "p-color", "p-coordinates", "p-tooltip-position", "p-bar-click", "p-bar-hover"]], template: function PoChartColumnComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵtemplate(1, PoChartColumnComponent__svg_g_1_Template, 2, 6, "g", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, PoChartBarPathComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartColumnComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-column]", template: `<svg:g>
  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    [class]="'po-chart-bar-group-' + i"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-bar-path
      [attr.key]="'po-chart-bar-path-' + i"
      [p-color]="item[0]?.color" 
      [p-coordinates]="item"
      [p-tooltip-position]="tooltipPosition"
      (p-bar-click)="onSerieBarClick($event)"
      (p-bar-hover)="onSerieBarHover($event)"
      >
      </svg:g>
  </svg:g>
</svg:g>` }]
  }], () => [{ type: PoChartMathsService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartColumnComponent, { className: "PoChartColumnComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-bar/po-chart-column/po-chart-column.component.ts", lineNumber: 15 });
})();
var PoDefaultColors = [
  ["#29B6C5"],
  ["#0C6C94", "#29B6C5"],
  ["#0C6C94", "#29B6C5", "#C9ECF0"],
  ["#0C6C94", "#0B92B4", "#29B6C5", "#94DAE2"],
  ["#0C6C94", "#0B92B4", "#29B6C5", "#94DAE2", "#C9ECF0"],
  ["#0C6C94", "#00A5C5", "#0082A8", "#31628D", "#364473", "#32285C"],
  ["#0C6C94", "#00AACB", "#018DAE", "#277099", "#325783", "#35426E", "#32285D"],
  ["#0C6C94", "#00AFCE", "#0194B6", "#117FA2", "#0088AC", "#23789F", "#2B6992", "#32285C"],
  ["#0C6C94", "#00BAD5", "#00A7C7", "#0197B8", "#0088AC", "#23789F", "#2B6992", "#315C87", "#32285C"],
  ["#0C6C94", "#00BAD5", "#00A7C7", "#0197B8", "#0088AC", "#23789F", "#2B6992", "#315C87", "#364E7C", "#32285C"],
  [
    "#0C6C94",
    "#00BAD5",
    "#00A7C7",
    "#0197B8",
    "#0088AC",
    "#23789F",
    "#2B6992",
    "#315C87",
    "#364E7C",
    "#36436F",
    "#32285C"
  ],
  [
    "#0C6C94",
    "#00BAD5",
    "#00A7C7",
    "#0197B8",
    "#0088AC",
    "#23789F",
    "#2B6992",
    "#315C87",
    "#364E7C",
    "#36436F",
    "#333565",
    "#32285C"
  ]
];
var PoDefaultColorsTextBlack = ["#94DAE2", "#C9ECF0"];
var poColorPalette = Object.values(PoColorPaletteEnum);
var PoColorService = class _PoColorService {
  defaultColors = [];
  colorBlack = "#000000";
  /**
   * Avalia a propriedade `color` na lista de items passada. Caso sim, trata se é decimal ou string `po-color`. Caso não haja, retorna a cor default.
   *
   * @param data
   */
  getColors(data) {
    this.verifyIfHasColorProperty(data);
    return data.map((dataItem, index) => {
      if (dataItem.color) {
        dataItem.color = this.verifyIfIsPoColorPalette(dataItem.color);
        return dataItem;
      }
      const color = this.defaultColors[index] === void 0 ? this.colorBlack : this.defaultColors[index];
      return __spreadProps(__spreadValues({}, dataItem), { color });
    });
  }
  verifyIfHasColorProperty(data) {
    const hasColorProperty = data.every((dataItem) => dataItem.hasOwnProperty("color") && dataItem.color?.length > 0);
    if (!hasColorProperty) {
      this.defaultColors = this.getDefaultColors(data.length);
    }
  }
  verifyIfIsPoColorPalette(color) {
    if (poColorPalette.includes(color)) {
      return `po-${color}`;
    }
    return color;
  }
  getDefaultColors(length) {
    if (length === 1) {
      return PoDefaultColors[0];
    }
    const colorsLength = PoDefaultColors.length;
    if (length > colorsLength) {
      const quantityDuplicates = length / colorsLength;
      let colors2 = PoDefaultColors[colorsLength - 1];
      for (let i = 0; i <= quantityDuplicates; i++) {
        colors2 = colors2.concat(PoDefaultColors[colorsLength]);
      }
      return colors2;
    }
    return PoDefaultColors[length - 1];
  }
  static ɵfac = function PoColorService_Factory(t) {
    return new (t || _PoColorService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoColorService, factory: _PoColorService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoColorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var poChartDefaultHeight = 400;
var poChartMinHeight = 200;
var PoChartBaseComponent = class _PoChartBaseComponent {
  colorService;
  /** Define o título do gráfico. */
  title;
  /**
   * @optional
   *
   * @description
   *
   * Evento executado quando o usuário clicar sobre um elemento do gráfico.
   *
   * O evento emitirá o seguinte parâmetro:
   * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
   * - *area*, *line*, *column* e *bar*: um objeto contendo o nome da série, valor e categoria do eixo do gráfico.
   */
  seriesClick = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado quando o usuário passar o *mouse* sobre um elemento do gráfico.
   *
   * O evento emitirá o seguinte parâmetro de acordo com o tipo de gráfico:
   * - *donut* e *pie*: um objeto contendo a categoria e valor da série.
   * - *area*, *line*, *column* e *bar*: um objeto contendo a categoria, valor da série e categoria do eixo do gráfico.
   */
  seriesHover = new EventEmitter();
  // manipulação das séries tratadas internamente para preservar 'p-series';
  chartSeries = [];
  chartType;
  svgContainerSize;
  _options;
  _categories;
  _height;
  _series;
  _type;
  defaultType;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do gráfico.
   *
   * > O valor mínimo aceito nesta propriedade é 200.
   *
   * @default `400px`
   */
  set height(value) {
    const intValue = convertToInt(value);
    let height;
    if (isTypeof(value, "number")) {
      height = intValue <= poChartMinHeight ? poChartMinHeight : intValue;
    } else {
      height = this.setDefaultHeight();
    }
    this._height = height;
    this.getSvgContainerSize();
    this.rebuildComponentRef();
  }
  get height() {
    return this._height || this.setDefaultHeight();
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tipo de gráfico.
   *
   * É possível também combinar gráficos dos tipos linha e coluna. Para isso, opte pela declaração de `type` conforme a interface `PoChartSerie`.
   *
   * > Note que, se houver declaração de tipo de gráfico tanto em `p-type` quanto em `PochartSerie.type`, o valor `{ type }` da primeira série anulará o valor definido em `p-type`.
   *
   * Se não passado valor, o padrão será relativo à primeira série passada em `p-series`:
   * - Se `p-series = [{ data: [1,2,3] }]`: será `PoChartType.Column`.
   * - Se `p-series = [{ data: 1 }]`: será `PoChartType.Pie`.
   *
   * > Veja os valores válidos no *enum* `PoChartType`.
   */
  set type(value) {
    this._type = Object.values(PoChartType).includes(value) ? value : void 0;
    this.rebuildComponentRef();
  }
  get type() {
    return this._type;
  }
  /**
   * @description
   *
   * Define os elementos do gráfico que serão criados dinamicamente.
   */
  set series(value) {
    this._series = value || [];
    if (Array.isArray(this._series) && this._series.length) {
      this.setTypeDefault(this._series[0]);
    } else {
      this.transformObjectToArrayObject(this.series);
      this.rebuildComponentRef();
    }
  }
  get series() {
    return this._series;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define os nomes das categorias que serão plotadas no eixo X do gráfico caso seja do tipo `bar`, ou então nos eixos Y do grid de gráficos dos tipos `area`, `columnn` e `line`.
   *
   * > Gráficos do tipo `bar` dimensionam a área do gráfico de acordo com a largura do maior texto de categorias. No entanto, é uma boa prática optar por palavras curtas para que a leitura do gráfico não seja prejudicada.
   *
   * > Caso não seja especificado um valor para a categoria, será plotado um hífen na categoria referente a cada série.
   */
  set categories(value) {
    if (Array.isArray(value)) {
      this._categories = value;
    }
  }
  get categories() {
    return this._categories;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as configurações usadas no `po-chart`.
   *
   * É possível, por exemplo, definir as configurações de exibição das legendas,
   * configurar os eixos(*axis*) para os gráficos dos tipos `area`, `line`, `column` e `bar` da seguinte forma:
   *
   * ```
   *  chartOptions: PoChartOptions = {
   *    legend: true,
   *    axis: {
   *      minRange: 0,
   *      maxRange: 100,
   *      gridLines: 5,
   *    },
   *  };
   * ```
   */
  set options(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._options = value;
      if (this._options.hasOwnProperty("legend") && typeof this._options.legend === "boolean") {
        this.getSvgContainerSize();
      }
    }
  }
  get options() {
    return this._options;
  }
  constructor(colorService) {
    this.colorService = colorService;
  }
  get isTypeCircular() {
    return this.defaultType === PoChartType.Pie || this.defaultType === PoChartType.Donut;
  }
  ngOnChanges(changes) {
    const isArrayOfseries = Array.isArray(this.series) && this.series.length > 0;
    if (changes.series && isArrayOfseries || changes.type && isArrayOfseries || changes.categories && isArrayOfseries) {
      this.validateSerieAndAddType(this.series);
    }
    if (changes.type && !this.isTypeCircular || changes.categories && !this.isTypeCircular) {
      this.svgContainerSize = __spreadProps(__spreadValues({}, this.svgContainerSize), {
        axisXLabelWidth: this.calculateAxisXLabelArea()
      });
    }
  }
  onSeriesClick(event) {
    this.seriesClick.emit(event);
  }
  onSeriesHover(event) {
    this.seriesHover.emit(event);
  }
  setDefaultHeight() {
    return poChartDefaultHeight;
  }
  transformObjectToArrayObject(serie) {
    this.chartSeries = typeof serie === "object" && Object.keys(serie).length ? [__spreadValues({}, serie)] : [];
  }
  setTypeDefault(serie) {
    const data = serie.data;
    const serieType = Object.values(PoChartType).includes(serie.type) ? serie.type : void 0;
    this.defaultType = serieType ? serieType : Array.isArray(data) ? PoChartType.Column : PoChartType.Pie;
  }
  validateSerieAndAddType(series) {
    const filteredSeries = series.filter((serie) => this.isTypeCircular ? typeof serie.data === "number" : Array.isArray(serie.data));
    this.chartSeries = this.appendType(this.appendColors(filteredSeries));
  }
  appendColors(series) {
    return this.colorService.getColors(series);
  }
  appendType(series) {
    return series.map((serie, index) => {
      if (index === 0) {
        this.chartType = Object.values(PoChartType).includes(serie.type) ? serie.type : this.type || this.defaultType;
      }
      return __spreadProps(__spreadValues({}, serie), { type: serie.type || this.chartType });
    });
  }
  static ɵfac = function PoChartBaseComponent_Factory(t) {
    return new (t || _PoChartBaseComponent)(ɵɵdirectiveInject(PoColorService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoChartBaseComponent, inputs: { title: [InputFlags.None, "p-title", "title"], height: [InputFlags.None, "p-height", "height"], type: [InputFlags.None, "p-type", "type"], series: [InputFlags.None, "p-series", "series"], categories: [InputFlags.None, "p-categories", "categories"], options: [InputFlags.None, "p-options", "options"] }, outputs: { seriesClick: "p-series-click", seriesHover: "p-series-hover" }, features: [ɵɵNgOnChangesFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartBaseComponent, [{
    type: Directive
  }], () => [{ type: PoColorService }], { title: [{
    type: Input,
    args: ["p-title"]
  }], seriesClick: [{
    type: Output,
    args: ["p-series-click"]
  }], seriesHover: [{
    type: Output,
    args: ["p-series-hover"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }], categories: [{
    type: Input,
    args: ["p-categories"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }] });
})();
var PoChartSvgContainerService = class _PoChartSvgContainerService {
  constructor() {
  }
  /**
   * Retorna um objeto do tipo PoChartContainerSize contendo as dimensões necessárias para plotagem do SVG.
   *
   * @param chartHeight
   * @param chartWrapperWidth
   * @param chartHeaderHeight
   * @param chartLegendHeight
   */
  calculateSVGContainerMeasurements(chartHeight = 0, chartWrapperWidth = 0, chartHeaderHeight = 0, chartLegendHeight = 0) {
    const svgWidth = this.svgWidth(chartWrapperWidth);
    const centerX = this.center(chartWrapperWidth);
    const svgHeight = this.svgHeight(chartHeight, chartHeaderHeight, chartLegendHeight);
    const centerY = this.center(svgHeight);
    const svgPlottingAreaHeight = this.svgPlottingAreaHeight(svgHeight);
    return {
      svgWidth,
      svgHeight,
      centerX,
      centerY,
      svgPlottingAreaHeight
    };
  }
  // Largura do container.
  svgWidth(chartWrapperWidth) {
    const wrapperWidth = chartWrapperWidth - PoChartPadding * 2;
    return wrapperWidth > 0 ? wrapperWidth : 0;
  }
  // O centro do container. Usado para gráficos do tipo circular.
  center(dimension) {
    return dimension / 2;
  }
  // Altura do container
  svgHeight(chartHeight, chartHeaderHeight, chartLegendHeight) {
    const subtractedHeights = chartHeight - chartHeaderHeight - chartLegendHeight - PoChartPadding * 2;
    return subtractedHeights <= 0 ? 0 : subtractedHeights;
  }
  /**
   * Altura da área de plotagem.
   * Subtrai a altura do container SVG pelo padding superior + área para overflow de labels do eixo X.
   */
  svgPlottingAreaHeight(svgHeight) {
    return svgHeight - PoChartPadding - 8;
  }
  static ɵfac = function PoChartSvgContainerService_Factory(t) {
    return new (t || _PoChartSvgContainerService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoChartSvgContainerService, factory: _PoChartSvgContainerService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartSvgContainerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var _c0$1j = ["po-chart-line", ""];
function PoChartLineComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 2);
    ɵɵlistener("mouseenter", function PoChartLineComponent__svg_g_2_Template__svg_g_mouseenter_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const i_r3 = restoredCtx.index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onEnter(i_r3));
    })("mouseleave", function PoChartLineComponent__svg_g_2_Template__svg_g_mouseleave_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const i_r3 = restoredCtx.index;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.onLeave(i_r3));
    });
    ɵɵelement(1, "g", 3);
    ɵɵelementStart(2, "g", 4);
    ɵɵlistener("p-point-click", function PoChartLineComponent__svg_g_2_Template__svg_g_p_point_click_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onSeriePointClick($event));
    })("p-point-hover", function PoChartLineComponent__svg_g_2_Template__svg_g_p_point_hover_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.onSeriePointHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("po-chart-line-path-group-" + i_r3);
    ɵɵadvance();
    ɵɵproperty("p-chart-line", ctx_r1.chartType === "line")("p-animate", ctx_r1.animate)("p-color", item_r2.color)("p-coordinates", item_r2 == null ? null : item_r2.coordinates)("p-is-active", item_r2.isActive);
    ɵɵattribute("key", "po-chart-line-path-" + i_r3);
    ɵɵadvance();
    ɵɵproperty("p-animate", ctx_r1.animate)("p-chart-line", ctx_r1.chartType === "line")("p-color", item_r2.color)("p-coordinates", ctx_r1.seriesPointsCoordinates[i_r3])("p-is-active", ctx_r1.activeTooltip)("p-relative-to", "po-chart-line-path-group-" + i_r3);
    ɵɵattribute("key", "po-chart-line-path-points-group-" + i_r3);
  }
}
var PoChartLineComponent = class _PoChartLineComponent extends PoChartLineBaseComponent {
  mathsService;
  renderer;
  elementRef;
  constructor(mathsService, renderer, elementRef) {
    super(mathsService, renderer, elementRef);
    this.mathsService = mathsService;
    this.renderer = renderer;
    this.elementRef = elementRef;
  }
  onEnter(serieIndex) {
    return null;
  }
  onLeave(serieIndex) {
    return null;
  }
  onSeriePointHover(selectedItem) {
    const _a = selectedItem, { relativeTo } = _a, item = __objRest(_a, ["relativeTo"]);
    this.reorderSVGGroup(relativeTo);
    this.pointHover.emit(item);
  }
  // É necessário reordenar os svgs on hover pois eventualmente os elemntos svg ficam por trás de outros. Não há z-index para svgElement.
  reorderSVGGroup(pathGroup) {
    const pathGroupElement = this.elementRef.nativeElement.querySelectorAll(`.${pathGroup}`);
    this.animate = false;
    this.renderer.appendChild(this.chartLine.nativeElement, pathGroupElement[0]);
  }
  static ɵfac = function PoChartLineComponent_Factory(t) {
    return new (t || _PoChartLineComponent)(ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartLineComponent, selectors: [["", "po-chart-line", ""]], features: [ɵɵInheritDefinitionFeature], attrs: _c0$1j, decls: 3, vars: 2, consts: [["chartLine", ""], [3, "class", "mouseenter", "mouseleave", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "mouseenter", "mouseleave"], ["po-chart-path", "", 3, "p-chart-line", "p-animate", "p-color", "p-coordinates", "p-is-active"], ["po-chart-series-point", "", 3, "p-animate", "p-chart-line", "p-color", "p-coordinates", "p-is-active", "p-relative-to", "p-point-click", "p-point-hover"]], template: function PoChartLineComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g", null, 0);
      ɵɵtemplate(2, PoChartLineComponent__svg_g_2_Template, 3, 15, "g", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.seriesPathsCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, PoChartPathComponent, PoChartSeriesPointComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartLineComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-line]", template: `<svg:g #chartLine>

  <svg:g *ngFor="let item of seriesPathsCoordinates; let i = index; trackBy: trackBy"
    [class]="'po-chart-line-path-group-' + i"
    (mouseenter)="onEnter(i)"
    (mouseleave)="onLeave(i)"
  >
    <!-- SERIES PATHS -->
    <svg:g po-chart-path
      [p-chart-line]="chartType === 'line'"
      [attr.key]="'po-chart-line-path-' + i"
      [p-animate]="animate"
      [p-color]="item.color" 
      [p-coordinates]="item?.coordinates"
      [p-is-active]="item.isActive"
      >
      </svg:g>

    <!-- SERIES POINTS -->
    <svg:g po-chart-series-point
      [p-animate]="animate"
      [p-chart-line]="chartType === 'line'"
      [p-color]="item.color"
      [p-coordinates]="seriesPointsCoordinates[i]"
      [p-is-active]="activeTooltip"
      [p-relative-to]="'po-chart-line-path-group-' + i" 
      [attr.key]="'po-chart-line-path-points-group-' + i"
      (p-point-click)="onSeriePointClick($event)"
      (p-point-hover)="onSeriePointHover($event)"
      ></svg:g>
  </svg:g>

</svg:g>` }]
  }], () => [{ type: PoChartMathsService }, { type: Renderer2 }, { type: ElementRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartLineComponent, { className: "PoChartLineComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-line/po-chart-line.component.ts", lineNumber: 10 });
})();
var _c0$1i = ["svgPaths"];
var _c1$z = ["svgLabels"];
var PoChartCircularComponent = class _PoChartCircularComponent {
  ngZone;
  changeDetector;
  containerSize;
  circularClick = new EventEmitter();
  circularHover = new EventEmitter();
  svgPaths;
  svgLabels;
  canDisplayLabels = false;
  seriesLabels = [];
  seriesList;
  showLabels = false;
  innerRadius;
  totalValue;
  _options;
  _series;
  animate;
  set options(value) {
    if (!isNaN(value?.innerRadius)) {
      this._options = value;
      this.innerRadius = Math.min(Math.max(this._options.innerRadius, 0), 100);
    }
  }
  get options() {
    return this._options;
  }
  set series(value) {
    this._series = value;
    this.animate = true;
  }
  get series() {
    return this._series;
  }
  constructor(ngZone, changeDetector) {
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
  }
  onSerieClick(selectedItem) {
    this.circularClick.emit(selectedItem);
  }
  onSerieHover(selectedItem) {
    this.circularHover.emit(selectedItem);
  }
  calculateAngle(data, totalValue) {
    return data / totalValue * (Math.PI * 2);
  }
  drawSeries(series = [], height) {
    this.seriesList = [];
    this.showLabels = false;
    this.totalValue = this.calculateTotalValue(series);
    if (this.totalValue && this.totalValue > 0) {
      this.seriesList = this.validateSeries(series);
      this.changeDetector.detectChanges();
      if (this.seriesList.length && this.svgPaths) {
        this.initDrawPaths(this.seriesList, this.totalValue, height);
      }
    }
  }
  calculateTotalValue(series) {
    return series.reduce((previousValue, serie) => {
      const data = serie.data ? serie.data : serie.value;
      return previousValue + (data > 0 ? data : 0);
    }, 0);
  }
  calculateSerieCoordinates(series, totalValue, height) {
    let startRadianAngle;
    let endRadianAngle = PoChartStartAngle;
    series.forEach((serie, index) => {
      startRadianAngle = endRadianAngle;
      endRadianAngle = startRadianAngle + this.calculateAngle(serie.data, totalValue) - PoChartCompleteCircle;
      const coordinates = this.calculateCoordinates(height, startRadianAngle, endRadianAngle);
      this.svgPaths.toArray()[index].applyCoordinates(coordinates);
      this.showLabels = this.canDisplayLabels;
    });
  }
  calculateCoordinatesWithAnimation(series, totalValue, height, startRadianAngle, endRadianAngle, currentRadianAngle = 0, seriesIndex = 0) {
    const finishedCurrentSerie = currentRadianAngle > endRadianAngle;
    const finishedAllSeries = seriesIndex === series.length;
    if (finishedAllSeries) {
      this.animate = false;
      return;
    }
    if (finishedCurrentSerie) {
      this.setSerieLabelCoordinates(seriesIndex);
      currentRadianAngle = 0;
      seriesIndex++;
      startRadianAngle = startRadianAngle + endRadianAngle;
      endRadianAngle = seriesIndex < series.length ? this.calculateAngle(series[seriesIndex].data, totalValue) : void 0;
    } else {
      currentRadianAngle += PoChartAngleStepInterval;
      const currentEndRadianAngle = this.calculateCurrentEndAngle(currentRadianAngle, startRadianAngle, endRadianAngle);
      const coordinates = this.calculateCoordinates(height, startRadianAngle, currentEndRadianAngle);
      this.svgPaths.toArray()[seriesIndex].applyCoordinates(coordinates);
    }
    window.requestAnimationFrame(this.calculateCoordinatesWithAnimation.bind(this, series, totalValue, height, startRadianAngle, endRadianAngle, currentRadianAngle, seriesIndex));
  }
  calculateCurrentEndAngle(currentRadianAngle, startRadianAngle, endRadianAngle) {
    const isSerieDrawCompleted = startRadianAngle + currentRadianAngle > startRadianAngle + endRadianAngle;
    return isSerieDrawCompleted ? startRadianAngle + endRadianAngle - PoChartCompleteCircle : startRadianAngle + currentRadianAngle;
  }
  initDrawPaths(seriesList, totalValue, height) {
    if (!this.animate) {
      this.calculateSerieCoordinates(seriesList, totalValue, height);
    } else {
      const startRadianAngle = PoChartStartAngle;
      const endRadianAngle = this.calculateAngle(seriesList[0].data, totalValue);
      this.ngZone.runOutsideAngular(() => this.calculateCoordinatesWithAnimation(seriesList, totalValue, height, startRadianAngle, endRadianAngle));
    }
  }
  setSerieLabelCoordinates(index) {
    if (this.svgLabels.toArray().length) {
      this.svgLabels.toArray()[index].applyCoordinates(this.seriesLabels[index]);
    }
  }
  validateSeries(series) {
    return series.reduce((seriesList, serie) => {
      const data = serie.data ?? serie.value;
      if (data && data > 0) {
        const color = serie.color;
        const label = serie.label;
        const tooltip = serie.tooltip;
        const tooltipLabel = this.getTooltipLabel(data, label, tooltip);
        seriesList = [...seriesList, { data, color, label, tooltipLabel }];
      }
      return seriesList;
    }, []);
  }
  static ɵfac = function PoChartCircularComponent_Factory(t) {
    return new (t || _PoChartCircularComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoChartCircularComponent, viewQuery: function PoChartCircularComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1i, 5);
      ɵɵviewQuery(_c1$z, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgPaths = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgLabels = _t);
    }
  }, inputs: { containerSize: [InputFlags.None, "p-container-size", "containerSize"], options: [InputFlags.None, "p-options", "options"], series: [InputFlags.None, "p-series", "series"] }, outputs: { circularClick: "p-circular-click", circularHover: "p-circular-hover" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartCircularComponent, [{
    type: Directive
  }], () => [{ type: NgZone }, { type: ChangeDetectorRef }], { containerSize: [{
    type: Input,
    args: ["p-container-size"]
  }], circularClick: [{
    type: Output,
    args: ["p-circular-click"]
  }], circularHover: [{
    type: Output,
    args: ["p-circular-hover"]
  }], svgPaths: [{
    type: ViewChildren,
    args: ["svgPaths"]
  }], svgLabels: [{
    type: ViewChildren,
    args: ["svgLabels"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }] });
})();
var PoChartTooltipDirective = class _PoChartTooltipDirective {
  elementRef;
  renderer;
  tooltip;
  lastTooltipText;
  tooltipElement;
  tooltipText;
  tooltipTextContent;
  constructor(elementRef, renderer) {
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  onMouseEnter(event) {
    this.tooltipElement ? this.showTooltip() : this.createTooltip();
    this.tooltipPosition(event);
    this.lastTooltipText = this.tooltip;
  }
  onMouseLeave() {
    this.hideTooltip();
  }
  onMouseMove(event) {
    this.tooltipPosition(event);
  }
  calculateTooltipPosition(event) {
    const displacement = 12;
    return {
      left: event.clientX - this.tooltipElement.offsetWidth / 2,
      top: event.clientY - this.tooltipElement.offsetHeight - displacement
    };
  }
  createTooltip() {
    const chartWrapper = this.elementRef.nativeElement.closest(".po-chart-wrapper");
    this.tooltipElement = this.renderer.createElement("div");
    this.renderer.addClass(this.tooltipElement, "po-chart-tooltip");
    this.renderer.addClass(this.tooltipElement, "po-tooltip");
    this.renderer.setStyle(this.tooltipElement, "transition", "visibility .3s, opacity .3s linear");
    this.renderer.setStyle(this.tooltipElement, "opacity", 0.9);
    const divArrow = this.renderer.createElement("div");
    this.renderer.addClass(divArrow, "po-tooltip-arrow");
    this.renderer.addClass(divArrow, "po-arrow-bottom");
    this.tooltipText = this.renderer.createElement("p");
    this.renderer.addClass(this.tooltipText, "po-tooltip-content");
    this.tooltipTextContent = this.renderer.createText(this.tooltip);
    this.renderer.appendChild(this.tooltipText, this.tooltipTextContent);
    this.renderer.appendChild(this.tooltipElement, divArrow);
    this.renderer.appendChild(this.tooltipElement, this.tooltipText);
    this.renderer.appendChild(chartWrapper, this.tooltipElement);
  }
  hideTooltip() {
    this.renderer.setStyle(this.tooltipElement, "opacity", 0);
    this.renderer.setStyle(this.tooltipElement, "visibility", "hidden");
  }
  showTooltip() {
    this.renderer.setStyle(this.tooltipElement, "opacity", 0.9);
    this.renderer.setStyle(this.tooltipElement, "visibility", "visible");
    this.updatetooltipTextContent();
  }
  tooltipPosition(event) {
    const tooltipPositions = this.calculateTooltipPosition(event);
    this.renderer.setStyle(this.tooltipElement, "left", `${tooltipPositions.left}px`);
    this.renderer.setStyle(this.tooltipElement, "top", `${tooltipPositions.top}px`);
  }
  updatetooltipTextContent() {
    if (this.lastTooltipText !== this.tooltip) {
      this.renderer.removeChild(this.tooltipText, this.tooltipTextContent);
      this.tooltipTextContent = this.renderer.createText(this.tooltip);
      this.renderer.appendChild(this.tooltipText, this.tooltipTextContent);
    }
  }
  static ɵfac = function PoChartTooltipDirective_Factory(t) {
    return new (t || _PoChartTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoChartTooltipDirective, selectors: [["", "p-chart-tooltip", ""]], hostBindings: function PoChartTooltipDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function PoChartTooltipDirective_mouseenter_HostBindingHandler($event) {
        return ctx.onMouseEnter($event);
      })("mouseleave", function PoChartTooltipDirective_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      })("mousemove", function PoChartTooltipDirective_mousemove_HostBindingHandler($event) {
        return ctx.onMouseMove($event);
      });
    }
  }, inputs: { tooltip: [InputFlags.None, "p-chart-tooltip", "tooltip"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[p-chart-tooltip]"
    }]
  }], () => [{ type: ElementRef }, { type: Renderer2 }], { tooltip: [{
    type: Input,
    args: ["p-chart-tooltip"]
  }], onMouseEnter: [{
    type: HostListener,
    args: ["mouseenter", ["$event"]]
  }], onMouseLeave: [{
    type: HostListener,
    args: ["mouseleave"]
  }], onMouseMove: [{
    type: HostListener,
    args: ["mousemove", ["$event"]]
  }] });
})();
var _c0$1h = ["svgPath"];
var _c1$y = ["po-chart-circular-path", ""];
var PoChartCircularPathComponent = class _PoChartCircularPathComponent {
  renderer;
  serie;
  onClick = new EventEmitter();
  onHover = new EventEmitter();
  svgPath;
  constructor(renderer) {
    this.renderer = renderer;
  }
  applyCoordinates(coordinates) {
    this.renderer.setAttribute(this.svgPath.nativeElement, "d", coordinates);
  }
  onMouseClick() {
    const { label, data } = this.serie;
    this.onClick.emit({ label, data });
  }
  onMouseEnter() {
    const { label, data } = this.serie;
    this.onHover.emit({ label, data });
  }
  static ɵfac = function PoChartCircularPathComponent_Factory(t) {
    return new (t || _PoChartCircularPathComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartCircularPathComponent, selectors: [["", "po-chart-circular-path", ""]], viewQuery: function PoChartCircularPathComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1h, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgPath = _t.first);
    }
  }, inputs: { serie: [InputFlags.None, "p-serie", "serie"] }, outputs: { onClick: "p-on-click", onHover: "p-on-hover" }, attrs: _c1$y, decls: 2, vars: 4, consts: [[1, "po-path-item", 3, "p-chart-tooltip", "click", "mouseenter"], ["svgPath", ""]], template: function PoChartCircularPathComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "path", 0, 1);
      ɵɵlistener("click", function PoChartCircularPathComponent_Template__svg_path_click_0_listener() {
        return ctx.onMouseClick();
      })("mouseenter", function PoChartCircularPathComponent_Template__svg_path_mouseenter_0_listener() {
        return ctx.onMouseEnter();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassMap((ctx.serie == null ? null : ctx.serie.color.includes("po-color")) ? ctx.serie.color : "");
      ɵɵproperty("p-chart-tooltip", ctx.serie == null ? null : ctx.serie.tooltipLabel);
      ɵɵattribute("fill", ctx.serie == null ? null : ctx.serie.color);
    }
  }, dependencies: [PoChartTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartCircularPathComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-circular-path]", template: `<svg:path #svgPath
  class="po-path-item"
  [class]="serie?.color.includes('po-color') ? serie.color : ''"
  [p-chart-tooltip]="serie?.tooltipLabel"
  [attr.fill]="serie?.color"
  (click)="onMouseClick()"
  (mouseenter)="onMouseEnter()"
  >
</svg:path> 
` }]
  }], () => [{ type: Renderer2 }], { serie: [{
    type: Input,
    args: ["p-serie"]
  }], onClick: [{
    type: Output,
    args: ["p-on-click"]
  }], onHover: [{
    type: Output,
    args: ["p-on-hover"]
  }], svgPath: [{
    type: ViewChild,
    args: ["svgPath", { read: ElementRef }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartCircularPathComponent, { className: "PoChartCircularPathComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-circular-path/po-chart-circular-path.component.ts", lineNumber: 9 });
})();
var _c0$1g = ["svgLabel"];
var _c1$x = ["po-chart-circular-label", ""];
var PoChartCircularLabelComponent = class _PoChartCircularLabelComponent {
  changeDetection;
  renderer;
  serie;
  showLabel;
  svgLabel;
  constructor(changeDetection, renderer) {
    this.changeDetection = changeDetection;
    this.renderer = renderer;
  }
  applyCoordinates(coordinates) {
    this.renderer.setAttribute(this.svgLabel.nativeElement, "x", coordinates.xCoordinate.toString());
    this.renderer.setAttribute(this.svgLabel.nativeElement, "y", coordinates.yCoordinate.toString());
    this.showLabel = true;
    this.changeDetection.detectChanges();
  }
  static ɵfac = function PoChartCircularLabelComponent_Factory(t) {
    return new (t || _PoChartCircularLabelComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartCircularLabelComponent, selectors: [["", "po-chart-circular-label", ""]], viewQuery: function PoChartCircularLabelComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1g, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgLabel = _t.first);
    }
  }, inputs: { serie: [InputFlags.None, "p-serie", "serie"], showLabel: [InputFlags.None, "p-show-label", "showLabel"] }, attrs: _c1$x, decls: 3, vars: 6, consts: [["dominant-baseline", "middle", 1, "po-chart-label"], ["svgLabel", ""]], template: function PoChartCircularLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "text", 0, 1);
      ɵɵtext(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("po-invisible", !ctx.showLabel);
      ɵɵattribute("fill", ctx.serie == null ? null : ctx.serie.color)("x", ctx.serie == null ? null : ctx.serie.xCoordinate)("y", ctx.serie == null ? null : ctx.serie.yCoordinate);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.serie == null ? null : ctx.serie.label, "\n");
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartCircularLabelComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-circular-label]", template: '<svg:text #svgLabel \n  class="po-chart-label" \n  dominant-baseline="middle"\n  [class.po-invisible]="!showLabel"\n  [attr.fill]="serie?.color"\n  [attr.x]="serie?.xCoordinate"\n  [attr.y]="serie?.yCoordinate">\n  {{ serie?.label }}\n</svg:text> ' }]
  }], () => [{ type: ChangeDetectorRef }, { type: Renderer2 }], { serie: [{
    type: Input,
    args: ["p-serie"]
  }], showLabel: [{
    type: Input,
    args: ["p-show-label"]
  }], svgLabel: [{
    type: ViewChild,
    args: ["svgLabel", { read: ElementRef }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartCircularLabelComponent, { className: "PoChartCircularLabelComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-circular-label/po-chart-circular-label.component.ts", lineNumber: 9 });
})();
var _c0$1f = ["po-chart-pie", ""];
function PoChartPieComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 2, 3);
    ɵɵlistener("p-on-click", function PoChartPieComponent__svg_g_1_Template__svg_g_p_on_click_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onSerieClick($event));
    })("p-on-hover", function PoChartPieComponent__svg_g_1_Template__svg_g_p_on_hover_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onSerieHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r2);
    ɵɵattribute("key", "po-chart-circular-path-" + i_r3);
  }
}
function PoChartPieComponent__svg_g_2__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵelement(1, "g", 4, 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const i_r10 = ctx.index;
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r9)("p-show-label", ctx_r8.showLabels);
    ɵɵattribute("key", "po-chart-circular-label-" + i_r10);
  }
}
function PoChartPieComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵtemplate(1, PoChartPieComponent__svg_g_2__svg_g_1_Template, 3, 3, "g", 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.seriesLabels);
  }
}
var PoChartPieComponent = class _PoChartPieComponent extends PoChartCircularComponent {
  /* istanbul ignore next */
  constructor(ngZone, changeDetector) {
    super(ngZone, changeDetector);
  }
  ngOnChanges(changes) {
    if (changes.series || changes.containerSize) {
      this.drawSeries(this.series, this.containerSize.svgHeight);
    }
  }
  calculateCoordinates(height, startRadianAngle, endRadianAngle) {
    const radius = height / 2;
    const sinAlpha = Math.sin(startRadianAngle);
    const cosAlpha = Math.cos(startRadianAngle);
    const sinBeta = Math.sin(endRadianAngle);
    const cosBeta = Math.cos(endRadianAngle);
    const startX = radius + cosAlpha * radius;
    const startY = radius + sinAlpha * radius;
    const endX = radius + cosBeta * radius;
    const endY = radius + sinBeta * radius;
    const largeArc = endRadianAngle - startRadianAngle > Math.PI;
    return [
      "M",
      startX,
      startY,
      "A",
      radius,
      radius,
      0,
      largeArc ? "1,1" : "0,1",
      endX,
      endY,
      "L",
      radius,
      radius,
      "Z"
    ].join(" ");
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = data.toString();
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  static ɵfac = function PoChartPieComponent_Factory(t) {
    return new (t || _PoChartPieComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartPieComponent, selectors: [["", "po-chart-pie", ""]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], attrs: _c0$1f, decls: 3, vars: 2, consts: [[4, "ngFor", "ngForOf"], [4, "ngIf"], ["po-chart-circular-path", "", 3, "p-serie", "p-on-click", "p-on-hover"], ["svgPaths", ""], ["po-chart-circular-label", "", 3, "p-serie", "p-show-label"], ["svgLabels", ""]], template: function PoChartPieComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵtemplate(1, PoChartPieComponent__svg_g_1_Template, 3, 2, "g", 0)(2, PoChartPieComponent__svg_g_2_Template, 2, 1, "g", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.seriesList);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.canDisplayLabels);
    }
  }, dependencies: [NgForOf, NgIf, PoChartCircularPathComponent, PoChartCircularLabelComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartPieComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-pie]", template: `<svg:g>
  <!-- SERIES PATHS -->
  <svg:g *ngFor="let item of seriesList; let i = index">
    <svg:g #svgPaths po-chart-circular-path
      [attr.key]="'po-chart-circular-path-' + i"
      [p-serie]="item"
      (p-on-click)="onSerieClick($event)"
      (p-on-hover)="onSerieHover($event)">
    </svg:g>
  </svg:g>

  <!-- SERIES LABELS -->
  <svg:g *ngIf="canDisplayLabels">
    <svg:g *ngFor="let item of seriesLabels; let i = index">
      <svg:g #svgLabels po-chart-circular-label
        [attr.key]="'po-chart-circular-label-' + i"
        [p-serie]="item"
        [p-show-label]="showLabels">
      </svg:g>
    </svg:g>
  </svg:g>
</svg:g>

` }]
  }], () => [{ type: NgZone }, { type: ChangeDetectorRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartPieComponent, { className: "PoChartPieComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-pie/po-chart-pie.component.ts", lineNumber: 9 });
})();
var _c0$1e = ["po-chart-donut", ""];
function PoChartDonutComponent__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g")(1, "g", 2, 3);
    ɵɵlistener("p-on-click", function PoChartDonutComponent__svg_g_1_Template__svg_g_p_on_click_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onSerieClick($event));
    })("p-on-hover", function PoChartDonutComponent__svg_g_1_Template__svg_g_p_on_hover_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onSerieHover($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const i_r3 = ctx.index;
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r2);
    ɵɵattribute("key", "po-chart-circular-path-" + i_r3);
  }
}
function PoChartDonutComponent__svg_g_2__svg_g_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵelement(1, "g", 4, 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const i_r10 = ctx.index;
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("p-serie", item_r9)("p-show-label", ctx_r8.showLabels);
    ɵɵattribute("key", "po-chart-circular-label-" + i_r10);
  }
}
function PoChartDonutComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g");
    ɵɵtemplate(1, PoChartDonutComponent__svg_g_2__svg_g_1_Template, 3, 3, "g", 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.seriesLabels);
  }
}
var PoChartDonutComponent = class _PoChartDonutComponent extends PoChartCircularComponent {
  poChartBlackColor = "#000000";
  poChartWhiteColor = "#ffffff";
  /* istanbul ignore next */
  constructor(ngZone, changeDetector) {
    super(ngZone, changeDetector);
  }
  ngOnChanges(changes) {
    if (changes.series || changes.containerSize || changes.options) {
      this.drawSeries(this.series, this.containerSize.svgHeight);
      this.applySeriesLabels(this.seriesList, this.containerSize.svgHeight);
    }
  }
  calculateCoordinates(height, startRadianAngle, endRadianAngle) {
    const radius = height / 2;
    const innerRadius = this.getInnerRadius(radius);
    const sinAlpha = Math.sin(startRadianAngle);
    const cosAlpha = Math.cos(startRadianAngle);
    const sinBeta = Math.sin(endRadianAngle);
    const cosBeta = Math.cos(endRadianAngle);
    const startX = radius + cosAlpha * radius;
    const startY = radius + sinAlpha * radius;
    const endX = radius + cosBeta * radius;
    const endY = radius + sinBeta * radius;
    const startInnerX = radius + cosAlpha * innerRadius;
    const startInnerY = radius + sinAlpha * innerRadius;
    const endInnerX = radius + cosBeta * innerRadius;
    const endInnerY = radius + sinBeta * innerRadius;
    const largeArc = endRadianAngle - startRadianAngle > Math.PI;
    this.verifyDisplayLabels(radius, innerRadius);
    return [
      "M",
      startX,
      startY,
      "A",
      radius,
      radius,
      0,
      largeArc ? "1,1" : "0,1",
      endX,
      endY,
      "L",
      endInnerX,
      endInnerY,
      "A",
      innerRadius,
      innerRadius,
      0,
      largeArc ? "1,0" : "0,0",
      startInnerX,
      startInnerY,
      "Z"
    ].join(" ");
  }
  getTooltipLabel(data, label, tooltipLabel) {
    const dataLabel = label ? `${label}: ` : "";
    const dataValue = this.getPercentValue(data, this.totalValue) + "%";
    return tooltipLabel || `${dataLabel}${dataValue}`;
  }
  applySeriesLabels(seriesList, height) {
    let startRadianAngle = PoChartStartAngle;
    let endRadianAngle = PoChartStartAngle;
    this.seriesLabels = seriesList.map((serie) => {
      startRadianAngle = endRadianAngle;
      endRadianAngle = startRadianAngle + this.calculateAngle(serie.data, this.totalValue);
      const label = this.getPercentValue(serie.data, this.totalValue) + "% ";
      const color = this.getTextColor(serie.color);
      const coordinates = this.calculateLabelCoordinates(height, startRadianAngle, endRadianAngle);
      return __spreadProps(__spreadValues({}, coordinates), { label, color });
    });
  }
  calculateLabelCoordinates(height, startRadianAngle, endRadianAngle) {
    const radius = height / 2;
    const innerRadius = this.getInnerRadius(radius);
    const sliceCenterAngle = (startRadianAngle + endRadianAngle) / 2;
    const labelRadius = innerRadius + (radius - innerRadius) / 2;
    const xCoordinate = labelRadius * Math.cos(sliceCenterAngle) + radius;
    const yCoordinate = labelRadius * Math.sin(sliceCenterAngle) + radius;
    return { xCoordinate, yCoordinate };
  }
  getInnerRadius(radius) {
    const defaultInnerRadius = radius - PoChartDonutDefaultThickness;
    return this.innerRadius >= 0 ? this.innerRadius / 100 * radius : defaultInnerRadius;
  }
  getPercentValue(value, totalValue) {
    const percentValue = value / totalValue * 100;
    const floatPercentValue = convertNumberToDecimal(percentValue, 2);
    return String(floatPercentValue).replace(".", ",");
  }
  getTextColor(color) {
    if (PoDefaultColorsTextBlack.includes(color)) {
      return this.poChartBlackColor;
    }
    return this.poChartWhiteColor;
  }
  verifyDisplayLabels(radius, innerRadius) {
    this.canDisplayLabels = radius - innerRadius >= radius - (radius - PoChartDonutDefaultThickness);
  }
  static ɵfac = function PoChartDonutComponent_Factory(t) {
    return new (t || _PoChartDonutComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartDonutComponent, selectors: [["", "po-chart-donut", ""]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], attrs: _c0$1e, decls: 3, vars: 2, consts: [[4, "ngFor", "ngForOf"], [4, "ngIf"], ["po-chart-circular-path", "", 3, "p-serie", "p-on-click", "p-on-hover"], ["svgPaths", ""], ["po-chart-circular-label", "", 3, "p-serie", "p-show-label"], ["svgLabels", ""]], template: function PoChartDonutComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵtemplate(1, PoChartDonutComponent__svg_g_1_Template, 3, 2, "g", 0)(2, PoChartDonutComponent__svg_g_2_Template, 2, 1, "g", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.seriesList);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.canDisplayLabels);
    }
  }, dependencies: [NgForOf, NgIf, PoChartCircularPathComponent, PoChartCircularLabelComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartDonutComponent, [{
    type: Component,
    args: [{ selector: "[po-chart-donut]", template: `<svg:g>
  <!-- SERIES PATHS -->
  <svg:g *ngFor="let item of seriesList; let i = index">
    <svg:g #svgPaths po-chart-circular-path
      [attr.key]="'po-chart-circular-path-' + i"
      [p-serie]="item"
      (p-on-click)="onSerieClick($event)"
      (p-on-hover)="onSerieHover($event)">
    </svg:g>
  </svg:g>

  <!-- SERIES LABELS -->
  <svg:g *ngIf="canDisplayLabels">
    <svg:g *ngFor="let item of seriesLabels; let i = index">
      <svg:g #svgLabels po-chart-circular-label
        [attr.key]="'po-chart-circular-label-' + i"
        [p-serie]="item"
        [p-show-label]="showLabels">
      </svg:g>
    </svg:g>
  </svg:g>
</svg:g>

` }]
  }], () => [{ type: NgZone }, { type: ChangeDetectorRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartDonutComponent, { className: "PoChartDonutComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-circular/po-chart-donut/po-chart-donut.component.ts", lineNumber: 13 });
})();
var _c0$1d = ["svgELement"];
function PoChartContainerComponent__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 9);
    ɵɵlistener("p-categories-coordinates", function PoChartContainerComponent__svg_g_2_Template__svg_g_p_categories_coordinates_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.getCategoriesCoordinates($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-align-by-the-corners", ctx_r1.alignByTheCorners)("p-range", ctx_r1.range)("p-type", ctx_r1.type)("p-series", ctx_r1.series)("p-container-size", ctx_r1.containerSize)("p-options", ctx_r1.axisOptions)("p-categories", ctx_r1.categories);
  }
}
function PoChartContainerComponent__svg_g_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 10);
    ɵɵlistener("p-bar-hover", function PoChartContainerComponent__svg_g_3_Template__svg_g_p_bar_hover_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.onSerieHover($event));
    })("p-bar-click", function PoChartContainerComponent__svg_g_3_Template__svg_g_p_bar_click_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r12 = ɵɵnextContext();
      return ɵɵresetView(ctx_r12.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-align-by-the-corners", ctx_r2.alignByTheCorners)("p-svg-space", ctx_r2.svgSpace)("p-categories", ctx_r2.categories)("p-categories-coordinates", ctx_r2.categoriesCoordinates)("p-range", ctx_r2.range)("p-series", ctx_r2.seriesByType["area"])("p-container-size", ctx_r2.containerSize);
  }
}
function PoChartContainerComponent__svg_g_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 11);
    ɵɵlistener("p-bar-hover", function PoChartContainerComponent__svg_g_4_Template__svg_g_p_bar_hover_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r13 = ɵɵnextContext();
      return ɵɵresetView(ctx_r13.onSerieHover($event));
    })("p-bar-click", function PoChartContainerComponent__svg_g_4_Template__svg_g_p_bar_click_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-categories", ctx_r3.categories)("p-range", ctx_r3.range)("p-series", ctx_r3.seriesByType["column"])("p-container-size", ctx_r3.containerSize);
  }
}
function PoChartContainerComponent__svg_g_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 12);
    ɵɵlistener("p-point-hover", function PoChartContainerComponent__svg_g_5_Template__svg_g_p_point_hover_0_listener($event) {
      ɵɵrestoreView(_r17);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.onSerieHover($event));
    })("p-point-click", function PoChartContainerComponent__svg_g_5_Template__svg_g_p_point_click_0_listener($event) {
      ɵɵrestoreView(_r17);
      const ctx_r18 = ɵɵnextContext();
      return ɵɵresetView(ctx_r18.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("p-categories", ctx_r4.categories)("p-range", ctx_r4.range)("p-series", ctx_r4.seriesByType["line"])("p-container-size", ctx_r4.containerSize);
  }
}
function PoChartContainerComponent__svg_g_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 13);
    ɵɵlistener("p-bar-hover", function PoChartContainerComponent__svg_g_6_Template__svg_g_p_bar_hover_0_listener($event) {
      ɵɵrestoreView(_r20);
      const ctx_r19 = ɵɵnextContext();
      return ɵɵresetView(ctx_r19.onSerieHover($event));
    })("p-bar-click", function PoChartContainerComponent__svg_g_6_Template__svg_g_p_bar_click_0_listener($event) {
      ɵɵrestoreView(_r20);
      const ctx_r21 = ɵɵnextContext();
      return ɵɵresetView(ctx_r21.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("p-categories", ctx_r5.categories)("p-range", ctx_r5.range)("p-series", ctx_r5.seriesByType["bar"])("p-container-size", ctx_r5.containerSize);
  }
}
function PoChartContainerComponent__svg_g_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 14);
    ɵɵlistener("p-circular-hover", function PoChartContainerComponent__svg_g_7_Template__svg_g_p_circular_hover_0_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r22 = ɵɵnextContext();
      return ɵɵresetView(ctx_r22.onSerieHover($event));
    })("p-circular-click", function PoChartContainerComponent__svg_g_7_Template__svg_g_p_circular_click_0_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r24 = ɵɵnextContext();
      return ɵɵresetView(ctx_r24.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("p-series", ctx_r6.seriesByType["pie"])("p-container-size", ctx_r6.containerSize);
  }
}
function PoChartContainerComponent__svg_g_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = ɵɵgetCurrentView();
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "g", 15);
    ɵɵlistener("p-circular-hover", function PoChartContainerComponent__svg_g_8_Template__svg_g_p_circular_hover_0_listener($event) {
      ɵɵrestoreView(_r26);
      const ctx_r25 = ɵɵnextContext();
      return ɵɵresetView(ctx_r25.onSerieHover($event));
    })("p-circular-click", function PoChartContainerComponent__svg_g_8_Template__svg_g_p_circular_click_0_listener($event) {
      ɵɵrestoreView(_r26);
      const ctx_r27 = ɵɵnextContext();
      return ɵɵresetView(ctx_r27.onSerieClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext();
    ɵɵproperty("p-options", ctx_r7.options)("p-series", ctx_r7.seriesByType["donut"])("p-container-size", ctx_r7.containerSize);
  }
}
var PoChartContainerComponent = class _PoChartContainerComponent {
  mathsService;
  categories;
  type;
  containerSize;
  serieClick = new EventEmitter();
  serieHover = new EventEmitter();
  svgELement;
  alignByTheCorners;
  axisOptions;
  categoriesCoordinates;
  range;
  seriesByType;
  svgSpace;
  viewBox;
  _options;
  _series = [];
  set options(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._options = value;
      this.verifyAxisOptions(this._options);
    }
  }
  get options() {
    return this._options;
  }
  set series(data) {
    this._series = data;
    this.setAlignByTheCorners(this._series);
    this.setSeriesByType(this._series);
    this.setRange(this._series, this.options);
  }
  get series() {
    return this._series;
  }
  get isTypeCircular() {
    return this.type === PoChartType.Pie || this.type === PoChartType.Donut;
  }
  constructor(mathsService) {
    this.mathsService = mathsService;
  }
  ngOnChanges(changes) {
    if (changes.type || changes.containerSize) {
      this.setViewBox();
      this.setSvgSpace();
    }
  }
  getCategoriesCoordinates(value) {
    this.categoriesCoordinates = value;
  }
  onSerieClick(event) {
    this.serieClick.emit(event);
  }
  onSerieHover(event) {
    this.serieHover.emit(event);
  }
  getRange(series, options = {}) {
    const domain = this.mathsService.calculateMinAndMaxValues(series);
    const minValue = !options.axis?.minRange && domain.minValue > 0 ? 0 : options.axis?.minRange < domain.minValue ? options.axis.minRange : domain.minValue;
    const maxValue = options.axis?.maxRange > domain.maxValue ? options.axis.maxRange : domain.maxValue;
    const updatedDomainValues = { minValue, maxValue };
    return __spreadValues(__spreadValues({}, domain), updatedDomainValues);
  }
  setSvgSpace() {
    const svgPoint = this.svgELement.nativeElement.createSVGPoint();
    const svgDomMatrix = this.svgELement.nativeElement.getScreenCTM()?.inverse();
    this.svgSpace = { svgPoint, svgDomMatrix };
  }
  setAlignByTheCorners(series) {
    this.alignByTheCorners = series.every((serie) => serie.type === PoChartType.Area || serie.type === PoChartType.Bar);
  }
  setRange(series, options = {}) {
    if (!this.isTypeCircular) {
      this.range = this.getRange(series, options);
    }
  }
  setSeriesByType(series) {
    this.seriesByType = {
      [PoChartType.Area]: series.filter((serie) => serie.type === PoChartType.Area),
      [PoChartType.Column]: series.filter((serie) => serie.type === PoChartType.Column),
      [PoChartType.Bar]: series.filter((serie) => serie.type === PoChartType.Bar),
      [PoChartType.Line]: series.filter((serie) => serie.type === PoChartType.Line),
      [PoChartType.Donut]: series.filter((serie) => serie.type === PoChartType.Donut),
      [PoChartType.Pie]: series.filter((serie) => serie.type === PoChartType.Pie)
    };
  }
  setViewBox() {
    const { svgWidth, svgHeight } = this.containerSize;
    const viewBoxWidth = this.isTypeCircular ? svgHeight : svgWidth;
    const offsetXY = 1;
    this.viewBox = `${offsetXY} -${offsetXY} ${viewBoxWidth} ${this.containerSize.svgHeight}`;
  }
  verifyAxisOptions(options) {
    if (!this.isTypeCircular && options.hasOwnProperty("axis")) {
      this.range = this.getRange(this.series, this.options);
      this.axisOptions = __spreadValues(__spreadValues({}, this.axisOptions), options.axis);
    }
  }
  static ɵfac = function PoChartContainerComponent_Factory(t) {
    return new (t || _PoChartContainerComponent)(ɵɵdirectiveInject(PoChartMathsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartContainerComponent, selectors: [["po-chart-container"]], viewQuery: function PoChartContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1d, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgELement = _t.first);
    }
  }, inputs: { categories: [InputFlags.None, "p-categories", "categories"], type: [InputFlags.None, "p-type", "type"], containerSize: [InputFlags.None, "p-container-size", "containerSize"], options: [InputFlags.None, "p-options", "options"], series: [InputFlags.None, "p-series", "series"] }, outputs: { serieClick: "p-serie-click", serieHover: "p-serie-hover" }, features: [ɵɵNgOnChangesFeature], decls: 9, vars: 10, consts: [["preserveAspectRatio", "xMidYMin meet", 1, "po-chart-svg-element"], ["svgELement", ""], ["po-chart-axis", "", 3, "p-align-by-the-corners", "p-range", "p-type", "p-series", "p-container-size", "p-options", "p-categories", "p-categories-coordinates", 4, "ngIf"], ["po-chart-area", "", 3, "p-align-by-the-corners", "p-svg-space", "p-categories", "p-categories-coordinates", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click", 4, "ngIf"], ["po-chart-column", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click", 4, "ngIf"], ["po-chart-line", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-point-hover", "p-point-click", 4, "ngIf"], ["po-chart-bar", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click", 4, "ngIf"], ["po-chart-pie", "", 3, "p-series", "p-container-size", "p-circular-hover", "p-circular-click", 4, "ngIf"], ["po-chart-donut", "", 3, "p-options", "p-series", "p-container-size", "p-circular-hover", "p-circular-click", 4, "ngIf"], ["po-chart-axis", "", 3, "p-align-by-the-corners", "p-range", "p-type", "p-series", "p-container-size", "p-options", "p-categories", "p-categories-coordinates"], ["po-chart-area", "", 3, "p-align-by-the-corners", "p-svg-space", "p-categories", "p-categories-coordinates", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click"], ["po-chart-column", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click"], ["po-chart-line", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-point-hover", "p-point-click"], ["po-chart-bar", "", 3, "p-categories", "p-range", "p-series", "p-container-size", "p-bar-hover", "p-bar-click"], ["po-chart-pie", "", 3, "p-series", "p-container-size", "p-circular-hover", "p-circular-click"], ["po-chart-donut", "", 3, "p-options", "p-series", "p-container-size", "p-circular-hover", "p-circular-click"]], template: function PoChartContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "svg", 0, 1);
      ɵɵtemplate(2, PoChartContainerComponent__svg_g_2_Template, 1, 7, "g", 2)(3, PoChartContainerComponent__svg_g_3_Template, 1, 7, "g", 3)(4, PoChartContainerComponent__svg_g_4_Template, 1, 4, "g", 4)(5, PoChartContainerComponent__svg_g_5_Template, 1, 4, "g", 5)(6, PoChartContainerComponent__svg_g_6_Template, 1, 4, "g", 6)(7, PoChartContainerComponent__svg_g_7_Template, 1, 2, "g", 7)(8, PoChartContainerComponent__svg_g_8_Template, 1, 3, "g", 8);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("viewBox", ctx.viewBox)("width", ctx.containerSize.svgWidth)("height", ctx.containerSize.svgHeight);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.isTypeCircular);
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.type === "area" || ctx.type === "line" || ctx.type === "column") && ctx.seriesByType["area"].length);
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.type === "area" || ctx.type === "line" || ctx.type === "column") && ctx.seriesByType["column"].length);
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.type === "area" || ctx.type === "line" || ctx.type === "column") && ctx.seriesByType["line"].length);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "bar");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "pie");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "donut");
    }
  }, dependencies: [NgIf, PoChartAreaComponent, PoChartAxisComponent, PoChartLineComponent, PoChartPieComponent, PoChartDonutComponent, PoChartBarComponent, PoChartColumnComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartContainerComponent, [{
    type: Component,
    args: [{ selector: "po-chart-container", template: `<svg:svg
  #svgELement
  class="po-chart-svg-element"
  preserveAspectRatio="xMidYMin meet"
  [attr.viewBox]="viewBox"
  [attr.width]="containerSize.svgWidth"
  [attr.height]="containerSize.svgHeight"
>
  <!-- axis -->
  <svg:g
    *ngIf="!isTypeCircular"
    po-chart-axis
    [p-align-by-the-corners]="alignByTheCorners"
    [p-range]="range"
    [p-type]="type"
    [p-series]="series"
    [p-container-size]="containerSize"
    [p-options]="axisOptions"
    [p-categories]="categories"
    (p-categories-coordinates)="getCategoriesCoordinates($event)"
  ></svg:g>

  <!-- chart area -->
  <svg:g
    *ngIf="(type === 'area' || type === 'line' || type === 'column') && seriesByType['area'].length"
    po-chart-area
    [p-align-by-the-corners]="alignByTheCorners"
    [p-svg-space]="svgSpace"
    [p-categories]="categories"
    [p-categories-coordinates]="categoriesCoordinates"
    [p-range]="range"
    [p-series]="seriesByType['area']"
    [p-container-size]="containerSize"
    (p-bar-hover)="onSerieHover($event)"
    (p-bar-click)="onSerieClick($event)"
  ></svg:g>

  <!-- chart column -->
  <svg:g
    *ngIf="(type === 'area' || type === 'line' || type === 'column') && seriesByType['column'].length"
    po-chart-column
    [p-categories]="categories"
    [p-range]="range"
    [p-series]="seriesByType['column']"
    [p-container-size]="containerSize"
    (p-bar-hover)="onSerieHover($event)"
    (p-bar-click)="onSerieClick($event)"
  ></svg:g>

  <!-- chart line -->
  <svg:g
    *ngIf="(type === 'area' || type === 'line' || type === 'column') && seriesByType['line'].length"
    po-chart-line
    [p-categories]="categories"
    [p-range]="range"
    [p-series]="seriesByType['line']"
    [p-container-size]="containerSize"
    (p-point-hover)="onSerieHover($event)"
    (p-point-click)="onSerieClick($event)"
  ></svg:g>

  <!-- chart bar -->
  <svg:g
    *ngIf="type === 'bar'"
    po-chart-bar
    [p-categories]="categories"
    [p-range]="range"
    [p-series]="seriesByType['bar']"
    [p-container-size]="containerSize"
    (p-bar-hover)="onSerieHover($event)"
    (p-bar-click)="onSerieClick($event)"
  ></svg:g>

  <svg:g
    *ngIf="type === 'pie'"
    po-chart-pie
    [p-series]="seriesByType['pie']"
    [p-container-size]="containerSize"
    (p-circular-hover)="onSerieHover($event)"
    (p-circular-click)="onSerieClick($event)"
  ></svg:g>

  <svg:g
    *ngIf="type === 'donut'"
    po-chart-donut
    [p-options]="options"
    [p-series]="seriesByType['donut']"
    [p-container-size]="containerSize"
    (p-circular-hover)="onSerieHover($event)"
    (p-circular-click)="onSerieClick($event)"
  ></svg:g>
</svg:svg>
` }]
  }], () => [{ type: PoChartMathsService }], { categories: [{
    type: Input,
    args: ["p-categories"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }], containerSize: [{
    type: Input,
    args: ["p-container-size"]
  }], serieClick: [{
    type: Output,
    args: ["p-serie-click"]
  }], serieHover: [{
    type: Output,
    args: ["p-serie-hover"]
  }], svgELement: [{
    type: ViewChild,
    args: ["svgELement", { static: true }]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartContainerComponent, { className: "PoChartContainerComponent", filePath: "lib/components/po-chart/po-chart-container/po-chart-container.component.ts", lineNumber: 15 });
})();
function PoChartLegendComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "div", 4);
    ɵɵelementStart(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const serie_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵclassMap((serie_r1.color == null ? null : serie_r1.color.includes("po-color")) ? serie_r1.color : "");
    ɵɵstyleProp("background", serie_r1.color);
    ɵɵadvance(2);
    ɵɵtextInterpolate(serie_r1.label || serie_r1.category);
  }
}
var PoChartLegendComponent = class _PoChartLegendComponent {
  type;
  _series;
  set series(value) {
    this._series = value;
  }
  get series() {
    return this._series;
  }
  static ɵfac = function PoChartLegendComponent_Factory(t) {
    return new (t || _PoChartLegendComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartLegendComponent, selectors: [["po-chart-legend"]], inputs: { type: [InputFlags.None, "p-type", "type"], series: [InputFlags.None, "p-series", "series"] }, decls: 3, vars: 1, consts: [[1, "po-chart-legend"], [1, "po-chart-legend-container"], ["class", "po-chart-legend-item", 4, "ngFor", "ngForOf"], [1, "po-chart-legend-item"], [1, "po-chart-legend-square"], [1, "po-chart-legend-text"]], template: function PoChartLegendComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, PoChartLegendComponent_div_2_Template, 4, 5, "div", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.series);
    }
  }, dependencies: [NgForOf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartLegendComponent, [{
    type: Component,
    args: [{ selector: "po-chart-legend", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div class="po-chart-legend">
  <div class="po-chart-legend-container">
    <div class="po-chart-legend-item" *ngFor="let serie of series; let i = index">
      <div
        class="po-chart-legend-square"
        [class]="serie.color?.includes('po-color') ? serie.color : ''"
        [style.background]="serie.color"
      ></div>
      <span class="po-chart-legend-text">{{ serie.label || serie.category }}</span>
    </div>
  </div>
</div>
` }]
  }], null, { type: [{
    type: Input,
    args: ["p-type"]
  }], series: [{
    type: Input,
    args: ["p-series"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartLegendComponent, { className: "PoChartLegendComponent", filePath: "lib/components/po-chart/po-chart-legend/po-chart-legend.component.ts", lineNumber: 10 });
})();
var PoResizeObserverDirective = class _PoResizeObserverDirective {
  elementRef;
  resize = new EventEmitter();
  subscription = new Subscription();
  observer;
  chartWidthResize$ = new Subject();
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  ngOnDestroy() {
    if (this.isResizeObserverSupported) {
      this.observer.unobserve(this.elementRef.nativeElement);
      this.subscription.unsubscribe();
    }
  }
  ngOnInit() {
    if (this.isResizeObserverSupported) {
      this.observer = new window.ResizeObserver(() => {
        this.chartWidthResize$.next({});
      });
      this.observer.observe(this.elementRef.nativeElement);
      this.subscription.add(this.chartWidthResize$.pipe(debounceTime(20)).subscribe((_) => {
        this.resize.emit();
      }));
    }
  }
  get isResizeObserverSupported() {
    return typeof window.ResizeObserver === "function";
  }
  static ɵfac = function PoResizeObserverDirective_Factory(t) {
    return new (t || _PoResizeObserverDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoResizeObserverDirective, selectors: [["", "p-resize-observer", ""]], outputs: { resize: "p-resize-observer" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoResizeObserverDirective, [{
    type: Directive,
    args: [{
      selector: "[p-resize-observer]"
    }]
  }], () => [{ type: ElementRef }], { resize: [{
    type: Output,
    args: ["p-resize-observer"]
  }] });
})();
var _c0$1c = ["chartContainer"];
var _c1$w = ["chartHeader"];
var _c2$g = ["chartLegend"];
var _c3$a = ["chartWrapper"];
function PoChartComponent_ng_template_7_Template(rf, ctx) {
}
function PoChartComponent_div_9_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoChartComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoChartComponent_div_9_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r6 = ɵɵreference(11);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
  }
}
function PoChartComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-chart-legend", 10, 11);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("p-series", ctx_r5.chartSeries)("p-type", ctx_r5.type);
  }
}
var PoChartComponent = class _PoChartComponent extends PoChartBaseComponent {
  colorService;
  changeDetector;
  containerService;
  componentFactoryResolver;
  elementRef;
  mathsService;
  renderer;
  chartContainer;
  chartHeader;
  chartLegend;
  chartWrapper;
  calculatedComponentRefElement = false;
  calculatedSvgContainerElement = false;
  componentRef;
  initialized = false;
  windowResizeListener = new Subject();
  subscription = new Subscription();
  mappings = {};
  constructor(colorService, changeDetector, containerService, componentFactoryResolver, elementRef, mathsService, renderer) {
    super(colorService);
    this.colorService = colorService;
    this.changeDetector = changeDetector;
    this.containerService = containerService;
    this.componentFactoryResolver = componentFactoryResolver;
    this.elementRef = elementRef;
    this.mathsService = mathsService;
    this.renderer = renderer;
  }
  onResize = () => {
    this.getSvgContainerSize();
    this.windowResizeListener.next({});
  };
  ngAfterViewInit() {
    this.initialized = true;
    this.getSvgContainerSize();
  }
  ngDoCheck() {
    const charWrapperWidth = this.chartWrapper.nativeElement.offsetWidth;
    const isDynamicChart = this.getComponentType(this.type);
    if (charWrapperWidth && this.initialized && !isDynamicChart && !this.calculatedSvgContainerElement) {
      this.getSvgContainerSize();
      this.calculatedSvgContainerElement = true;
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.removeWindowResizeListener();
  }
  resizeAction() {
    this.getSvgContainerSize();
    this.windowResizeListener.next({});
    this.changeDetector.detectChanges();
  }
  ngOnInit() {
    this.getSvgContainerSize();
  }
  rebuildComponentRef() {
    if (this.componentRef) {
      this.componentRef.destroy();
    }
  }
  calculateAxisXLabelArea() {
    const axisXLabels = this.chartType === PoChartType.Bar ? this.categories : this.chartSeries;
    return this.getAxisXLabelArea(this.mathsService.getLongestDataValue(axisXLabels, this.chartType, this.options));
  }
  getSvgContainerSize() {
    let axisXLabelWidth;
    const { chartHeaderHeight, chartLegendHeight, chartWrapperWidth } = this.getChartMeasurements();
    if (!this.isTypeCircular) {
      axisXLabelWidth = this.calculateAxisXLabelArea();
    }
    this.svgContainerSize = __spreadProps(__spreadValues({}, this.containerService.calculateSVGContainerMeasurements(this.height, chartWrapperWidth, chartHeaderHeight, chartLegendHeight)), {
      axisXLabelWidth
    });
  }
  chartLegendHeight(chartLegend) {
    return chartLegend ? chartLegend.nativeElement.offsetHeight : 0;
  }
  createComponent() {
    const componentType = this.getComponentType(this.type);
    const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
    this.componentRef = this.chartContainer.createComponent(factory);
    const instance = this.componentRef.instance;
    this.setComponentRefProperties(instance);
    return instance;
  }
  dynamicComponentSetting() {
    const instance = this.createComponent();
    this.setResizeListenerSubscribe(instance);
    this.changeDetector.detectChanges();
    this.setClickSubscribe(instance);
    this.setHoverSubscribe(instance);
  }
  getAxisXLabelArea(axisXLabel) {
    const labelPoChartPadding = PoChartPadding / 3;
    const spanElement = this.renderer.createElement("span");
    this.renderer.addClass(spanElement, "po-chart-axis-x-label");
    spanElement.innerHTML = axisXLabel;
    this.renderer.appendChild(this.elementRef.nativeElement, spanElement);
    const axisXLabelWidth = Math.ceil(spanElement.offsetWidth) + labelPoChartPadding;
    this.renderer.removeChild(this.elementRef.nativeElement, spanElement);
    return axisXLabelWidth > PoChartAxisXLabelArea ? axisXLabelWidth : PoChartAxisXLabelArea;
  }
  getComponentType(typeName) {
    return this.mappings[typeName];
  }
  getChartMeasurements() {
    const chartWrapperWidth = this.chartWrapper.nativeElement.offsetWidth;
    const chartHeaderHeight = this.chartHeader.nativeElement.offsetHeight;
    const chartLegendHeight = this.chartLegendHeight(this.chartLegend);
    return { chartWrapperWidth, chartHeaderHeight, chartLegendHeight };
  }
  removeWindowResizeListener() {
    if (this.onResize) {
      this.onResize = () => {
      };
    }
  }
  setComponentRefProperties(instance) {
    const { chartHeaderHeight, chartLegendHeight, chartWrapperWidth } = this.getChartMeasurements();
    instance.chartHeader = chartHeaderHeight;
    instance.chartLegend = chartLegendHeight;
    instance.chartWrapper = chartWrapperWidth;
    instance.colors = PoDefaultColors[0];
    instance.height = this.height;
    instance.type = this.type;
    instance.series = this.chartSeries || [];
  }
  setClickSubscribe(instance) {
    this.subscription.add(instance.onSerieClick.subscribe((event) => {
      this.onSeriesClick(event);
    }));
  }
  setHoverSubscribe(instance) {
    this.subscription.add(instance.onSerieHover.subscribe((event) => {
      this.onSeriesHover(event);
    }));
  }
  setResizeListenerSubscribe(instance) {
    this.subscription.add(this.windowResizeListener.subscribe(() => {
      const measuresForComponentRef = this.getChartMeasurements();
      instance.chartWrapper = measuresForComponentRef.chartWrapperWidth;
      instance.chartHeader = measuresForComponentRef.chartHeaderHeight;
      instance.chartLegend = measuresForComponentRef.chartLegendHeight;
    }));
  }
  static ɵfac = function PoChartComponent_Factory(t) {
    return new (t || _PoChartComponent)(ɵɵdirectiveInject(PoColorService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoChartSvgContainerService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoChartMathsService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoChartComponent, selectors: [["po-chart"]], viewQuery: function PoChartComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1c, 7, ViewContainerRef);
      ɵɵviewQuery(_c1$w, 7);
      ɵɵviewQuery(_c2$g, 5, ElementRef);
      ɵɵviewQuery(_c3$a, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartHeader = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartLegend = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chartWrapper = _t.first);
    }
  }, hostBindings: function PoChartComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("resize", function PoChartComponent_resize_HostBindingHandler() {
        return ctx.onResize();
      }, false, ɵɵresolveWindow);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 12, vars: 7, consts: [[1, "po-chart-wrapper", 3, "p-resize-observer"], ["chartWrapper", ""], [1, "po-chart-header"], ["chartHeader", ""], [1, "po-chart-title"], [3, "p-options", "p-type", "p-series", "p-categories", "p-container-size", "p-serie-click", "p-serie-hover"], ["chartContainer", ""], [4, "ngIf"], ["chartLegendGroup", ""], [4, "ngTemplateOutlet"], [3, "p-series", "p-type"], ["chartLegend", ""]], template: function PoChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("p-resize-observer", function PoChartComponent_Template_div_p_resize_observer_0_listener() {
        return ctx.resizeAction();
      });
      ɵɵelementStart(2, "div", 2, 3)(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd()();
      ɵɵelementStart(6, "po-chart-container", 5);
      ɵɵlistener("p-serie-click", function PoChartComponent_Template_po_chart_container_p_serie_click_6_listener($event) {
        return ctx.onSeriesClick($event);
      })("p-serie-hover", function PoChartComponent_Template_po_chart_container_p_serie_hover_6_listener($event) {
        return ctx.onSeriesHover($event);
      });
      ɵɵelementEnd();
      ɵɵtemplate(7, PoChartComponent_ng_template_7_Template, 0, 0, "ng-template", null, 6, ɵɵtemplateRefExtractor)(9, PoChartComponent_div_9_Template, 2, 1, "div", 7);
      ɵɵelementEnd();
      ɵɵtemplate(10, PoChartComponent_ng_template_10_Template, 2, 2, "ng-template", null, 8, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵadvance(5);
      ɵɵtextInterpolate(ctx.title);
      ɵɵadvance();
      ɵɵproperty("p-options", ctx.options)("p-type", ctx.chartType)("p-series", ctx.chartSeries)("p-categories", ctx.categories)("p-container-size", ctx.svgContainerSize);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", (ctx.options == null ? null : ctx.options.legend) !== false);
    }
  }, dependencies: [NgIf, NgTemplateOutlet, PoChartContainerComponent, PoChartLegendComponent, PoResizeObserverDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartComponent, [{
    type: Component,
    args: [{ selector: "po-chart", template: '<div #chartWrapper class="po-chart-wrapper" (p-resize-observer)="resizeAction()">\n  <div #chartHeader class="po-chart-header">\n    <div class="po-chart-title">{{ title }}</div>\n  </div>\n\n  <po-chart-container\n    [p-options]="options"\n    [p-type]="chartType"\n    [p-series]="chartSeries"\n    [p-categories]="categories"\n    [p-container-size]="svgContainerSize"\n    (p-serie-click)="onSeriesClick($event)"\n    (p-serie-hover)="onSeriesHover($event)"\n  ></po-chart-container>\n\n  <!-- Injeção de gráficos do tipo gauge. Remover na depreciação.  -->\n  <ng-template #chartContainer></ng-template>\n\n  <div *ngIf="options?.legend !== false">\n    <ng-container *ngTemplateOutlet="chartLegendGroup"></ng-container>\n  </div>\n</div>\n\n<ng-template #chartLegendGroup>\n  <po-chart-legend #chartLegend [p-series]="chartSeries" [p-type]="type"> </po-chart-legend>\n</ng-template>\n' }]
  }], () => [{ type: PoColorService }, { type: ChangeDetectorRef }, { type: PoChartSvgContainerService }, { type: ComponentFactoryResolver$1 }, { type: ElementRef }, { type: PoChartMathsService }, { type: Renderer2 }], { chartContainer: [{
    type: ViewChild,
    args: ["chartContainer", { read: ViewContainerRef, static: true }]
  }], chartHeader: [{
    type: ViewChild,
    args: ["chartHeader", { static: true }]
  }], chartLegend: [{
    type: ViewChild,
    args: ["chartLegend", { read: ElementRef }]
  }], chartWrapper: [{
    type: ViewChild,
    args: ["chartWrapper", { static: true }]
  }], onResize: [{
    type: HostListener,
    args: ["window:resize"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoChartComponent, { className: "PoChartComponent", filePath: "lib/components/po-chart/po-chart.component.ts", lineNumber: 53 });
})();
var PoChartModule = class _PoChartModule {
  static ɵfac = function PoChartModule_Factory(t) {
    return new (t || _PoChartModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoChartModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoChartModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTooltipModule],
      declarations: [
        PoChartAreaComponent,
        PoChartAxisComponent,
        PoChartAxisPathComponent,
        PoChartAxisLabelComponent,
        PoChartComponent,
        PoChartContainerComponent,
        PoChartLegendComponent,
        PoChartLineComponent,
        PoChartPathComponent,
        PoChartPieComponent,
        PoChartDonutComponent,
        PoChartSeriesPointComponent,
        PoChartBarComponent,
        PoChartColumnComponent,
        PoChartBarPathComponent,
        PoChartCircularPathComponent,
        PoChartCircularLabelComponent,
        PoChartTooltipDirective,
        PoResizeObserverDirective
      ],
      exports: [PoChartComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoChartModule, { declarations: [
    PoChartAreaComponent,
    PoChartAxisComponent,
    PoChartAxisPathComponent,
    PoChartAxisLabelComponent,
    PoChartComponent,
    PoChartContainerComponent,
    PoChartLegendComponent,
    PoChartLineComponent,
    PoChartPathComponent,
    PoChartPieComponent,
    PoChartDonutComponent,
    PoChartSeriesPointComponent,
    PoChartBarComponent,
    PoChartColumnComponent,
    PoChartBarPathComponent,
    PoChartCircularPathComponent,
    PoChartCircularLabelComponent,
    PoChartTooltipDirective,
    PoResizeObserverDirective
  ], imports: [CommonModule, PoTooltipModule], exports: [PoChartComponent] });
})();
var PoContainerBaseComponent = class _PoContainerBaseComponent {
  _height;
  _noBorder = false;
  _noPadding = false;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do `po-container`.
   *
   * > Caso não seja definido um valor, a altura se ajustará de acordo com o conteúdo.
   */
  set height(value) {
    this._height = convertToInt(value);
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita a borda e a sombra em torno do `po-container`.
   *
   * @default `false`
   */
  set noBorder(value) {
    this._noBorder = convertToBoolean(value);
  }
  get noBorder() {
    return this._noBorder;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o espaçamento interno do `po-container`.
   *
   * @default `false`
   */
  set noPadding(value) {
    this._noPadding = convertToBoolean(value);
  }
  get noPadding() {
    return this._noPadding;
  }
  static ɵfac = function PoContainerBaseComponent_Factory(t) {
    return new (t || _PoContainerBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoContainerBaseComponent, inputs: { height: [InputFlags.None, "p-height", "height"], noBorder: [InputFlags.None, "p-no-border", "noBorder"], noPadding: [InputFlags.None, "p-no-padding", "noPadding"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoContainerBaseComponent, [{
    type: Directive
  }], null, { height: [{
    type: Input,
    args: ["p-height"]
  }], noBorder: [{
    type: Input,
    args: ["p-no-border"]
  }], noPadding: [{
    type: Input,
    args: ["p-no-padding"]
  }] });
})();
var _c0$1b = ["*"];
var PoContainerComponent = class _PoContainerComponent extends PoContainerBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoContainerComponent_BaseFactory;
    return function PoContainerComponent_Factory(t) {
      return (ɵPoContainerComponent_BaseFactory || (ɵPoContainerComponent_BaseFactory = ɵɵgetInheritedFactory(_PoContainerComponent)))(t || _PoContainerComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoContainerComponent, selectors: [["po-container"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$1b, decls: 2, vars: 6, consts: [[1, "po-container"]], template: function PoContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.height ? ctx.height + "px" : "auto");
      ɵɵclassProp("po-container-no-border", ctx.noBorder)("po-container-no-padding", ctx.noPadding);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoContainerComponent, [{
    type: Component,
    args: [{ selector: "po-container", template: `<div
  class="po-container"
  [class.po-container-no-border]="noBorder"
  [class.po-container-no-padding]="noPadding"
  [style.height]="height ? height + 'px' : 'auto'"
>
  <ng-content></ng-content>
</div>
` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoContainerComponent, { className: "PoContainerComponent", filePath: "lib/components/po-container/po-container.component.ts", lineNumber: 30 });
})();
var PoContainerModule = class _PoContainerModule {
  static ɵfac = function PoContainerModule_Factory(t) {
    return new (t || _PoContainerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoContainerModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: [PoContainerComponent],
      declarations: [PoContainerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoContainerModule, { declarations: [PoContainerComponent], imports: [CommonModule], exports: [PoContainerComponent] });
})();
var PoDisclaimerLiterals = {
  en: {
    remove: "Remove"
  },
  es: {
    remove: "Eliminar"
  },
  pt: {
    remove: "Remover"
  },
  ru: {
    remove: "удалять"
  }
};
var PO_DISCLAIMER_TYPES = ["default", "danger"];
var PO_DISCLAIMER_DEFAULT_TYPE = "default";
var PoDisclaimerBaseComponent = class _PoDisclaimerBaseComponent {
  languageService;
  /**
   * Label que aparecerá dentro do po-disclaimer.
   * Quando não for definido um label será apresentada a propriedade p-value.
   */
  label;
  /** Valor do po-disclaimer. */
  value;
  /** Nome da propriedade vinculada à este po-disclaimer. */
  property;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao fechar o disclaimer.
   * Para este evento será passado como parâmetro um objeto com value, label e property.
   */
  closeAction = new EventEmitter();
  literals;
  showDisclaimer = true;
  _type = "default";
  _hideClose = false;
  /**
   * @description
   *
   * Esta propriedade esconde o botão para fechamento do po-disclaimer, ao utilizar esta propriedade
   * sem passar valor a mesma é setada como false, onde o botão de fechamento está visível.
   *
   * @default false
   */
  set hideClose(value) {
    this._hideClose = value === "" ? true : convertToBoolean(value);
  }
  get hideClose() {
    return this._hideClose;
  }
  /**
   * @description
   *
   * Tipo do po-disclaimer. Pode ser 'default' ou 'danger'.
   *
   * @default default
   * @optional
   */
  set type(type) {
    this._type = PO_DISCLAIMER_TYPES.includes(type) ? type : PO_DISCLAIMER_DEFAULT_TYPE;
  }
  get type() {
    return this._type;
  }
  constructor(languageService) {
    this.languageService = languageService;
    const language = this.languageService?.getShortLanguage();
    this.literals = __spreadValues({}, PoDisclaimerLiterals[language]);
  }
  close() {
    this.showDisclaimer = false;
    this.closeAction.emit({ value: this.value, label: this.label, property: this.property });
  }
  getLabel() {
    return this.label ? this.label : this.value;
  }
  setAriaLabel() {
    return this.label ? this.label + " " + this.literals.remove : this.value + " " + this.literals.remove;
  }
  static ɵfac = function PoDisclaimerBaseComponent_Factory(t) {
    return new (t || _PoDisclaimerBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDisclaimerBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], value: [InputFlags.None, "p-value", "value"], property: [InputFlags.None, "p-property", "property"], hideClose: [InputFlags.None, "p-hide-close", "hideClose"], type: [InputFlags.None, "p-type", "type"] }, outputs: { closeAction: "p-close-action" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { label: [{
    type: Input,
    args: ["p-label"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], property: [{
    type: Input,
    args: ["p-property"]
  }], closeAction: [{
    type: Output,
    args: ["p-close-action"]
  }], hideClose: [{
    type: Input,
    args: ["p-hide-close"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }] });
})();
var _c0$1a = ["disclaimerContainer"];
function PoDisclaimerComponent_div_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 7);
    ɵɵlistener("click", function PoDisclaimerComponent_div_2_span_4_Template_span_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.close());
    })("keydown", function PoDisclaimerComponent_div_2_span_4_Template_span_keydown_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.onKeyPress($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassProp("po-disclaimer-remove-danger", ctx_r2.type === "danger");
    ɵɵattribute("aria-label", ctx_r2.setAriaLabel())("role", !ctx_r2.hideClose ? "button" : "");
  }
}
function PoDisclaimerComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3)(1, "div", 4)(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵtemplate(4, PoDisclaimerComponent_div_2_span_4_Template, 1, 4, "span", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-disclaimer-remove-all", ctx_r1.hideClose)("po-disclaimer-danger", ctx_r1.type === "danger");
    ɵɵproperty("p-tooltip", ctx_r1.getWidthDisclaimer() ? ctx_r1.getLabel() : "")("tabindex", ctx_r1.hideClose ? "0" : "-1");
    ɵɵadvance();
    ɵɵclassProp("show-close", !ctx_r1.hideClose);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.getLabel(), " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hideClose === false);
  }
}
var PoDisclaimerComponent = class _PoDisclaimerComponent extends PoDisclaimerBaseComponent {
  disclaimerContainer;
  onKeyPress(event) {
    if (isKeyCodeEnter(event)) {
      this.close();
    }
  }
  getWidthDisclaimer() {
    return this.disclaimerContainer.nativeElement.offsetWidth > 201;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoDisclaimerComponent_BaseFactory;
    return function PoDisclaimerComponent_Factory(t) {
      return (ɵPoDisclaimerComponent_BaseFactory || (ɵPoDisclaimerComponent_BaseFactory = ɵɵgetInheritedFactory(_PoDisclaimerComponent)))(t || _PoDisclaimerComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoDisclaimerComponent, selectors: [["po-disclaimer"]], viewQuery: function PoDisclaimerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$1a, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.disclaimerContainer = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 3, vars: 1, consts: [[1, "disclaimer-container"], ["disclaimerContainer", ""], ["class", "po-disclaimer", "p-tooltip-position", "bottom", 3, "po-disclaimer-remove-all", "po-disclaimer-danger", "p-tooltip", "tabindex", 4, "ngIf"], ["p-tooltip-position", "bottom", 1, "po-disclaimer", 3, "p-tooltip", "tabindex"], [1, "po-disclaimer-label"], [1, "label"], ["class", "po-disclaimer-remove po-icon po-icon-close po-clickable", "tabindex", "0", 3, "po-disclaimer-remove-danger", "click", "keydown", 4, "ngIf"], ["tabindex", "0", 1, "po-disclaimer-remove", "po-icon", "po-icon-close", "po-clickable", 3, "click", "keydown"]], template: function PoDisclaimerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵtemplate(2, PoDisclaimerComponent_div_2_Template, 5, 10, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showDisclaimer === true);
    }
  }, dependencies: [NgIf, PoTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerComponent, [{
    type: Component,
    args: [{ selector: "po-disclaimer", template: `<div #disclaimerContainer class="disclaimer-container">
  <div
    *ngIf="showDisclaimer === true"
    class="po-disclaimer"
    [class.po-disclaimer-remove-all]="hideClose"
    [class.po-disclaimer-danger]="type === 'danger'"
    [p-tooltip]="getWidthDisclaimer() ? getLabel() : ''"
    p-tooltip-position="bottom"
    [tabindex]="hideClose ? '0' : '-1'"
  >
    <div class="po-disclaimer-label" [class.show-close]="!hideClose">
      <span class="label">
        {{ getLabel() }}
      </span>
    </div>

    <span
      *ngIf="hideClose === false"
      [attr.aria-label]="setAriaLabel()"
      [attr.role]="!hideClose ? 'button' : ''"
      class="po-disclaimer-remove po-icon po-icon-close po-clickable"
      tabindex="0"
      [class.po-disclaimer-remove-danger]="type === 'danger'"
      (click)="close()"
      (keydown)="onKeyPress($event)"
    >
    </span>
  </div>
</div>
` }]
  }], null, { disclaimerContainer: [{
    type: ViewChild,
    args: ["disclaimerContainer", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDisclaimerComponent, { className: "PoDisclaimerComponent", filePath: "lib/components/po-disclaimer/po-disclaimer.component.ts", lineNumber: 23 });
})();
var PoDisclaimerModule = class _PoDisclaimerModule {
  static ɵfac = function PoDisclaimerModule_Factory(t) {
    return new (t || _PoDisclaimerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDisclaimerModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTooltipModule],
      declarations: [PoDisclaimerComponent],
      exports: [PoDisclaimerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDisclaimerModule, { declarations: [PoDisclaimerComponent], imports: [CommonModule, PoTooltipModule], exports: [PoDisclaimerComponent] });
})();
var poDisclaimerGroupLiteralsDefault = {
  en: { removeAll: "Remove all" },
  es: { removeAll: "Eliminar todos" },
  pt: { removeAll: "Remover todos" },
  ru: { removeAll: "Удалить все" }
};
var PoDisclaimerGroupBaseComponent = class _PoDisclaimerGroupBaseComponent {
  changeDetector;
  /** Título do grupo de *disclaimers*. */
  title;
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada quando a lista de *disclaimers* for modificada.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada quando um *disclaimer* for removido da lista de *disclaimers* pelo usuário.
   *
   * Recebe como parâmetro um objeto conforme a interface `PoDisclaimerGroupRemoveAction`.
   */
  remove = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada quando todos os *disclaimers* forem removidos da lista de *disclaimers* pelo usuário,
   * utilizando o botão "remover todos".
   *
   * Recebe como parâmetro uma lista contendo todos os `disclaimers` removidos.
   */
  removeAll = new EventEmitter();
  literals;
  _disclaimers = [];
  _hideRemoveAll = false;
  differ;
  previousDisclaimers = [];
  /** Lista de *disclaimers*. */
  /**
   * @description
   *
   * Lista de *disclaimers*.
   *
   * Para que a lista de *disclaimers* seja atualizada dinamicamente deve-se passar uma nova referência do array de `PoDisclaimer`.
   *
   * Exemplo adicionando um *disclaimer* no array:
   *
   * ```
   * this.disclaimers = [...this.disclaimers, disclaimer];
   * ```
   *
   * ou
   *
   * ```
   * this.disclaimers = this.disclaimers.concat(disclaimer);
   * ```
   */
  set disclaimers(value) {
    this.previousDisclaimers = [...this.disclaimers];
    this._disclaimers = this.checkDisclaimers(value);
  }
  get disclaimers() {
    return this._disclaimers;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta o botão para remover todos os *disclaimers* do grupo.
   *
   * > Por padrão, o mesmo é exibido à partir de dois ou mais *disclaimers* com a opção `hideClose` habilitada.
   *
   * @default `false`
   */
  set hideRemoveAll(value) {
    this._hideRemoveAll = value === "" ? true : convertToBoolean(value);
  }
  get hideRemoveAll() {
    return this._hideRemoveAll;
  }
  constructor(differs, languageService, changeDetector) {
    this.changeDetector = changeDetector;
    const language = languageService.getShortLanguage();
    this.differ = differs.find([]).create(null);
    this.literals = __spreadValues(__spreadValues({}, poDisclaimerGroupLiteralsDefault[poLocaleDefault]), poDisclaimerGroupLiteralsDefault[language]);
  }
  ngDoCheck() {
    this.checkChanges();
  }
  isRemoveAll() {
    return !this.hideRemoveAll && this.disclaimers.filter((c) => !c.hideClose).length > 1;
  }
  onKeyPress(event) {
    if (isKeyCodeEnter(event)) {
      this.removeAllItems();
    }
  }
  removeAllItems() {
    const removeItems = [];
    this.disclaimers.forEach((disclaimer) => {
      if (!disclaimer.hideClose) {
        removeItems.push(disclaimer);
      }
    });
    removeItems.forEach((disclaimer) => this.removeDisclaimer(disclaimer));
    this.emitChangeDisclaimers();
    this.removeAll.emit([...removeItems]);
  }
  removeDisclaimer(disclaimer) {
    const itemIndex = this.disclaimers.findIndex((d) => d["$id"] === disclaimer["$id"]);
    this.disclaimers.splice(itemIndex, 1);
  }
  emitChangeDisclaimers() {
    setTimeout(() => {
      this.change.emit(this.disclaimers);
    });
    this.previousDisclaimers = [...this._disclaimers];
    this.changeDetector?.detectChanges();
  }
  checkChanges() {
    if (this.differ) {
      const changes = this.differ.diff(this.disclaimers);
      if (changes && this.disclaimersAreChanged(this.disclaimers)) {
        this.emitChangeDisclaimers();
      }
    } else {
      this.changeDetector?.detectChanges();
    }
  }
  checkDisclaimers(disclaimers) {
    if (Array.isArray(disclaimers)) {
      for (let i = 0; i < disclaimers.length; i++) {
        const disclaimer = disclaimers[i];
        if (disclaimer.value || disclaimer.value === 0 || disclaimer.value === false) {
          disclaimer["$id"] = uuid();
        } else {
          disclaimers.splice(i, 1);
          i--;
        }
      }
      return disclaimers;
    }
    return [];
  }
  disclaimersAreChanged(disclaimers) {
    const currentValues = disclaimers;
    if (currentValues.length !== this.previousDisclaimers.length) {
      return true;
    }
    return currentValues.some((disclaimer, index) => disclaimer.value !== this.previousDisclaimers[index].value || disclaimer.property !== this.previousDisclaimers[index].property);
  }
  static ɵfac = function PoDisclaimerGroupBaseComponent_Factory(t) {
    return new (t || _PoDisclaimerGroupBaseComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDisclaimerGroupBaseComponent, inputs: { title: [InputFlags.None, "p-title", "title"], disclaimers: [InputFlags.None, "p-disclaimers", "disclaimers"], hideRemoveAll: [InputFlags.None, "p-hide-remove-all", "hideRemoveAll"] }, outputs: { change: "p-change", remove: "p-remove", removeAll: "p-remove-all" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerGroupBaseComponent, [{
    type: Directive
  }], () => [{ type: IterableDiffers }, { type: PoLanguageService }, { type: ChangeDetectorRef }], { title: [{
    type: Input,
    args: ["p-title"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], remove: [{
    type: Output,
    args: ["p-remove"]
  }], removeAll: [{
    type: Output,
    args: ["p-remove-all"]
  }], disclaimers: [{
    type: Input,
    args: ["p-disclaimers"]
  }], hideRemoveAll: [{
    type: Input,
    args: ["p-hide-remove-all"]
  }] });
})();
var PoDisclaimerRemoveComponent = class _PoDisclaimerRemoveComponent {
  /** Texto exibido.  */
  label;
  /** Ação para remover todos.  */
  removeAllAction = new EventEmitter();
  // Emite a ação de remover todos.
  removeAction() {
    this.removeAllAction.emit();
  }
  static ɵfac = function PoDisclaimerRemoveComponent_Factory(t) {
    return new (t || _PoDisclaimerRemoveComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDisclaimerRemoveComponent, selectors: [["po-disclaimer-remove"]], inputs: { label: [InputFlags.None, "p-label", "label"] }, outputs: { removeAllAction: "p-remove-all-action" }, decls: 1, vars: 2, consts: [["p-type", "danger", 1, "po-clickable", 3, "p-inverse", "p-value", "p-click"]], template: function PoDisclaimerRemoveComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-tag", 0);
      ɵɵlistener("p-click", function PoDisclaimerRemoveComponent_Template_po_tag_p_click_0_listener() {
        return ctx.removeAction();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-inverse", true)("p-value", ctx.label);
    }
  }, dependencies: [PoTagComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerRemoveComponent, [{
    type: Component,
    args: [{ selector: "po-disclaimer-remove", template: '<po-tag class="po-clickable" [p-inverse]="true" p-type="danger" [p-value]="label" (p-click)="removeAction()"> </po-tag>\n' }]
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], removeAllAction: [{
    type: Output,
    args: ["p-remove-all-action"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDisclaimerRemoveComponent, { className: "PoDisclaimerRemoveComponent", filePath: "lib/components/po-disclaimer-group/po-disclaimer-remove/po-disclaimer-remove.component.ts", lineNumber: 14 });
})();
function PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-remove", 5);
    ɵɵlistener("keydown", function PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template_po_disclaimer_remove_keydown_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onKeyPress($event));
    })("p-remove-all-action", function PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template_po_disclaimer_remove_p_remove_all_action_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.removeAllItems());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-label", ctx_r1.literals.removeAll);
  }
}
function PoDisclaimerGroupComponent_div_0_po_tag_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-tag", 6);
    ɵɵlistener("p-close", function PoDisclaimerGroupComponent_div_0_po_tag_4_Template_po_tag_p_close_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r8);
      const disclaimer_r6 = restoredCtx.$implicit;
      const ctx_r7 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r7.onCloseAction(disclaimer_r6, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const disclaimer_r6 = ctx.$implicit;
    ɵɵproperty("p-value", disclaimer_r6.label || disclaimer_r6.value)("p-removable", !disclaimer_r6.hideClose);
  }
}
function PoDisclaimerGroupComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, PoDisclaimerGroupComponent_div_0_po_disclaimer_remove_3_Template, 1, 1, "po-disclaimer-remove", 3)(4, PoDisclaimerGroupComponent_div_0_po_tag_4_Template, 1, 2, "po-tag", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isRemoveAll());
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.disclaimers);
  }
}
var PoDisclaimerGroupComponent = class _PoDisclaimerGroupComponent extends PoDisclaimerGroupBaseComponent {
  changeDetector;
  subscription = new Subscription();
  el = inject(ElementRef);
  constructor(differs, languageService, changeDetector) {
    super(differs, languageService, changeDetector);
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    this.handleKeyboardNavigationTag();
  }
  ngOnChanges(changes) {
    if (changes.disclaimers) {
      setTimeout(() => {
        this.handleKeyboardNavigationTag();
      });
    }
  }
  onCloseAction(disclaimer, event) {
    const index = this.disclaimers.findIndex((option) => option.value === disclaimer.value);
    this.removeDisclaimer(disclaimer);
    this.emitChangeDisclaimers();
    this.remove.emit({
      removedDisclaimer: __spreadValues({}, disclaimer),
      currentDisclaimers: [...this.disclaimers]
    });
    setTimeout(() => {
      this.focusOnNextTag(index, event);
    }, 300);
  }
  focusOnNextTag(indexClosed, clickOrEnter) {
    if (clickOrEnter === "enter") {
      const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
      indexClosed = indexClosed || indexClosed === 0 ? indexClosed : tagRemoveElements.length;
      this.focusOnRemoveTag(tagRemoveElements, indexClosed);
    } else {
      indexClosed = 0;
    }
    this.handleKeyboardNavigationTag(indexClosed);
  }
  handleKeyboardNavigationTag(initialIndex = 0) {
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
    this.initializeTagRemoveElements(tagRemoveElements, initialIndex);
  }
  handleArrowLeft(tagRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index - 1].focus();
      this.setTabIndex(tagRemoveElements[index - 1], 0);
    }
  }
  handleArrowRight(tagRemoveElements, index) {
    if (index < tagRemoveElements.length - 1) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index + 1].focus();
      this.setTabIndex(tagRemoveElements[index + 1], 0);
    }
  }
  setTabIndex(element, tabIndex) {
    element.setAttribute("tabindex", tabIndex);
  }
  initializeTagRemoveElements(tagRemoveElements, initialIndex) {
    tagRemoveElements.forEach((tagRemoveElement, index) => {
      if (index === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex], 0);
      } else if (tagRemoveElements.length === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex - 1], 0);
      } else {
        this.setTabIndex(tagRemoveElement, -1);
      }
      this.subscription.add(fromEvent(tagRemoveElement, "keydown").subscribe((event) => {
        this.handleKeyDown(event, tagRemoveElements, index);
      }));
      if (index !== 0) {
        this.subscription.add(fromEvent(tagRemoveElements, "blur").subscribe(() => {
          this.setTabIndex(tagRemoveElements[index], -1);
          this.setTabIndex(tagRemoveElements[0], 0);
        }));
      }
    });
  }
  handleKeyDown(event, tagRemoveElements, index) {
    const KEY_SPACE = "Space";
    const KEY_ARROW_LEFT = "ArrowLeft";
    const KEY_ARROW_RIGHT = "ArrowRight";
    if (event.code === KEY_SPACE) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.key === KEY_ARROW_LEFT) {
      this.handleArrowLeft(tagRemoveElements, index);
    } else if (event.key === KEY_ARROW_RIGHT) {
      this.handleArrowRight(tagRemoveElements, index);
    }
  }
  focusOnRemoveTag(tag, indexClosed) {
    if (tag.length === indexClosed) {
      tag[indexClosed - 1]?.focus();
    } else {
      tag[indexClosed]?.focus();
    }
  }
  static ɵfac = function PoDisclaimerGroupComponent_Factory(t) {
    return new (t || _PoDisclaimerGroupComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDisclaimerGroupComponent, selectors: [["po-disclaimer-group"]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "po-disclaimer-group", 4, "ngIf"], [1, "po-disclaimer-group"], [1, "po-disclaimer-group-title"], ["class", "po-disclaimer-group-disclaimer-align", 3, "p-label", "keydown", "p-remove-all-action", 4, "ngIf"], ["class", "po-disclaimer-group-disclaimer-align", 3, "p-value", "p-removable", "p-close", 4, "ngFor", "ngForOf"], [1, "po-disclaimer-group-disclaimer-align", 3, "p-label", "keydown", "p-remove-all-action"], [1, "po-disclaimer-group-disclaimer-align", 3, "p-value", "p-removable", "p-close"]], template: function PoDisclaimerGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoDisclaimerGroupComponent_div_0_Template, 5, 3, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.disclaimers.length > 0);
    }
  }, dependencies: [NgForOf, NgIf, PoTagComponent, PoDisclaimerRemoveComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerGroupComponent, [{
    type: Component,
    args: [{ selector: "po-disclaimer-group", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-disclaimer-group" *ngIf="disclaimers.length > 0">\n  <div class="po-disclaimer-group-title">{{ title }}</div>\n\n  <po-disclaimer-remove\n    *ngIf="isRemoveAll()"\n    class="po-disclaimer-group-disclaimer-align"\n    [p-label]="literals.removeAll"\n    (keydown)="onKeyPress($event)"\n    (p-remove-all-action)="removeAllItems()"\n  >\n  </po-disclaimer-remove>\n\n  <po-tag\n    *ngFor="let disclaimer of disclaimers"\n    class="po-disclaimer-group-disclaimer-align"\n    [p-value]="disclaimer.label || disclaimer.value"\n    [p-removable]="!disclaimer.hideClose"\n    (p-close)="onCloseAction(disclaimer, $event)"\n  >\n  </po-tag>\n</div>\n' }]
  }], () => [{ type: IterableDiffers }, { type: PoLanguageService }, { type: ChangeDetectorRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDisclaimerGroupComponent, { className: "PoDisclaimerGroupComponent", filePath: "lib/components/po-disclaimer-group/po-disclaimer-group.component.ts", lineNumber: 46 });
})();
var PoDisclaimerGroupModule = class _PoDisclaimerGroupModule {
  static ɵfac = function PoDisclaimerGroupModule_Factory(t) {
    return new (t || _PoDisclaimerGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDisclaimerGroupModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoDisclaimerModule, PoTagModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDisclaimerGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoDisclaimerModule, PoTagModule],
      declarations: [PoDisclaimerGroupComponent, PoDisclaimerRemoveComponent],
      exports: [PoDisclaimerGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDisclaimerGroupModule, { declarations: [PoDisclaimerGroupComponent, PoDisclaimerRemoveComponent], imports: [CommonModule, PoDisclaimerModule, PoTagModule], exports: [PoDisclaimerGroupComponent] });
})();
var PoDropdownBaseComponent = class _PoDropdownBaseComponent {
  /** Adiciona um rótulo ao `dropdown`. */
  label;
  icon = "po-icon-arrow-down";
  open = false;
  _actions;
  _disabled = false;
  /** Lista de ações que serão exibidas no componente. */
  set actions(value) {
    this._actions = Array.isArray(value) ? value : [];
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o campo.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
  }
  get disabled() {
    return this._disabled;
  }
  static ɵfac = function PoDropdownBaseComponent_Factory(t) {
    return new (t || _PoDropdownBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDropdownBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], actions: [InputFlags.None, "p-actions", "actions"], disabled: [InputFlags.None, "p-disabled", "disabled"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDropdownBaseComponent, [{
    type: Directive
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], actions: [{
    type: Input,
    args: ["p-actions"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }] });
})();
var _c0$19 = ["dropdownRef"];
var _c1$v = ["popupRef"];
var _c2$f = (a0, a1) => ({ "po-dropdown-button-disabled": a0, "po-dropdown-button-open": a1 });
var _c3$9 = () => ["bottom-left", "top-left"];
var PoDropdownComponent = class _PoDropdownComponent extends PoDropdownBaseComponent {
  renderer;
  dropdownRef;
  popupRef;
  clickoutListener;
  resizeListener;
  constructor(renderer) {
    super();
    this.renderer = renderer;
  }
  onKeyDown(event) {
    if (isKeyCodeEnter(event)) {
      this.toggleDropdown();
    }
  }
  toggleDropdown() {
    this.dropdownRef && !this.open && !this.disabled ? this.showDropdown() : this.hideDropdown();
  }
  checkClickArea(event) {
    return this.dropdownRef && this.dropdownRef.nativeElement.contains(event.target);
  }
  hideDropdown() {
    this.icon = "po-icon-arrow-down";
    this.removeListeners();
    this.popupRef.close();
    this.open = false;
  }
  initializeListeners() {
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnDropdown(event);
    });
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.hideDropdown();
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onScroll = ({ target }) => {
    if (this.open && target.className !== "po-popup-container" && !this.isDropdownClosed()) {
      this.hideDropdown();
    }
  };
  isDropdownClosed() {
    const dropdownRect = this.dropdownRef.nativeElement.getBoundingClientRect();
    return dropdownRect.top >= 0 && dropdownRect.bottom <= window.innerHeight;
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.resizeListener) {
      this.resizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  showDropdown() {
    this.icon = "po-icon-arrow-up";
    this.initializeListeners();
    this.popupRef.open();
    this.open = true;
  }
  wasClickedOnDropdown(event) {
    const clickedOnDropdown = this.checkClickArea(event);
    if (!clickedOnDropdown) {
      this.hideDropdown();
    }
  }
  static ɵfac = function PoDropdownComponent_Factory(t) {
    return new (t || _PoDropdownComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDropdownComponent, selectors: [["po-dropdown"]], viewQuery: function PoDropdownComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$19, 7, ElementRef);
      ɵɵviewQuery(_c1$v, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupRef = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 7, vars: 14, consts: [[1, "po-dropdown", 3, "tabindex", "click", "keydown"], ["dropdownRef", ""], [1, "po-dropdown-button", 3, "ngClass"], ["p-hide-arrow", "", "p-is-corner-align", "", "p-position", "bottom-left", 3, "p-actions", "p-custom-positions", "p-target"], ["popupRef", ""]], template: function PoDropdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("click", function PoDropdownComponent_Template_div_click_0_listener() {
        return ctx.toggleDropdown();
      })("keydown", function PoDropdownComponent_Template_div_keydown_0_listener($event) {
        return ctx.onKeyDown($event);
      });
      ɵɵelementStart(2, "div", 2);
      ɵɵtext(3);
      ɵɵelement(4, "div");
      ɵɵelementEnd()();
      ɵɵelement(5, "po-popup", 3, 4);
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(1);
      ɵɵpropertyInterpolate("tabindex", ctx.disabled ? -1 : 0);
      ɵɵattribute("disabled", ctx.disabled);
      ɵɵadvance(2);
      ɵɵproperty("ngClass", ɵɵpureFunction2(10, _c2$f, ctx.disabled, ctx.open));
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.label, " ");
      ɵɵadvance();
      ɵɵclassMapInterpolate1("po-dropdown-icon po-icon ", ctx.icon, "");
      ɵɵadvance();
      ɵɵproperty("p-actions", ctx.actions)("p-custom-positions", ɵɵpureFunction0(13, _c3$9))("p-target", _r0);
    }
  }, dependencies: [NgClass, PoPopupComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDropdownComponent, [{
    type: Component,
    args: [{ selector: "po-dropdown", template: `<div
  #dropdownRef
  class="po-dropdown"
  [attr.disabled]="disabled"
  tabindex="{{ disabled ? -1 : 0 }}"
  (click)="toggleDropdown()"
  (keydown)="onKeyDown($event)"
>
  <div
    class="po-dropdown-button"
    [ngClass]="{ 'po-dropdown-button-disabled': disabled, 'po-dropdown-button-open': open }"
  >
    {{ label }}
    <div class="po-dropdown-icon po-icon {{ icon }}"></div>
  </div>
</div>

<po-popup
  #popupRef
  p-hide-arrow
  p-is-corner-align
  p-position="bottom-left"
  [p-actions]="actions"
  [p-custom-positions]="['bottom-left', 'top-left']"
  [p-target]="dropdownRef"
>
</po-popup>
` }]
  }], () => [{ type: Renderer2 }], { dropdownRef: [{
    type: ViewChild,
    args: ["dropdownRef", { read: ElementRef, static: true }]
  }], popupRef: [{
    type: ViewChild,
    args: ["popupRef"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDropdownComponent, { className: "PoDropdownComponent", filePath: "lib/components/po-dropdown/po-dropdown.component.ts", lineNumber: 33 });
})();
var PoDropdownModule = class _PoDropdownModule {
  static ɵfac = function PoDropdownModule_Factory(t) {
    return new (t || _PoDropdownModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDropdownModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoPopupModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDropdownModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoPopupModule],
      declarations: [PoDropdownComponent],
      exports: [PoDropdownComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDropdownModule, { declarations: [PoDropdownComponent], imports: [CommonModule, PoPopupModule], exports: [PoDropdownComponent] });
})();
function PoFieldContainerBottomComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "po-icon", 4);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r0.errorPattern, "");
  }
}
function PoFieldContainerBottomComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.help, " ");
  }
}
var PoFieldContainerBottomComponent = class _PoFieldContainerBottomComponent {
  /**
   * Mensagem que será apresentada quando o pattern ou a máscara não for satisfeita.
   * Obs: Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
   */
  errorPattern = "";
  disabled = false;
  help;
  static ɵfac = function PoFieldContainerBottomComponent_Factory(t) {
    return new (t || _PoFieldContainerBottomComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoFieldContainerBottomComponent, selectors: [["po-field-container-bottom"]], inputs: { errorPattern: [InputFlags.None, "p-error-pattern", "errorPattern"], disabled: [InputFlags.None, "p-disabled", "disabled"], help: [InputFlags.None, "p-help", "help"] }, decls: 3, vars: 4, consts: [[1, "po-field-container-bottom"], ["class", "po-field-container-bottom-text-error", 4, "ngIf"], ["class", "po-field-container-bottom-help-text", 4, "ngIf"], [1, "po-field-container-bottom-text-error"], ["p-icon", "po-icon-warning"], [1, "po-field-container-bottom-help-text"]], template: function PoFieldContainerBottomComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoFieldContainerBottomComponent_div_1_Template, 4, 1, "div", 1)(2, PoFieldContainerBottomComponent_span_2_Template, 2, 1, "span", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("po-field-container-bottom-disabled", ctx.disabled);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.errorPattern);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.help && !ctx.errorPattern);
    }
  }, dependencies: [NgIf, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldContainerBottomComponent, [{
    type: Component,
    args: [{ selector: "po-field-container-bottom", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-field-container-bottom" [class.po-field-container-bottom-disabled]="disabled">\n  <div *ngIf="errorPattern" class="po-field-container-bottom-text-error">\n    <po-icon p-icon="po-icon-warning"></po-icon>\n    <span> {{ errorPattern }}</span>\n  </div>\n  <span *ngIf="help && !errorPattern" class="po-field-container-bottom-help-text">\n    {{ help }}\n  </span>\n</div>\n' }]
  }], null, { errorPattern: [{
    type: Input,
    args: ["p-error-pattern"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoFieldContainerBottomComponent, { className: "PoFieldContainerBottomComponent", filePath: "lib/components/po-field/po-field-container/po-field-container-bottom/po-field-container-bottom.component.ts", lineNumber: 16 });
})();
var poFieldContainerLiterals = {
  en: {
    optional: "Optional",
    required: "Required"
  },
  es: {
    optional: "Opcional",
    required: "Obligatorio"
  },
  pt: {
    optional: "Opcional",
    required: "Obrigatório"
  },
  ru: {
    optional: "Пожеланию",
    required: "Обязательный"
  }
};
function PoFieldContainerComponent_po_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-label", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r0.disabled)("p-for", ctx_r0.id)("p-label", ctx_r0.label)("p-requirement", ctx_r0.requirement);
  }
}
function PoFieldContainerComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.help);
  }
}
var _c0$18 = ["*"];
var PoFieldContainerComponent = class _PoFieldContainerComponent {
  /** Indica se o campo será desabilitado. */
  disabled;
  /** Identificador do campo */
  id;
  /** Label do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  literals;
  requirement;
  _optional = false;
  _required = false;
  /** Indica se o campo será opcional. */
  set optional(value) {
    this._optional = convertToBoolean(value);
  }
  get optional() {
    return this._optional;
  }
  /** Indica se o campo será obrigatório. */
  set required(value) {
    this._required = convertToBoolean(value);
  }
  get required() {
    return this._required;
  }
  /** Define se a indicação de campo obrigatório será exibida. */
  showRequired = false;
  constructor(languageService) {
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, poFieldContainerLiterals[language]);
  }
  ngOnInit() {
    this.setRequirement();
  }
  ngOnChanges(changes) {
    if (changes.help || changes.label || changes.optional || changes.required || changes.showRequired) {
      this.setRequirement();
    }
  }
  setRequirement() {
    if (this.label || this.help) {
      if (!this.required && this.optional) {
        this.requirement = this.literals["optional"];
      } else if (this.required && this.showRequired) {
        this.requirement = this.literals["required"];
      } else {
        this.requirement = void 0;
      }
    }
  }
  static ɵfac = function PoFieldContainerComponent_Factory(t) {
    return new (t || _PoFieldContainerComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoFieldContainerComponent, selectors: [["po-field-container"]], inputs: { disabled: [InputFlags.None, "p-disabled", "disabled"], id: [InputFlags.None, "p-id", "id"], label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"], optional: [InputFlags.None, "p-optional", "optional"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"] }, features: [ɵɵNgOnChangesFeature], ngContentSelectors: _c0$18, decls: 5, vars: 2, consts: [[1, "po-field-container"], [1, "po-field-container-title"], ["p-field", "true", 3, "p-disabled", "p-for", "p-label", "p-requirement", 4, "ngIf"], ["class", "po-field-help", 4, "ngIf"], ["p-field", "true", 3, "p-disabled", "p-for", "p-label", "p-requirement"], [1, "po-field-help"]], template: function PoFieldContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, PoFieldContainerComponent_po_label_2_Template, 1, 4, "po-label", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, PoFieldContainerComponent_div_3_Template, 2, 1, "div", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.label || ctx.help);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.help);
    }
  }, dependencies: [NgIf, PoLabelComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldContainerComponent, [{
    type: Component,
    args: [{ selector: "po-field-container", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-field-container">\n  <div class="po-field-container-title">\n    <po-label\n      *ngIf="label || help"\n      [p-disabled]="disabled"\n      p-field="true"\n      [p-for]="id"\n      [p-label]="label"\n      [p-requirement]="requirement"\n    ></po-label>\n  </div>\n\n  <div class="po-field-help" *ngIf="help">{{ help }}</div>\n\n  <ng-content></ng-content>\n</div>\n' }]
  }], () => [{ type: PoLanguageService }], { disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], id: [{
    type: Input,
    args: ["p-id"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoFieldContainerComponent, { className: "PoFieldContainerComponent", filePath: "lib/components/po-field/po-field-container/po-field-container.component.ts", lineNumber: 17 });
})();
var PoFieldContainerModule = class _PoFieldContainerModule {
  static ɵfac = function PoFieldContainerModule_Factory(t) {
    return new (t || _PoFieldContainerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoFieldContainerModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoLabelModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoLabelModule, PoIconModule],
      exports: [PoFieldContainerBottomComponent, PoFieldContainerComponent],
      declarations: [PoFieldContainerBottomComponent, PoFieldContainerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoFieldContainerModule, { declarations: [PoFieldContainerBottomComponent, PoFieldContainerComponent], imports: [CommonModule, PoLabelModule, PoIconModule], exports: [PoFieldContainerBottomComponent, PoFieldContainerComponent] });
})();
function requiredFailed(required, disabled, value) {
  const valid = typeof value === "string" && value || typeof value === "object" && value && value.length || typeof value === "number" && (value || value === 0) || typeof value === "boolean" && value;
  return required && !disabled && !valid;
}
function maxlengpoailed(maxlength, value) {
  const validMaxlength = maxlength || maxlength === 0;
  const validValue2 = (value || value === 0) && value.toString();
  return validMaxlength && validValue2 && validValue2.length > Number(maxlength);
}
function minlengpoailed(minlength, value) {
  const validMinlength = minlength || minlength === 0;
  const validValue2 = (value || value === 0) && value.toString();
  return validMinlength && validValue2 && validValue2.length < Number(minlength);
}
function patternFailed(pattern, value) {
  let reg;
  try {
    reg = new RegExp(pattern);
  } catch (e) {
    return true;
  }
  return pattern && value && !reg.test(value);
}
function minFailed(min, value) {
  const validValue2 = value || value === 0;
  const validMin = min || min === 0;
  return validValue2 && validMin && value < min;
}
function maxFailed(max, value) {
  const validValue2 = value || value === 0;
  const validMax = max || max === 0;
  return validValue2 && validMax && value > max;
}
function dateFailed(value) {
  return value && isNaN(Date.parse(value));
}
var poCheckboxGroupColumnsDefaultLength = 6;
var poCheckboxGroupColumnsTotalLength = 12;
var PoCheckboxGroupBaseComponent = class _PoCheckboxGroupBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Nome dos checkboxes */
  name;
  /** Texto de apoio do campo */
  help;
  /** Label do campo */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o `ngModel` do componente, necessário quando não for utilizado dentro da tag form.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-checkbox-group ... [ngModel]="checkboxgroupModel" (ngModelChange)="checkboxgroupModel = $event"> </po-checkbox-group>
   * ```
   *
   */
  ngModelChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo
   */
  change = new EventEmitter();
  checkboxGroupOptionsView;
  checkedOptions = {};
  checkedOptionsList = [];
  mdColumns = poCheckboxGroupColumnsDefaultLength;
  propagateChange;
  validatorChange;
  _columns = poCheckboxGroupColumnsDefaultLength;
  _disabled = false;
  _indeterminate = false;
  _options;
  _required = false;
  /**
   * @optional
   *
   * @description
   *
   * Possibilita definir a quantidade de colunas para exibição dos itens do *checkbox*.
   * - É possível exibir as opções entre `1` e `4` colunas.
   * - Para resolução `sm` a colunagem invariavelmente passa para `1` coluna.
   * - Quando se trata de resolução `md` e o valor estabelecido para colunas for superior a `2`,
   * o *grid system* será composto por `2` colunas.
   * - Para evitar a quebra de linha, prefira a utilização de `1` coluna para opções com textos grandes.
   *
   * @default `2`
   *
   */
  set columns(value) {
    const columns = convertToInt(value, poCheckboxGroupColumnsDefaultLength);
    this._columns = this.getGridSystemColumns(columns, 4);
    this.mdColumns = this.getGridSystemColumns(columns, 2);
  }
  get columns() {
    return this._columns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita todos os itens do checkbox.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.validateModel(this.checkIndeterminate());
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Caso exista a necessidade de usar o valor indeterminado (`null`) dentro da lista de opções, é necessário setar
   * a propriedade `p-indeterminate` como `true`, por padrão essa propriedade vem desabilitada (`false`).
   *
   * Quando essa propriedade é setada como `true`, o *po-checkbox-group* passa a devolver um objeto completo para o
   * `ngModel`, diferente do array que contém apenas os valores selecionados.
   *
   * @default `false`
   */
  set indeterminate(indeterminate) {
    this._indeterminate = convertToBoolean(indeterminate);
  }
  get indeterminate() {
    return this._indeterminate;
  }
  /**
   * @optional
   *
   * @description
   * Lista de opções que serão exibidas
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface PoCheckboxGroupOption
   */
  set options(value) {
    this._options = Array.isArray(value) ? value : [];
    this.removeDuplicatedOptions();
    this.setCheckboxGroupOptionsView(this.options);
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.checkIndeterminate());
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  changeValue() {
    const value = this.checkIndeterminate();
    if (this.propagateChange) {
      this.propagateChange(value);
    } else {
      this.ngModelChange.emit(value);
    }
    this.change.emit(value);
  }
  checkIndeterminate() {
    return this.indeterminate ? this.checkedOptions : this.checkedOptionsList;
  }
  checkOption(value) {
    if (!this._disabled && !value.disabled && !value.fixed) {
      this.checkOptionModel(value);
      this.changeValue();
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
  }
  writeValue(optionsModel) {
    if (optionsModel && this.checkedOptions !== optionsModel) {
      this.generateCheckOptions(optionsModel);
    } else {
      this.checkedOptionsList = [];
      this.checkedOptions = {};
    }
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (!this.indeterminate && requiredFailed(this.required, this.disabled, abstractControl.value) || this.isInvalidIndeterminate()) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  checkColumnsRange(columns, maxColumns) {
    const minColumns = 1;
    return columns >= minColumns && columns <= maxColumns;
  }
  checkOptionModel(optionChecked) {
    this.checkedOptions[optionChecked.value] = !this.checkedOptions[optionChecked.value];
    if (!this.indeterminate && this.checkedOptionsList.includes(optionChecked.value)) {
      this.checkedOptionsList.splice(this.checkedOptionsList.indexOf(optionChecked.value), 1);
    } else if (!this.indeterminate) {
      this.checkedOptionsList.push(optionChecked.value);
    }
  }
  generateCheckOptions(optionsModel) {
    this.checkedOptions = {};
    if (optionsModel instanceof Array) {
      this.checkedOptionsList = optionsModel;
      this.options.forEach((option) => {
        this.checkedOptions[option.value] = optionsModel.includes(option.value);
      });
    } else {
      this.options.forEach((option) => {
        optionsModel[option.value] = optionsModel[option.value] === void 0 ? false : optionsModel[option.value];
        this.checkedOptions = optionsModel;
      });
    }
  }
  getGridSystemColumns(columns, maxColumns) {
    const gridSystemColumns = poCheckboxGroupColumnsTotalLength / columns;
    return this.checkColumnsRange(columns, maxColumns) ? gridSystemColumns : poCheckboxGroupColumnsDefaultLength;
  }
  isInvalidIndeterminate() {
    if (this.indeterminate && this.required && this.checkedOptions) {
      return Object.values(this.checkedOptions).every((value) => value === false);
    }
    return false;
  }
  removeDuplicatedOptions() {
    this.options.forEach((option, index) => {
      const duplicatedIndex = this.options.findIndex((optionFind) => optionFind.value === option.value) === index;
      if (!duplicatedIndex) {
        this.options.splice(this.options.indexOf(option), 1);
      }
    });
  }
  setCheckboxGroupOptionsView(optionsList) {
    this.checkboxGroupOptionsView = optionsList.map((option) => __spreadProps(__spreadValues({}, option), { id: uuid() }));
  }
  static ɵfac = function PoCheckboxGroupBaseComponent_Factory(t) {
    return new (t || _PoCheckboxGroupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoCheckboxGroupBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], name: "name", help: [InputFlags.None, "p-help", "help"], label: [InputFlags.None, "p-label", "label"], optional: [InputFlags.None, "p-optional", "optional"], columns: [InputFlags.None, "p-columns", "columns"], disabled: [InputFlags.None, "p-disabled", "disabled"], indeterminate: [InputFlags.None, "p-indeterminate", "indeterminate"], options: [InputFlags.None, "p-options", "options"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"] }, outputs: { ngModelChange: "ngModelChange", change: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxGroupBaseComponent, [{
    type: Directive
  }], null, { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], name: [{
    type: Input,
    args: ["name"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], ngModelChange: [{
    type: Output,
    args: ["ngModelChange"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], indeterminate: [{
    type: Input,
    args: ["p-indeterminate"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }] });
})();
var _c0$17 = ["checkboxLabel"];
function PoCheckboxGroupComponent_li_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "po-checkbox", 4, 5);
    ɵɵlistener("click", function PoCheckboxGroupComponent_li_3_Template_po_checkbox_click_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r4);
      const option_r1 = restoredCtx.$implicit;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.checkOption(option_r1));
    })("keydown", function PoCheckboxGroupComponent_li_3_Template_po_checkbox_keydown_1_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r4);
      const option_r1 = restoredCtx.$implicit;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onKeyDown($event, option_r1));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMapInterpolate2("po-checkbox-group-item po-md-", ctx_r0.mdColumns, " po-lg-", ctx_r0.columns, "");
    ɵɵclassProp("po-checkbox-group-item-disabled", option_r1.disabled || ctx_r0.disabled);
    ɵɵadvance();
    ɵɵproperty("p-label", option_r1.label)("p-disabled", option_r1.disabled || ctx_r0.disabled)("p-checkboxValue", ctx_r0.checkedOptions[option_r1.value] === null ? "mixed" : ctx_r0.checkedOptions[option_r1.value])("p-required", ctx_r0.required);
  }
}
var PoCheckboxGroupComponent = class _PoCheckboxGroupComponent extends PoCheckboxGroupBaseComponent {
  changeDetector;
  checkboxLabels;
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  ngAfterViewChecked() {
    this.changeDetector.detectChanges();
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoCheckboxGroupComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoCheckboxGroupComponent, { static: true }) checkbox: PoCheckboxGroupComponent;
   *
   * focusCheckbox() {
   *   this.checkbox.focus();
   * }
   * ```
   */
  focus() {
    if (this.checkboxLabels && !this.disabled) {
      const checkboxLabel = this.checkboxLabels.find((_, index) => !this.options[index].disabled);
      if (checkboxLabel) {
        checkboxLabel.checkboxLabel.nativeElement.focus();
      }
    }
  }
  onKeyDown(event, option) {
    const spaceBar = 32;
    if (event.which === spaceBar || event.keyCode === spaceBar) {
      this.checkOption(option);
      event.preventDefault();
    }
  }
  trackByFn(index) {
    return index;
  }
  static ɵfac = function PoCheckboxGroupComponent_Factory(t) {
    return new (t || _PoCheckboxGroupComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoCheckboxGroupComponent, selectors: [["po-checkbox-group"]], viewQuery: function PoCheckboxGroupComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$17, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxLabels = _t);
    }
  }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoCheckboxGroupComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoCheckboxGroupComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 5, vars: 9, consts: [[3, "p-disabled", "p-help", "p-label", "p-optional", "p-required", "p-show-required"], ["role", "group", 1, "po-field-container-content", "po-checkbox-group-content"], [1, "po-row", "po-pt-2", "po-pb-1"], [3, "class", "po-checkbox-group-item-disabled", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-label", "p-disabled", "p-checkboxValue", "p-required", "click", "keydown"], ["checkboxLabel", ""]], template: function PoCheckboxGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "ul", 2);
      ɵɵtemplate(3, PoCheckboxGroupComponent_li_3_Template, 3, 10, "li", 3);
      ɵɵelementEnd()();
      ɵɵelement(4, "po-field-container-bottom");
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-help", ctx.help)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.label);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.checkboxGroupOptionsView)("ngForTrackBy", ctx.trackByFn);
    }
  }, dependencies: [NgForOf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoCheckboxComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxGroupComponent, [{
    type: Component,
    args: [{ selector: "po-checkbox-group", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoCheckboxGroupComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoCheckboxGroupComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-help]="help"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div role="group" [attr.aria-label]="label" class="po-field-container-content po-checkbox-group-content">
    <ul class="po-row po-pt-2 po-pb-1">
      <li
        *ngFor="let option of checkboxGroupOptionsView; trackBy: trackByFn"
        class="po-checkbox-group-item po-md-{{ mdColumns }} po-lg-{{ columns }}"
        [class.po-checkbox-group-item-disabled]="option.disabled || disabled"
      >
        <po-checkbox
          #checkboxLabel
          [p-label]="option.label"
          [p-disabled]="option.disabled || disabled"
          (click)="checkOption(option)"
          (keydown)="onKeyDown($event, option)"
          [p-checkboxValue]="checkedOptions[option.value] === null ? 'mixed' : checkedOptions[option.value]"
          [p-required]="required"
        >
        </po-checkbox>
      </li>
    </ul>
  </div>

  <po-field-container-bottom></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ChangeDetectorRef }], { checkboxLabels: [{
    type: ViewChildren,
    args: ["checkboxLabel"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCheckboxGroupComponent, { className: "PoCheckboxGroupComponent", filePath: "lib/components/po-field/po-checkbox-group/po-checkbox-group.component.ts", lineNumber: 54 });
})();
var PoCheckboxGroupModule = class _PoCheckboxGroupModule {
  static ɵfac = function PoCheckboxGroupModule_Factory(t) {
    return new (t || _PoCheckboxGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoCheckboxGroupModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCheckboxModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCheckboxGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCheckboxModule],
      exports: [PoCheckboxGroupComponent],
      declarations: [PoCheckboxGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCheckboxGroupModule, { declarations: [PoCheckboxGroupComponent], imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCheckboxModule], exports: [PoCheckboxGroupComponent] });
})();
var poRadioGroupColumnsDefaultLength = 6;
var poRadioGroupColumnsTotalLength = 12;
var PoRadioGroupBaseComponent = class _PoRadioGroupBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Nome das opções. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Evento ao alterar valor do campo.
   */
  change = new EventEmitter();
  mdColumns = poRadioGroupColumnsDefaultLength;
  value;
  onTouched = null;
  _columns = poRadioGroupColumnsDefaultLength;
  _disabled = false;
  _options;
  _required = false;
  onChangePropagate = null;
  validatorChange;
  /**
   * @optional
   *
   * @description
   *
   * Define a quantidade de colunas para exibição das opções.
   *
   * **Considerações:**
   *  - É possível exibir as opções entre `1` e `4` colunas.
   *  - O número máximo de colunas é invariável nas seguintes resoluções:
   *    + `sm`: `1`
   *    + `md`: `2`
   *
   * @default `2`
   */
  set columns(value) {
    const columns = convertToInt(value, poRadioGroupColumnsDefaultLength);
    this._columns = this.getGridSystemColumns(columns, 4);
    this.mdColumns = this.getGridSystemColumns(columns, 2);
  }
  get columns() {
    return this._columns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
    this.validateModel();
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel();
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * Lista de opções que serão exibidas.
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface PoRadioGroupOption.
   */
  set options(value) {
    this._options = value;
    removeDuplicatedOptions(this.options);
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do *radio*
   * @default `medium`
   */
  size;
  // Função que controla quando deve ser emitido onChange e atualiza o Model
  changeValue(changedValue) {
    if (this.onChangePropagate) {
      this.onChangePropagate(changedValue);
    }
    if (this.value !== changedValue) {
      this.change.emit(changedValue);
    }
    this.value = changedValue;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onChangePropagate = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(modelValue) {
    this.value = modelValue;
    const element = this.getElementByValue(modelValue);
    if (!element && this.onChangePropagate) {
      this.value = void 0;
      this.onChangePropagate(this.value);
    }
  }
  checkColumnsRange(columns, maxColumns) {
    const minColumns = 1;
    return columns >= minColumns && columns <= maxColumns;
  }
  getGridSystemColumns(columns, maxColumns) {
    const gridSystemColumns = poRadioGroupColumnsTotalLength / columns;
    return this.checkColumnsRange(columns, maxColumns) ? gridSystemColumns : poRadioGroupColumnsDefaultLength;
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  static ɵfac = function PoRadioGroupBaseComponent_Factory(t) {
    return new (t || _PoRadioGroupBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoRadioGroupBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], name: "name", optional: [InputFlags.None, "p-optional", "optional"], columns: [InputFlags.None, "p-columns", "columns"], disabled: [InputFlags.None, "p-disabled", "disabled"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], options: [InputFlags.None, "p-options", "options"], size: [InputFlags.None, "p-size", "size"] }, outputs: { change: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioGroupBaseComponent, [{
    type: Directive
  }], null, { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], name: [{
    type: Input,
    args: ["name"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
var PoFieldModel = class _PoFieldModel {
  /** Rótulo exibido pelo componente. */
  label;
  /** Nome do componente. */
  name;
  /** Texto de apoio para o campo. */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o campo será desabilitado.
   *
   * @default `false`
   */
  disabled = false;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo.
   */
  change = new EventEmitter();
  value;
  onTouched;
  propagateChange;
  constructor() {
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.propagateChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    this.onWriteValue(value);
  }
  emitChange(value) {
    this.change.emit(value);
  }
  updateModel(value) {
    if (this.propagateChange) {
      this.propagateChange(value);
    }
  }
  static ɵfac = function PoFieldModel_Factory(t) {
    return new (t || _PoFieldModel)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoFieldModel, inputs: { label: [InputFlags.None, "p-label", "label"], name: "name", help: [InputFlags.None, "p-help", "help"], disabled: [InputFlags.HasDecoratorInputTransform, "p-disabled", "disabled", convertToBoolean] }, outputs: { change: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldModel, [{
    type: Directive
  }], () => [], { label: [{
    type: Input,
    args: ["p-label"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], disabled: [{
    type: Input,
    args: [{ alias: "p-disabled", transform: convertToBoolean }]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }] });
})();
var PoRadioSize;
(function(PoRadioSize2) {
  PoRadioSize2["Medium"] = "medium";
  PoRadioSize2["Large"] = "large";
})(PoRadioSize || (PoRadioSize = {}));
var _c0$16 = ["radio"];
var _c1$u = ["radioInput"];
function PoRadioComponent_po_label_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-label", 6);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r2.disabled)("p-label", ctx_r2.label);
  }
}
var PoRadioComponent = class _PoRadioComponent extends PoFieldModel {
  changeDetector;
  renderer;
  radio;
  radioInput;
  value = false;
  _size = PoRadioSize.Medium;
  /** Define o valor do *radio* */
  radioValue;
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho do *radio*
   * @default `medium`
   */
  set size(value) {
    this._size = Object.values(PoRadioSize).includes(value) ? value : PoRadioSize.Medium;
  }
  get size() {
    return this._size;
  }
  required;
  /** Define o status do *radio* */
  checked = false;
  /** Emite evento para a tabela ao selecionar ou desselecionar */
  changeSelected = new EventEmitter();
  constructor(changeDetector, renderer) {
    super();
    this.changeDetector = changeDetector;
    this.renderer = renderer;
  }
  /**
   * Função que atribui foco ao *radio*.
   *
   * Para utilizá-la é necessário capturar a referência do componente no DOM através do `ViewChild`, como por exemplo:
   *
   * ```
   * import { ViewChild } from '@angular/core';
   * import { PoRadioComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoRadioComponent, { static: true }) radio: PoRadioComponent;
   *
   * focusRadio() {
   * this.radio.focus();
   * }
   * ```
   *
   */
  focus() {
    if (!this.disabled) {
      this.radioInput.nativeElement.focus();
      this.onKeyup();
    }
  }
  onBlur() {
    this.onTouched?.();
  }
  onKeyDown(event) {
    if (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space) {
      this.eventClick();
    }
  }
  changeValue(value) {
    if (value) {
      this.value = value;
      this.updateModel(value);
      this.emitChange(this.value);
    }
  }
  eventClick() {
    if (!this.disabled) {
      this.changeValue(!this.value);
      this.changeDetector.detectChanges();
      this.changeSelected.emit(null);
    }
  }
  onWriteValue(value) {
    if (value !== this.value) {
      this.value = !!value;
      this.changeDetector.markForCheck();
    }
  }
  focusOut() {
    this.renderer.removeClass(this.radio.nativeElement, "po-radio-focus");
  }
  onKeyup() {
    this.renderer.addClass(this.radio.nativeElement, "po-radio-focus");
  }
  onKeydown() {
    this.renderer.addClass(this.radio.nativeElement, "po-radio-focus");
  }
  static ɵfac = function PoRadioComponent_Factory(t) {
    return new (t || _PoRadioComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRadioComponent, selectors: [["po-radio"]], viewQuery: function PoRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$16, 7);
      ɵɵviewQuery(_c1$u, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radio = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioInput = _t.first);
    }
  }, hostBindings: function PoRadioComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusout", function PoRadioComponent_focusout_HostBindingHandler($event) {
        return ctx.focusOut($event.target);
      })("keyup", function PoRadioComponent_keyup_HostBindingHandler($event) {
        return ctx.onKeyup($event.target);
      })("keydown", function PoRadioComponent_keydown_HostBindingHandler($event) {
        return ctx.onKeydown($event.target);
      });
    }
  }, inputs: { radioValue: [InputFlags.None, "p-value", "radioValue"], size: [InputFlags.None, "p-size", "size"], required: [InputFlags.HasDecoratorInputTransform, "p-required", "required", convertToBoolean], checked: [InputFlags.None, "p-checked", "checked"] }, outputs: { changeSelected: "p-change-selected" }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoRadioComponent),
      multi: true
    }
  ]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature], decls: 6, vars: 7, consts: [[1, "po-radio"], ["radio", ""], [3, "click", "keydown"], ["type", "radio", 3, "checked", "disabled", "name", "required", "value"], ["radioInput", ""], [3, "p-disabled", "p-label", 4, "ngIf"], [3, "p-disabled", "p-label"]], template: function PoRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1)(2, "label", 2);
      ɵɵlistener("click", function PoRadioComponent_Template_label_click_2_listener() {
        return ctx.eventClick();
      })("keydown", function PoRadioComponent_Template_label_keydown_2_listener($event) {
        return ctx.onKeyDown($event);
      });
      ɵɵelement(3, "input", 3, 4);
      ɵɵtemplate(5, PoRadioComponent_po_label_5_Template, 1, 2, "po-label", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      let tmp_2_0;
      let tmp_4_0;
      ɵɵadvance(3);
      ɵɵproperty("checked", ctx.checked)("disabled", ctx.disabled)("name", (tmp_2_0 = ctx.name) !== null && tmp_2_0 !== void 0 ? tmp_2_0 : "po-input-radio")("required", ctx.required)("value", (tmp_4_0 = ctx.radioValue) !== null && tmp_4_0 !== void 0 ? tmp_4_0 : "");
      ɵɵattribute("p-size", ctx.size);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.label);
    }
  }, dependencies: [NgIf, PoLabelComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioComponent, [{
    type: Component,
    args: [{ selector: "po-radio", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoRadioComponent),
        multi: true
      }
    ], template: `<div #radio class="po-radio">
  <label (click)="eventClick()" (keydown)="onKeyDown($event)">
    <input
      #radioInput
      type="radio"
      [attr.p-size]="size"
      [checked]="checked"
      [disabled]="disabled"
      [name]="name ?? 'po-input-radio'"
      [required]="required"
      [value]="radioValue ?? ''"
    />
    <po-label *ngIf="label" [p-disabled]="disabled" [p-label]="label"></po-label>
  </label>
</div>
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: Renderer2 }], { radio: [{
    type: ViewChild,
    args: ["radio", { static: true }]
  }], radioInput: [{
    type: ViewChild,
    args: ["radioInput", { static: true }]
  }], radioValue: [{
    type: Input,
    args: ["p-value"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }], required: [{
    type: Input,
    args: [{ alias: "p-required", transform: convertToBoolean }]
  }], checked: [{
    type: Input,
    args: ["p-checked"]
  }], changeSelected: [{
    type: Output,
    args: ["p-change-selected"]
  }], focusOut: [{
    type: HostListener,
    args: ["focusout", ["$event.target"]]
  }], onKeyup: [{
    type: HostListener,
    args: ["keyup", ["$event.target"]]
  }], onKeydown: [{
    type: HostListener,
    args: ["keydown", ["$event.target"]]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRadioComponent, { className: "PoRadioComponent", filePath: "lib/components/po-field/po-radio/po-radio.component.ts", lineNumber: 34 });
})();
var _c0$15 = ["inp"];
var _c1$t = ["inputRadio"];
function PoRadioGroupComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "po-radio", 5, 6);
    ɵɵlistener("keyup", function PoRadioGroupComponent_div_4_Template_po_radio_keyup_1_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r5);
      const option_r2 = restoredCtx.$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onKeyUp($event, option_r2.value));
    })("click", function PoRadioGroupComponent_div_4_Template_po_radio_click_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const option_r2 = restoredCtx.$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.eventClick(option_r2.value, option_r2.disabled === true || ctx_r6.disabled));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const option_r2 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate2("po-radio-group-item po-md-", ctx_r1.mdColumns, " po-lg-", ctx_r1.columns, "");
    ɵɵadvance();
    ɵɵproperty("name", ctx_r1.name)("p-checked", ctx_r1.value === option_r2.value)("p-disabled", option_r2.disabled === true || ctx_r1.disabled)("p-label", option_r2.label)("p-required", ctx_r1.required)("p-size", ctx_r1.size)("p-value", option_r2.value);
  }
}
var PoRadioGroupComponent = class _PoRadioGroupComponent extends PoRadioGroupBaseComponent {
  cd;
  /** Label do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  inputEl;
  radioLabels;
  differ;
  constructor(differs, cd) {
    super();
    this.cd = cd;
    this.differ = differs.find([]).create(null);
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  ngDoCheck() {
    const change = this.differ.diff(this.options);
    if (change) {
      removeDuplicatedOptions(this.options);
    }
    this.cd.markForCheck();
  }
  eventClick(value, disabled) {
    if (!disabled) {
      this.onTouched?.();
      this.changeValue(value);
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoRadioGroupComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoRadioGroupComponent, { static: true }) radio: PoRadioGroupComponent;
   *
   * focusRadio() {
   *   this.radio.focus();
   * }
   * ```
   */
  focus() {
    if (this.radioLabels && !this.disabled) {
      const radioLabel = this.radioLabels.find((_, index) => !this.options[index].disabled);
      if (radioLabel) {
        radioLabel.focus();
      }
    }
  }
  getElementByValue(value) {
    return this.inputEl.nativeElement.querySelector(`input[value='${value}']`);
  }
  onKeyUp(event, value) {
    const key = event.keyCode || event.which;
    if (this.isArrowKey(key)) {
      this.changeValue(value);
    }
  }
  isArrowKey(key) {
    return key >= 37 && key <= 40;
  }
  static ɵfac = function PoRadioGroupComponent_Factory(t) {
    return new (t || _PoRadioGroupComponent)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRadioGroupComponent, selectors: [["po-radio-group"]], viewQuery: function PoRadioGroupComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$15, 7, ElementRef);
      ɵɵviewQuery(_c1$t, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioLabels = _t);
    }
  }, inputs: { label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"] }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoRadioGroupComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoRadioGroupComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 6, vars: 10, consts: [[3, "p-disabled", "p-help", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["role", "radiogroup", 1, "po-radio-group"], ["inp", ""], [3, "class", 4, "ngFor", "ngForOf"], [3, "name", "p-checked", "p-disabled", "p-label", "p-required", "p-size", "p-value", "keyup", "click"], ["inputRadio", ""]], template: function PoRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "div", 2, 3);
      ɵɵtemplate(4, PoRadioGroupComponent_div_4_Template, 3, 11, "div", 4);
      ɵɵelementEnd()();
      ɵɵelement(5, "po-field-container-bottom");
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-help", ctx.help)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance();
      ɵɵattribute("name", ctx.name);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.label)("data-options", ctx.options.length);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.options);
    }
  }, dependencies: [NgForOf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoRadioComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioGroupComponent, [{
    type: Component,
    args: [{ selector: "po-radio-group", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoRadioGroupComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoRadioGroupComponent),
        multi: true
      }
    ], template: '<po-field-container\n  [p-disabled]="disabled"\n  [p-help]="help"\n  [p-label]="label"\n  [p-optional]="optional"\n  [p-required]="required"\n  [p-show-required]="showRequired"\n>\n  <div class="po-field-container-content" [attr.name]="name">\n    <div #inp class="po-radio-group" role="radiogroup" [attr.aria-label]="label" [attr.data-options]="options.length">\n      <div *ngFor="let option of options" class="po-radio-group-item po-md-{{ mdColumns }} po-lg-{{ columns }}">\n        <po-radio\n          #inputRadio\n          [name]="name"\n          [p-checked]="value === option.value"\n          [p-disabled]="option.disabled === true || disabled"\n          [p-label]="option.label"\n          [p-required]="required"\n          [p-size]="size"\n          [p-value]="option.value"\n          (keyup)="onKeyUp($event, option.value)"\n          (click)="eventClick(option.value, option.disabled === true || disabled)"\n        >\n        </po-radio>\n      </div>\n    </div>\n  </div>\n  <po-field-container-bottom></po-field-container-bottom>\n</po-field-container>\n' }]
  }], () => [{ type: IterableDiffers }, { type: ChangeDetectorRef }], { label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: true }]
  }], radioLabels: [{
    type: ViewChildren,
    args: ["inputRadio"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRadioGroupComponent, { className: "PoRadioGroupComponent", filePath: "lib/components/po-field/po-radio-group/po-radio-group.component.ts", lineNumber: 67 });
})();
var PoRadioModule = class _PoRadioModule {
  static ɵfac = function PoRadioModule_Factory(t) {
    return new (t || _PoRadioModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoRadioModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoLabelModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioModule, [{
    type: NgModule,
    args: [{
      declarations: [PoRadioComponent],
      exports: [PoRadioComponent],
      imports: [CommonModule, FormsModule, PoLabelModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoRadioModule, { declarations: [PoRadioComponent], imports: [CommonModule, FormsModule, PoLabelModule], exports: [PoRadioComponent] });
})();
var PoRadioGroupModule = class _PoRadioGroupModule {
  static ɵfac = function PoRadioGroupModule_Factory(t) {
    return new (t || _PoRadioGroupModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoRadioGroupModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoFieldContainerModule, PoRadioModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRadioGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoRadioModule],
      exports: [PoRadioGroupComponent],
      declarations: [PoRadioGroupComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoRadioGroupModule, { declarations: [PoRadioGroupComponent], imports: [CommonModule, FormsModule, PoFieldContainerModule, PoRadioModule], exports: [PoRadioGroupComponent] });
})();
var PoCleanBaseComponent = class _PoCleanBaseComponent {
  /** Nesta propriedade deve-se informar o elementRef do campo de entrada que utilizará o po-clean. */
  inputRef;
  /** Valor que será atribuído ao campo quando for clicado no po-clean. */
  defaultValue = "";
  /**
   * @optional
   *
   * @description
   *
   *
   * Evento disparado quando executada ação do po-clean.
   * Este evento deve ser usado para avisar para o componente que está usando o po-clean, que o botão foi disparado,
   * e provavelmente será preciso emitir o evento para atualizar o model.
   */
  changeEvent = new EventEmitter();
  clear() {
    this.setInputValue(this.defaultValue);
    this.changeEvent.emit(this.defaultValue);
  }
  showIcon() {
    return this.defaultValue !== this.getInputValue();
  }
  static ɵfac = function PoCleanBaseComponent_Factory(t) {
    return new (t || _PoCleanBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoCleanBaseComponent, inputs: { inputRef: [InputFlags.None, "p-element-ref", "inputRef"], defaultValue: [InputFlags.None, "p-default-value", "defaultValue"] }, outputs: { changeEvent: "p-change-event" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCleanBaseComponent, [{
    type: Directive
  }], null, { inputRef: [{
    type: Input,
    args: ["p-element-ref"]
  }], defaultValue: [{
    type: Input,
    args: ["p-default-value"]
  }], changeEvent: [{
    type: Output,
    args: ["p-change-event"]
  }] });
})();
function PoCleanComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 1);
    ɵɵlistener("click", function PoCleanComponent_span_0_Template_span_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clear());
    });
    ɵɵelementEnd();
  }
}
var PoCleanComponent = class _PoCleanComponent extends PoCleanBaseComponent {
  setInputValue(value) {
    if (this.inputRef && this.inputRef.nativeElement) {
      this.inputRef.nativeElement.value = value;
    }
  }
  getInputValue() {
    if (this.inputRef && this.inputRef.nativeElement) {
      return this.inputRef.nativeElement.value;
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoCleanComponent_BaseFactory;
    return function PoCleanComponent_Factory(t) {
      return (ɵPoCleanComponent_BaseFactory || (ɵPoCleanComponent_BaseFactory = ɵɵgetInheritedFactory(_PoCleanComponent)))(t || _PoCleanComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoCleanComponent, selectors: [["po-clean"]], features: [ɵɵInheritDefinitionFeature], decls: 1, vars: 1, consts: [["class", "po-icon po-field-icon po-icon-close", 3, "click", 4, "ngIf"], [1, "po-icon", "po-field-icon", "po-icon-close", 3, "click"]], template: function PoCleanComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoCleanComponent_span_0_Template, 1, 0, "span", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showIcon());
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCleanComponent, [{
    type: Component,
    args: [{ selector: "po-clean", template: '<span *ngIf="showIcon()" class="po-icon po-field-icon po-icon-close" (click)="clear()"> </span>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoCleanComponent, { className: "PoCleanComponent", filePath: "lib/components/po-field/po-clean/po-clean.component.ts", lineNumber: 21 });
})();
var PoCleanModule = class _PoCleanModule {
  static ɵfac = function PoCleanModule_Factory(t) {
    return new (t || _PoCleanModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoCleanModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoCleanModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: [PoCleanComponent],
      declarations: [PoCleanComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoCleanModule, { declarations: [PoCleanComponent], imports: [CommonModule], exports: [PoCleanComponent] });
})();
var PoMask = class {
  mask = "";
  formatModel = false;
  // controle de posição
  initialPosition = 0;
  finalPosition = 0;
  pattern = "";
  get getPattern() {
    return this.pattern;
  }
  valueToInput;
  get getValueToInput() {
    return this.valueToInput;
  }
  set setValueToInput(value) {
    this.valueToInput = value;
  }
  valueToModel;
  get getValueToModel() {
    return this.valueToModel;
  }
  set setValueToModel(value) {
    this.valueToModel = value;
  }
  formattingEnds;
  constructor(mask, formatModel) {
    this.mask = mask;
    this.formatModel = formatModel;
    this.pattern = this.getRegexFromMask(mask);
  }
  keyup($event) {
    if (this.mask) {
      const value = $event.target.value;
      if ($event.keyCode === 17 || $event.keyCode === 91) {
        $event.target.value = this.controlFormatting(value);
        this.resetPositions($event);
      }
      $event.preventDefault();
      switch ($event.keyCode) {
        case 37:
          if (this.initialPosition > 0) {
            this.initialPosition--;
          }
          this.setPositionNotShiftKey($event);
          this.setSelectionRange($event);
          break;
        case 39:
          if (this.initialPosition < value.toString().length) {
            this.initialPosition++;
          }
          this.setPositionNotShiftKey($event);
          this.setSelectionRange($event);
          break;
        case 35:
          this.finalPosition = value.toString().length;
          if ($event.shiftKey) {
            this.setPositions($event);
          } else {
            this.initialPosition = this.finalPosition;
            this.setPositions($event);
          }
          break;
        case 36:
          if ($event.shiftKey) {
            this.finalPosition = this.initialPosition;
            this.initialPosition = 0;
            this.setPositions($event);
          } else {
            this.initialPosition = 0;
            this.finalPosition = 0;
            this.setPositions($event);
          }
          break;
      }
    }
  }
  setPositionNotShiftKey($event) {
    if (!$event.shiftKey) {
      this.finalPosition = this.initialPosition;
    }
  }
  setSelectionRange($event) {
    if (this.initialPosition > this.finalPosition) {
      $event.target.setSelectionRange(this.finalPosition, this.initialPosition);
    } else {
      $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
    }
  }
  keydown($event) {
    if (this.mask) {
      let value = $event.target.value;
      if ($event.keyCode === 9) {
        return;
      }
      if (!$event.ctrlKey && !$event.metaKey) {
        $event.preventDefault();
      }
      if ($event.ctrlKey || $event.metaKey && $event.keyCode !== 86 || $event.keyCode >= 37 && $event.keyCode <= 40 || $event.keyCode === 16 || $event.keyCode === 9) {
        return;
      }
      if (this.isKeyValid($event.keyCode)) {
        if (this.finalPosition === null) {
          this.finalPosition = this.initialPosition;
        }
        this.revertPositions(this.initialPosition, this.finalPosition);
        switch ($event.keyCode) {
          case 8:
            this.getPosition($event);
            if (this.initialPosition < 0) {
              this.initialPosition = 0;
              this.setPositions($event);
            }
            if (this.initialPosition === this.finalPosition) {
              this.checkMaskBefore($event, -1);
              if (this.initialPosition !== 0) {
                value = value.slice(0, this.initialPosition - 1) + value.slice(this.finalPosition);
                value = this.controlFormatting(value);
                $event.target.value = value;
                this.changePosition($event, -1);
                this.checkMaskBefore($event, -1);
                this.setPositions($event);
                this.resetPositions($event);
              }
            } else {
              this.clearRangeSelection(value, $event, true);
            }
            this.setPositions($event);
            break;
          case 46:
            this.getPosition($event);
            if (this.initialPosition === this.finalPosition) {
              this.checkMaskAfter($event, 1);
              value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition + 1);
              value = this.controlFormatting(value);
              $event.target.value = value;
              this.setPositions($event);
              this.resetPositions($event);
            } else {
              this.clearRangeSelection(value, $event, false);
            }
            this.setPositions($event);
            break;
          default:
            this.getPosition($event);
            value = value.slice(0, this.initialPosition) + $event.key + value.slice(this.finalPosition);
            value = this.controlFormatting(value);
            $event.target.value = value;
            this.changePosition($event, 1);
            this.checkMaskBefore($event, 1);
            this.setPositions($event);
            this.resetPositions($event);
            this.setPositions($event);
        }
      }
    }
  }
  clearRangeSelection(value, $event, isBackspace) {
    value = value.slice(0, this.initialPosition) + value.slice(this.finalPosition);
    value = this.controlFormatting(value);
    $event.target.value = value;
    if (isBackspace) {
      this.checkMaskBefore($event, -1);
    }
    this.setPositions($event);
    this.resetPositions($event);
  }
  // passa a posição do click para o controle de posição
  click($event) {
    this.initialPosition = $event.target.selectionStart;
    this.finalPosition = $event.target.selectionEnd;
  }
  blur($event) {
    if (this.mask) {
      let value = $event.target.value;
      value = this.controlFormatting(value);
      $event.target.value = value;
    }
  }
  revertPositions(initialPosition, finalPosition) {
    if (initialPosition > finalPosition) {
      const tempPosition = initialPosition;
      this.initialPosition = finalPosition;
      this.finalPosition = tempPosition;
    }
  }
  // reseta o controle de posição
  resetPositions($event) {
    this.initialPosition = $event.target.selectionStart;
    this.finalPosition = this.initialPosition;
  }
  // posiciona o cursor de acordo com o controle de posição
  setPositions($event) {
    $event.target.setSelectionRange(this.initialPosition, this.finalPosition);
  }
  // muda a posição do cursor e atualiza o controle de posição
  changePosition($event, value) {
    this.initialPosition = this.initialPosition + value;
    this.finalPosition = this.finalPosition + value;
    this.setPositions($event);
  }
  getPosition($event) {
    this.initialPosition = $event.target.selectionStart;
    this.finalPosition = $event.target.selectionEnd;
    this.setPositions($event);
  }
  // Método responsável por controlar a formatação e aplicar todas as máscara possíveis
  // quando houver valores opcionais (?)
  controlFormatting(value) {
    if (!value) {
      this.valueToInput = "";
      this.valueToModel = "";
      return "";
    }
    let valueProcessed;
    let maskTmp = this.mask;
    const arrMasks = [];
    let contMasks = 0;
    while (this.hasOptionalNumber(maskTmp)) {
      arrMasks.push(maskTmp);
      maskTmp = this.replaceOptionalNumber(maskTmp);
    }
    arrMasks.push(maskTmp);
    arrMasks.reverse();
    this.formattingEnds = false;
    while (!this.formattingEnds) {
      this.formattingEnds = true;
      if (!arrMasks[contMasks]) {
        break;
      }
      valueProcessed = this.formatValue(value, arrMasks[contMasks]);
      contMasks++;
    }
    return valueProcessed;
  }
  // Função que formata a máscara com o valor passado
  formatValue(value, mask) {
    mask = mask.replace(/\?/g, "");
    const guide = mask.replace(this.listValidKeys(), "_");
    let contGuide = 0;
    let valueProcessed = "";
    value = this.removeFormattingValue(value);
    for (let i = 0; i < value.length; i++) {
      const charValue = value[i];
      if (!guide[contGuide]) {
        this.formattingEnds = false;
        break;
      }
      while (this.isFixedCharacterGuide(guide[contGuide]) && guide[contGuide]) {
        valueProcessed += guide[contGuide];
        contGuide++;
      }
      if (this.isKeyValidMask(charValue, mask[contGuide])) {
        valueProcessed += charValue;
        contGuide++;
      } else {
        break;
      }
    }
    if (this.formatModel) {
      this.valueToInput = valueProcessed;
      this.valueToModel = valueProcessed;
    } else {
      this.valueToInput = valueProcessed;
      this.valueToModel = this.removeFormattingValue(valueProcessed);
    }
    return valueProcessed;
  }
  // verifica se tem algum caracter de mascara antes do cursor
  checkMaskBefore($event, position) {
    if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition - 1))) {
      this.changePosition($event, position);
      this.checkMaskBefore($event, position);
    }
  }
  // verifica se tem algum caracter de mascara depois do cursor
  checkMaskAfter($event, position) {
    if (this.isFixedCharacterGuide($event.target.value.toString().charAt(this.initialPosition))) {
      this.changePosition($event, position);
      this.checkMaskAfter($event, position);
    }
  }
  // Retorna a máscara sem um valor opcional
  replaceOptionalNumber(mask) {
    let i = 9;
    while (i >= 0) {
      if (mask.indexOf(i + "?") > -1) {
        return mask.replace(i + "?", "");
      }
      i--;
    }
    return mask;
  }
  // Verifica se contém caracteres permitidos somente na máscara \/() +-
  isFixedCharacterGuide(key) {
    return this.testRegex(key, this.getFixedCharacterGuide());
  }
  // Retorna caracteres permitidos somente na máscara \/() +-
  getFixedCharacterGuide() {
    return /[\\\/() +-.\:]/g;
  }
  // Caracteres permitidos de serem digitados
  listValidKeys() {
    return /[a-zA-Z0-9]/g;
  }
  // Se é um dígito válido
  isKeyValid(keyCode) {
    return this.isKeyCodeValid(keyCode);
  }
  // Verifica se a tecla digitada é permitida
  // Permite apenas números, letras, backspace e del
  isKeyCodeValid(keyCode) {
    return keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 105 || keyCode === 8 || keyCode === 9 || keyCode === 46;
  }
  // Se está de acordo com a máscara
  isKeyValidMask(key, keyMask) {
    return this.testRegex(key, this.replaceMask(keyMask));
  }
  // Retorna se a chave foi aprovada pela expressão regular
  testRegex(key, regex) {
    return regex.test(key);
  }
  // Remove a formatacão do valor
  // É possível ser melhorado para remover pontualmente os caracteres fixos de acordo com a máscara
  removeFormattingValue(value) {
    return value.replace(this.getFixedCharacterGuide(), "");
  }
  // Verifica se contém valor opcional na máscara 0-9?
  hasOptionalNumber(mask) {
    return mask.match(/\d\?/g);
  }
  // Retorna a expressão regular correspondente ao comando passado
  replaceMask(char) {
    let regex = /./;
    switch (char) {
      case "0":
        regex = /[0]/;
        break;
      case "1":
        regex = /[0-1]/;
        break;
      case "2":
        regex = /[0-2]/;
        break;
      case "3":
        regex = /[0-3]/;
        break;
      case "4":
        regex = /[0-4]/;
        break;
      case "5":
        regex = /[0-5]/;
        break;
      case "6":
        regex = /[0-6]/;
        break;
      case "7":
        regex = /[0-7]/;
        break;
      case "8":
        regex = /[0-8]/;
        break;
      case "9":
        regex = /[0-9]/;
        break;
      case " ":
        regex = /\s/;
        break;
      case "@":
        regex = /[a-zA-Z]/;
        break;
      case "w":
        regex = /[a-zA-Z0-9]/;
        break;
    }
    return regex;
  }
  getRegexFromMask(mask) {
    if (mask) {
      let pattern;
      if (this.formatModel) {
        pattern = mask.replace(/\\/g, "\\\\");
        pattern = pattern.replace(/\+/g, "\\+");
        pattern = pattern.replace(/\./g, "\\.");
        pattern = pattern.replace(/-/g, "-");
        pattern = pattern.replace(/\(/g, "\\(");
        pattern = pattern.replace(/\)/g, "\\)");
        pattern = pattern.replace(/\//g, "\\/");
        pattern = pattern.replace(/\s/g, "\\s");
        pattern = pattern.replace(/:/g, "\\:");
        pattern = pattern.replace(/\@(?!\s)/g, "\\w");
        pattern = pattern.replace(/\d/g, "\\w");
      } else {
        pattern = mask.replace(/\\/g, "");
        pattern = pattern.replace(/\+/g, "");
        pattern = pattern.replace(/\./g, "");
        pattern = pattern.replace(/-/g, "");
        pattern = pattern.replace(/\(/g, "");
        pattern = pattern.replace(/\)/g, "");
        pattern = pattern.replace(/\//g, "");
        pattern = pattern.replace(/\s/g, "");
        pattern = pattern.replace(/:/g, "");
        pattern = pattern.replace(/\@/g, "\\w");
        pattern = pattern.replace(/\d/g, "\\w");
      }
      return pattern;
    } else {
      return null;
    }
  }
};
var PoDatepickerIsoFormat;
(function(PoDatepickerIsoFormat2) {
  PoDatepickerIsoFormat2["Basic"] = "basic";
  PoDatepickerIsoFormat2["Extended"] = "extended";
})(PoDatepickerIsoFormat || (PoDatepickerIsoFormat = {}));
var poDatepickerFormatDefault = "dd/mm/yyyy";
var PoDatepickerBaseComponent = class _PoDatepickerBaseComponent {
  languageService;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /* Nome do componente datepicker. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * Mensagem apresentada quando a data for inválida ou fora do período.
   *
   * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja obrigatório.
   */
  errorPattern = "";
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao sair do campo.
   */
  onblur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo.
   */
  onchange = new EventEmitter();
  offset;
  firstStart = true;
  hour = "T00:00:00-00:00";
  isExtendedISO = false;
  objMask;
  onChangeModel = null;
  validatorChange;
  onTouchedModel = null;
  shortLanguage;
  _format = poDatepickerFormatDefault;
  _isoFormat;
  _maxDate;
  _minDate;
  _noAutocomplete = false;
  _placeholder = "";
  previousValue;
  _date;
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Mensagem que aparecerá enquanto o campo não estiver preenchido.
   */
  set placeholder(placeholder) {
    this._placeholder = isTypeof(placeholder, "string") ? placeholder : "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /** Desabilita o campo. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  disabled = false;
  set setDisabled(disabled) {
    this.disabled = disabled === "" ? true : convertToBoolean(disabled);
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  /** Torna o elemento somente leitura. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  readonly = false;
  set setReadonly(readonly) {
    this.readonly = readonly === "" ? true : convertToBoolean(readonly);
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  required = false;
  set setRequired(required) {
    this.required = required === "" ? true : convertToBoolean(required);
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /** Habilita ação para limpar o campo. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  clean = false;
  set setClean(clean) {
    this.clean = clean === "" ? true : convertToBoolean(clean);
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data mínima para o `po-datepicker`.
   */
  set minDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
      setYearFrom0To100(date, year);
      this._minDate = date;
    } else {
      this._minDate = convertIsoToDate(value, true, false);
    }
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  get minDate() {
    return this._minDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data máxima para o `po-datepicker`.
   */
  set maxDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
      setYearFrom0To100(date, year);
      this._maxDate = date;
    } else {
      this._maxDate = convertIsoToDate(value, false, true);
    }
    this.validateModel(convertDateToISOExtended(this.date, this.hour));
  }
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Formato de exibição da data.
   *
   * Valores válidos:
   *  - `dd/mm/yyyy`
   *  - `mm/dd/yyyy`
   *  - `yyyy/mm/dd`
   *
   * @default `dd/mm/yyyy`
   */
  set format(value) {
    if (value) {
      value = value.toLowerCase();
      if (value.match(/dd/) && value.match(/mm/) && value.match(/yyyy/)) {
        this._format = value;
        this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
        this.refreshValue(this.date);
        return;
      }
    }
    this._format = poDatepickerFormatDefault;
    this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
  }
  get format() {
    return this._format;
  }
  /**
   * @optional
   *
   * @description
   *
   * Padrão de formatação para saída do *model*, independentemente do formato de entrada.
   *
   * > Veja os valores válidos no *enum* `PoDatepickerIsoFormat`.
   */
  set isoFormat(value) {
    if (Object.values(PoDatepickerIsoFormat).includes(value)) {
      this._isoFormat = value;
      this.isExtendedISO = value === PoDatepickerIsoFormat.Extended;
    }
  }
  get isoFormat() {
    return this._isoFormat;
  }
  /**
   * @optional
   *
   * @description
   *
   * Idioma do Datepicker.
   *
   * > O locale padrão sera recuperado com base no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  _locale;
  set locale(value) {
    if (value) {
      this._locale = value.length >= 2 ? value : poLocaleDefault;
      this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    } else {
      this._locale = this.shortLanguage;
      this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    }
    this.refreshValue(this.date);
  }
  get locale() {
    return this._locale || this.shortLanguage;
  }
  constructor(languageService) {
    this.languageService = languageService;
  }
  set date(value) {
    this._date = typeof value === "string" ? convertIsoToDate(value, false, false) : value;
  }
  get date() {
    return this._date;
  }
  ngOnInit() {
    this.offset = (/* @__PURE__ */ new Date()).getTimezoneOffset();
    this.formatTimezoneAndHour(this.offset);
    this.objMask = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
  }
  // Converte um objeto string em Date
  getDateFromString(dateString) {
    const day = parseInt(dateString.substring(this.format.indexOf("d"), this.format.indexOf("d") + 2), 10);
    const month = parseInt(dateString.substring(this.format.indexOf("m"), this.format.indexOf("m") + 2), 10) - 1;
    const year = parseInt(dateString.substring(this.format.indexOf("y"), this.format.indexOf("y") + 4), 10);
    const date = new Date(year, month, day);
    setYearFrom0To100(date, year);
    return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day ? date : null;
  }
  // Formata a data.
  formatToDate(value) {
    let dateFormatted = this.format;
    dateFormatted = dateFormatted.replace("dd", ("0" + value.getDate()).slice(-2));
    dateFormatted = dateFormatted.replace("mm", ("0" + (value.getMonth() + 1)).slice(-2));
    dateFormatted = dateFormatted.replace("yyyy", formatYear(value.getFullYear()));
    return dateFormatted;
  }
  // Método responsável por controlar o modelo.
  controlModel(date) {
    this.date = date;
    if (date && this.isExtendedISO) {
      this.callOnChange(convertDateToISOExtended(this.date, this.hour));
    } else if (date && !this.isExtendedISO) {
      this.callOnChange(convertDateToISODate(this.date));
    } else {
      date === void 0 ? this.callOnChange("") : this.callOnChange("Data inválida");
    }
  }
  // Executa a função onChange
  callOnChange(value, retry = true) {
    if (this.onChangeModel && value !== this.previousValue) {
      this.onChangeModel(value);
      this.previousValue = value;
    } else if (retry) {
      setTimeout(() => this.callOnChange(value, false));
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangeModel = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouchedModel = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(c) {
    this.errorPattern = this.errorPattern !== "Data inválida" && this.errorPattern !== "Data fora do período" ? this.errorPattern : "";
    if (dateFailed(c.value)) {
      this.errorPattern = this.errorPattern || "Data inválida";
      return {
        date: {
          valid: false
        }
      };
    }
    if (requiredFailed(this.required, this.disabled, c.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    if (this.date && !validateDateRange(this.date, this._minDate, this._maxDate)) {
      this.errorPattern = this.errorPattern || "Data fora do período";
      return {
        date: {
          valid: false
        }
      };
    }
    return null;
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  // Retorna um objeto do tipo PoMask com a mascara configurada.
  buildMask(format = this.format) {
    let mask = format.toUpperCase();
    mask = mask.replace(/DD/g, "99");
    mask = mask.replace(/MM/g, "99");
    mask = mask.replace(/YYYY/g, "9999");
    return new PoMask(mask, true);
  }
  formatTimezoneAndHour(offset) {
    const offsetAbsolute = Math.abs(offset);
    const timezone = (offset < 0 ? "+" : "-") + ("00" + Math.floor(offsetAbsolute / 60)).slice(-2) + ":" + ("00" + offsetAbsolute % 60).slice(-2);
    this.hour = "T00:00:00" + timezone;
  }
  static ɵfac = function PoDatepickerBaseComponent_Factory(t) {
    return new (t || _PoDatepickerBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDatepickerBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], name: "name", optional: [InputFlags.None, "p-optional", "optional"], errorPattern: [InputFlags.None, "p-error-pattern", "errorPattern"], noAutocomplete: [InputFlags.None, "p-no-autocomplete", "noAutocomplete"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], setDisabled: [InputFlags.None, "p-disabled", "setDisabled"], setReadonly: [InputFlags.None, "p-readonly", "setReadonly"], setRequired: [InputFlags.None, "p-required", "setRequired"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], setClean: [InputFlags.None, "p-clean", "setClean"], minDate: [InputFlags.None, "p-min-date", "minDate"], maxDate: [InputFlags.None, "p-max-date", "maxDate"], format: [InputFlags.None, "p-format", "format"], isoFormat: [InputFlags.None, "p-iso-format", "isoFormat"], locale: [InputFlags.None, "p-locale", "locale"] }, outputs: { onblur: "p-blur", onchange: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], name: [{
    type: Input,
    args: ["name"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], errorPattern: [{
    type: Input,
    args: ["p-error-pattern"]
  }], onblur: [{
    type: Output,
    args: ["p-blur"]
  }], onchange: [{
    type: Output,
    args: ["p-change"]
  }], noAutocomplete: [{
    type: Input,
    args: ["p-no-autocomplete"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], setDisabled: [{
    type: Input,
    args: ["p-disabled"]
  }], setReadonly: [{
    type: Input,
    args: ["p-readonly"]
  }], setRequired: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], setClean: [{
    type: Input,
    args: ["p-clean"]
  }], minDate: [{
    type: Input,
    args: ["p-min-date"]
  }], maxDate: [{
    type: Input,
    args: ["p-max-date"]
  }], format: [{
    type: Input,
    args: ["p-format"]
  }], isoFormat: [{
    type: Input,
    args: ["p-iso-format"]
  }], locale: [{
    type: Input,
    args: ["p-locale"]
  }] });
})();
var PoDatepickerLiterals = {
  en: {
    open: "Open calendar"
  },
  es: {
    open: "Calendario abierto"
  },
  pt: {
    open: "Abrir calendário"
  },
  ru: {
    open: "открытый календарь"
  }
};
var _c0$14 = ["calendar"];
var _c1$s = ["dialogPicker"];
var _c2$e = ["iconDatepicker"];
var _c3$8 = ["inp"];
function PoDatepickerComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 14);
    ɵɵlistener("p-change-event", function PoDatepickerComponent_po_clean_6_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.clear());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
function PoDatepickerComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 15);
  }
}
var poCalendarContentOffset$1 = 8;
var poCalendarPositionDefault$1 = "bottom-left";
var PoDatepickerComponent = class _PoDatepickerComponent extends PoDatepickerBaseComponent {
  languageService;
  controlPosition;
  renderer;
  calendar;
  dialogPicker;
  iconDatepicker;
  inputEl;
  /** Rótulo do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  el;
  hour;
  id = `po-datepicker[${uuid()}]`;
  visible = false;
  literals;
  eventListenerFunction;
  eventResizeListener;
  clickListener;
  dateRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])$");
  isoRegex = new RegExp("^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])(?:|:?[0-5]\\d)$");
  timeoutChange;
  valueBeforeChange;
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  constructor(languageService, controlPosition, renderer, el) {
    super(languageService);
    this.languageService = languageService;
    this.controlPosition = controlPosition;
    this.renderer = renderer;
    this.shortLanguage = this.languageService.getShortLanguage();
    this.el = el;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, PoDatepickerLiterals[language]);
  }
  onKeyup($event) {
    if (this.readonly) {
      return;
    }
    this.objMask.keyup($event);
    if (this.objMask.valueToModel || this.objMask.valueToModel === "") {
      if (this.objMask.valueToModel.length >= 10) {
        this.controlModel(this.getDateFromString(this.inputEl.nativeElement.value));
        this.date = this.getDateFromString(this.inputEl.nativeElement.value);
      } else {
        this.date = void 0;
        this.controlModel(this.date);
      }
    } else {
      this.date = void 0;
    }
  }
  onKeydown($event) {
    if (this.readonly) {
      return;
    }
    this.objMask.keydown($event);
  }
  ngAfterViewInit() {
    this.setDialogPickerStyleDisplay("none");
    if (this.autoFocus) {
      this.focus();
    }
    this.renderer.setAttribute(this.iconDatepicker.buttonElement.nativeElement, "aria-label", this.literals.open);
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoDatepickerComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoDatepickerComponent, { static: true }) datepicker: PoDatepickerComponent;
   *
   * focusDatepicker() {
   *   this.datepicker.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  togglePicker() {
    if (this.disabled || this.readonly) {
      return;
    }
    if (!this.visible) {
      this.setCalendarPosition();
      this.initializeListeners();
      this.visible = true;
    } else {
      this.inputEl.nativeElement.disabled = false;
      this.closeCalendar();
    }
  }
  dateSelected() {
    this.onTouchedModel?.();
    if (!this.verifyMobile()) {
      this.inputEl.nativeElement.focus();
    }
    this.inputEl.nativeElement.value = this.formatToDate(this.date);
    this.controlModel(this.date);
    this.controlChangeEmitter();
    this.closeCalendar();
  }
  // Esconde Picker quando for clicado fora
  wasClickedOnPicker(event) {
    if (!this.dialogPicker || !this.iconDatepicker) {
      return;
    }
    if ((!this.dialogPicker.nativeElement.contains(event.target) || this.hasOverlayClass(event.target)) && !this.iconDatepicker.buttonElement.nativeElement.contains(event.target) && !this.hasAttrCalendar(event.target)) {
      this.closeCalendar();
    }
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && this.inputEl.nativeElement.value !== "";
  }
  getErrorPattern() {
    return this.errorPattern !== "" && this.hasInvalidClass() ? this.errorPattern : "";
  }
  clear() {
    this.valueBeforeChange = this.formatToDate(this.date);
    this.date = void 0;
    this.controlModel(this.date);
    this.controlChangeEmitter();
  }
  eventOnBlur($event) {
    this.onTouchedModel?.();
    const date = this.inputEl.nativeElement.value;
    const newDate = date ? this.getDateFromString(date) : void 0;
    this.objMask.blur($event);
    this.onblur.emit();
    if (this.objMask.valueToModel) {
      if (this.objMask.valueToModel.length >= 10) {
        this.controlModel(newDate);
        this.date = newDate;
      } else {
        this.date = null;
        this.controlModel(this.date);
      }
    } else {
      this.date = void 0;
      this.callOnChange(this.date);
    }
    this.controlChangeEmitter();
  }
  eventOnClick($event) {
    if (this.verifyMobile()) {
      $event.target.blur();
      setTimeout(() => this.togglePicker(), 0);
    } else {
      this.objMask.click($event);
    }
  }
  onKeyPress(event) {
    if (isKeyCodeEnter(event) || isKeyCodeSpace(event)) {
      this.togglePicker();
    }
  }
  formatToDate(value) {
    if (!value) {
      return void 0;
    }
    let dateFormatted = replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale));
    dateFormatted = dateFormatted.replace("dd", ("0" + value.getDate()).slice(-2));
    dateFormatted = dateFormatted.replace("mm", ("0" + (value.getMonth() + 1)).slice(-2));
    dateFormatted = dateFormatted.replace("yyyy", formatYear(value.getFullYear()));
    return dateFormatted;
  }
  refreshValue(value) {
    if (value) {
      this.inputEl.nativeElement.value = this.formatToDate(value);
    }
  }
  // Função implementada do ControlValueAccessor
  writeValue(value) {
    if (this.inputEl && value) {
      if (value instanceof Date) {
        const dateString = value.toString();
        this.hour = "T" + dateString.substring(16, 24) + dateString.substring(28, 31) + ":" + dateString.substring(31, 33);
        this.date = value;
        this.inputEl.nativeElement.value = this.formatToDate(value);
      } else if (this.isValidDateIso(value) || this.isValidExtendedIso(value)) {
        if (this.isValidExtendedIso(value)) {
          this.hour = value.substring(10, 25);
        }
        if (this.isoFormat === void 0) {
          this.isExtendedISO = this.isValidExtendedIso(value);
        }
        const day = parseInt(value.substring(8, 10), 10);
        const month = parseInt(value.substring(5, 7), 10) - 1;
        const year = parseInt(value.substring(0, 4), 10);
        const dateTemp = new Date(year, month, day);
        setYearFrom0To100(dateTemp, year);
        this.date = dateTemp;
        this.inputEl.nativeElement.value = this.formatToDate(dateTemp);
      } else {
        this.inputEl.nativeElement.value = "";
        this.date = void 0;
      }
      this.controlModel(this.date);
    } else if (this.inputEl) {
      this.inputEl.nativeElement.value = "";
      this.date = void 0;
      this.callOnChange(this.date, false);
    }
    this.valueBeforeChange = this.formatToDate(this.date);
  }
  isValidDateIso(value) {
    return this.dateRegex.test(value);
  }
  isValidExtendedIso(value) {
    return this.isoRegex.test(value);
  }
  hasOverlayClass(element) {
    return element.classList.contains("po-datepicker-calendar-overlay");
  }
  /* istanbul ignore next */
  verifyMobile() {
    return isMobile();
  }
  closeCalendar() {
    this.visible = false;
    this.removeListeners();
    this.setDialogPickerStyleDisplay("none");
  }
  controlChangeEmitter() {
    const dateModelFormatted = this.formatToDate(this.date);
    if (dateModelFormatted !== this.valueBeforeChange) {
      this.valueBeforeChange = dateModelFormatted;
      clearTimeout(this.timeoutChange);
      this.timeoutChange = setTimeout(() => {
        this.onchange.emit(dateModelFormatted);
      }, 200);
    }
  }
  hasAttrCalendar(element) {
    const attrCalendar = "attr-calendar";
    return element && element.hasAttribute(attrCalendar) || element.parentElement && element.parentElement.hasAttribute(attrCalendar);
  }
  initializeListeners() {
    this.clickListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnPicker(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      this.closeCalendar();
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onScroll = () => {
    this.controlPosition.adjustPosition(poCalendarPositionDefault$1);
  };
  removeListeners() {
    if (this.clickListener) {
      this.clickListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setDialogPickerStyleDisplay(value) {
    this.dialogPicker.nativeElement.style.display = value;
  }
  setCalendarPosition() {
    this.setDialogPickerStyleDisplay("block");
    this.controlPosition.setElements(this.dialogPicker.nativeElement, poCalendarContentOffset$1, this.inputEl, ["top-left", "top-right", "bottom-left", "bottom-right"], false, true);
    this.controlPosition.adjustPosition(poCalendarPositionDefault$1);
  }
  static ɵfac = function PoDatepickerComponent_Factory(t) {
    return new (t || _PoDatepickerComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDatepickerComponent, selectors: [["po-datepicker"]], viewQuery: function PoDatepickerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$14, 7);
      ɵɵviewQuery(_c1$s, 7, ElementRef);
      ɵɵviewQuery(_c2$e, 5);
      ɵɵviewQuery(_c3$8, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calendar = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dialogPicker = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconDatepicker = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    }
  }, hostBindings: function PoDatepickerComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keyup", function PoDatepickerComponent_keyup_HostBindingHandler($event) {
        return ctx.onKeyup($event);
      })("keydown", function PoDatepickerComponent_keydown_HostBindingHandler($event) {
        return ctx.onKeydown($event);
      });
    }
  }, inputs: { label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"] }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoDatepickerComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoDatepickerComponent),
      multi: true
    },
    PoControlPositionService
  ]), ɵɵInheritDefinitionFeature], decls: 15, vars: 29, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content", "po-field-container-content-datepicker"], [1, "po-field-container-input"], ["type", "text", 1, "po-input", "po-datepicker", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "blur", "click"], ["inp", ""], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], ["p-icon", "po-icon-calendar", "p-kind", "tertiary", 1, "po-datepicker-button", 3, "p-disabled", "keydown", "p-click"], ["iconDatepicker", ""], ["dialogPicker", ""], ["class", "po-datepicker-calendar-overlay", 4, "ngIf"], [3, "ngModel", "p-max-date", "p-min-date", "p-locale", "ngModelChange", "p-change"], ["calendar", ""], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-icon-input", 3, "p-element-ref", "p-change-event"], [1, "po-datepicker-calendar-overlay"]], template: function PoDatepickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "div", 2)(3, "input", 3, 4);
      ɵɵlistener("blur", function PoDatepickerComponent_Template_input_blur_3_listener($event) {
        return ctx.eventOnBlur($event);
      })("click", function PoDatepickerComponent_Template_input_click_3_listener($event) {
        return ctx.eventOnClick($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵtemplate(6, PoDatepickerComponent_po_clean_6_Template, 1, 1, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "po-button", 7, 8);
      ɵɵlistener("keydown", function PoDatepickerComponent_Template_po_button_keydown_7_listener($event) {
        return ctx.onKeyPress($event);
      })("p-click", function PoDatepickerComponent_Template_po_button_p_click_7_listener() {
        return ctx.togglePicker();
      });
      ɵɵelementEnd()();
      ɵɵelementStart(9, "div", null, 9);
      ɵɵtemplate(11, PoDatepickerComponent_div_11_Template, 1, 0, "div", 10);
      ɵɵelementStart(12, "po-calendar", 11, 12);
      ɵɵtwoWayListener("ngModelChange", function PoDatepickerComponent_Template_po_calendar_ngModelChange_12_listener($event) {
        ɵɵtwoWayBindingSet(ctx.date, $event) || (ctx.date = $event);
        return $event;
      });
      ɵɵlistener("p-change", function PoDatepickerComponent_Template_po_calendar_p_change_12_listener() {
        return ctx.dateSelected();
      });
      ɵɵelementEnd()();
      ɵɵelement(14, "po-field-container-bottom", 13);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(4);
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(3);
      ɵɵclassProp("po-input-icon-right", ctx.clean && _r0.value);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-disabled", ctx.disabled || ctx.readonly);
      ɵɵadvance(2);
      ɵɵclassProp("po-datepicker-popup-calendar", !ctx.verifyMobile());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.verifyMobile());
      ɵɵadvance();
      ɵɵclassProp("po-datepicker-calendar-mobile", ctx.verifyMobile());
      ɵɵtwoWayProperty("ngModel", ctx.date);
      ɵɵproperty("p-max-date", ctx.maxDate)("p-min-date", ctx.minDate)("p-locale", ctx.locale);
      ɵɵadvance(2);
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern());
    }
  }, dependencies: [NgIf, NgControlStatus, NgModel, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoCleanComponent, PoCalendarComponent, PoButtonComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerComponent, [{
    type: Component,
    args: [{ selector: "po-datepicker", providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoDatepickerComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoDatepickerComponent),
        multi: true
      },
      PoControlPositionService
    ], changeDetection: ChangeDetectionStrategy.OnPush, template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content po-field-container-content-datepicker">
    <div class="po-field-container-input">
      <input
        #inp
        class="po-input po-datepicker"
        [class.po-input-icon-right]="clean && inp.value"
        type="text"
        [attr.name]="name"
        [autocomplete]="autocomplete"
        [disabled]="disabled"
        [id]="id"
        [placeholder]="disabled ? '' : placeholder"
        [readonly]="readonly"
        [required]="required"
        (blur)="eventOnBlur($event)"
        (click)="eventOnClick($event)"
      />
      <div class="po-field-icon-container-right">
        <po-clean
          class="po-icon-input"
          *ngIf="clean && !disabled && !readonly"
          [p-element-ref]="inputEl"
          (p-change-event)="clear()"
        >
        </po-clean>
      </div>
    </div>
    <po-button
      #iconDatepicker
      class="po-datepicker-button"
      p-icon="po-icon-calendar"
      p-kind="tertiary"
      [p-disabled]="disabled || readonly"
      (keydown)="onKeyPress($event)"
      (p-click)="togglePicker()"
    >
    </po-button>
  </div>

  <div #dialogPicker [class.po-datepicker-popup-calendar]="!verifyMobile()">
    <div *ngIf="verifyMobile()" class="po-datepicker-calendar-overlay"></div>
    <po-calendar
      [class.po-datepicker-calendar-mobile]="verifyMobile()"
      #calendar
      [(ngModel)]="date"
      [p-max-date]="maxDate"
      [p-min-date]="minDate"
      [p-locale]="locale"
      (p-change)="dateSelected()"
    >
    </po-calendar>
  </div>

  <po-field-container-bottom
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
  ></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: PoLanguageService }, { type: PoControlPositionService }, { type: Renderer2 }, { type: ElementRef }], { calendar: [{
    type: ViewChild,
    args: ["calendar", { static: true }]
  }], dialogPicker: [{
    type: ViewChild,
    args: ["dialogPicker", { read: ElementRef, static: true }]
  }], iconDatepicker: [{
    type: ViewChild,
    args: ["iconDatepicker"]
  }], inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: true }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], onKeyup: [{
    type: HostListener,
    args: ["keyup", ["$event"]]
  }], onKeydown: [{
    type: HostListener,
    args: ["keydown", ["$event"]]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDatepickerComponent, { className: "PoDatepickerComponent", filePath: "lib/components/po-field/po-datepicker/po-datepicker.component.ts", lineNumber: 80 });
})();
var PoDatepickerModule = class _PoDatepickerModule {
  static ɵfac = function PoDatepickerModule_Factory(t) {
    return new (t || _PoDatepickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDatepickerModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCleanModule, PoCalendarModule, PoButtonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCleanModule, PoCalendarModule, PoButtonModule],
      exports: [PoDatepickerComponent],
      declarations: [PoDatepickerComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDatepickerModule, { declarations: [PoDatepickerComponent], imports: [CommonModule, FormsModule, PoFieldContainerModule, PoCleanModule, PoCalendarModule, PoButtonModule], exports: [PoDatepickerComponent] });
})();
var poModalLiterals = {
  en: {
    close: "Close"
  },
  es: {
    close: "Cerrar"
  },
  pt: {
    close: "Fechar"
  },
  ru: {
    close: "Закрыть"
  }
};
var PoModalBaseComponent = class _PoModalBaseComponent {
  /** Título da modal. */
  title;
  /** Evento disparado ao fechar o modal. */
  closeModal = new EventEmitter();
  /**
   * Deve ser definido um objeto que implementa a interface `PoModalAction` contendo a label e a função da primeira ação.
   * Caso esta propriedade não seja definida ou esteja incompleta, automaticamente será adicionado um botão de ação com
   * a função de fechar a modal.
   */
  primaryAction;
  /** Deve ser definido um objeto que implementa a interface `PoModalAction` contendo a label e a função da segunda ação. */
  secondaryAction;
  language;
  literals;
  // Controla se a modal fica oculto ou visível, por padrão é oculto
  isHidden = true;
  // Event emmiter para quando a modal é fechada pelo 'X'.
  onXClosed = new EventEmitter();
  _hideClose = false;
  _size = "md";
  /**
   * Define o tamanho da modal.
   *
   * Valores válidos:
   *  - `sm` (pequeno)
   *  - `md` (médio)
   *  - `lg` (grande)
   *  - `xl` (extra grande)
   *  - `auto` (automático)
   *
   * > Quando informado `auto` a modal calculará automaticamente seu tamanho baseado em seu conteúdo.
   * Caso não seja informado um valor, a modal terá o tamanho definido como `md`.
   *
   * > Todas as opções de tamanho possuem uma largura máxima de **768px**.
   */
  set size(value) {
    const sizes = ["sm", "md", "lg", "xl", "auto"];
    this._size = sizes.indexOf(value) > -1 ? value : "md";
  }
  get size() {
    return this._size;
  }
  /**
   * Define o fechamento da modal ao clicar fora da mesma.
   * Informe o valor `true` para ativar o fechamento ao clicar fora da modal.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  clickOut = false;
  set setClickOut(value) {
    this.clickOut = value === "" ? false : convertToBoolean(value);
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta o ícone de fechar do cabeçalho da modal.
   *
   * > Caso a propriedade estiver habilitada, não será possível fechar a modal através da tecla *ESC*.
   *
   * @default `false`
   */
  set hideClose(value) {
    this._hideClose = convertToBoolean(value);
  }
  get hideClose() {
    return this._hideClose;
  }
  /**
   * @optional
   *
   * @description
   * Ícone exibido ao lado esquerdo do label do titúlo da modal.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-modal p-icon="po-icon-user" p-title="PO Modal"></po-modal>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-modal p-icon="fa fa-podcast" p-title="PO Modal"></po-modal>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-modal [p-icon]="template" p-title="PO Modal"></po-modal>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   */
  icon;
  constructor(poLanguageService) {
    this.language = poLanguageService.getShortLanguage();
    this.literals = __spreadValues({}, poModalLiterals[this.language]);
  }
  /** Função para fechar a modal. */
  close(xClosed = false) {
    this.closeModal.emit();
    this.isHidden = true;
    if (xClosed) {
      this.onXClosed.emit(xClosed);
    }
  }
  /** Função para abrir a modal. */
  open() {
    this.validPrimaryAction();
    this.isHidden = false;
  }
  validPrimaryAction() {
    if (!this.primaryAction) {
      this.primaryAction = {
        action: () => this.close(),
        label: this.literals.close
      };
    }
    if (!this.primaryAction["action"]) {
      this.primaryAction["action"] = () => this.close();
    }
    if (!this.primaryAction["label"]) {
      this.primaryAction["label"] = this.literals.close;
    }
  }
  static ɵfac = function PoModalBaseComponent_Factory(t) {
    return new (t || _PoModalBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoModalBaseComponent, inputs: { title: [InputFlags.None, "p-title", "title"], primaryAction: [InputFlags.None, "p-primary-action", "primaryAction"], secondaryAction: [InputFlags.None, "p-secondary-action", "secondaryAction"], size: [InputFlags.None, "p-size", "size"], setClickOut: [InputFlags.None, "p-click-out", "setClickOut"], hideClose: [InputFlags.None, "p-hide-close", "hideClose"], icon: [InputFlags.None, "p-icon", "icon"] }, outputs: { closeModal: "p-close" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { title: [{
    type: Input,
    args: ["p-title"]
  }], closeModal: [{
    type: Output,
    args: ["p-close"]
  }], primaryAction: [{
    type: Input,
    args: ["p-primary-action"]
  }], secondaryAction: [{
    type: Input,
    args: ["p-secondary-action"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }], setClickOut: [{
    type: Input,
    args: ["p-click-out"]
  }], hideClose: [{
    type: Input,
    args: ["p-hide-close"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }] });
})();
var _c0$13 = ["*"];
var PoModalFooterComponent = class _PoModalFooterComponent {
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o alinhamento padrão, à direita, dos botões de ações que ficam no rodapé da [`PoModal`](/documentation/po-modal).
   *
   * > Caso a propriedade esteja habilitada, o alinhamento deverá ser a esquerda e pode ser personalizado.
   *
   * @default false
   */
  disabledAlign = false;
  static ɵfac = function PoModalFooterComponent_Factory(t) {
    return new (t || _PoModalFooterComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoModalFooterComponent, selectors: [["po-modal-footer"]], inputs: { disabledAlign: [InputFlags.None, "p-disabled-align", "disabledAlign"] }, ngContentSelectors: _c0$13, decls: 2, vars: 2, consts: [[1, "po-modal-footer"]], template: function PoModalFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("po-modal-footer-align-right", !ctx.disabledAlign);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalFooterComponent, [{
    type: Component,
    args: [{ selector: "po-modal-footer", template: '<div class="po-modal-footer" [class.po-modal-footer-align-right]="!disabledAlign">\n  <ng-content></ng-content>\n</div>\n' }]
  }], null, { disabledAlign: [{
    type: Input,
    args: ["p-disabled-align"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoModalFooterComponent, { className: "PoModalFooterComponent", filePath: "lib/components/po-modal/po-modal-footer/po-modal-footer.component.ts", lineNumber: 23 });
})();
var PoActiveOverlayService = class _PoActiveOverlayService {
  activeOverlay = [];
  static ɵfac = function PoActiveOverlayService_Factory(t) {
    return new (t || _PoActiveOverlayService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoActiveOverlayService, factory: _PoActiveOverlayService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoActiveOverlayService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _c0$12 = ["modalContent"];
var _c1$r = ["modalContainer"];
function PoModalComponent_div_0_po_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 16);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r3.icon);
  }
}
function PoModalComponent_div_0_po_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 17);
    ɵɵlistener("p-click", function PoModalComponent_div_0_po_button_12_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r8.close(true));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("p-aria-label", ctx_r4.literals.close);
  }
}
function PoModalComponent_div_0_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1, 1);
    ɵɵelementContainerEnd();
  }
}
function PoModalComponent_div_0_ng_template_16_po_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 21);
    ɵɵlistener("p-click", function PoModalComponent_div_0_ng_template_16_po_button_2_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r11 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r11.secondaryAction.action());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(3);
    ɵɵproperty("p-danger", ctx_r10.getSecondaryActionButtonDanger())("p-disabled", ctx_r10.secondaryAction.disabled)("p-label", ctx_r10.secondaryAction.label)("p-loading", ctx_r10.secondaryAction.loading);
  }
}
function PoModalComponent_div_0_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-modal-footer")(1, "div", 18);
    ɵɵtemplate(2, PoModalComponent_div_0_ng_template_16_po_button_2_Template, 1, 4, "po-button", 19);
    ɵɵelementStart(3, "po-button", 20);
    ɵɵlistener("p-click", function PoModalComponent_div_0_ng_template_16_Template_po_button_p_click_3_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r13 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r13.primaryAction.action());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r6.secondaryAction);
    ɵɵadvance();
    ɵɵproperty("p-danger", ctx_r6.primaryAction.danger)("p-disabled", ctx_r6.primaryAction.disabled)("p-label", ctx_r6.primaryAction.label)("p-loading", ctx_r6.primaryAction.loading);
  }
}
function PoModalComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1, 2);
    ɵɵlistener("keydown.esc", function PoModalComponent_div_0_Template_div_keydown_esc_0_listener($event) {
      ɵɵrestoreView(_r16);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15.closeModalOnEscapeKey($event));
    });
    ɵɵelementStart(2, "div", 3);
    ɵɵlistener("mousedown", function PoModalComponent_div_0_Template_div_mousedown_2_listener($event) {
      ɵɵrestoreView(_r16);
      const ctx_r17 = ɵɵnextContext();
      return ɵɵresetView(ctx_r17.onClickOut($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 4)(4, "div", 5)(5, "div", 6, 7)(7, "div", 8)(8, "div", 9);
    ɵɵtemplate(9, PoModalComponent_div_0_po_icon_9_Template, 1, 1, "po-icon", 10);
    ɵɵelementStart(10, "div", 11);
    ɵɵtext(11);
    ɵɵelementEnd()();
    ɵɵtemplate(12, PoModalComponent_div_0_po_button_12_Template, 1, 1, "po-button", 12);
    ɵɵelementEnd();
    ɵɵelementStart(13, "div", 13);
    ɵɵprojection(14);
    ɵɵelementEnd();
    ɵɵtemplate(15, PoModalComponent_div_0_ng_container_15_Template, 2, 0, "ng-container", 14)(16, PoModalComponent_div_0_ng_template_16_Template, 4, 5, "ng-template", null, 15, ɵɵtemplateRefExtractor);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const _r7 = ɵɵreference(17);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(5);
    ɵɵclassMapInterpolate1("po-modal-content po-modal-", ctx_r0.size, "");
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r0.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.hideClose);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.modalFooter)("ngIfElse", _r7);
  }
}
var _c2$d = ["*", [["po-modal-footer"]]];
var _c3$7 = ["*", "po-modal-footer"];
var PoModalComponent = class _PoModalComponent extends PoModalBaseComponent {
  poActiveOverlayService;
  modalContent;
  modalContainer;
  modalFooter;
  firstElement;
  focusFunction;
  focusableElements = "input, select, textarea, button:not([disabled]), a";
  id = uuid();
  sourceElement;
  constructor(poActiveOverlayService, poLanguageService) {
    super(poLanguageService);
    this.poActiveOverlayService = poActiveOverlayService;
  }
  close(xClosed = false) {
    this.poActiveOverlayService.activeOverlay.pop();
    super.close(xClosed);
    this.removeEventListeners();
    if (this.sourceElement) {
      this.sourceElement.focus();
    }
  }
  closeModalOnEscapeKey(event) {
    if (!this.hideClose) {
      event.preventDefault();
      event.stopPropagation();
      this.close();
    }
  }
  getSecondaryActionButtonDanger() {
    return this.secondaryAction && this.secondaryAction.danger && !this.primaryAction.danger ? "true" : "false";
  }
  onClickOut(event) {
    if (this.clickOut && !this.modalContent.nativeElement.contains(event.target)) {
      this.close();
    }
  }
  open() {
    this.sourceElement = document.activeElement;
    super.open();
    this.handleFocus();
  }
  handleFocus() {
    this.poActiveOverlayService.activeOverlay.push(this.id);
    setTimeout(() => {
      if (this.modalContent) {
        this.initFocus();
        document.addEventListener("focus", this.focusFunction, true);
      }
    });
  }
  initFocus() {
    this.focusFunction = (event) => {
      const modalElement = this.modalContent.nativeElement;
      if (!modalElement.contains(event.target) && this.poActiveOverlayService.activeOverlay[this.poActiveOverlayService.activeOverlay.length - 1] === this.id) {
        event.stopPropagation();
        this.firstElement.focus();
      }
    };
    this.setFirstElement();
    if (this.hideClose) {
      this.firstElement.focus();
    } else {
      const firstFieldElement = this.modalContent.nativeElement.querySelectorAll(this.focusableElements)[1] || this.modalContent.nativeElement;
      firstFieldElement.focus();
    }
  }
  removeEventListeners() {
    document.removeEventListener("focus", this.focusFunction, true);
  }
  setFirstElement() {
    this.firstElement = this.modalContent.nativeElement.querySelector(this.focusableElements) || this.modalContent.nativeElement;
  }
  static ɵfac = function PoModalComponent_Factory(t) {
    return new (t || _PoModalComponent)(ɵɵdirectiveInject(PoActiveOverlayService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoModalComponent, selectors: [["po-modal"]], contentQueries: function PoModalComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoModalFooterComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalFooter = _t.first);
    }
  }, viewQuery: function PoModalComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$12, 5, ElementRef);
      ɵɵviewQuery(_c1$r, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalContent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalContainer = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c3$7, decls: 1, vars: 1, consts: [["class", "po-modal", "tabindex", "0", 3, "keydown.esc", 4, "ngIf"], ["tabindex", "0", 1, "po-modal", 3, "keydown.esc"], ["modalContainer", ""], [1, "po-modal-overlay", 3, "mousedown"], [1, "po-modal-container", "po-pb-2", "po-pt-2"], [1, "po-modal-vertical-align"], ["tabindex", "-1"], ["modalContent", ""], [1, "po-modal-header"], [1, "po-modal-title", "po-text-ellipsis"], [3, "p-icon", 4, "ngIf"], [1, "po-text-ellipsis"], ["p-icon", "po-icon po-icon-close", "p-kind", "tertiary", 3, "p-aria-label", "p-click", 4, "ngIf"], [1, "po-modal-body"], [4, "ngIf", "ngIfElse"], ["defaultModalFooterTemplate", ""], [3, "p-icon"], ["p-icon", "po-icon po-icon-close", "p-kind", "tertiary", 3, "p-aria-label", "p-click"], [1, "po-modal-footer-basic"], ["p-kind", "secondary", 3, "p-danger", "p-disabled", "p-label", "p-loading", "p-click", 4, "ngIf"], ["p-kind", "primary", 1, "po-button-modal-first-action", 3, "p-danger", "p-disabled", "p-label", "p-loading", "p-click"], ["p-kind", "secondary", 3, "p-danger", "p-disabled", "p-label", "p-loading", "p-click"]], template: function PoModalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c2$d);
      ɵɵtemplate(0, PoModalComponent_div_0_Template, 18, 8, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.isHidden);
    }
  }, dependencies: [NgIf, PoButtonComponent, PoIconComponent, PoModalFooterComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalComponent, [{
    type: Component,
    args: [{ selector: "po-modal", template: '<div #modalContainer *ngIf="!isHidden" class="po-modal" tabindex="0" (keydown.esc)="closeModalOnEscapeKey($event)">\n  <div class="po-modal-overlay" (mousedown)="onClickOut($event)"></div>\n  <div class="po-modal-container po-pb-2 po-pt-2">\n    <div class="po-modal-vertical-align">\n      <div #modalContent class="po-modal-content po-modal-{{ size }}" tabindex="-1">\n        <div class="po-modal-header">\n          <div class="po-modal-title po-text-ellipsis">\n            <po-icon *ngIf="icon" [p-icon]="icon"></po-icon>\n            <div class="po-text-ellipsis">\n              {{ title }}\n            </div>\n          </div>\n          <po-button\n            *ngIf="!hideClose"\n            [p-aria-label]="literals.close"\n            p-icon="po-icon po-icon-close"\n            (p-click)="close(true)"\n            p-kind="tertiary"\n          >\n          </po-button>\n        </div>\n\n        <div class="po-modal-body">\n          <ng-content></ng-content>\n        </div>\n\n        <ng-container *ngIf="modalFooter; else defaultModalFooterTemplate">\n          <ng-content select="po-modal-footer"></ng-content>\n        </ng-container>\n\n        <ng-template #defaultModalFooterTemplate>\n          <po-modal-footer>\n            <div class="po-modal-footer-basic">\n              <po-button\n                *ngIf="secondaryAction"\n                [p-danger]="getSecondaryActionButtonDanger()"\n                [p-disabled]="secondaryAction.disabled"\n                [p-label]="secondaryAction.label"\n                [p-loading]="secondaryAction.loading"\n                p-kind="secondary"\n                (p-click)="secondaryAction.action()"\n              >\n              </po-button>\n\n              <po-button\n                class="po-button-modal-first-action"\n                [p-danger]="primaryAction.danger"\n                [p-disabled]="primaryAction.disabled"\n                [p-label]="primaryAction.label"\n                [p-loading]="primaryAction.loading"\n                p-kind="primary"\n                (p-click)="primaryAction.action()"\n              >\n              </po-button>\n            </div>\n          </po-modal-footer>\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n' }]
  }], () => [{ type: PoActiveOverlayService }, { type: PoLanguageService }], { modalContent: [{
    type: ViewChild,
    args: ["modalContent", { read: ElementRef }]
  }], modalContainer: [{
    type: ViewChild,
    args: ["modalContainer", { read: ElementRef }]
  }], modalFooter: [{
    type: ContentChild,
    args: [PoModalFooterComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoModalComponent, { className: "PoModalComponent", filePath: "lib/components/po-modal/po-modal.component.ts", lineNumber: 35 });
})();
var PoModalModule = class _PoModalModule {
  static ɵfac = function PoModalModule_Factory(t) {
    return new (t || _PoModalModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoModalModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoButtonModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoButtonModule, PoIconModule],
      declarations: [PoModalComponent, PoModalFooterComponent],
      exports: [PoModalComponent, PoModalFooterComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoModalModule, { declarations: [PoModalComponent, PoModalFooterComponent], imports: [CommonModule, PoButtonModule, PoIconModule], exports: [PoModalComponent, PoModalFooterComponent] });
})();
function PoProgressBarComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "div", 3)(2, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-valuenow", ctx_r0.value);
    ɵɵadvance(2);
    ɵɵstyleProp("left", "-" + (100 - ctx_r0.value) + "%");
  }
}
function PoProgressBarComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵelement(1, "div", 6);
    ɵɵelementEnd();
  }
}
var PoProgressBarComponent = class _PoProgressBarComponent {
  indeterminate;
  value;
  get valueScale() {
    return `${this.value / 100}`;
  }
  static ɵfac = function PoProgressBarComponent_Factory(t) {
    return new (t || _PoProgressBarComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoProgressBarComponent, selectors: [["po-progress-bar"]], inputs: { indeterminate: [InputFlags.None, "p-indeterminate", "indeterminate"], value: [InputFlags.None, "p-value", "value"] }, decls: 2, vars: 2, consts: [["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", "aria-live", "polite", "class", "po-progress-bar-default", 4, "ngIf"], ["class", "po-progress-bar-indeterminate-track", 4, "ngIf"], ["role", "progressbar", "aria-valuemin", "0", "aria-valuemax", "100", "aria-live", "polite", 1, "po-progress-bar-default"], [1, "po-progress-bar-element", "po-progress-bar-primary"], [1, "po-progress-bar-element", "po-progress-bar-secondary"], [1, "po-progress-bar-indeterminate-track"], [1, "po-progress-bar-indeterminate-track-bar"]], template: function PoProgressBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoProgressBarComponent_div_0_Template, 3, 3, "div", 0)(1, PoProgressBarComponent_div_1_Template, 2, 0, "div", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.indeterminate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.indeterminate);
    }
  }, dependencies: [NgIf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressBarComponent, [{
    type: Component,
    args: [{ selector: "po-progress-bar", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div
  *ngIf="!indeterminate"
  role="progressbar"
  [attr.aria-valuenow]="value"
  aria-valuemin="0"
  aria-valuemax="100"
  aria-live="polite"
  class="po-progress-bar-default"
>
  <div class="po-progress-bar-element po-progress-bar-primary"></div>
  <div class="po-progress-bar-element po-progress-bar-secondary" [style.left]="'-' + (100 - value) + '%'"></div>
</div>

<div *ngIf="indeterminate" class="po-progress-bar-indeterminate-track">
  <div class="po-progress-bar-indeterminate-track-bar"></div>
</div>
` }]
  }], null, { indeterminate: [{
    type: Input,
    args: ["p-indeterminate"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoProgressBarComponent, { className: "PoProgressBarComponent", filePath: "lib/components/po-progress/po-progress-bar/po-progress-bar.component.ts", lineNumber: 8 });
})();
var PoProgressStatus;
(function(PoProgressStatus2) {
  PoProgressStatus2["Default"] = "default";
  PoProgressStatus2["Error"] = "error";
  PoProgressStatus2["Success"] = "success";
})(PoProgressStatus || (PoProgressStatus = {}));
var PoProgressSize;
(function(PoProgressSize2) {
  PoProgressSize2["medium"] = "medium";
  PoProgressSize2["large"] = "large";
})(PoProgressSize || (PoProgressSize = {}));
var poProgressMaxValue = 100;
var poProgressMinValue = 0;
var PoProgressBaseComponent = class _PoProgressBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Informação adicional que aparecerá abaixo da barra de progresso ao lado direito.
   */
  info;
  /**
   * @optional
   *
   * @description
   *
   * Ícone que aparecerá ao lado do texto da propriedade `p-info`.
   *
   * Exemplo: `po-icon-ok`.
   */
  infoIcon;
  /**
   * @optional
   *
   * @description
   *
   * Status da barra de progresso que indicará visualmente ao usuário
   * o andamento, por exemplo, se a mesma foi concluída com sucesso.
   *
   * @default `PoProgressStatus.Default`
   */
  status = PoProgressStatus.Default;
  /**
   * @optional
   *
   * @description
   *
   * Texto principal que aparecerá abaixo da barra de progresso no lado esquerdo.
   */
  text;
  /**
   * @optional
   *
   * @description
   *
   * Evento que será disparado ao clicar no ícone de cancelamento ("x") na parte inferior da barra de progresso.
   *
   * Ao ser disparado, a função receberá como parâmetro o status atual da barra de progresso.
   *
   * > Se nenhuma função for passada para o evento ou a barra de progresso estiver com o status `PoProgressStatus.Success`,
   * o ícone de cancelamento não será exibido.
   */
  cancel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento que será disparado ao clicar no ícone de tentar novamente na parte inferior da barra de progresso.
   *
   * > o ícone será exibido apenas se informar uma função neste evento e o status da barra de progresso for
   * `PoProgressStatus.Error`.
   */
  retry = new EventEmitter();
  _indeterminate;
  _value = 0;
  _size = "large";
  /**
   * @optional
   *
   * @description
   *
   * Habilita o modo indeterminado na barra de progresso, que mostra uma animação fixa sem um valor estabelecido.
   *
   * Esta opção pode ser utilizada quando não souber quanto tempo levará para que um processo seja concluído.
   *
   * > Caso esta propriedade e a `p-value` seja habilitada, a propriedade `p-value` será ignorada.
   *
   * @default `false`
   */
  set indeterminate(indeterminate) {
    this._indeterminate = convertToBoolean(indeterminate);
  }
  get indeterminate() {
    return this._indeterminate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor que representará o progresso.
   *
   * > Os valores aceitos são números inteiros de `0` à `100`.
   *
   * @default `0`
   */
  set value(value) {
    const integerValue = convertToInt(value, poProgressMinValue);
    const isProgressRangeValue = this.isProgressRangeValue(integerValue);
    this._value = isProgressRangeValue ? integerValue : poProgressMinValue;
  }
  get value() {
    return this._value;
  }
  /**
   * @optional
   *
   * @description
   *
   * Definição do tamanho da altura da barra de progresso.
   *
   * Valores válidos:
   *  - `medium`: tamanho médio
   *  - `large`: tamanho grande
   *
   * @default `large`
   */
  set size(value) {
    this._size = PoProgressSize[value] ? PoProgressSize[value] : PoProgressSize.large;
  }
  get size() {
    return this._size;
  }
  /**
   * @optional
   *
   * @description
   *
   * Ativa a exibição da porcentagem atual da barra de progresso.
   *
   * @default `false`
   */
  showPercentage = false;
  isProgressRangeValue(value) {
    return value >= poProgressMinValue && value <= poProgressMaxValue;
  }
  static ɵfac = function PoProgressBaseComponent_Factory(t) {
    return new (t || _PoProgressBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoProgressBaseComponent, inputs: { info: [InputFlags.None, "p-info", "info"], infoIcon: [InputFlags.None, "p-info-icon", "infoIcon"], status: [InputFlags.None, "p-status", "status"], text: [InputFlags.None, "p-text", "text"], indeterminate: [InputFlags.None, "p-indeterminate", "indeterminate"], value: [InputFlags.None, "p-value", "value"], size: [InputFlags.None, "p-size", "size"], showPercentage: [InputFlags.HasDecoratorInputTransform, "p-show-percentage", "showPercentage", convertToBoolean] }, outputs: { cancel: "p-cancel", retry: "p-retry" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressBaseComponent, [{
    type: Directive
  }], null, { info: [{
    type: Input,
    args: ["p-info"]
  }], infoIcon: [{
    type: Input,
    args: ["p-info-icon"]
  }], status: [{
    type: Input,
    args: ["p-status"]
  }], text: [{
    type: Input,
    args: ["p-text"]
  }], cancel: [{
    type: Output,
    args: ["p-cancel"]
  }], retry: [{
    type: Output,
    args: ["p-retry"]
  }], indeterminate: [{
    type: Input,
    args: ["p-indeterminate"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }], showPercentage: [{
    type: Input,
    args: [{ alias: "p-show-percentage", transform: convertToBoolean }]
  }] });
})();
var poProgressLiterals = {
  en: {
    cancel: "Cancel",
    retry: "Retry"
  },
  es: {
    cancel: "Cancelar",
    retry: "Procesar de nuevo"
  },
  pt: {
    cancel: "Cancelar",
    retry: "Tentar Novamente"
  },
  ru: {
    cancel: "Отмена",
    retry: "Повторить попытку"
  }
};
function PoProgressComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵelement(1, "po-label", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-label", ctx_r0.text);
  }
}
function PoProgressComponent_po_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 14);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-progress-info-icon-error", ctx_r1.status === "error");
    ɵɵproperty("p-icon", ctx_r1.infoIcon);
  }
}
function PoProgressComponent_po_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 15);
  }
}
function PoProgressComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("po-progress-info-text-error", ctx_r3.status === "error");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.info);
  }
}
function PoProgressComponent_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r4.value, "%");
  }
}
function PoProgressComponent_po_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 17);
    ɵɵlistener("p-click", function PoProgressComponent_po_button_10_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.emitRetry());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("p-aria-label", ctx_r5.literals.retry);
  }
}
function PoProgressComponent_po_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 18);
    ɵɵlistener("p-click", function PoProgressComponent_po_button_11_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.emitCancellation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("p-aria-label", ctx_r6.literals.cancel)("p-danger", true);
  }
}
var PoProgressComponent = class _PoProgressComponent extends PoProgressBaseComponent {
  language;
  literals;
  get isAllowCancel() {
    return !!this.cancel.observers.length && this.status !== PoProgressStatus.Success;
  }
  get isAllowInfoError() {
    return !!(!this.infoIcon && this.info && this.status === PoProgressStatus.Error);
  }
  get isAllowRetry() {
    return !!this.retry.observers.length && this.status === PoProgressStatus.Error;
  }
  get statusClass() {
    if (this.status === PoProgressStatus.Success) {
      return "po-progress-success";
    }
    if (this.status === PoProgressStatus.Error) {
      return "po-progress-error";
    }
    return "po-progress-default";
  }
  poLanguageService = inject(PoLanguageService);
  ngOnInit() {
    this.language = this.poLanguageService.getShortLanguage();
    this.literals = __spreadValues({}, poProgressLiterals[this.language]);
  }
  emitCancellation() {
    this.cancel.emit(this.status);
  }
  emitRetry() {
    this.retry.emit();
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoProgressComponent_BaseFactory;
    return function PoProgressComponent_Factory(t) {
      return (ɵPoProgressComponent_BaseFactory || (ɵPoProgressComponent_BaseFactory = ɵɵgetInheritedFactory(_PoProgressComponent)))(t || _PoProgressComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoProgressComponent, selectors: [["po-progress"]], features: [ɵɵInheritDefinitionFeature], decls: 12, vars: 13, consts: [[1, "po-progress", 3, "ngClass"], ["class", "po-progress-description", 4, "ngIf"], [3, "p-indeterminate", "p-value"], [1, "po-progress-info"], [1, "po-progress-info-left"], [3, "p-icon", "po-progress-info-icon-error", 4, "ngIf"], ["p-icon", "po-icon-exclamation", "class", "po-progress-info-icon-error", 4, "ngIf"], ["class", "po-progress-info-text", 3, "po-progress-info-text-error", 4, "ngIf"], [1, "po-progress-info-right"], [4, "ngIf"], ["p-icon", "po-icon-refresh", "p-kind", "tertiary", 3, "p-aria-label", "p-click", 4, "ngIf"], ["p-icon", "po-icon-close", "p-kind", "secondary", 3, "p-aria-label", "p-danger", "p-click", 4, "ngIf"], [1, "po-progress-description"], [3, "p-label"], [3, "p-icon"], ["p-icon", "po-icon-exclamation", 1, "po-progress-info-icon-error"], [1, "po-progress-info-text"], ["p-icon", "po-icon-refresh", "p-kind", "tertiary", 3, "p-aria-label", "p-click"], ["p-icon", "po-icon-close", "p-kind", "secondary", 3, "p-aria-label", "p-danger", "p-click"]], template: function PoProgressComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoProgressComponent_div_1_Template, 2, 1, "div", 1);
      ɵɵelement(2, "po-progress-bar", 2);
      ɵɵelementStart(3, "div", 3)(4, "div", 4);
      ɵɵtemplate(5, PoProgressComponent_po_icon_5_Template, 1, 3, "po-icon", 5)(6, PoProgressComponent_po_icon_6_Template, 1, 0, "po-icon", 6)(7, PoProgressComponent_span_7_Template, 2, 3, "span", 7);
      ɵɵelementEnd();
      ɵɵelementStart(8, "div", 8);
      ɵɵtemplate(9, PoProgressComponent_span_9_Template, 2, 1, "span", 9)(10, PoProgressComponent_po_button_10_Template, 1, 1, "po-button", 10)(11, PoProgressComponent_po_button_11_Template, 1, 2, "po-button", 11);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ctx.statusClass);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.text);
      ɵɵadvance();
      ɵɵclassMapInterpolate1("po-progress-bar po-progress-bar-", ctx.size, "");
      ɵɵproperty("p-indeterminate", ctx.indeterminate)("p-value", ctx.value);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.infoIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isAllowInfoError);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.info);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showPercentage && !ctx.indeterminate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isAllowRetry);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isAllowCancel);
    }
  }, dependencies: [NgClass, NgIf, PoButtonComponent, PoIconComponent, PoLabelComponent, PoProgressBarComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressComponent, [{
    type: Component,
    args: [{ selector: "po-progress", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div class="po-progress" [ngClass]="statusClass">
  <div *ngIf="text" class="po-progress-description">
    <po-label [p-label]="text"></po-label>
  </div>

  <po-progress-bar
    class="po-progress-bar po-progress-bar-{{ size }}"
    [p-indeterminate]="indeterminate"
    [p-value]="value"
  >
  </po-progress-bar>

  <div class="po-progress-info">
    <div class="po-progress-info-left">
      <po-icon *ngIf="infoIcon" [p-icon]="infoIcon" [class.po-progress-info-icon-error]="status === 'error'"></po-icon>
      <po-icon *ngIf="isAllowInfoError" p-icon="po-icon-exclamation" class="po-progress-info-icon-error"></po-icon>
      <span *ngIf="info" class="po-progress-info-text" [class.po-progress-info-text-error]="status === 'error'">{{
        info
      }}</span>
    </div>
    <div class="po-progress-info-right">
      <span *ngIf="showPercentage && !indeterminate">{{ value }}%</span>
      <po-button
        *ngIf="isAllowRetry"
        p-icon="po-icon-refresh"
        (p-click)="emitRetry()"
        [p-aria-label]="literals.retry"
        p-kind="tertiary"
      ></po-button>

      <po-button
        *ngIf="isAllowCancel"
        p-icon="po-icon-close"
        (p-click)="emitCancellation()"
        p-kind="secondary"
        [p-aria-label]="literals.cancel"
        [p-danger]="true"
      ></po-button>
    </div>
  </div>
</div>
` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoProgressComponent, { className: "PoProgressComponent", filePath: "lib/components/po-progress/po-progress.component.ts", lineNumber: 32 });
})();
var PoProgressModule = class _PoProgressModule {
  static ɵfac = function PoProgressModule_Factory(t) {
    return new (t || _PoProgressModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoProgressModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoButtonModule, PoIconModule, PoLabelModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoProgressModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoButtonModule, PoIconModule, PoLabelModule],
      exports: [PoProgressComponent],
      declarations: [PoProgressBarComponent, PoProgressComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoProgressModule, { declarations: [PoProgressBarComponent, PoProgressComponent], imports: [CommonModule, PoButtonModule, PoIconModule, PoLabelModule], exports: [PoProgressComponent] });
})();
var PoActiveOverlayModule = class _PoActiveOverlayModule {
  static ɵfac = function PoActiveOverlayModule_Factory(t) {
    return new (t || _PoActiveOverlayModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoActiveOverlayModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoActiveOverlayService] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoActiveOverlayModule, [{
    type: NgModule,
    args: [{
      providers: [PoActiveOverlayService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoColorPaletteService = class _PoColorPaletteService {
  getColor(value) {
    return Object.values(PoColorPaletteEnum).includes(value.color) ? value.color : this.getColorFromType(value.type || value.color);
  }
  getColorFromType(type) {
    switch (type) {
      case "danger":
        return PoColorPaletteEnum.Color07;
      case "success":
        return PoColorPaletteEnum.Color11;
      case "warning":
        return PoColorPaletteEnum.Color08;
      default:
        return PoColorPaletteEnum.Color01;
    }
  }
  static ɵfac = function PoColorPaletteService_Factory(t) {
    return new (t || _PoColorPaletteService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoColorPaletteService, factory: _PoColorPaletteService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoColorPaletteService, [{
    type: Injectable
  }], null, null);
})();
var PoColorPaletteModule = class _PoColorPaletteModule {
  static ɵfac = function PoColorPaletteModule_Factory(t) {
    return new (t || _PoColorPaletteModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoColorPaletteModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoColorPaletteService] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoColorPaletteModule, [{
    type: NgModule,
    args: [{
      providers: [PoColorPaletteService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoComponentInjectorService = class _PoComponentInjectorService {
  componentResolver;
  applicationRef;
  injector;
  constructor(componentResolver, applicationRef, injector) {
    this.componentResolver = componentResolver;
    this.applicationRef = applicationRef;
    this.injector = injector;
  }
  // Cria um dinamicamente no ApplicationRef
  createComponentInApplication(component) {
    const componentRef = this.componentResolver.resolveComponentFactory(component).create(this.injector);
    this.applicationRef.attachView(componentRef.hostView);
    const domElem = componentRef.hostView.rootNodes[0];
    document.body.appendChild(domElem);
    return componentRef;
  }
  // Destrói o componente e remove do ApplicationRef
  destroyComponentInApplication(componentRef) {
    this.applicationRef.detachView(componentRef.hostView);
    componentRef.destroy();
  }
  static ɵfac = function PoComponentInjectorService_Factory(t) {
    return new (t || _PoComponentInjectorService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(ApplicationRef), ɵɵinject(Injector));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoComponentInjectorService, factory: _PoComponentInjectorService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComponentInjectorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{ type: ComponentFactoryResolver$1 }, { type: ApplicationRef }, { type: Injector }], null);
})();
var PoComponentInjectorModule = class _PoComponentInjectorModule {
  static ɵfac = function PoComponentInjectorModule_Factory(t) {
    return new (t || _PoComponentInjectorModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoComponentInjectorModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoComponentInjectorService] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComponentInjectorModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [],
      exports: [],
      providers: [PoComponentInjectorService],
      bootstrap: []
    }]
  }], null, null);
})();
var PoControlPositionModule = class _PoControlPositionModule {
  static ɵfac = function PoControlPositionModule_Factory(t) {
    return new (t || _PoControlPositionModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoControlPositionModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoControlPositionService] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoControlPositionModule, [{
    type: NgModule,
    args: [{
      providers: [PoControlPositionService]
    }]
  }], null, null);
})();
var PoDialogType;
(function(PoDialogType2) {
  PoDialogType2[PoDialogType2["Alert"] = 0] = "Alert";
  PoDialogType2[PoDialogType2["Confirm"] = 1] = "Confirm";
})(PoDialogType || (PoDialogType = {}));
var poDialogAlertLiteralsDefault = {
  en: { ok: "Ok" },
  es: { ok: "Ok" },
  pt: { ok: "Ok" },
  ru: { ok: "Ок" }
};
var poDialogConfirmLiteralsDefault = {
  en: { cancel: "Cancel", confirm: "Confirm" },
  es: { cancel: "Cancelar", confirm: "Confirmar" },
  pt: { cancel: "Cancelar", confirm: "Confirmar" },
  ru: { cancel: "отменить", confirm: "подтвердить" }
};
var PoDialogComponent = class _PoDialogComponent {
  // ViewChild para o uso do po-modal.component
  poModal;
  // Title do poModal
  title;
  // Message do poModal
  message;
  // Objeto primary do poModal
  primaryAction = { label: "ok", action: () => {
  } };
  // Objeto secondary do poModal
  secondaryAction;
  // Callback executado ao fechar o poModal
  closeAction;
  // Literais usadas nos botão de alerta do poModal
  literalsAlert;
  // Literais usadas nos botões de confirmação do poModal
  literalsConfirm;
  // Atributo para armazenar a referencia do componente criado via serviço.
  componentRef;
  closeSubscription;
  language;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  ngOnDestroy() {
    this.closeSubscription.unsubscribe();
  }
  ngOnInit() {
    this.closeSubscription = this.poModal.onXClosed.subscribe((close) => this.close(true));
  }
  // Fecha o poModal
  close(xClosed = false) {
    if (xClosed && this.closeAction) {
      this.closeAction();
    }
    this.poModal.close();
    this.destroy();
  }
  destroy() {
    if (this.componentRef) {
      this.componentRef.destroy();
    }
  }
  // Insere os valores recebidos de this.open para o poModal
  configDialog(primaryLabel, primaryAction, secondaryLabel, secondaryAction, closeAction) {
    this.primaryAction = {
      label: primaryLabel,
      action: () => {
        if (primaryAction) {
          primaryAction();
        }
        this.close();
      }
    };
    if (secondaryLabel) {
      this.secondaryAction = {
        label: secondaryLabel,
        action: () => {
          if (secondaryAction) {
            secondaryAction();
          }
          this.close();
        }
      };
    }
    this.closeAction = closeAction;
  }
  // Insere os valores recebidos de po-dialog.service de acordo com o tipo de diálago solicitado
  open(dialogOptions, dialogType, componentRef) {
    this.title = dialogOptions.title;
    this.message = dialogOptions.message;
    this.componentRef = componentRef;
    this.setDialogLiterals(dialogOptions, dialogType);
    switch (dialogType) {
      case PoDialogType.Confirm: {
        this.configDialog(this.literalsConfirm.confirm, dialogOptions.confirm, this.literalsConfirm.cancel, dialogOptions.cancel, dialogOptions.close);
        break;
      }
      case PoDialogType.Alert: {
        this.configDialog(this.literalsAlert.ok, dialogOptions.ok);
        break;
      }
    }
    this.poModal.open();
  }
  setDialogLiterals(dialogOptions, dialogType) {
    const alertLiterals = poDialogAlertLiteralsDefault;
    const confirmLiterals = poDialogConfirmLiteralsDefault;
    const literals = dialogOptions.literals;
    if (dialogType === PoDialogType.Alert) {
      this.literalsAlert = __spreadValues(__spreadValues(__spreadValues({}, alertLiterals[poLocaleDefault]), alertLiterals[this.language]), literals);
    } else {
      this.literalsConfirm = __spreadValues(__spreadValues(__spreadValues({}, confirmLiterals[poLocaleDefault]), confirmLiterals[this.language]), literals);
    }
  }
  static ɵfac = function PoDialogComponent_Factory(t) {
    return new (t || _PoDialogComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDialogComponent, selectors: [["ng-component"]], viewQuery: function PoDialogComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoModalComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poModal = _t.first);
    }
  }, decls: 2, vars: 4, consts: [[3, "p-title", "p-primary-action", "p-secondary-action"], [3, "innerHtml"]], template: function PoDialogComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-modal", 0);
      ɵɵelement(1, "div", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-title", ctx.title)("p-primary-action", ctx.primaryAction)("p-secondary-action", ctx.secondaryAction);
      ɵɵadvance();
      ɵɵproperty("innerHtml", ctx.message, ɵɵsanitizeHtml);
    }
  }, dependencies: [PoModalComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDialogComponent, [{
    type: Component,
    args: [{ template: '<po-modal [p-title]="title" [p-primary-action]="primaryAction" [p-secondary-action]="secondaryAction">\n  <div [innerHtml]="message"></div>\n</po-modal>\n' }]
  }], () => [{ type: PoLanguageService }], { poModal: [{
    type: ViewChild,
    args: [PoModalComponent, { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDialogComponent, { className: "PoDialogComponent", filePath: "lib/services/po-dialog/po-dialog.component.ts", lineNumber: 41 });
})();
var PoDialogBaseService = class {
  /** Exibe um diálogo de confirmação, é possível definir ações para as opções de confirmação e cancelamento. */
  confirm(confirmOptions) {
    this.openDialog(PoDialogType.Confirm, confirmOptions);
  }
  /** Exibe um diálogo de alerta. */
  alert(alertOptions) {
    this.openDialog(PoDialogType.Alert, alertOptions);
  }
};
var PoDialogService = class _PoDialogService extends PoDialogBaseService {
  poComponentInjector;
  constructor(poComponentInjector) {
    super();
    this.poComponentInjector = poComponentInjector;
  }
  openDialog(dialogType, dialogOptions) {
    const componentRef = this.poComponentInjector.createComponentInApplication(PoDialogComponent);
    componentRef.changeDetectorRef.detectChanges();
    componentRef.instance.open(dialogOptions, dialogType, componentRef);
  }
  static ɵfac = function PoDialogService_Factory(t) {
    return new (t || _PoDialogService)(ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoDialogService, factory: _PoDialogService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDialogService, [{
    type: Injectable
  }], () => [{ type: PoComponentInjectorService }], null);
})();
var PoDialogModule = class _PoDialogModule {
  static ɵfac = function PoDialogModule_Factory(t) {
    return new (t || _PoDialogModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDialogModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoDialogService], imports: [PoModalModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDialogModule, [{
    type: NgModule,
    args: [{
      declarations: [PoDialogComponent],
      imports: [PoModalModule],
      exports: [PoDialogComponent],
      providers: [PoDialogService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDialogModule, { declarations: [PoDialogComponent], imports: [PoModalModule], exports: [PoDialogComponent] });
})();
var PoI18nBasePipe = class {
  transform(value, args) {
    if (!value) {
      return "";
    }
    if (!(args instanceof Array)) {
      args = [args];
    }
    for (const arg of args) {
      value = value.replace(/(\{\w*\})+/, arg);
    }
    return value;
  }
};
var PoI18nPipe = class _PoI18nPipe extends PoI18nBasePipe {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoI18nPipe_BaseFactory;
    return function PoI18nPipe_Factory(t) {
      return (ɵPoI18nPipe_BaseFactory || (ɵPoI18nPipe_BaseFactory = ɵɵgetInheritedFactory(_PoI18nPipe)))(t || _PoI18nPipe);
    };
  })();
  static ɵpipe = ɵɵdefinePipe({ name: "poI18n", type: _PoI18nPipe, pure: true });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nPipe, [{
    type: Pipe,
    args: [{
      name: "poI18n"
    }]
  }], null, null);
})();
var poToasterLiterals = {
  en: {
    close: "Close"
  },
  es: {
    close: "Cerrar"
  },
  pt: {
    close: "Fechar"
  },
  ru: {
    close: "близко"
  }
};
var PoToasterOrientation;
(function(PoToasterOrientation2) {
  PoToasterOrientation2[PoToasterOrientation2["Bottom"] = 0] = "Bottom";
  PoToasterOrientation2[PoToasterOrientation2["Top"] = 1] = "Top";
})(PoToasterOrientation || (PoToasterOrientation = {}));
var PoToasterBaseComponent = class {
  /** Disponibiliza uma ação para a notificação. */
  action;
  /** Permite alterar o label do botão quando houver uma ação definida. */
  actionLabel;
  /** Mensagem a ser exibida na notificação. */
  message;
  /** Orientação da notificação, a mesma pode ser exibida na parte superior ou inferior da página. */
  orientation = PoToasterOrientation.Bottom;
  /** ComponentRef */
  componentRef;
  /** Posição para notificação aparecer na tela. */
  position;
  /** Tipo de notificação. */
  type;
};
var PoToasterType;
(function(PoToasterType2) {
  PoToasterType2[PoToasterType2["Error"] = 0] = "Error";
  PoToasterType2[PoToasterType2["Information"] = 1] = "Information";
  PoToasterType2[PoToasterType2["Success"] = 2] = "Success";
  PoToasterType2[PoToasterType2["Warning"] = 3] = "Warning";
})(PoToasterType || (PoToasterType = {}));
var _c0$11 = ["toaster"];
var _c1$q = ["buttonClose"];
function PoToasterComponent_po_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 11);
    ɵɵlistener("p-click", function PoToasterComponent_po_button_8_Template_po_button_p_click_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.poToasterAction($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r1.actionLabel);
  }
}
var SPACE_BETWEEN_TOASTERS = 8;
var PoToasterComponent = class _PoToasterComponent extends PoToasterBaseComponent {
  changeDetector;
  renderer;
  /* Componente toaster */
  toaster;
  buttonClose;
  alive = true;
  language;
  literals;
  /* Ícone do Toaster */
  icon;
  /* Margem do Toaster referênte à sua orientação e posição*/
  margin = 0;
  /* Observable para monitorar o Close to Toaster */
  observableOnClose = new Subject();
  /* Posição do Toaster*/
  toasterPosition = "po-toaster-bottom";
  /* Tipo do Toaster */
  toasterType;
  constructor(poLanguageService, changeDetector, renderer) {
    super();
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.language = poLanguageService.getShortLanguage();
    this.literals = __spreadValues({}, poToasterLiterals[this.language]);
  }
  ngOnDestroy() {
    this.alive = false;
  }
  ngAfterViewInit() {
    setTimeout(() => this.renderer.addClass(this.toaster.nativeElement, "po-toaster-visible"));
  }
  /* Muda a posição do Toaster na tela*/
  changePosition(position) {
    setTimeout(() => {
      this.margin = SPACE_BETWEEN_TOASTERS;
      for (let i = 0; i < position; i++) {
        this.margin += this.returnHeightToaster(i) + SPACE_BETWEEN_TOASTERS;
      }
      if (this.orientation === PoToasterOrientation.Top) {
        this.toaster.nativeElement.style.top = this.margin + "px";
      } else {
        this.toaster.nativeElement.style.bottom = this.margin + "px";
      }
    });
  }
  /* Fecha o componente Toaster */
  close() {
    this.observableOnClose.next(true);
  }
  setFadeOut() {
    this.renderer.removeClass(this.toaster.nativeElement, "po-toaster-visible");
    this.renderer.addClass(this.toaster.nativeElement, "po-toaster-invisible");
  }
  /* Configura o Toaster com os atributos passados para ele */
  configToaster(poToaster) {
    this.type = poToaster.type;
    this.message = poToaster.message;
    this.orientation = poToaster.orientation;
    this.position = poToaster.position;
    this.action = poToaster.action;
    this.actionLabel = poToaster.actionLabel;
    this.componentRef = poToaster.componentRef;
    if (this.orientation === PoToasterOrientation.Top) {
      this.toasterPosition = "po-toaster-top";
    }
    this.changePosition(this.position);
    if (this.type === PoToasterType.Error) {
      this.toaster.nativeElement.setAttribute("role", "alert");
    } else if (this.action && this.actionLabel) {
      this.toaster.nativeElement.setAttribute("role", "alertdialog");
    } else {
      this.toaster.nativeElement.setAttribute("role", "status");
    }
    switch (this.type) {
      case PoToasterType.Error: {
        this.toasterType = "po-toaster-error";
        this.icon = "po-icon-warning";
        break;
      }
      case PoToasterType.Information: {
        this.toasterType = "po-toaster-info";
        this.icon = "po-icon-info";
        break;
      }
      case PoToasterType.Success: {
        this.toasterType = "po-toaster-success";
        this.icon = "po-icon-ok";
        break;
      }
      case PoToasterType.Warning: {
        this.toasterType = "po-toaster-warning";
        this.icon = "po-icon-warning";
        break;
      }
    }
    this.buttonClose.buttonElement.nativeElement.setAttribute("aria-label", this.literals.close);
    this.changeDetector.detectChanges();
  }
  getIcon() {
    return this.icon;
  }
  getToasterPosition() {
    return this.toasterPosition;
  }
  getToasterType() {
    return this.toasterType;
  }
  onButtonClose(event) {
    if (this.action && !this.actionLabel) {
      this.poToasterAction(event);
    } else {
      this.close();
    }
  }
  /* Chama a função passada pelo atributo `action` */
  poToasterAction(event) {
    this.action(this);
  }
  returnHeightToaster(position) {
    if (this.orientation === PoToasterOrientation.Top) {
      return document.querySelectorAll(".po-toaster-top")[position].offsetHeight;
    }
    return document.querySelectorAll(".po-toaster-bottom")[position].offsetHeight;
  }
  static ɵfac = function PoToasterComponent_Factory(t) {
    return new (t || _PoToasterComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoToasterComponent, selectors: [["po-toaster"]], viewQuery: function PoToasterComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$11, 5);
      ɵɵviewQuery(_c1$q, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toaster = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttonClose = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 13, vars: 7, consts: [["toaster", ""], [1, "po-toaster-icon"], [3, "p-icon"], [1, "po-toaster-actions"], [1, "po-toaster-message"], [1, "po-toaster-action"], ["p-kind", "tertiary", 3, "p-label", "p-click", 4, "ngIf"], [1, "po-toaster-close"], [1, "po-toaster-divider"], ["p-icon", "po-icon-close", "p-kind", "tertiary", 1, "po-toaster-button-close", 3, "p-click"], ["buttonClose", ""], ["p-kind", "tertiary", 3, "p-label", "p-click"]], template: function PoToasterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", null, 0)(2, "div", 1);
      ɵɵelement(3, "po-icon", 2);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3)(5, "div", 4);
      ɵɵtext(6);
      ɵɵelementEnd();
      ɵɵelementStart(7, "div", 5);
      ɵɵtemplate(8, PoToasterComponent_po_button_8_Template, 1, 1, "po-button", 6);
      ɵɵelementEnd()();
      ɵɵelementStart(9, "div", 7);
      ɵɵelement(10, "div", 8);
      ɵɵelementStart(11, "po-button", 9, 10);
      ɵɵlistener("p-click", function PoToasterComponent_Template_po_button_p_click_11_listener($event) {
        return ctx.onButtonClose($event);
      });
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate2("po-toaster ", ctx.getToasterType(), " ", ctx.getToasterPosition(), "");
      ɵɵadvance(3);
      ɵɵproperty("p-icon", ctx.getIcon());
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.message);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.action && ctx.actionLabel);
    }
  }, dependencies: [NgIf, PoButtonComponent, PoIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToasterComponent, [{
    type: Component,
    args: [{ selector: "po-toaster", template: '<div #toaster class="po-toaster {{ getToasterType() }} {{ getToasterPosition() }}">\n  <div class="po-toaster-icon">\n    <po-icon [p-icon]="getIcon()"></po-icon>\n  </div>\n\n  <div class="po-toaster-actions">\n    <div class="po-toaster-message">{{ message }}</div>\n    <div class="po-toaster-action">\n      <po-button\n        *ngIf="action && actionLabel"\n        (p-click)="poToasterAction($event)"\n        [p-label]="actionLabel"\n        p-kind="tertiary"\n      ></po-button>\n    </div>\n  </div>\n\n  <div class="po-toaster-close">\n    <div class="po-toaster-divider"></div>\n    <po-button\n      #buttonClose\n      class="po-toaster-button-close"\n      (p-click)="onButtonClose($event)"\n      p-icon="po-icon-close"\n      p-kind="tertiary"\n    ></po-button>\n  </div>\n</div>\n' }]
  }], () => [{ type: PoLanguageService }, { type: ChangeDetectorRef }, { type: Renderer2 }], { toaster: [{
    type: ViewChild,
    args: ["toaster"]
  }], buttonClose: [{
    type: ViewChild,
    args: ["buttonClose"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToasterComponent, { className: "PoToasterComponent", filePath: "lib/services/po-notification/po-toaster/po-toaster.component.ts", lineNumber: 33 });
})();
var PoNotificationModule = class _PoNotificationModule {
  static ɵfac = function PoNotificationModule_Factory(t) {
    return new (t || _PoNotificationModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoNotificationModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoButtonModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNotificationModule, [{
    type: NgModule,
    args: [{
      declarations: [PoToasterComponent],
      imports: [CommonModule, PoButtonModule, PoIconModule],
      exports: [],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNotificationModule, { declarations: [PoToasterComponent], imports: [CommonModule, PoButtonModule, PoIconModule] });
})();
var PoServicesModule = class _PoServicesModule {
  static ɵfac = function PoServicesModule_Factory(t) {
    return new (t || _PoServicesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoServicesModule });
  static ɵinj = ɵɵdefineInjector({ imports: [
    PoActiveOverlayModule,
    PoColorPaletteModule,
    PoComponentInjectorModule,
    PoControlPositionModule,
    PoDateTimeModule,
    PoDialogModule,
    PoLanguageModule,
    PoNotificationModule,
    PoActiveOverlayModule,
    PoColorPaletteModule,
    PoComponentInjectorModule,
    PoControlPositionModule,
    PoDateTimeModule,
    PoDialogModule,
    PoNotificationModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoServicesModule, [{
    type: NgModule,
    args: [{
      declarations: [PoI18nPipe],
      imports: [
        PoActiveOverlayModule,
        PoColorPaletteModule,
        PoComponentInjectorModule,
        PoControlPositionModule,
        PoDateTimeModule,
        PoDialogModule,
        PoLanguageModule,
        PoNotificationModule
      ],
      exports: [
        PoActiveOverlayModule,
        PoColorPaletteModule,
        PoComponentInjectorModule,
        PoControlPositionModule,
        PoDateTimeModule,
        PoDialogModule,
        PoI18nPipe,
        PoNotificationModule
      ],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoServicesModule, { declarations: [PoI18nPipe], imports: [
    PoActiveOverlayModule,
    PoColorPaletteModule,
    PoComponentInjectorModule,
    PoControlPositionModule,
    PoDateTimeModule,
    PoDialogModule,
    PoLanguageModule,
    PoNotificationModule
  ], exports: [
    PoActiveOverlayModule,
    PoColorPaletteModule,
    PoComponentInjectorModule,
    PoControlPositionModule,
    PoDateTimeModule,
    PoDialogModule,
    PoI18nPipe,
    PoNotificationModule
  ] });
})();
var PO_POPOVER_DEFAULT_POSITION = "right";
var PO_POPOVER_DEFAULT_TRIGGER = "click";
var PO_POPOVER_TRIGGERS = ["click", "hover"];
var PoPopoverBaseComponent = class _PoPopoverBaseComponent {
  /**
   * @description
   *
   * ElementRef do componente de origem responsável por abrir o popover.
   * Para utilizar o po-popover deve-se colocar uma variável no componente que vai disparar o evento
   * de abertura, exemplo:
   *
   * ```
   * <po-button
   *   p-label="Open Popover">
   * </po-button>
   *
   * <po-popover
   *   [p-target]="poButton"
   *   [p-title]="PO Popover">
   * </po-popover>
   * ```
   *
   * Também deve-se criar um ViewChild para cada popover, passando como referência o elemento do
   * HTML que irá disparar o evento. Exemplo:
   *
   * ```
   * @ViewChild(PoButtonComponent, {read: ElementRef}) poButton: PoButtonComponent;
   * ```
   *
   * Pode-se tambem informar diretamente o HTMLElement, para não ter que utilizar o ViewChild.
   * Para utilizar o po-popover deve-se colocar uma variável no componente que vai disparar o evento
   * de abertura, exemplo:
   *
   * ```
   * <button #target>
   *   Abrir popover
   * </button>
   *
   * <po-popover
   *     [p-target]="target"
   *     p-trigger="click" >
   * </po-popover>
   * ```
   *
   *
   *
   */
  target;
  /** Título do popover. */
  title;
  /** Evento disparado ao fechar o popover. */
  closePopover = new EventEmitter();
  // Controla se o popover fica oculto ou visível, por padrão é oculto.
  isHidden = true;
  clickoutListener;
  mouseEnterListener;
  mouseLeaveListener;
  resizeListener;
  _hideArrow = false;
  _position = PO_POPOVER_DEFAULT_POSITION;
  _trigger = PO_POPOVER_DEFAULT_TRIGGER;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita a seta do componente *popover*.
   *
   * @default `false`
   */
  set hideArrow(value) {
    this._hideArrow = convertToBoolean(value);
  }
  get hideArrow() {
    return this._hideArrow;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a posição que o po-popover abrirá em relação ao componente alvo. Sugere-se que seja
   * usada a orientação "right" (direita), porém o mesmo é flexível e será rotacionado
   * automaticamente para se adequar a tela, caso necessário.
   *
   * Posições válidas:
   * - `right`: Posiciona o po-popover no lado direito do componente alvo.
   * - `right-bottom`: Posiciona o po-popover no lado direito inferior do componente alvo.
   * - `right-top`: Posiciona o po-popover no lado direito superior do componente alvo.
   * - `bottom`: Posiciona o po-popover abaixo do componente alvo.
   * - `bottom-left`: Posiciona o po-popover abaixo e à esquerda do componente alvo.
   * - `bottom-right`: Posiciona o po-popover abaixo e à direita do componente alvo.
   * - `left`: Posiciona o po-popover no lado esquerdo do componente alvo.
   * - `left-top`: Posiciona o po-popover no lado esquerdo superior do componente alvo.
   * - `left-bottom`: Posiciona o po-popover no lado esquerdo inferior do componente alvo.
   * - `top`: Posiciona o po-popover acima do componente alvo.
   * - `top-right`: Posiciona o po-popover acima e à direita do componente alvo.
   * - `top-left`: Posiciona o po-popover acima e à esquerda do componente alvo.
   *
   *
   * @default right
   */
  set position(value) {
    this._position = PO_CONTROL_POSITIONS.includes(value) ? value : PO_POPOVER_DEFAULT_POSITION;
  }
  get position() {
    return this._position;
  }
  /**
   * @description
   *
   * Define o evento que abrirá o po-popover.
   *
   * Valores válidos:
   *  - `click`: Abre ao clicar no componente alvo.
   *  - `hover`: Abre ao passar o mouse sobre o componente alvo.
   *
   * @default click
   * @optional
   */
  set trigger(value) {
    this._trigger = PO_POPOVER_TRIGGERS.includes(value) ? value : PO_POPOVER_DEFAULT_TRIGGER;
  }
  get trigger() {
    return this._trigger;
  }
  static ɵfac = function PoPopoverBaseComponent_Factory(t) {
    return new (t || _PoPopoverBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPopoverBaseComponent, inputs: { target: [InputFlags.None, "p-target", "target"], title: [InputFlags.None, "p-title", "title"], hideArrow: [InputFlags.None, "p-hide-arrow", "hideArrow"], position: [InputFlags.None, "p-position", "position"], trigger: [InputFlags.None, "p-trigger", "trigger"] }, outputs: { closePopover: "p-close" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopoverBaseComponent, [{
    type: Directive
  }], null, { target: [{
    type: Input,
    args: ["p-target"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], closePopover: [{
    type: Output,
    args: ["p-close"]
  }], hideArrow: [{
    type: Input,
    args: ["p-hide-arrow"]
  }], position: [{
    type: Input,
    args: ["p-position"]
  }], trigger: [{
    type: Input,
    args: ["p-trigger"]
  }] });
})();
var _c0$10 = ["popoverElement"];
function PoPopoverComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("po-popover-arrow po-arrow-", ctx_r1.arrowDirection, "");
  }
}
function PoPopoverComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.title);
  }
}
var _c1$p = ["*"];
var PoPopoverComponent = class _PoPopoverComponent extends PoPopoverBaseComponent {
  renderer;
  poControlPosition;
  popoverElement;
  arrowDirection = "left";
  timeoutResize;
  targetElement;
  eventListenerFunction;
  constructor(renderer, poControlPosition) {
    super();
    this.renderer = renderer;
    this.poControlPosition = poControlPosition;
  }
  ngAfterViewInit() {
    this.targetElement = this.target instanceof ElementRef ? this.target.nativeElement : this.target;
    this.initEventListenerFunction();
    this.setElementsControlPosition();
    this.setRendererListenInit();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  close() {
    this.isHidden = true;
    this.closePopover.emit();
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      this.setPopoverPosition();
    }, 200);
  }
  open() {
    this.addScrollEventListener();
    this.isHidden = false;
    this.setOpacity(0);
    setTimeout(() => {
      this.setElementsControlPosition();
      this.setPopoverPosition();
      this.setOpacity(1);
    });
  }
  setOpacity(value) {
    this.popoverElement.nativeElement.style.opacity = value;
  }
  setPopoverPosition() {
    this.poControlPosition.adjustPosition(this.position);
    this.arrowDirection = this.poControlPosition.getArrowDirection();
  }
  setRendererListenInit() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      if (!this.isHidden) {
        this.debounceResize();
      }
    });
    if (this.trigger === "hover") {
      this.mouseEnterListener = this.renderer.listen(this.targetElement, "mouseenter", (event) => {
        this.open();
      });
      this.mouseLeaveListener = this.renderer.listen(this.targetElement, "mouseleave", (event) => {
        this.close();
      });
    } else {
      this.clickoutListener = this.renderer.listen("document", "click", (event) => {
        this.togglePopup(event);
      });
    }
  }
  togglePopup(event) {
    if (!this.isHidden && !this.popoverElement.nativeElement.contains(event.target) && !this.targetElement.contains(event.target)) {
      this.close();
    } else if (this.targetElement.contains(event.target)) {
      this.popoverElement.nativeElement.hidden ? this.open() : this.close();
    }
  }
  addScrollEventListener() {
    window.addEventListener("scroll", this.eventListenerFunction, true);
  }
  initEventListenerFunction() {
    this.eventListenerFunction = () => {
      this.setPopoverPosition();
    };
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.mouseEnterListener) {
      this.mouseEnterListener();
    }
    if (this.mouseLeaveListener) {
      this.mouseLeaveListener();
    }
    this.resizeListener();
    window.removeEventListener("scroll", this.eventListenerFunction, true);
  }
  setElementsControlPosition() {
    const popoverOffset = 8;
    this.poControlPosition.setElements(this.popoverElement.nativeElement, popoverOffset, this.target);
  }
  static ɵfac = function PoPopoverComponent_Factory(t) {
    return new (t || _PoPopoverComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoControlPositionService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPopoverComponent, selectors: [["po-popover"]], viewQuery: function PoPopoverComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$10, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popoverElement = _t.first);
    }
  }, features: [ɵɵProvidersFeature([PoControlPositionService]), ɵɵInheritDefinitionFeature], ngContentSelectors: _c1$p, decls: 6, vars: 3, consts: [[1, "po-popover", 3, "hidden"], ["popoverElement", ""], [3, "class", 4, "ngIf"], [1, "po-popover-content"], ["class", "po-popover-title", 4, "ngIf"], [1, "po-popover-title"]], template: function PoPopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵtemplate(2, PoPopoverComponent_div_2_Template, 1, 3, "div", 2);
      ɵɵelementStart(3, "div", 3);
      ɵɵtemplate(4, PoPopoverComponent_span_4_Template, 2, 1, "span", 4);
      ɵɵprojection(5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("hidden", ctx.isHidden);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.hideArrow);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.title);
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopoverComponent, [{
    type: Component,
    args: [{ selector: "po-popover", providers: [PoControlPositionService], template: '<div [hidden]="isHidden" class="po-popover" #popoverElement>\n  <div *ngIf="!hideArrow" class="po-popover-arrow po-arrow-{{ arrowDirection }}"></div>\n\n  <div class="po-popover-content">\n    <span *ngIf="title" class="po-popover-title">{{ title }}</span>\n    <ng-content></ng-content>\n  </div>\n</div>\n' }]
  }], () => [{ type: Renderer2 }, { type: PoControlPositionService }], { popoverElement: [{
    type: ViewChild,
    args: ["popoverElement", { read: ElementRef, static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPopoverComponent, { className: "PoPopoverComponent", filePath: "lib/components/po-popover/po-popover.component.ts", lineNumber: 41 });
})();
var PoPopoverModule = class _PoPopoverModule {
  static ɵfac = function PoPopoverModule_Factory(t) {
    return new (t || _PoPopoverModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoPopoverModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoPopoverComponent],
      exports: [PoPopoverComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPopoverModule, { declarations: [PoPopoverComponent], imports: [CommonModule], exports: [PoPopoverComponent] });
})();
var PoTimePipe = class _PoTimePipe {
  transform(time, format) {
    const hourRegex = /^(([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9][\.]?([0-9]{1,6})?$/g;
    if (isTypeof(time, "string") && hourRegex.test(time)) {
      const amountOfF = format ? format.lastIndexOf("f") - format.indexOf("f") + 1 : 0;
      const miliseconds = this.addDotMiliseconds(time.substring(9, 9 + amountOfF), amountOfF);
      const formatMiliseconds = this.getFormatMiliseconds(amountOfF);
      return this.formatValue(time, format, formatMiliseconds, miliseconds);
    }
    return null;
  }
  addDotMiliseconds(miliseconds, amountOfF) {
    if (miliseconds && amountOfF) {
      miliseconds = "." + miliseconds;
    }
    return miliseconds;
  }
  formatValue(time, format, formatMiliseconds, miliseconds) {
    if (time && format) {
      const hour = time.substring(0, 2);
      const minutes = time.substring(3, 5);
      const seconds = time.substring(6, 8);
      format = format.replace("HH", hour);
      format = format.replace("mm", minutes);
      format = format.replace("ss", seconds);
      format = format.replace(`.${formatMiliseconds}`, miliseconds);
      return format;
    } else {
      return time;
    }
  }
  getFormatMiliseconds(amountOfF) {
    let formatMiliseconds = "";
    for (let i = 0; i < amountOfF; i++) {
      formatMiliseconds += "f";
    }
    return formatMiliseconds;
  }
  static ɵfac = function PoTimePipe_Factory(t) {
    return new (t || _PoTimePipe)();
  };
  static ɵpipe = ɵɵdefinePipe({ name: "po_time", type: _PoTimePipe, pure: true });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTimePipe, [{
    type: Pipe,
    args: [{
      name: "po_time"
    }]
  }], null, null);
})();
var PoTimeModule = class _PoTimeModule {
  static ɵfac = function PoTimeModule_Factory(t) {
    return new (t || _PoTimeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoTimeModule });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTimeModule, [{
    type: NgModule,
    args: [{
      declarations: [PoTimePipe],
      imports: [],
      exports: [PoTimePipe],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTimeModule, { declarations: [PoTimePipe], exports: [PoTimePipe] });
})();
var PoPageSlideBaseComponent = class _PoPageSlideBaseComponent {
  /**
   * @description
   *
   * Título da página.
   */
  title;
  /**
   * @description
   *
   * Subtítulo da página.
   */
  subtitle;
  /**
   * @optional
   *
   * @description
   *
   * Oculta o botão de encerramento da página.
   *
   * Esta opção só é possível se a propriedade `p-click-out` estiver habilitada.
   *
   * @default `false`
   */
  hideClose = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se permite o encerramento da página ao clicar fora da mesma.
   *
   * @default `false`
   */
  clickOut = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite a expansão dinâmica da largura do `po-page-slide` quando `p-size` for `auto` (automático).
   * Propriedade necessária para correto funcionamento da `po-table` dentro do `po-page-slide`
   *
   * @default `false`
   */
  flexibleWidth = false;
  /**
   * @optional
   *
   * @description
   * Evento executado ao fechar o page slide.
   */
  closePageSlide = new EventEmitter();
  // Controla se a página está ou não oculta, por padrão é oculto.
  hidden = true;
  _size = "md";
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho da página.
   *
   * Valores válidos:
   *  - `sm` (pequeno)
   *  - `md` (médio)
   *  - `lg` (grande)
   *  - `xl` (extra-grande)
   *  - `auto` (automático)
   *
   * > Todas as opções de tamanho, exceto `auto`, possuem uma largura máxima de **768px**.
   *
   * @default `md`
   */
  set size(value) {
    const sizes = ["sm", "md", "lg", "xl", "auto"];
    this._size = sizes.indexOf(value) > -1 ? value : "md";
  }
  get size() {
    return this._size;
  }
  /**
   * Ativa a visualização da página.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo
   * ser utilizado o `ViewChild` da seguinte forma:
   *
   * ```typescript
   * import { PoPageSlideComponent } from '@po/ng-components';
   *
   * ...
   *
   * @ViewChild(PoPageSlideComponent, { static: true }) pageSlide: PoPageSlideComponent;
   *
   * public openPage() {
   *   this.pageSlide.open();
   * }
   * ```
   */
  open() {
    if (this.hideClose && !this.clickOut) {
      this.hideClose = false;
    }
    this.hidden = false;
  }
  /**
   * Encerra a visualização da página.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo
   * ser utilizado o `ViewChild` da seguinte forma:
   *
   * ```typescript
   * import { PoPageSlideComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoPageSlideComponent, { static: true }) pageSlide: PoPageSlideComponent;
   *
   * public closePage() {
   *   this.pageSlide.close();
   * }
   * ```
   */
  close() {
    this.hidden = true;
    this.closePageSlide.emit();
  }
  static ɵfac = function PoPageSlideBaseComponent_Factory(t) {
    return new (t || _PoPageSlideBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPageSlideBaseComponent, inputs: { title: [InputFlags.None, "p-title", "title"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"], hideClose: [InputFlags.HasDecoratorInputTransform, "p-hide-close", "hideClose", convertToBoolean], clickOut: [InputFlags.HasDecoratorInputTransform, "p-click-out", "clickOut", convertToBoolean], flexibleWidth: [InputFlags.HasDecoratorInputTransform, "p-flexible-width", "flexibleWidth", convertToBoolean], size: [InputFlags.None, "p-size", "size"] }, outputs: { closePageSlide: "p-close" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideBaseComponent, [{
    type: Directive
  }], null, { title: [{
    type: Input,
    args: ["p-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }], hideClose: [{
    type: Input,
    args: [{ alias: "p-hide-close", transform: convertToBoolean }]
  }], clickOut: [{
    type: Input,
    args: [{ alias: "p-click-out", transform: convertToBoolean }]
  }], flexibleWidth: [{
    type: Input,
    args: [{ alias: "p-flexible-width", transform: convertToBoolean }]
  }], closePageSlide: [{
    type: Output,
    args: ["p-close"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }] });
})();
var _c0$$ = ["pageContent"];
function PoPageSlideComponent_div_0_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.subtitle);
  }
}
function PoPageSlideComponent_div_0_po_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 12);
    ɵɵlistener("p-click", function PoPageSlideComponent_div_0_po_button_10_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
}
var _c1$o = (a0) => ({ "width": a0 });
function PoPageSlideComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵlistener("mousedown", function PoPageSlideComponent_div_0_Template_div_mousedown_1_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.onClickOut($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 3)(3, "div", 4, 5)(5, "div", 6)(6, "div", 7)(7, "span");
    ɵɵtext(8);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoPageSlideComponent_div_0_div_9_Template, 2, 1, "div", 8);
    ɵɵelementEnd();
    ɵɵtemplate(10, PoPageSlideComponent_div_0_po_button_10_Template, 1, 0, "po-button", 9);
    ɵɵelementEnd();
    ɵɵelementStart(11, "div", 10);
    ɵɵprojection(12);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@fade", void 0);
    ɵɵadvance(2);
    ɵɵclassMapInterpolate1("po-page-slide-container po-page-slide-right po-page-slide-", ctx_r0.size, "");
    ɵɵproperty("@slide", void 0)("ngStyle", ɵɵpureFunction1(9, _c1$o, ctx_r0.flexibleWidth ? "" : ctx_r0.size === "auto" ? "auto" : ""));
    ɵɵadvance(6);
    ɵɵtextInterpolate(ctx_r0.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.subtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.hideClose);
  }
}
var _c2$c = ["*"];
var PoPageSlideComponent = class _PoPageSlideComponent extends PoPageSlideBaseComponent {
  poActiveOverlayService;
  _pageContent;
  firstElement;
  id = uuid();
  loadingCompleted = new ReplaySubject();
  sourceElement;
  focusEvent;
  set pageContent(pageContent) {
    if (pageContent) {
      this._pageContent = pageContent;
      this.loadingCompleted.next();
    }
  }
  get pageContent() {
    return this._pageContent;
  }
  constructor(poActiveOverlayService) {
    super();
    this.poActiveOverlayService = poActiveOverlayService;
  }
  open() {
    this.sourceElement = document.activeElement;
    super.open();
    this.loadingCompleted.pipe(take(1)).pipe(delay(0)).subscribe(this.handleFocus.bind(this));
  }
  close() {
    this.poActiveOverlayService.activeOverlay.pop();
    super.close();
    this.removeEventListeners();
    this.sourceElement.focus();
  }
  onClickOut(event) {
    if (this.clickOut && !this.pageContent.nativeElement.contains(event.target)) {
      this.close();
    }
  }
  handleFocus() {
    this.poActiveOverlayService.activeOverlay.push(this.id);
    this.loadFirstElement();
    this.initFocus();
    document.addEventListener("focus", this.focusEvent, true);
  }
  initFocus() {
    this.focusEvent = (event) => {
      if (!this.pageContent.nativeElement.contains(event.target) && this.poActiveOverlayService.activeOverlay[this.poActiveOverlayService.activeOverlay.length - 1] === this.id) {
        event.stopPropagation();
        this.firstElement.focus();
      }
    };
    if (this.hideClose) {
      this.firstElement.focus();
    } else {
      const elements = getFocusableElements(this.pageContent.nativeElement);
      const element = elements[0] || this.pageContent.nativeElement;
      element.focus();
    }
  }
  loadFirstElement() {
    this.firstElement = getFocusableElements(this.pageContent.nativeElement)[0] || this.pageContent.nativeElement;
  }
  removeEventListeners() {
    document.removeEventListener("focus", this.focusEvent, true);
    this.loadingCompleted.complete();
  }
  static ɵfac = function PoPageSlideComponent_Factory(t) {
    return new (t || _PoPageSlideComponent)(ɵɵdirectiveInject(PoActiveOverlayService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageSlideComponent, selectors: [["po-page-slide"]], viewQuery: function PoPageSlideComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$$, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageContent = _t.first);
    }
  }, features: [ɵɵProvidersFeature([]), ɵɵInheritDefinitionFeature], ngContentSelectors: _c2$c, decls: 1, vars: 1, consts: [["class", "po-page-slide", "tabindex", "0", 4, "ngIf"], ["tabindex", "0", 1, "po-page-slide"], [1, "po-page-slide-overlay", 3, "mousedown"], [3, "ngStyle"], ["tabindex", "-1", 1, "po-page-slide-content"], ["pageContent", ""], [1, "po-page-slide-header"], [1, "po-page-slide-title"], ["class", "po-page-slide-subtitle", 4, "ngIf"], ["p-icon", "po-icon-close", "p-kind", "tertiary", 3, "p-click", 4, "ngIf"], [1, "po-page-slide-body"], [1, "po-page-slide-subtitle"], ["p-icon", "po-icon-close", "p-kind", "tertiary", 3, "p-click"]], template: function PoPageSlideComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, PoPageSlideComponent_div_0_Template, 13, 11, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.hidden);
    }
  }, dependencies: [NgIf, NgStyle, PoButtonComponent], encapsulation: 2, data: { animation: [
    trigger("fade", [
      transition(":enter", [
        style({ opacity: 0 }),
        group([animate("150ms", style({ opacity: 1 })), query("@slide", animateChild())])
      ]),
      transition(":leave", group([query("@slide", animateChild()), animate("150ms", style({ opacity: 0 }))]))
    ]),
    trigger("slide", [
      transition(":enter", [
        style({ transform: "translateX(50px)" }),
        animate("691ms ease-in-out", style({ transform: "none" }))
      ]),
      transition(":leave", [animate("150ms", style({ transform: "translateX(50px)" }))])
    ])
  ] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideComponent, [{
    type: Component,
    args: [{ selector: "po-page-slide", providers: [], animations: [
      trigger("fade", [
        transition(":enter", [
          style({ opacity: 0 }),
          group([animate("150ms", style({ opacity: 1 })), query("@slide", animateChild())])
        ]),
        transition(":leave", group([query("@slide", animateChild()), animate("150ms", style({ opacity: 0 }))]))
      ]),
      trigger("slide", [
        transition(":enter", [
          style({ transform: "translateX(50px)" }),
          animate("691ms ease-in-out", style({ transform: "none" }))
        ]),
        transition(":leave", [animate("150ms", style({ transform: "translateX(50px)" }))])
      ])
    ], template: `<div class="po-page-slide" tabindex="0" *ngIf="!hidden" [@fade]>
  <div class="po-page-slide-overlay" (mousedown)="onClickOut($event)"></div>
  <div
    class="po-page-slide-container po-page-slide-right po-page-slide-{{ size }}"
    [@slide]
    [ngStyle]="{ 'width': flexibleWidth ? '' : size === 'auto' ? 'auto' : '' }"
  >
    <div class="po-page-slide-content" tabindex="-1" #pageContent>
      <div class="po-page-slide-header">
        <div class="po-page-slide-title">
          <span>{{ title }}</span>
          <div class="po-page-slide-subtitle" *ngIf="subtitle">{{ subtitle }}</div>
        </div>
        <po-button *ngIf="!hideClose" p-icon="po-icon-close" p-kind="tertiary" (p-click)="close()"> </po-button>
      </div>
      <div class="po-page-slide-body">
        <ng-content></ng-content>
      </div>
    </div>
  </div>
</div>
` }]
  }], () => [{ type: PoActiveOverlayService }], { pageContent: [{
    type: ViewChild,
    args: ["pageContent", { read: ElementRef }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageSlideComponent, { className: "PoPageSlideComponent", filePath: "lib/components/po-page/po-page-slide/po-page-slide.component.ts", lineNumber: 52 });
})();
var PoPageSlideModule = class _PoPageSlideModule {
  static ɵfac = function PoPageSlideModule_Factory(t) {
    return new (t || _PoPageSlideModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoPageSlideModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoButtonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageSlideModule, [{
    type: NgModule,
    args: [{
      declarations: [PoPageSlideComponent],
      exports: [PoPageSlideComponent],
      imports: [CommonModule, FormsModule, PoButtonModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPageSlideModule, { declarations: [PoPageSlideComponent], imports: [CommonModule, FormsModule, PoButtonModule], exports: [PoPageSlideComponent] });
})();
var _c0$_ = (a0, a1) => ({ "po-clickable": a0, "po-table-icon-disabled": a1 });
var PoTableIconComponent = class _PoTableIconComponent {
  /** Define se o ícone é clicável. */
  clickable;
  /** Cor do ícone. */
  color;
  /** Desabilitado. */
  disabled;
  /** Classe css do ícone. */
  icon;
  /** Texto do tooltip. */
  iconTooltip;
  /** Output click. */
  click = new EventEmitter();
  tooltip;
  get allowTooltip() {
    return !this.disabled && this.iconTooltip;
  }
  onClick(event) {
    if (this.clickable) {
      this.click.emit(event);
    }
  }
  tooltipMouseEnter() {
    if (this.allowTooltip) {
      this.tooltip = this.iconTooltip;
    }
  }
  tooltipMouseLeave() {
    this.tooltip = void 0;
  }
  static ɵfac = function PoTableIconComponent_Factory(t) {
    return new (t || _PoTableIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableIconComponent, selectors: [["po-table-icon"]], inputs: { clickable: [InputFlags.None, "p-clickable", "clickable"], color: [InputFlags.None, "p-color", "color"], disabled: [InputFlags.None, "p-disabled", "disabled"], icon: [InputFlags.None, "p-icon", "icon"], iconTooltip: [InputFlags.None, "p-icon-tooltip", "iconTooltip"] }, outputs: { click: "p-click" }, decls: 1, vars: 10, consts: [[3, "ngClass", "p-icon", "p-tooltip", "p-append-in-body", "click", "mouseenter", "mouseleave"]], template: function PoTableIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-icon", 0);
      ɵɵlistener("click", function PoTableIconComponent_Template_po_icon_click_0_listener($event) {
        return ctx.onClick($event);
      })("mouseenter", function PoTableIconComponent_Template_po_icon_mouseenter_0_listener() {
        return ctx.tooltipMouseEnter();
      })("mouseleave", function PoTableIconComponent_Template_po_icon_mouseleave_0_listener() {
        return ctx.tooltipMouseLeave();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("po-table-icon-content ", ctx.disabled ? "" : ctx.color, "");
      ɵɵproperty("ngClass", ɵɵpureFunction2(7, _c0$_, ctx.clickable, ctx.disabled))("p-icon", ctx.icon)("p-tooltip", ctx.tooltip)("p-append-in-body", true);
    }
  }, dependencies: [NgClass, PoTooltipDirective, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableIconComponent, [{
    type: Component,
    args: [{ selector: "po-table-icon", changeDetection: ChangeDetectionStrategy.OnPush, template: `<po-icon
  class="po-table-icon-content {{ disabled ? '' : color }}"
  [ngClass]="{ 'po-clickable': clickable, 'po-table-icon-disabled': disabled }"
  [p-icon]="icon"
  [p-tooltip]="tooltip"
  [p-append-in-body]="true"
  (click)="onClick($event)"
  (mouseenter)="tooltipMouseEnter()"
  (mouseleave)="tooltipMouseLeave()"
></po-icon>
` }]
  }], null, { clickable: [{
    type: Input,
    args: ["p-clickable"]
  }], color: [{
    type: Input,
    args: ["p-color"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], iconTooltip: [{
    type: Input,
    args: ["p-icon-tooltip"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableIconComponent, { className: "PoTableIconComponent", filePath: "lib/components/po-table/po-table-icon/po-table-icon.component.ts", lineNumber: 15 });
})();
function PoTableColumnIconComponent_po_table_icon_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-icon", 1);
    ɵɵlistener("p-click", function PoTableColumnIconComponent_po_table_icon_0_Template_po_table_icon_p_click_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r3);
      const column_r1 = restoredCtx.$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.click(column_r1, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-clickable", ctx_r0.isClickable(column_r1))("p-color", ctx_r0.getColor(column_r1))("p-disabled", ctx_r0.isDisabled(column_r1))("p-icon", ctx_r0.getIcon(column_r1))("p-icon-tooltip", column_r1.tooltip);
  }
}
var PoTableColumnIconComponent = class _PoTableColumnIconComponent {
  /** Definição da coluna que utiliza os icones. */
  column;
  /** Dados da linha da tabela. */
  row;
  _icons = [];
  /** Lista de colunas com ícones. */
  set icons(icons) {
    this._icons = this.convertToColumnIcon(icons);
  }
  get icons() {
    return this._icons;
  }
  click(columnIcon, event) {
    const isAbleAction = !this.isDisabled(columnIcon);
    if (isAbleAction) {
      if (columnIcon.action) {
        columnIcon.action(this.row, columnIcon);
      } else if (this.column.action) {
        this.column.action(this.row, columnIcon);
      }
      event.stopPropagation();
    }
  }
  getColor(column) {
    const color = typeof column.color === "function" ? column.color(this.row, column) : column.color;
    if (color) {
      return `po-text-${color}`;
    }
  }
  getIcon(column) {
    return column.icon || column.value;
  }
  isClickable(columnIcon) {
    return !!(!this.isDisabled(columnIcon) && (columnIcon.action || this.column.action));
  }
  isDisabled(column) {
    return column.disabled ? column.disabled(this.row) : false;
  }
  trackByFunction(index) {
    return index;
  }
  convertToColumnIcon(rowIcons) {
    if (Array.isArray(rowIcons)) {
      return rowIcons.map((rowIcon) => typeof rowIcon === "string" ? { value: rowIcon } : rowIcon);
    }
    if (typeof rowIcons === "string") {
      return [{ value: rowIcons }];
    }
    return [];
  }
  static ɵfac = function PoTableColumnIconComponent_Factory(t) {
    return new (t || _PoTableColumnIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableColumnIconComponent, selectors: [["po-table-column-icon"]], inputs: { column: [InputFlags.None, "p-column", "column"], row: [InputFlags.None, "p-row", "row"], icons: [InputFlags.None, "p-icons", "icons"] }, decls: 1, vars: 2, consts: [[3, "p-clickable", "p-color", "p-disabled", "p-icon", "p-icon-tooltip", "p-click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-clickable", "p-color", "p-disabled", "p-icon", "p-icon-tooltip", "p-click"]], template: function PoTableColumnIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoTableColumnIconComponent_po_table_icon_0_Template, 1, 5, "po-table-icon", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.icons)("ngForTrackBy", ctx.trackByFunction);
    }
  }, dependencies: [NgForOf, PoTableIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnIconComponent, [{
    type: Component,
    args: [{ selector: "po-table-column-icon", changeDetection: ChangeDetectionStrategy.OnPush, template: '<po-table-icon\n  *ngFor="let column of icons; trackBy: trackByFunction"\n  [p-clickable]="isClickable(column)"\n  [p-color]="getColor(column)"\n  [p-disabled]="isDisabled(column)"\n  [p-icon]="getIcon(column)"\n  [p-icon-tooltip]="column.tooltip"\n  (p-click)="click(column, $event)"\n>\n</po-table-icon>\n' }]
  }], null, { column: [{
    type: Input,
    args: ["p-column"]
  }], row: [{
    type: Input,
    args: ["p-row"]
  }], icons: [{
    type: Input,
    args: ["p-icons"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnIconComponent, { className: "PoTableColumnIconComponent", filePath: "lib/components/po-table/po-table-column-icon/po-table-column-icon.component.ts", lineNumber: 18 });
})();
function PoTableColumnLabelComponent_po_tag_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tag", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-color", ctx_r0.value == null ? null : ctx_r0.value.color)("p-value", ctx_r0.value == null ? null : ctx_r0.value.label)("p-text-color", ctx_r0.value == null ? null : ctx_r0.value.textColor)("p-icon", ctx_r0.value == null ? null : ctx_r0.value.icon)("p-type", ctx_r0.value == null ? null : ctx_r0.value.type);
  }
}
var PoTableColumnLabelComponent = class _PoTableColumnLabelComponent {
  hasLabel = false;
  value;
  ngOnInit() {
    this.checkValueHasLabel();
  }
  checkValueHasLabel() {
    this.hasLabel = this.value?.label?.trim() ? true : false;
  }
  static ɵfac = function PoTableColumnLabelComponent_Factory(t) {
    return new (t || _PoTableColumnLabelComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableColumnLabelComponent, selectors: [["po-table-column-label"]], inputs: { value: [InputFlags.None, "p-value", "value"] }, decls: 1, vars: 1, consts: [[3, "p-color", "p-value", "p-text-color", "p-icon", "p-type", 4, "ngIf"], [3, "p-color", "p-value", "p-text-color", "p-icon", "p-type"]], template: function PoTableColumnLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoTableColumnLabelComponent_po_tag_0_Template, 1, 5, "po-tag", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.hasLabel);
    }
  }, dependencies: [NgIf, PoTagComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnLabelComponent, [{
    type: Component,
    args: [{ selector: "po-table-column-label", changeDetection: ChangeDetectionStrategy.OnPush, template: '<po-tag\n  *ngIf="hasLabel"\n  [p-color]="value?.color"\n  [p-value]="value?.label"\n  [p-text-color]="value?.textColor"\n  [p-icon]="value?.icon"\n  [p-type]="value?.type"\n>\n</po-tag>\n' }]
  }], null, { value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnLabelComponent, { className: "PoTableColumnLabelComponent", filePath: "lib/components/po-table/po-table-column-label/po-table-column-label.component.ts", lineNumber: 18 });
})();
function PoTableColumnLinkComponent_po_link_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-link", 4);
    ɵɵlistener("p-action", function PoTableColumnLinkComponent_po_link_2_Template_po_link_p_action_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.action == null ? null : ctx_r3.action(ctx_r3.value, ctx_r3.row));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r0.value)("p-open-new-tab", ctx_r0.openNewTab);
  }
}
function PoTableColumnLinkComponent_po_link_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-link", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r1.value)("p-open-new-tab", ctx_r1.openNewTab)("p-url", ctx_r1.link);
  }
}
function PoTableColumnLinkComponent_po_link_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-link", 5);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-label", ctx_r2.value)("p-open-new-tab", ctx_r2.openNewTab)("p-url", ctx_r2.link);
  }
}
var _c0$Z = (a0) => ({ "po-table-link-disabled": a0 });
var PoTableColumnLinkComponent = class _PoTableColumnLinkComponent {
  action;
  disabled;
  link;
  openNewTab = false;
  row;
  value;
  get type() {
    if (this.action) {
      return "action";
    }
    return isExternalLink(this.link) ? "externalLink" : "internalLink";
  }
  static ɵfac = function PoTableColumnLinkComponent_Factory(t) {
    return new (t || _PoTableColumnLinkComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableColumnLinkComponent, selectors: [["po-table-column-link"]], inputs: { action: [InputFlags.None, "p-action", "action"], disabled: [InputFlags.None, "p-disabled", "disabled"], link: [InputFlags.None, "p-link", "link"], openNewTab: [InputFlags.None, "p-open-new-tab", "openNewTab"], row: [InputFlags.None, "p-row", "row"], value: [InputFlags.None, "p-value", "value"] }, decls: 5, vars: 7, consts: [[1, "po-table-link", 3, "ngClass"], [3, "ngSwitch"], [3, "p-label", "p-open-new-tab", "p-action", 4, "ngSwitchCase"], [3, "p-label", "p-open-new-tab", "p-url", 4, "ngSwitchCase"], [3, "p-label", "p-open-new-tab", "p-action"], [3, "p-label", "p-open-new-tab", "p-url"]], template: function PoTableColumnLinkComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵelementContainerStart(1, 1);
      ɵɵtemplate(2, PoTableColumnLinkComponent_po_link_2_Template, 1, 2, "po-link", 2)(3, PoTableColumnLinkComponent_po_link_3_Template, 1, 3, "po-link", 3)(4, PoTableColumnLinkComponent_po_link_4_Template, 1, 3, "po-link", 3);
      ɵɵelementContainerEnd();
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c0$Z, ctx.disabled));
      ɵɵadvance();
      ɵɵproperty("ngSwitch", ctx.type);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "action");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "externalLink");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "internalLink");
    }
  }, dependencies: [NgClass, NgSwitch, NgSwitchCase, PoLinkComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnLinkComponent, [{
    type: Component,
    args: [{ selector: "po-table-column-link", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div class="po-table-link" [ngClass]="{ 'po-table-link-disabled': disabled }">
  <ng-container [ngSwitch]="type">
    <po-link
      *ngSwitchCase="'action'"
      [p-label]="value"
      [p-open-new-tab]="openNewTab"
      (p-action)="action?.(value, row)"
    ></po-link>
    <po-link *ngSwitchCase="'externalLink'" [p-label]="value" [p-open-new-tab]="openNewTab" [p-url]="link"></po-link>
    <po-link *ngSwitchCase="'internalLink'" [p-label]="value" [p-open-new-tab]="openNewTab" [p-url]="link"></po-link>
  </ng-container>
</div>
` }]
  }], null, { action: [{
    type: Input,
    args: ["p-action"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], link: [{
    type: Input,
    args: ["p-link"]
  }], openNewTab: [{
    type: Input,
    args: ["p-open-new-tab"]
  }], row: [{
    type: Input,
    args: ["p-row"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnLinkComponent, { className: "PoTableColumnLinkComponent", filePath: "lib/components/po-table/po-table-column-link/po-table-column-link.component.ts", lineNumber: 17 });
})();
var PoSwitchLabelPosition;
(function(PoSwitchLabelPosition2) {
  PoSwitchLabelPosition2[PoSwitchLabelPosition2["Right"] = 0] = "Right";
  PoSwitchLabelPosition2[PoSwitchLabelPosition2["Left"] = 1] = "Left";
})(PoSwitchLabelPosition || (PoSwitchLabelPosition = {}));
var _c0$Y = ["switchContainer"];
function PoSwitchComponent_po_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 10);
  }
}
function PoSwitchComponent_po_label_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-label", 11);
    ɵɵlistener("click", function PoSwitchComponent_po_label_8_Template_po_label_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.eventClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r2.disabled)("p-label", ctx_r2.value === true ? ctx_r2.labelOn : ctx_r2.labelOff);
  }
}
var PoSwitchComponent = class _PoSwitchComponent extends PoFieldModel {
  changeDetector;
  switchContainer;
  id = `po-switch[${uuid()}]`;
  // Parâmetro interno, não documentar
  value = false;
  _labelOff = "false";
  _labelOn = "true";
  _labelPosition = PoSwitchLabelPosition.Right;
  _formatModel = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o `model` receberá o valor formatado pelas propriedades `p-label-on` e `p-label-off` ou
   * apenas o valor puro (sem formatação).
   *
   * > Por padrão será atribuído `false`.
   * @default `false`
   */
  set formatModel(format) {
    this._formatModel = format || false;
  }
  get formatModel() {
    return this._formatModel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Posição de exibição do rótulo que fica ao lado do switch.
   *
   * > Por padrão exibe à direita.
   */
  set labelPosition(position) {
    this._labelPosition = position in PoSwitchLabelPosition ? parseInt(position, 10) : PoSwitchLabelPosition.Right;
  }
  get labelPosition() {
    return this._labelPosition;
  }
  /**
   * Texto exibido quando o valor do componente for `false`.
   *
   * @default `false`
   */
  set labelOff(label) {
    this._labelOff = label || "false";
  }
  get labelOff() {
    return this._labelOff;
  }
  /**
   * Texto exibido quando o valor do componente for `true`.
   *
   * @default `true`
   */
  set labelOn(label) {
    this._labelOn = label || "true";
  }
  get labelOn() {
    return this._labelOn;
  }
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoSwitchComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoSwitchComponent, { static: true }) switch: PoSwitchComponent;
   *
   * focusSwitch() {
   *   this.switch.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.switchContainer.nativeElement.focus();
    }
  }
  onBlur() {
    this.onTouched?.();
  }
  getLabelPosition() {
    switch (this.labelPosition) {
      case PoSwitchLabelPosition.Left:
        return "left";
      case PoSwitchLabelPosition.Right:
        return "right";
      default:
        return "right";
    }
  }
  onKeyDown(event) {
    if (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space) {
      event.preventDefault();
      this.eventClick();
    }
  }
  changeValue(value) {
    if (this.value !== value) {
      this.value = value;
      if (this.formatModel) {
        if (this.value) {
          this.updateModel(this.labelOn);
        } else {
          this.updateModel(this.labelOff);
        }
      } else {
        this.updateModel(value);
      }
      this.emitChange(this.value);
    }
  }
  eventClick() {
    if (!this.disabled) {
      this.changeValue(!this.value);
    }
  }
  onWriteValue(value) {
    if (value !== this.value) {
      if (this.formatModel && !!value) {
        this.value = value.toLowerCase() === this.labelOn.toLowerCase();
      } else {
        this.value = !!value;
      }
      this.changeDetector.markForCheck();
    }
  }
  static ɵfac = function PoSwitchComponent_Factory(t) {
    return new (t || _PoSwitchComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSwitchComponent, selectors: [["po-switch"]], viewQuery: function PoSwitchComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$Y, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.switchContainer = _t.first);
    }
  }, inputs: { value: [InputFlags.HasDecoratorInputTransform, "p-value", "value", convertToBoolean], formatModel: [InputFlags.HasDecoratorInputTransform, "p-format-model", "formatModel", convertToBoolean], labelPosition: [InputFlags.None, "p-label-position", "labelPosition"], labelOff: [InputFlags.None, "p-label-off", "labelOff"], labelOn: [InputFlags.None, "p-label-on", "labelOn"] }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoSwitchComponent),
      multi: true
    }
  ]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature], decls: 10, vars: 14, consts: [[3, "p-disabled", "p-id", "p-label"], [1, "po-field-container-content"], [1, "po-switch"], ["role", "switch", 1, "po-switch-container", 3, "id", "tabindex", "blur", "click", "keydown"], ["switchContainer", ""], [1, "po-switch-track"], [1, "po-switch-toggle"], ["class", "po-switch-icon", "p-icon", "po-icon-ok", 4, "ngIf"], ["class", "po-switch-label", 3, "p-disabled", "p-label", "click", 4, "ngIf"], [3, "p-help", "p-disabled"], ["p-icon", "po-icon-ok", 1, "po-switch-icon"], [1, "po-switch-label", 3, "p-disabled", "p-label", "click"]], template: function PoSwitchComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3, 4);
      ɵɵlistener("blur", function PoSwitchComponent_Template_div_blur_3_listener() {
        return ctx.onBlur();
      })("click", function PoSwitchComponent_Template_div_click_3_listener() {
        return ctx.eventClick();
      })("keydown", function PoSwitchComponent_Template_div_keydown_3_listener($event) {
        return ctx.onKeyDown($event);
      });
      ɵɵelementStart(5, "div", 5)(6, "div", 6);
      ɵɵtemplate(7, PoSwitchComponent_po_icon_7_Template, 1, 0, "po-icon", 7);
      ɵɵelementEnd()()();
      ɵɵtemplate(8, PoSwitchComponent_po_label_8_Template, 1, 2, "po-label", 8);
      ɵɵelementEnd()();
      ɵɵelement(9, "po-field-container-bottom", 9);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label);
      ɵɵadvance();
      ɵɵattribute("name", ctx.name);
      ɵɵadvance();
      ɵɵattribute("data-label-position", ctx.getLabelPosition());
      ɵɵadvance();
      ɵɵproperty("id", ctx.id)("tabindex", ctx.disabled ? -1 : 0);
      ɵɵattribute("aria-checked", ctx.value)("aria-disabled", ctx.disabled);
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.value === true ? ctx.labelOn : ctx.labelOff);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.value === true);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.label);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, dependencies: [NgIf, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoLabelComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSwitchComponent, [{
    type: Component,
    args: [{ selector: "po-switch", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoSwitchComponent),
        multi: true
      }
    ], template: '<po-field-container [p-disabled]="disabled" [p-id]="id" [p-label]="label">\n  <div class="po-field-container-content" [attr.name]="name">\n    <div class="po-switch" [attr.data-label-position]="getLabelPosition()">\n      <div\n        #switchContainer\n        class="po-switch-container"\n        role="switch"\n        [attr.aria-checked]="value"\n        [attr.aria-disabled]="disabled"\n        [id]="id"\n        [tabindex]="disabled ? -1 : 0"\n        (blur)="onBlur()"\n        (click)="eventClick()"\n        (keydown)="onKeyDown($event)"\n      >\n        <div class="po-switch-track">\n          <div class="po-switch-toggle" [attr.aria-label]="value === true ? labelOn : labelOff">\n            <po-icon *ngIf="value === true" class="po-switch-icon" p-icon="po-icon-ok"></po-icon>\n          </div>\n        </div>\n      </div>\n\n      <po-label\n        *ngIf="label"\n        class="po-switch-label"\n        [p-disabled]="disabled"\n        [p-label]="value === true ? labelOn : labelOff"\n        (click)="eventClick()"\n      >\n      </po-label>\n    </div>\n  </div>\n\n  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>\n</po-field-container>\n' }]
  }], () => [{ type: ChangeDetectorRef }], { switchContainer: [{
    type: ViewChild,
    args: ["switchContainer", { static: true }]
  }], value: [{
    type: Input,
    args: [{ alias: "p-value", transform: convertToBoolean }]
  }], formatModel: [{
    type: Input,
    args: [{ alias: "p-format-model", transform: convertToBoolean }]
  }], labelPosition: [{
    type: Input,
    args: ["p-label-position"]
  }], labelOff: [{
    type: Input,
    args: ["p-label-off"]
  }], labelOn: [{
    type: Input,
    args: ["p-label-on"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSwitchComponent, { className: "PoSwitchComponent", filePath: "lib/components/po-field/po-switch/po-switch.component.ts", lineNumber: 105 });
})();
function PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c0$X = (a0) => ({ $implicit: a0 });
function PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "li", 8);
    ɵɵtemplate(2, PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r9 = ɵɵnextContext().$implicit;
    const ctx_r10 = ɵɵnextContext(2);
    const _r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵclassProp("po-checkbox-group-item-disabled", option_r9.disabled || ctx_r10.disabled);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r3)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c0$X, option_r9));
  }
}
function PoTableListManagerComponent_section_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableListManagerComponent_section_0_ng_container_3_ng_container_1_Template, 3, 6, "ng-container", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r9 = ctx.$implicit;
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r8.isFixed(option_r9));
  }
}
function PoTableListManagerComponent_section_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "section", 1)(1, "p", 2);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, PoTableListManagerComponent_section_0_ng_container_3_Template, 2, 1, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.literals.fixedColumns);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.checkboxGroupOptionsView)("ngForTrackBy", ctx_r0.trackByFn);
  }
}
function PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r13 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext();
    const _r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r3)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c0$X, option_r13));
  }
}
function PoTableListManagerComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "li", 8);
    ɵɵtemplate(2, PoTableListManagerComponent_ng_container_4_ng_container_1_ng_container_2_Template, 2, 4, "ng-container", 7);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r13 = ɵɵnextContext().$implicit;
    const ctx_r14 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-checkbox-group-item-disabled", option_r13.disabled || ctx_r14.disabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r14.isFixed(option_r13));
  }
}
function PoTableListManagerComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableListManagerComponent_ng_container_4_ng_container_1_Template, 3, 3, "ng-container", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const option_r13 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isFixed(option_r13));
  }
}
function PoTableListManagerComponent_ng_template_5_po_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 18);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_po_button_6_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r23);
      const option_r19 = ɵɵnextContext().$implicit;
      const ctx_r21 = ɵɵnextContext();
      return ɵɵresetView(ctx_r21.emitFixed(option_r19));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r19 = ɵɵnextContext().$implicit;
    const ctx_r20 = ɵɵnextContext();
    const _r7 = ɵɵreference(10);
    const _r5 = ɵɵreference(8);
    ɵɵproperty("p-icon", ctx_r20.isFixed(option_r19) ? _r7 : _r5)("p-disabled", !option_r19.visible || ctx_r20.checksIfHasFiveFixed(option_r19));
  }
}
function PoTableListManagerComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r26 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10)(1, "div", 11)(2, "po-switch", 12);
    ɵɵlistener("p-change", function PoTableListManagerComponent_ng_template_5_Template_po_switch_p_change_2_listener() {
      const restoredCtx = ɵɵrestoreView(_r26);
      const option_r19 = restoredCtx.$implicit;
      const ctx_r25 = ɵɵnextContext();
      return ɵɵresetView(ctx_r25.clickSwitch(option_r19));
    })("keydown", function PoTableListManagerComponent_ng_template_5_Template_po_switch_keydown_2_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r26);
      const option_r19 = restoredCtx.$implicit;
      const ctx_r27 = ɵɵnextContext();
      return ɵɵresetView(ctx_r27.onKeyDown($event, option_r19));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 13);
    ɵɵtext(4);
    ɵɵelementEnd()();
    ɵɵelementStart(5, "div", 14);
    ɵɵtemplate(6, PoTableListManagerComponent_ng_template_5_po_button_6_Template, 1, 2, "po-button", 15);
    ɵɵelementStart(7, "po-button", 16);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_Template_po_button_p_click_7_listener() {
      const restoredCtx = ɵɵrestoreView(_r26);
      const option_r19 = restoredCtx.$implicit;
      const ctx_r28 = ɵɵnextContext();
      return ɵɵresetView(ctx_r28.emitChangePosition(option_r19, "up"));
    });
    ɵɵelementEnd();
    ɵɵelementStart(8, "po-button", 17);
    ɵɵlistener("p-click", function PoTableListManagerComponent_ng_template_5_Template_po_button_p_click_8_listener() {
      const restoredCtx = ɵɵrestoreView(_r26);
      const option_r19 = restoredCtx.$implicit;
      const ctx_r29 = ɵɵnextContext();
      return ɵɵresetView(ctx_r29.emitChangePosition(option_r19, "down"));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const option_r19 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("p-disabled", option_r19.disabled || ctx_r2.disabled || ctx_r2.isFixed(option_r19))("p-value", ctx_r2.checkedOptions[option_r19.value]);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", option_r19.label, " ");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r2.hideActionFixedColumns);
    ɵɵadvance();
    ɵɵproperty("p-tooltip", ctx_r2.literals.up)("p-disabled", ctx_r2.verifyArrowDisabled(option_r19, "up") || ctx_r2.isFixed(option_r19));
    ɵɵadvance();
    ɵɵproperty("p-tooltip", ctx_r2.literals.down)("p-disabled", ctx_r2.verifyArrowDisabled(option_r19, "down") || ctx_r2.isFixed(option_r19));
  }
}
function PoTableListManagerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 19)(1, "g", 20);
    ɵɵelement(2, "path", 21);
    ɵɵelementEnd();
    ɵɵelementStart(3, "defs")(4, "clipPath", 22);
    ɵɵelement(5, "rect", 23);
    ɵɵelementEnd()()();
  }
}
function PoTableListManagerComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 19)(1, "g", 24);
    ɵɵelement(2, "path", 25);
    ɵɵelementEnd();
    ɵɵelementStart(3, "defs")(4, "clipPath", 26);
    ɵɵelement(5, "rect", 27);
    ɵɵelementEnd()()();
  }
}
var poTableListManagerLiterals = {
  en: {
    up: "up",
    down: "down",
    otherColumns: "Other columns",
    fixedColumns: "Fixed"
  },
  es: {
    up: "arriba",
    down: "abajo",
    otherColumns: "Otras columnas",
    fixedColumns: "Fijado"
  },
  pt: {
    up: "acima",
    down: "abaixo",
    otherColumns: "Outras colunas",
    fixedColumns: "Fixo"
  },
  ru: {
    up: "вверх",
    down: "вниз",
    otherColumns: "Другие столбцы",
    fixedColumns: "зафиксированный"
  }
};
var PoTableListManagerComponent = class _PoTableListManagerComponent extends PoCheckboxGroupComponent {
  changePosition = new EventEmitter();
  changeColumnFixed = new EventEmitter();
  columnsManager;
  hideActionFixedColumns = false;
  literals;
  constructor(languageService, changeDetector) {
    super(changeDetector);
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues(__spreadValues({}, poTableListManagerLiterals[poLocaleDefault]), poTableListManagerLiterals[language]);
  }
  emitChangePosition(option, direction) {
    if (!this.isFixed(option)) {
      const infoPosition = { option, direction };
      const hasDisabled = this.verifyArrowDisabled(option, direction);
      if (!hasDisabled) {
        this.changePosition.emit(infoPosition);
      }
    }
  }
  verifyArrowDisabled(option, direction) {
    const index = this.columnsManager.findIndex((el) => el.property === option.value);
    const existsDetail = this.columnsManager.some(function(el) {
      return el.property === "detail";
    });
    const valueSubtraction = existsDetail ? 2 : 1;
    if (index === 0 && direction === "up") {
      return true;
    }
    if (index !== 0 && direction === "up" && this.columnsManager[index - 1].fixed) {
      return true;
    }
    if (index === this.columnsManager.length - valueSubtraction && direction === "down") {
      return true;
    }
    return false;
  }
  emitFixed(option) {
    if (option.visible) {
      const index = this.columnsManager.findIndex((el) => el.property === option.value);
      if (this.columnsManager[index].fixed === null || this.columnsManager[index].fixed === void 0 || this.columnsManager[index].fixed === false) {
        this.columnsManager[index].fixed = true;
        option.fixed = true;
      } else {
        this.columnsManager[index].fixed = false;
        option.fixed = false;
      }
      this.changeColumnFixed.emit(option);
    }
  }
  isFixed(option) {
    const index = this.columnsManager.findIndex((el) => el.property === option.value);
    if (this.columnsManager[index].fixed === true) {
      return true;
    }
    return false;
  }
  existedFixedItem() {
    return this.columnsManager.some((option) => option["fixed"] === true);
  }
  checksIfHasFiveFixed(option) {
    const isMoreThanFive = this.columnsManager.filter((item) => item.fixed === true).length > 4;
    const isNotFixed = !this.isFixed(option);
    return isMoreThanFive && isNotFixed;
  }
  clickSwitch(option) {
    this.checkOption(option);
  }
  static ɵfac = function PoTableListManagerComponent_Factory(t) {
    return new (t || _PoTableListManagerComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableListManagerComponent, selectors: [["po-table-list-manager"]], inputs: { columnsManager: [InputFlags.None, "p-columns-manager", "columnsManager"], hideActionFixedColumns: [InputFlags.HasDecoratorInputTransform, "p-hide-action-fixed-columns", "hideActionFixedColumns", convertToBoolean] }, outputs: { changePosition: "p-change-position", changeColumnFixed: "p-change-fixed" }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoTableListManagerComponent),
      multi: true
    }
  ]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature], decls: 11, vars: 4, consts: [["class", "po-table-list-manager-section", 4, "ngIf"], [1, "po-table-list-manager-section"], [1, "po-table-list-manager-title-group-items"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["listItemsManagerDefault", ""], ["templateIconNotFixed", ""], ["templateIconFixed", ""], [4, "ngIf"], [1, "po-table-list-manager-container"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-table-list-manager-item"], [1, "po-table-list-manager-item-switch"], ["name", "switch", "p-label-off", " ", "p-label-on", " ", 3, "p-disabled", "p-value", "p-change", "keydown"], [1, "po-table-list-manager-item-text"], [1, "po-table-list-manager-item-buttons"], [3, "p-icon", "p-disabled", "p-click", 4, "ngIf"], ["p-tooltip-position", "left", "p-icon", "po-icon po-icon-arrow-up", 3, "p-tooltip", "p-disabled", "p-click"], ["p-tooltip-position", "top", "p-icon", "po-icon po-icon-arrow-down", 3, "p-tooltip", "p-disabled", "p-click"], [3, "p-icon", "p-disabled", "p-click"], ["xmlns", "http://www.w3.org/2000/svg", "width", "24", "height", "24", "viewBox", "0 0 24 24", "fill", "none"], ["clip-path", "url(#clip0_12562_15948)"], ["d", "M13.7143 5.71429V10C13.7143 10.96 14.0314 11.8514 14.5714 12.5714H9.42857C9.98571 11.8343 10.2857 10.9429 10.2857 10V5.71429H13.7143ZM16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z", "fill", "black"], ["id", "clip0_12562_15948"], ["width", "24", "height", "24", "fill", "white"], ["clip-path", "url(#clip0_12562_17487)"], ["d", "M16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z", "fill", "#B4B4C0"], ["id", "clip0_12562_17487"], ["width", "24", "height", "24", "fill", "black"]], template: function PoTableListManagerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoTableListManagerComponent_section_0_Template, 4, 3, "section", 0);
      ɵɵelementStart(1, "section", 1)(2, "p", 2);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵtemplate(4, PoTableListManagerComponent_ng_container_4_Template, 2, 1, "ng-container", 3);
      ɵɵelementEnd();
      ɵɵtemplate(5, PoTableListManagerComponent_ng_template_5_Template, 9, 8, "ng-template", null, 4, ɵɵtemplateRefExtractor)(7, PoTableListManagerComponent_ng_template_7_Template, 6, 0, "ng-template", null, 5, ɵɵtemplateRefExtractor)(9, PoTableListManagerComponent_ng_template_9_Template, 6, 0, "ng-template", null, 6, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.existedFixedItem());
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.literals.otherColumns);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.checkboxGroupOptionsView)("ngForTrackBy", ctx.trackByFn);
    }
  }, dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoButtonComponent, PoTooltipDirective, PoSwitchComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableListManagerComponent, [{
    type: Component,
    args: [{ selector: "po-table-list-manager", providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoTableListManagerComponent),
        multi: true
      }
    ], template: `<section class="po-table-list-manager-section" *ngIf="existedFixedItem()">
  <p class="po-table-list-manager-title-group-items">{{ literals.fixedColumns }}</p>
  <ng-container *ngFor="let option of checkboxGroupOptionsView; trackBy: trackByFn">
    <ng-container *ngIf="isFixed(option)">
      <li class="po-table-list-manager-container" [class.po-checkbox-group-item-disabled]="option.disabled || disabled">
        <ng-container *ngTemplateOutlet="listItemsManagerDefault; context: { $implicit: option }"></ng-container>
      </li>
    </ng-container>
  </ng-container>
</section>

<section class="po-table-list-manager-section">
  <p class="po-table-list-manager-title-group-items">{{ literals.otherColumns }}</p>
  <ng-container *ngFor="let option of checkboxGroupOptionsView; trackBy: trackByFn">
    <ng-container *ngIf="!isFixed(option)">
      <li class="po-table-list-manager-container" [class.po-checkbox-group-item-disabled]="option.disabled || disabled">
        <ng-container *ngIf="!isFixed(option)">
          <ng-container *ngTemplateOutlet="listItemsManagerDefault; context: { $implicit: option }"></ng-container>
        </ng-container>
      </li>
    </ng-container>
  </ng-container>
</section>

<ng-template #listItemsManagerDefault let-option>
  <div class="po-table-list-manager-item">
    <div class="po-table-list-manager-item-switch">
      <po-switch
        name="switch"
        (p-change)="clickSwitch(option)"
        (keydown)="onKeyDown($event, option)"
        [p-disabled]="option.disabled || disabled || isFixed(option)"
        [p-value]="checkedOptions[option.value]"
        p-label-off=" "
        p-label-on=" "
      >
      </po-switch>
      <span class="po-table-list-manager-item-text">
        {{ option.label }}
      </span>
    </div>

    <div class="po-table-list-manager-item-buttons">
      <po-button
        *ngIf="!hideActionFixedColumns"
        [p-icon]="isFixed(option) ? templateIconFixed : templateIconNotFixed"
        (p-click)="emitFixed(option)"
        [p-disabled]="!option.visible || checksIfHasFiveFixed(option)"
      >
      </po-button>

      <po-button
        [p-tooltip]="literals.up"
        p-tooltip-position="left"
        p-icon="po-icon po-icon-arrow-up"
        [p-disabled]="verifyArrowDisabled(option, 'up') || isFixed(option)"
        (p-click)="emitChangePosition(option, 'up')"
      >
      </po-button>

      <po-button
        [p-tooltip]="literals.down"
        p-tooltip-position="top"
        p-icon="po-icon po-icon-arrow-down"
        [p-disabled]="verifyArrowDisabled(option, 'down') || isFixed(option)"
        (p-click)="emitChangePosition(option, 'down')"
      >
      </po-button>
    </div>
  </div>
</ng-template>

<ng-template #templateIconNotFixed>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
    <g clip-path="url(#clip0_12562_15948)">
      <path
        d="M13.7143 5.71429V10C13.7143 10.96 14.0314 11.8514 14.5714 12.5714H9.42857C9.98571 11.8343 10.2857 10.9429 10.2857 10V5.71429H13.7143ZM16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z"
        fill="black"
      />
    </g>
    <defs>
      <clipPath id="clip0_12562_15948">
        <rect width="24" height="24" fill="white" />
      </clipPath>
    </defs>
  </svg>
</ng-template>

<ng-template #templateIconFixed>
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
    <g clip-path="url(#clip0_12562_17487)">
      <path
        d="M16.2857 4H7.71429C7.24286 4 6.85714 4.38571 6.85714 4.85714C6.85714 5.32857 7.24286 5.71429 7.71429 5.71429H8.57143V10C8.57143 11.4229 7.42286 12.5714 6 12.5714V14.2857H11.1171V20.2857L11.9743 21.1429L12.8314 20.2857V14.2857H18V12.5714C16.5771 12.5714 15.4286 11.4229 15.4286 10V5.71429H16.2857C16.7571 5.71429 17.1429 5.32857 17.1429 4.85714C17.1429 4.38571 16.7571 4 16.2857 4Z"
        fill="#B4B4C0"
      />
    </g>
    <defs>
      <clipPath id="clip0_12562_17487">
        <rect width="24" height="24" fill="black" />
      </clipPath>
    </defs>
  </svg>
</ng-template>
` }]
  }], () => [{ type: PoLanguageService }, { type: ChangeDetectorRef }], { changePosition: [{
    type: Output,
    args: ["p-change-position"]
  }], changeColumnFixed: [{
    type: Output,
    args: ["p-change-fixed"]
  }], columnsManager: [{
    type: Input,
    args: ["p-columns-manager"]
  }], hideActionFixedColumns: [{
    type: Input,
    args: [{ alias: "p-hide-action-fixed-columns", transform: convertToBoolean }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableListManagerComponent, { className: "PoTableListManagerComponent", filePath: "lib/components/po-table/po-table-list-manager/po-table-list-manager.component.ts", lineNumber: 50 });
})();
var _c0$W = ["pageSlideColumnsManager"];
var PoTableColumnManagerMaxColumnsDefault = 99999;
var poTableColumnManagerLiteralsDefault = {
  en: {
    columnsManager: "Columns manager",
    restoreDefault: "Restore default"
  },
  es: {
    columnsManager: "Gerente de columna",
    restoreDefault: "Restaurar por defecto"
  },
  pt: {
    columnsManager: "Gerenciador de colunas",
    restoreDefault: "Restaurar padrão"
  },
  ru: {
    columnsManager: "менеджер колонок",
    restoreDefault: "сброс настроек"
  }
};
var PoTableColumnManagerComponent = class _PoTableColumnManagerComponent {
  renderer;
  popover;
  pageSlideColumnsManager;
  columns = [];
  target;
  colunsDefault;
  lastVisibleColumnsSelected = [];
  visibleColumnsChange = new EventEmitter();
  // Evento disparado ao fechar o popover do gerenciador de colunas após alterar as colunas visíveis.
  // O po-table envia como parâmetro um array de string com as colunas visíveis atualizadas. Por exemplo: ["idCard", "name", "hireStatus", "age"].
  changeVisibleColumns = new EventEmitter();
  initialColumns = new EventEmitter();
  hideActionFixedColumns = false;
  literals;
  columnsOptions = [];
  visibleColumns = [];
  columnUpdate;
  _maxColumns = PoTableColumnManagerMaxColumnsDefault;
  defaultColumns = [];
  resizeListener;
  restoreDefaultEvent;
  lastEmittedValue;
  minColumns = 1;
  set maxColumns(value) {
    this._maxColumns = convertToInt(value, PoTableColumnManagerMaxColumnsDefault);
  }
  get maxColumns() {
    return this._maxColumns;
  }
  constructor(renderer, languageService) {
    this.renderer = renderer;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues(__spreadValues({}, poTableColumnManagerLiteralsDefault[poLocaleDefault]), poTableColumnManagerLiteralsDefault[language]);
  }
  ngOnChanges(changes) {
    const { columns, maxColumns, target, lastVisibleColumnsSelected } = changes;
    if (target && target.firstChange) {
      this.initializeListeners();
    }
    if (columns) {
      this.onChangeColumns(columns);
    }
    if (maxColumns) {
      this.updateValues(this.columns);
    }
    if (lastVisibleColumnsSelected?.currentValue) {
      this.pageSlideColumnsManager.open();
    }
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  // aqui chegam os eventos do checkbox e do close do popover que também é disparado no resize
  checkChanges(event = [], emit = false) {
    this.verifyToEmitChange(event);
    if (emit) {
      this.verifyToEmitVisibleColumns();
    }
  }
  restore() {
    this.restoreDefaultEvent = true;
    this.defaultColumns = this.removePropertyFixed(this.defaultColumns);
    const defaultColumns = this.getVisibleColumns(this.defaultColumns);
    this.initialColumns.emit(this.getVisibleColumns(this.colunsDefault));
    this.checkChanges(defaultColumns, this.restoreDefaultEvent);
  }
  changePosition({ option, direction }) {
    const indexColumn = this.columns.findIndex((el) => el.property === option.value);
    const newColumn = [...this.columns];
    this.changePositionColumn(newColumn, indexColumn, direction);
    this.columns = newColumn;
    this.visibleColumnsChange.emit(this.columns);
  }
  emitColumnFixed(option) {
    const newColumn = [...this.columns];
    if (option) {
      newColumn.forEach((itemColumn) => {
        if (itemColumn.property === option.value) {
          itemColumn.fixed = option.fixed;
        }
      });
      const amountOfFixed = newColumn.filter((itemFixed) => itemFixed.fixed === true).length;
      const indexColumn = newColumn.findIndex((el) => el.property === option.value);
      const item = newColumn.splice(indexColumn, 1)[0];
      if (option.fixed) {
        newColumn.splice(amountOfFixed - 1, 0, item);
      }
      if (option.fixed === false) {
        newColumn.splice(amountOfFixed, 0, item);
      }
      this.columns = [...newColumn];
    }
    this.visibleColumnsChange.emit(newColumn);
  }
  changePositionColumn(array, index, direction) {
    if (direction === "up") {
      array.splice(index, 0, array.splice(index - 1, 1)[0]);
    }
    if (direction === "down") {
      array.splice(index, 0, array.splice(index + 1, 1)[0]);
    }
  }
  verifyToEmitChange(event) {
    const newColumns = [...event];
    if (newColumns.length >= 1 && this.allowsChangeVisibleColumns()) {
      this.emitChangesToSelectedColumns(newColumns);
    }
    if (newColumns.length === 1) {
      const columnsOptions = this.mapTableColumnsToCheckboxOptions(this.columnUpdate);
      this.columnsOptions = this.disabledLastColumn(columnsOptions);
    }
  }
  emitChangesToSelectedColumns(newColumns) {
    this.visibleColumns = [...newColumns];
    const visibleTableColumns = this.getVisibleTableColumns(this.visibleColumns);
    this.visibleColumnsChange.emit(visibleTableColumns);
  }
  allowsChangeVisibleColumns() {
    const visibleTableColumns = this.getVisibleTableColumns(this.visibleColumns);
    return this.stringify(visibleTableColumns) !== this.stringify(this.columns);
  }
  verifyToEmitVisibleColumns() {
    if (this.restoreDefaultEvent) {
      this.verifyRestoreValues();
    } else {
      this.verifyOnClose();
    }
  }
  verifyRestoreValues() {
    const defaultColumns = [...this.defaultColumns];
    const defaultVisibleColumns = this.getVisibleColumns(defaultColumns);
    if (this.allowsChangeSelectedColumns(defaultVisibleColumns)) {
      this.visibleColumnsChange.emit(this.defaultColumns);
    }
    this.restoreDefaultEvent = false;
  }
  allowsChangeSelectedColumns(defaultVisibleColumns) {
    const visibleColumns = this.getVisibleColumns(this.columns);
    return !this.isEqualArrays(defaultVisibleColumns, visibleColumns);
  }
  verifyOnClose() {
    if (this.allowsEmission()) {
      this.emitVisibleColumns();
    }
  }
  emitVisibleColumns() {
    this.lastEmittedValue = [...this.visibleColumns];
    this.changeVisibleColumns.emit(this.visibleColumns);
  }
  allowsEmission() {
    const updatedVisibleColumns = this.visibleColumns ? [...this.visibleColumns] : [];
    const lastEmittedValue = this.lastEmittedValue ? [...this.lastEmittedValue] : [];
    const lastVisibleColumnsSelected = this.lastVisibleColumnsSelected ? [...this.lastVisibleColumnsSelected] : [];
    const lastVisibleColumns = this.getVisibleColumns(lastVisibleColumnsSelected);
    return this.isUpdate(updatedVisibleColumns, lastEmittedValue) || this.isFirstTime(updatedVisibleColumns, lastVisibleColumns);
  }
  isFirstTime(updatedVisibleColumns, lastVisibleColumns) {
    return !this.lastEmittedValue && !this.isEqualArrays(updatedVisibleColumns, lastVisibleColumns);
  }
  isUpdate(updatedVisibleColumns, lastEmittedValue) {
    return this.lastEmittedValue && !this.isEqualArrays(updatedVisibleColumns, lastEmittedValue);
  }
  isEqualArrays(first, second) {
    const one = first ? [...first] : [];
    const two = second ? [...second] : [];
    const firstSort = one.slice();
    const secondSort = two.slice();
    const firstString = JSON.stringify(firstSort);
    const secondString = JSON.stringify(secondSort);
    return firstString === secondString;
  }
  // desabilitará as colunas, que não estiverem selecionadas, após exeder o numero maximo de colunas.
  disableColumnsOptions(columns = []) {
    return columns.map((column) => __spreadProps(__spreadValues({}, column), {
      disabled: this.isDisableColumn(column.value)
    }));
  }
  getColumnTitleLabel(column) {
    return column.label || capitalizeFirstLetter(column.property);
  }
  /** Retorna um Array de column.property das colunas que são visiveis. */
  getVisibleColumns(columns) {
    let visibleColumns = [];
    columns.forEach((column) => {
      if (this.isVisibleColumn(column, visibleColumns)) {
        visibleColumns = [...visibleColumns, column.property];
      }
    });
    return visibleColumns;
  }
  isVisibleColumn(column, visibleColumns) {
    return column.visible !== false && visibleColumns.length < this.maxColumns && column.type !== "detail";
  }
  /** Retorna um Array PoTableColumn a partir das colunas visiveis no gerenciador de colunas. */
  getVisibleTableColumns(visibleColumns) {
    const columns = this.columns ? [...this.columns] : [];
    return columns.map((column) => __spreadProps(__spreadValues({}, column), {
      visible: visibleColumns.includes(column.property) || column.type === "detail"
    }));
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      if (this.popover && !this.popover.isHidden) {
        this.popover.close();
      }
    });
  }
  isDisableColumn(property) {
    return this.visibleColumns.length >= this.maxColumns ? !this.visibleColumns.includes(property) : false;
  }
  mapTableColumnsToCheckboxOptions(columns = []) {
    const tableColumns = [...columns];
    const columnsOptions = [];
    tableColumns.forEach((column) => {
      if (column.type !== "detail") {
        columnsOptions.push({
          value: column.property,
          label: this.getColumnTitleLabel(column),
          disabled: this.isDisableColumn(column.property),
          visible: column.visible
        });
      }
    });
    return columnsOptions;
  }
  disabledLastColumn(columns) {
    return columns.map((column) => __spreadProps(__spreadValues({}, column), {
      disabled: column.type !== "detail" && column.visible ? true : false
    }));
  }
  onChangeColumns(columns) {
    const { currentValue = [], previousValue = [] } = columns;
    this.columnUpdate = columns.currentValue;
    if (!this.lastVisibleColumnsSelected && this.stringify(this.defaultColumns) !== this.stringify(currentValue)) {
      this.defaultColumns = [...currentValue];
    }
    if (this.stringify(previousValue) !== this.stringify(currentValue)) {
      this.updateValues(currentValue);
    }
  }
  updateValues(currentValue) {
    const visibleColumns = this.getVisibleColumns(currentValue);
    this.visibleColumns = [...visibleColumns];
    const columnsOptions = this.mapTableColumnsToCheckboxOptions(currentValue);
    this.columnsOptions = this.disableColumnsOptions(columnsOptions);
    this.checkChanges(visibleColumns, false);
  }
  removeListeners() {
    if (this.resizeListener) {
      this.resizeListener();
    }
  }
  stringify(columns) {
    return JSON.stringify(columns, (key, value) => {
      if (key !== "icon" && key !== "searchService") {
        return value;
      }
    });
  }
  removePropertyFixed(arr) {
    return arr.map((obj) => {
      if (obj.hasOwnProperty("fixed")) {
        obj.fixed = false;
      }
      return obj;
    });
  }
  static ɵfac = function PoTableColumnManagerComponent_Factory(t) {
    return new (t || _PoTableColumnManagerComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableColumnManagerComponent, selectors: [["po-table-column-manager"]], viewQuery: function PoTableColumnManagerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoPopoverComponent, 5);
      ɵɵviewQuery(_c0$W, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popover = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageSlideColumnsManager = _t.first);
    }
  }, inputs: { columns: [InputFlags.None, "p-columns", "columns"], target: [InputFlags.None, "p-target", "target"], colunsDefault: [InputFlags.None, "p-columns-default", "colunsDefault"], lastVisibleColumnsSelected: [InputFlags.None, "p-last-visible-columns-selected", "lastVisibleColumnsSelected"], hideActionFixedColumns: [InputFlags.HasDecoratorInputTransform, "p-hide-action-fixed-columns", "hideActionFixedColumns", convertToBoolean], maxColumns: [InputFlags.None, "p-max-columns", "maxColumns"] }, outputs: { visibleColumnsChange: "p-visible-columns-change", changeVisibleColumns: "p-change-visible-columns", initialColumns: "p-initial-columns" }, features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature], decls: 7, vars: 7, consts: [["p-size", "auto", 3, "p-title", "p-click-out", "p-close"], ["pageSlideColumnsManager", ""], [1, "po-table-column-manager-body"], ["name", "visibleColumns", "p-columns", "1", 3, "ngModel", "p-options", "p-hide-action-fixed-columns", "p-columns-manager", "ngModelChange", "p-change", "p-change-position", "p-change-fixed"], [1, "po-table-column-manager-footer"], ["p-kind", "tertiary", 1, "po-table-column-manager-footer-restore", 3, "p-label", "p-click"]], template: function PoTableColumnManagerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-page-slide", 0, 1);
      ɵɵlistener("p-close", function PoTableColumnManagerComponent_Template_po_page_slide_p_close_0_listener() {
        return ctx.checkChanges([], true);
      });
      ɵɵelementStart(2, "div")(3, "div", 2)(4, "po-table-list-manager", 3);
      ɵɵtwoWayListener("ngModelChange", function PoTableColumnManagerComponent_Template_po_table_list_manager_ngModelChange_4_listener($event) {
        ɵɵtwoWayBindingSet(ctx.visibleColumns, $event) || (ctx.visibleColumns = $event);
        return $event;
      });
      ɵɵlistener("p-change", function PoTableColumnManagerComponent_Template_po_table_list_manager_p_change_4_listener($event) {
        return ctx.checkChanges($event, false);
      })("p-change-position", function PoTableColumnManagerComponent_Template_po_table_list_manager_p_change_position_4_listener($event) {
        return ctx.changePosition($event);
      })("p-change-fixed", function PoTableColumnManagerComponent_Template_po_table_list_manager_p_change_fixed_4_listener($event) {
        return ctx.emitColumnFixed($event);
      });
      ɵɵelementEnd()();
      ɵɵelementStart(5, "div", 4)(6, "po-button", 5);
      ɵɵlistener("p-click", function PoTableColumnManagerComponent_Template_po_button_p_click_6_listener() {
        return ctx.restore();
      });
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵproperty("p-title", ctx.literals.columnsManager)("p-click-out", true);
      ɵɵadvance(4);
      ɵɵtwoWayProperty("ngModel", ctx.visibleColumns);
      ɵɵproperty("p-options", ctx.columnsOptions)("p-hide-action-fixed-columns", ctx.hideActionFixedColumns)("p-columns-manager", ctx.columns);
      ɵɵadvance(2);
      ɵɵproperty("p-label", ctx.literals.restoreDefault);
    }
  }, dependencies: [NgControlStatus, NgModel, PoButtonComponent, PoPageSlideComponent, PoTableListManagerComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnManagerComponent, [{
    type: Component,
    args: [{ selector: "po-table-column-manager", template: '<po-page-slide\n  #pageSlideColumnsManager\n  p-size="auto"\n  [p-title]="literals.columnsManager"\n  [p-click-out]="true"\n  (p-close)="checkChanges([], true)"\n>\n  <div>\n    <div class="po-table-column-manager-body">\n      <po-table-list-manager\n        name="visibleColumns"\n        [(ngModel)]="visibleColumns"\n        p-columns="1"\n        [p-options]="columnsOptions"\n        [p-hide-action-fixed-columns]="hideActionFixedColumns"\n        (p-change)="checkChanges($event, false)"\n        (p-change-position)="changePosition($event)"\n        (p-change-fixed)="emitColumnFixed($event)"\n        [p-columns-manager]="columns"\n      >\n      </po-table-list-manager>\n    </div>\n\n    <div class="po-table-column-manager-footer">\n      <po-button\n        class="po-table-column-manager-footer-restore"\n        p-kind="tertiary"\n        [p-label]="literals.restoreDefault"\n        (p-click)="restore()"\n      >\n      </po-button>\n    </div>\n  </div>\n</po-page-slide>\n' }]
  }], () => [{ type: Renderer2 }, { type: PoLanguageService }], { popover: [{
    type: ViewChild,
    args: [PoPopoverComponent]
  }], pageSlideColumnsManager: [{
    type: ViewChild,
    args: ["pageSlideColumnsManager"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }], target: [{
    type: Input,
    args: ["p-target"]
  }], colunsDefault: [{
    type: Input,
    args: ["p-columns-default"]
  }], lastVisibleColumnsSelected: [{
    type: Input,
    args: ["p-last-visible-columns-selected"]
  }], visibleColumnsChange: [{
    type: Output,
    args: ["p-visible-columns-change"]
  }], changeVisibleColumns: [{
    type: Output,
    args: ["p-change-visible-columns"]
  }], initialColumns: [{
    type: Output,
    args: ["p-initial-columns"]
  }], hideActionFixedColumns: [{
    type: Input,
    args: [{ alias: "p-hide-action-fixed-columns", transform: convertToBoolean }]
  }], maxColumns: [{
    type: Input,
    args: ["p-max-columns"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableColumnManagerComponent, { className: "PoTableColumnManagerComponent", filePath: "lib/components/po-table/po-table-column-manager/po-table-column-manager.component.ts", lineNumber: 50 });
})();
var PoNotificationBaseService = class {
  // Array responsável por guardar a instância de po-toaster's superiores.
  stackTop = [];
  // Array responsável por guardar a instância de po-toaster's inferiores.
  stackBottom = [];
  // Duração da notificação ativa.
  defaultDuration = 9e3;
  /**
   * Emite uma notificação de sucesso.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação.
   */
  success(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Success));
  }
  /**
   * Emite uma notificação de atenção.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação
   */
  warning(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Warning));
  }
  /**
   * Emite uma notificação de erro.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação
   */
  error(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Error));
  }
  /**
   * Emite uma notificação de informação.
   *
   * @param {PoNotification | string} notification Objeto com os dados da notificação ou somente a string com a mensagem da notificação
   */
  information(notification) {
    this.createToaster(this.buildToaster(notification, PoToasterType.Information));
  }
  /**
   * Define em milissegundos a duração padrão para as notificações.
   *
   * > Padrão 9 segundos.
   *
   * @param {number} defaultDuration Duração em milisegundos
   */
  setDefaultDuration(defaultDuration) {
    this.defaultDuration = defaultDuration;
  }
  /**
   * @docsPrivate
   *
   * Cria um objeto do tipo PoToaster de acordo o tipo.
   *
   * @param {PoNotification | string} notification Objeto PoNotification com os dados da notificação
   */
  buildToaster(notification, type) {
    let index = 0;
    let orientation;
    if (notification.orientation === void 0 || notification.orientation === PoToasterOrientation.Bottom) {
      index = this.stackBottom.length;
      orientation = PoToasterOrientation.Bottom;
    } else {
      index = this.stackTop.length;
      orientation = PoToasterOrientation.Top;
    }
    const toaster = {
      componentRef: void 0,
      message: notification.message || notification,
      type,
      orientation,
      action: notification.action,
      actionLabel: notification.actionLabel,
      position: index,
      duration: notification.duration || this.defaultDuration
    };
    if (notification.action) {
      toaster.action = (param) => {
        notification.action();
        this.destroyToaster(param.componentRef);
      };
    }
    return toaster;
  }
};
var PoNotificationMaxLength = 5;
var PoNotificationFadeTime = 200;
var PoNotificationService = class _PoNotificationService extends PoNotificationBaseService {
  poComponentInjector;
  constructor(poComponentInjector) {
    super();
    this.poComponentInjector = poComponentInjector;
  }
  createToaster(toaster) {
    const componentRef = this.poComponentInjector.createComponentInApplication(PoToasterComponent);
    toaster.componentRef = componentRef;
    componentRef.changeDetectorRef.detectChanges();
    componentRef.instance.configToaster(toaster);
    const stack = toaster.orientation === PoToasterOrientation.Top ? this.stackTop : this.stackBottom;
    stack.push(componentRef);
    this.verifyLimitToaster(stack);
    this.observableOnClose(componentRef);
    if (!(toaster.action && toaster.actionLabel || toaster.type === PoToasterType.Error)) {
      timer(toaster.duration).pipe(takeWhile(() => componentRef.instance.alive)).subscribe(() => {
        this.destroyToaster(componentRef);
      });
    }
  }
  destroyToaster(toaster) {
    let stack;
    if (toaster.instance.orientation === PoToasterOrientation.Top) {
      stack = this.stackTop;
    } else {
      stack = this.stackBottom;
    }
    toaster.instance.setFadeOut();
    const index = stack.indexOf(toaster);
    stack.splice(index, 1);
    setTimeout(() => {
      this.poComponentInjector.destroyComponentInApplication(toaster);
      for (let count = 0; count < stack.length; count++) {
        stack[count].instance.changePosition(count);
      }
    }, PoNotificationFadeTime);
  }
  observableOnClose(componentRef) {
    componentRef.instance.observableOnClose.subscribe(() => {
      this.destroyToaster(componentRef);
    });
  }
  verifyLimitToaster(stack) {
    if (stack.length > PoNotificationMaxLength) {
      this.destroyToaster(stack[0]);
    }
  }
  static ɵfac = function PoNotificationService_Factory(t) {
    return new (t || _PoNotificationService)(ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoNotificationService, factory: _PoNotificationService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNotificationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{ type: PoComponentInjectorService }], null);
})();
var PoTableRowTemplateArrowDirection;
(function(PoTableRowTemplateArrowDirection2) {
  PoTableRowTemplateArrowDirection2["Left"] = "LEFT";
  PoTableRowTemplateArrowDirection2["Right"] = "RIGHT";
})(PoTableRowTemplateArrowDirection || (PoTableRowTemplateArrowDirection = {}));
var PoSearchFilterMode;
(function(PoSearchFilterMode2) {
  PoSearchFilterMode2[PoSearchFilterMode2["startsWith"] = 0] = "startsWith";
  PoSearchFilterMode2[PoSearchFilterMode2["contains"] = 1] = "contains";
  PoSearchFilterMode2[PoSearchFilterMode2["endsWith"] = 2] = "endsWith";
})(PoSearchFilterMode || (PoSearchFilterMode = {}));
var PoTableColumnSortType;
(function(PoTableColumnSortType2) {
  PoTableColumnSortType2["Ascending"] = "ascending";
  PoTableColumnSortType2["Descending"] = "descending";
})(PoTableColumnSortType || (PoTableColumnSortType = {}));
var PoTableColumnSpacing;
(function(PoTableColumnSpacing2) {
  PoTableColumnSpacing2["Small"] = "small";
  PoTableColumnSpacing2["Medium"] = "medium";
  PoTableColumnSpacing2["Large"] = "large";
})(PoTableColumnSpacing || (PoTableColumnSpacing = {}));
var PoTableService = class _PoTableService {
  http;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  url;
  urlDelete;
  constructor(http) {
    this.http = http;
  }
  getFilteredItems(filteredParams) {
    const params = this.validateParams(filteredParams);
    return this.http.get(this.url, { headers: this.headers, params });
  }
  deleteItem(paramDelete, paramResponse) {
    const params = {
      [paramDelete]: paramResponse
    };
    return this.http.delete(this.urlDelete, { headers: this.headers, params });
  }
  setUrl(url, method) {
    if (method === "GET") {
      this.url = url;
    } else {
      this.urlDelete = url;
    }
  }
  scrollListener(componentListner) {
    return fromEvent(componentListner, "scroll").pipe(debounceTime(100));
  }
  validateParams(params) {
    return isTypeof(params, "object") && !Array.isArray(params) ? params : void 0;
  }
  static ɵfac = function PoTableService_Factory(t) {
    return new (t || _PoTableService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoTableService, factory: _PoTableService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{ type: HttpClient }], null);
})();
var poTableContainer = ["border", "shadow"];
var poTableContainerDefault = "border";
var poTableParamDeleteApi = "id";
var poTableLiteralsDefault = {
  en: {
    noColumns: "Columns are not defined",
    noData: "No data found",
    noItem: "No selected item",
    oneItem: "1 selected item",
    multipleItems: "selected items",
    noVisibleColumn: "No visible column",
    loadingData: "Loading",
    loadMoreData: "Load more data",
    seeCompleteSubtitle: "See complete subtitle",
    completeSubtitle: "Complete subtitle",
    columnsManager: "Columns manager",
    bodyDelete: "Do you really want to delete this item?",
    cancel: "Cancel",
    delete: "Delete",
    deleteSuccessful: "Items removed successfully",
    deleteApiError: "An unexpected error occurred, please try again later"
  },
  es: {
    noColumns: "Columnas no definidas",
    noData: "Datos no encontrados",
    noItem: "Ningún elemento seleccionado",
    oneItem: "1 elemento seleccionado",
    multipleItems: "elementos seleccionados",
    noVisibleColumn: "Sin columnas visibles",
    loadingData: "Cargando datos",
    loadMoreData: "Cargar más resultados",
    seeCompleteSubtitle: "Ver subtitulo completo",
    completeSubtitle: "Subtitulo completo",
    columnsManager: "Gerente de columna",
    bodyDelete: "¿Realmente desea eliminar este elemento?",
    cancel: "Cancelar",
    delete: "Borrar",
    deleteSuccessful: "Elementos eliminados con éxito",
    deleteApiError: "Ocurrió un error inesperado, inténtalo de nuevo más tarde"
  },
  pt: {
    noColumns: "Nenhuma definição de colunas",
    noData: "Nenhum dado encontrado",
    noVisibleColumn: "Nenhuma coluna visível",
    noItem: "Nenhum item selecionado",
    oneItem: "1 item selecionado",
    multipleItems: "itens selecionados",
    loadingData: "Carregando",
    loadMoreData: "Carregar mais resultados",
    seeCompleteSubtitle: "Ver legenda completa",
    completeSubtitle: "Legenda completa",
    columnsManager: "Gerenciador de colunas",
    bodyDelete: "Deseja realmente excluir esse item?",
    cancel: "Cancelar",
    delete: "Excluir",
    deleteSuccessful: "Itens removidos com sucesso",
    deleteApiError: "Ocorreu um erro inesperado, tente novamente mais tarde!"
  },
  ru: {
    noColumns: "Нет определения столбца",
    noData: "Данные не найдены",
    noItem: "Нет выбранного элемента",
    oneItem: "1 элемент выбран",
    multipleItems: "выбранные элементы",
    noVisibleColumn: "нет видимых столбцов",
    loadingData: "Загрузка",
    loadMoreData: "Загрузка",
    seeCompleteSubtitle: "Посмотреть полный субтитр",
    completeSubtitle: "Полный заголовок",
    columnsManager: "менеджер колонок",
    bodyDelete: "Вы действительно хотите удалить этот элемент?",
    cancel: "Отмена",
    delete: "Удалить",
    deleteSuccessful: "Элементы успешно удалены",
    deleteApiError: "Произошла непредвиденная ошибка, повторите попытку позже"
  }
};
var PoTableBaseComponent = class _PoTableBaseComponent {
  poDate;
  poTableService;
  /**
   * @optional
   *
   * @description
   *
   * Permite que o gerenciador de colunas, responsável pela definição de quais colunas serão exibidas, seja escondido.
   *
   * @default `false`
   */
  hideColumnsManager = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite que as ações em lote, responsável por excluir e exibir a quantidade de itens, sejam escondidas.
   *
   * @default `true`
   */
  hideBatchActions = true;
  /**
   * @optional
   *
   * @description
   *
   * Permite que as ações para fixar uma coluna da tabela sejam escondidas.
   *
   * @default `false`
   */
  set hideActionFixedColumns(hide) {
    if (hide) {
      this.columns = this.removePropertyFixed(this.columns);
    }
    this._hideActionFixedColumns = hide;
  }
  get hideActionFixedColumns() {
    return this._hideActionFixedColumns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Permite que o campo de pesquisa seja escondido.
   *
   * @default `true`
   */
  hideTableSearch = true;
  /**
   * @optional
   *
   * @description
   *
   * Permite fechar um detalhe ou row template automaticamente, ao abrir outro item.
   *
   * @default `false`
   */
  autoCollapse = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite que seja adicionado o estado de carregamento no botão "Carregar mais resultados".
   *
   * @default `false`
   */
  loadingShowMore = false;
  /**
   * @optional
   *
   * @description
   *
   * Habilita em todas as colunas a opção de ordenação de dados. Caso a coluna seja do tipo 'data' ou 'dateTime' a
   * mesma deve respeitar os tipos de entrada definidos para que sejam ordenadas.
   *
   * @default `false`
   */
  sort = false;
  /**
   * @description
   *
   * Se verdadeiro, torna habilitado o botão "Carregar mais resultados".
   *
   * @default `false`
   */
  showMoreDisabled = false;
  /**
   * @description
   *
   * Habilita ou desabilita o estilo listrado da tabela (`striped`).
   * > Recomendado para tabelas com maior número de dados, facilitando a sua visualização na tabela.
   *
   * @default `false`
   */
  striped = false;
  /**
   * @description
   *
   * Esconde o *checkbox* para seleção de todas as linhas.
   *
   * > Sempre receberá *true* caso a seleção de apenas uma linha esteja ativa.
   *
   * @default `false`
   */
  hideSelectAll = false;
  /**
   * @description
   *
   * Define que somente uma linha da tabela pode ser selecionada.
   *
   * > Esta definição não se aplica aos itens filhos, os mesmos possuem comportamento independente do item pai.
   */
  singleSelect = false;
  /**
   * @description
   *
   * Permite selecionar um item da tabela clicando na linha.
   *
   * > Caso haja necessidade de selecionar o item apenas via radio ou checkbox, deve-se definir esta propriedade como `false`.
   *
   * @default `true`
   */
  selectableEntireLine = true;
  /**
   * @optional
   *
   * @description
   *
   * Define que a coluna de ações ficará no lado direito da tabela.
   *
   * @default `false`
   */
  actionRight = false;
  /**
   * @optional
   *
   * @description
   *
   * Define uma quantidade máxima de colunas que serão exibidas na tabela.
   *
   * Quando chegar no valor informado, as colunas que não estiverem selecionadas ficarão
   * desabilitadas e caso houver mais colunas visíveis do que o permitido, as excedentes
   * serão ignoradas por ordem de posição.
   */
  maxColumns;
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no campo de busca, quando habilitado.
   * Valores definidos no enum: PoSearchFilterMode
   * > Obs: A pesquisa é realizada exclusivamente nos dados locais, ou seja, aqueles que foram
   * > renderizados na tabela.
   *
   * @default `startsWith`
   */
  filterType = PoSearchFilterMode.startsWith;
  /**
   * @optional
   *
   * @description
   * Evento executado quando todas as linhas são selecionadas por meio do *checkbox* que seleciona todas as linhas.
   */
  allSelected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento executado quando a seleção das linhas é desmarcada por meio do *checkbox* que seleciona todas as linhas.
   */
  allUnselected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao colapsar uma linha do `po-table`.
   *
   * > Como parâmetro o componente envia o item colapsado.
   */
  collapsed = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao expandir uma linha do `po-table`.
   *
   * > Como parâmetro o componente envia o item expandido.
   */
  expanded = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado após o método de exclusão ser finalizado.
   *
   * ```
   *<po-table
   *  (p-delete-items)="items = $event"
   * >
   *</po-table>
   * ```
   *
   *
   * > Como parâmetro o componente envia a lista atualizada, sem os itens excluídos.
   */
  eventDelete = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao selecionar uma linha do `po-table`.
   */
  selected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Recebe uma ação de clique para o botão "Carregar mais resultados", caso nenhuma ação for definida o mesmo
   * não é visível.
   *
   * Recebe um objeto `{ column, type }` onde:
   *
   * - column (`PoTableColumn`): objeto da coluna que está ordenada.
   * - type (`PoTableColumnSortType`): tipo da ordenação.
   */
  showMore = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento executado ao ordenar colunas da tabela.
   *
   * Recebe um objeto `{ column, type }` onde:
   *
   * - column (`PoTableColumn`): objeto da coluna que foi clicada/ordenada.
   * - type (`PoTableColumnSortType`): tipo da ordenação.
   */
  sortBy = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento executado ao desmarcar a seleção de uma linha do `po-table`.
   */
  unselected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao fechar o page slide do gerenciador de colunas após alterar as colunas visíveis.
   *
   * O componente envia como parâmetro um array de string com as colunas visíveis atualizadas.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  changeVisibleColumns = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no botão de restaurar padrão no gerenciador de colunas.
   *
   * O componente envia como parâmetro um array de string com as colunas configuradas inicialmente.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  columnRestoreManager = new EventEmitter();
  allColumnsWidthPixels;
  columnMasterDetail;
  hasMainColumns = false;
  mainColumns = [];
  selectAll = false;
  sortedColumn = { property: null, ascending: true };
  subtitleColumns = [];
  page = 1;
  pageSize = 10;
  hasService = false;
  initialColumns;
  showBatchActions = false;
  itemsSelected = [];
  paramsFilter;
  filteredItems = [];
  initialized = false;
  fixedLayout = false;
  initialVisibleColumns = false;
  _spacing = PoTableColumnSpacing.Medium;
  _filteredColumns;
  _actions = [];
  _columns = [];
  _container;
  _paramDelete = poTableParamDeleteApi;
  _height;
  _hideDetail = false;
  _items;
  _literals;
  _loading = false;
  _selectable;
  language = poLocaleDefault;
  _serviceApi;
  _serviceDeleteApi;
  poTableServiceSubscription;
  sortStore;
  _infiniteScrollDistance = 100;
  _infiniteScroll = false;
  _draggable = false;
  _hideActionFixedColumns = false;
  constructor(poDate, languageService, poTableService) {
    this.poDate = poDate;
    this.poTableService = poTableService;
    this.language = languageService.getShortLanguage();
  }
  /**
   * @description
   *
   * Lista de itens da tabela.
   * > Se falso, será inicializado como um *array* vazio.
   */
  set items(items) {
    if (this.height) {
      this._items = Array.isArray(items) ? [...items] : [];
    } else {
      this._items = Array.isArray(items) ? items : [];
    }
    if (!this.hasItems) {
      this.selectAll = false;
    } else if (!this.hasColumns) {
      this.columns = this.getDefaultColumns(items[0]);
    }
    this.filteredItems = this.height ? [...this.items] : this.items;
    setTimeout(() => this.checkInfiniteScroll());
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Lista das colunas da tabela, deve receber um *array* de objetos que implementam a interface `PoTableColumn`.
   * Por padrão receberá como valor a primeira coluna da lista de itens da tabela.
   * > Caso não encontre valor, a mensagem 'Nenhuma definição de colunas' será exibida.
   *
   */
  set columns(columns) {
    const hasColumnsWithVisible = columns?.find((column) => column.visible === true);
    if (this.initialColumns === void 0) {
      this.initialColumns = columns;
    }
    this._columns = columns || [];
    if (hasColumnsWithVisible && !this.initialVisibleColumns) {
      this.initialVisibleColumns = true;
      this.verifyInteractiveColumns();
    }
    if (this._columns.length) {
      this.setColumnLink();
    } else if (this.hasItems) {
      this._columns = this.getDefaultColumns(this.items[0]);
    }
    this.onChangeColumns();
  }
  get columns() {
    return this._columns;
  }
  /**
   * @optional
   *
   * @description
   *
   * Adiciona um contorno arredondado ao `po-table`, as opções são:
   * - `border`: com bordas/linhas.
   * - `shadow`: com sombras.
   *
   * @default `border`
   */
  set container(value) {
    this._container = poTableContainer.includes(value) ? value : poTableContainerDefault;
  }
  get container() {
    return this._container;
  }
  /**
   * @optional
   *
   * @description
   *
   * Adiciona o parâmetro a ser enviado para a requisição de DELETE.
   *
   * É necessário a utilização da propriedade `p-service-delete` em conjunto.
   *
   * @default `id`
   */
  set paramDeleteApi(value) {
    this._paramDelete = value && typeof value === "string" ? value : poTableParamDeleteApi;
  }
  get paramDeleteApi() {
    return this._paramDelete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura da tabela em *pixels* e fixa o cabeçalho.
   *
   * Ao utilizar essa propriedade será inserido o `virtual-scroll` na tabela melhorando a performance.
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita a visualização da lista de detalhes de cada linha da coluna.
   *
   * @default `false`
   */
  set hideDetail(hideDetail) {
    this._hideDetail = hideDetail != null && hideDetail.toString() === "" ? true : convertToBoolean(hideDetail);
  }
  get hideDetail() {
    return this._hideDetail;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-table`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoTableLiterals = {
   *    noColumns: 'Nenhuma definição de colunas',
   *    noData: 'Nenhum dado encontrado',
   *    noVisibleColumn: 'Nenhuma coluna visível',
   *    noItem: 'Nenhum item selecionado',
   *    oneItem: '1 item selecionado',
   *    multipleItems: 'itens selecionados',
   *    loadingData: 'Carregando',
   *    loadMoreData: 'Carregar mais resultados',
   *    seeCompleteSubtitle: 'Ver legenda completa',
   *    completeSubtitle: 'Legenda completa',
   *    columnsManager: 'Gerenciador de colunas',
   *    bodyDelete: 'Deseja realmente excluir esse item?',
   *    cancel: 'Cancelar',
   *    delete: 'Excluir',
   *    deleteSuccessful: 'Itens removidos com sucesso',
   *    deleteApiError: 'Ocorreu um erro inesperado, tente novamente mais tarde!',
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoTableLiterals = {
   *    noData: 'Sem dados'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-table
   *   [p-literals]="customLiterals">
   * </po-table>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poTableLiteralsDefault[poLocaleDefault]), poTableLiteralsDefault[this.language]), value);
    } else {
      this._literals = poTableLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poTableLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Bloqueia a interação do usuário com os dados da _table_.
   *
   * @default `false`
   */
  set loading(loading) {
    this._loading = convertToBoolean(loading);
  }
  get loading() {
    return this._loading;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de ações.
   *
   * Quando houver apenas uma ação definida ela será exibida diretamente na coluna, caso contrário, o componente
   * se encarrega de agrupá-las exibindo o ícone [**po-icon-more**](/guides/icons) que listará as ações ao ser clicado.
   *
   * **A coluna de ações não será exibida quando:**
   *  - a lista conter valores inválidos ou indefinidos.
   *  - tenha uma única ação e a mesma não for visível.
   */
  set actions(actions) {
    this._actions = actions;
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Permite a seleção de linhas na tabela e, caso a propriedade `p-single-select` esteja definida será possível
   * selecionar apenas uma única linha.
   *
   * **Importante:**
   *  - As linhas de detalhe definidas em `PoTableDetail` possuem comportamento independente da linha mestre;
   *  - Cada linha possui por padrão a propriedade dinâmica `$selected`, na qual é possível validar se a linha
   * está selecionada, por exemplo: `item.$selected` ou `item['$selected']`.
   *
   * @default `false`
   */
  set selectable(value) {
    this._selectable = value === "" ? true : convertToBoolean(value);
  }
  get selectable() {
    return this._selectable;
  }
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro, ativa a funcionalidade de scroll infinito para a tabela e o botão "Carregar Mais" deixará de ser exibido. Ao chegar no fim da tabela
   * executará a função `p-show-more`.
   *
   * **Regras de utilização:**
   *  - O scroll infinito só funciona para tabelas que utilizam a propriedade `p-height` e que possuem o scroll já na carga inicial dos dados.
   *
   * @default `false`
   */
  set infiniteScroll(value) {
    this._infiniteScroll = convertToBoolean(value && this.height > 0);
  }
  get infiniteScroll() {
    return this._infiniteScroll;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o percentual necessário para disparar o evento `p-show-more`, que é responsável por carregar mais dados na tabela. Caso o valor informado seja maior que 100 ou menor
   * que 0, o valor padrão será 100%
   *
   * **Exemplos:**
   *  - p-infinite-scroll-distance = 80: Quando atingir 80%  do scroll da tabela, o `p-show-more` será disparado.
   */
  set infiniteScrollDistance(value) {
    this._infiniteScrollDistance = value > 100 || value < 0 ? 100 : value;
  }
  get infiniteScrollDistance() {
    return this._infiniteScrollDistance;
  }
  /**
   * @optional
   *
   * @description
   *
   * URL da API responsável por retornar os registros.
   *
   * Ao realizar a busca de mais registros via paginação (Carregar mais resultados), será enviado os parâmetros `page` e `pageSize`, conforme abaixo:
   *
   * ```
   * url + ?page=1&pageSize=10
   * ```
   *
   * Caso utilizar ordenação, a coluna ordenada será enviada através do parâmetro `order`, por exemplo:
   * - Coluna decrescente:
   * ```
   *  url + ?page=1&pageSize=10&order=-name
   * ```
   *
   * - Coluna ascendente:
   * ```
   *  url + ?page=1&pageSize=10&order=name
   * ```
   *
   * > Esta URL deve retornar e receber os dados no padrão de [API do PO UI](https://po-ui.io/guides/api).
   */
  set serviceApi(service) {
    this._serviceApi = service;
    this.setService(this.serviceApi, "GET");
    this.hasService = !!service;
    this.showMoreDisabled = !this.hasService;
    this.page = 1;
    this.initializeData();
  }
  get serviceApi() {
    return this._serviceApi;
  }
  /**
   * @optional
   *
   * @description
   *
   * URL da API responsável por excluir os registros.
   *
   * Ao selecionar o botão de excluir itens, essa url será executada utilizando o parâmetro enviado na propriedade `p-param-delete-api`.
   * Caso ela não seja utilizada, o parâmetro padrão a ser enviado será `id`.
   *
   * > Esta URL deve retornar e receber os dados no padrão de [API do PO UI](https://po-ui.io/guides/api).
   */
  set serviceDeleteApi(service) {
    this._serviceDeleteApi = service;
    this.setService(this.serviceDeleteApi, "DELETE");
  }
  get serviceDeleteApi() {
    return this._serviceDeleteApi;
  }
  /**
   * @optional
   *
   * @description
   *
   * Responsável por aplicar espaçamento nas colunas.
   *
   * Deve receber um dos valores do enum `PoTableColumnSpacing`.
   *
   * Valor `small` só funciona em tabelas não interativas. Caso seja setado com `small` e a tabela seja interativa, o valor será retornado para `medium`.
   *
   * @default `medium`
   */
  set spacing(value) {
    if (value === "small" || value === "medium" || value === "large") {
      this._spacing = value;
    } else {
      this._spacing = PoTableColumnSpacing.Medium;
    }
  }
  get spacing() {
    return this._spacing;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define as colunas que serão filtradas no campo de pesquisa.
   * Aceita um array de strings, representando as colunas específicas que serão consideradas na filtragem.
   *
   */
  set filteredColumns(values) {
    this._filteredColumns = values;
  }
  get filteredColumns() {
    return this._filteredColumns;
  }
  get hasColumns() {
    return this.columns && this.columns.length > 0;
  }
  get hasItems() {
    return !!(this.items && this.items.length);
  }
  get nameColumnDetail() {
    return this.columnMasterDetail ? this.columnMasterDetail.property : null;
  }
  get validColumns() {
    const typesValid = [
      "string",
      "number",
      "boolean",
      "date",
      "time",
      "dateTime",
      "currency",
      "subtitle",
      "link",
      "label",
      "icon",
      "cellTemplate",
      "columnTemplate"
    ];
    return this.columns.filter((col) => !col.type || typesValid.includes(col.type));
  }
  get visibleActions() {
    return this.actions !== void 0 && this.actions && this.actions.filter((action) => action && action.visible !== false);
  }
  getFilteredColumns() {
    this.filteredColumns = this.columns.filter((column) => column.visible !== false).map((column) => column.property || column.label);
  }
  get sortType() {
    return this.sortedColumn.ascending ? PoTableColumnSortType.Ascending : PoTableColumnSortType.Descending;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita o modo drag and drop para as colunas da tabela.
   *
   * @default `false`
   */
  set draggable(draggable) {
    this._draggable = draggable || false;
  }
  get draggable() {
    return this._draggable;
  }
  ngOnDestroy() {
    this.poTableServiceSubscription?.unsubscribe();
  }
  ngOnChanges(changes) {
    if (this.singleSelect || this.hideSelectAll) {
      this.selectAll = false;
      this.hideSelectAll = true;
    }
    if (changes.height) {
      this.calculateHeightTableContainer(this.height);
    }
    if ((changes.height || changes.items) && this.initialized) {
      this.changeHeaderWidth();
    }
    this.changeSizeLoading();
  }
  selectAllRows() {
    if (!this.hideSelectAll) {
      this.selectAll = !this.selectAll;
      this.items.forEach((item) => {
        item.$selected = this.selectAll;
      });
      this.emitSelectAllEvents(this.selectAll, [...this.items]);
      this.setSelectedList();
    }
  }
  selectRow(row) {
    row.$selected = !row.$selected;
    this.emitSelectEvents(row);
    this.configAfterSelectRow(this.items, row);
    this.setSelectedList();
  }
  hasSelectableRow() {
    return this.selectable && this.selectableEntireLine;
  }
  selectDetailRow(row) {
    this.emitSelectEvents(row);
  }
  setSelectedList() {
    this.itemsSelected = [];
    this.items.forEach((item) => {
      if (item.$selected) {
        this.itemsSelected.push(item);
      }
    });
  }
  getClassColor(row, column) {
    return column.color ? `po-text-${this.getColumnColor(row, column)}` : "";
  }
  toggleDetail(row) {
    const rowShowDetail = row.$showDetail;
    if (this.autoCollapse) {
      this.collapseAllItems(this.items);
    }
    this.setShowDetail(row, !rowShowDetail);
    this.emitExpandEvents(row);
  }
  toggleRowAction(row) {
    const toggleShowAction = row.$showAction;
    this.items.forEach((item) => {
      if (item.$showAction) {
        item.$showAction = false;
      }
    });
    row.$showAction = !toggleShowAction;
  }
  sortColumn(column) {
    if (!this.sort || column.type === "detail" || column.sortable === false) {
      return;
    }
    this.sortedColumn.ascending = this.sortedColumn.property === column ? !this.sortedColumn.ascending : true;
    this.sortArray(column, this.sortedColumn.ascending);
    this.sortBy.emit({ column, type: this.sortType });
    if (this.hasService && this.sort) {
      this.sortStore = { column, type: this.sortType };
    }
    this.sortedColumn.property = column;
  }
  onShowMore() {
    const sort = this.sortedColumn.property ? { column: this.sortedColumn.property, type: this.sortType } : void 0;
    if (this.hasService) {
      this.page++;
      this.loading = true;
      this.loadingShowMore = true;
      this.poTableServiceSubscription = this.getFilteredItems().subscribe((data) => {
        this.items = [...this.items, ...data.items];
        this.showMoreDisabled = !data.hasNext;
        this.loading = false;
        this.loadingShowMore = false;
      });
    }
    this.showMore.emit(sort);
  }
  getFilteredItems(queryParams) {
    const filteredParams = this.getFilteredParams(queryParams);
    return this.poTableService.getFilteredItems(filteredParams);
  }
  setTableResponseProperties(data) {
    this.items = data.items || [];
    this.showMoreDisabled = !data.hasNext;
    this.loading = false;
  }
  initializeData(params) {
    if (this.hasService) {
      this.loading = true;
      this.paramsFilter = params;
      this.getFilteredItems(params).subscribe((data) => {
        this.setTableResponseProperties(data);
      });
    }
  }
  sortArray(column, ascending, item) {
    let itemsList;
    if (item) {
      itemsList = this.height ? [...item] : item;
    } else {
      itemsList = this.height ? [...this.filteredItems] : this.filteredItems;
    }
    itemsList.sort((leftSide, rightSide) => sortValues(leftSide[column.property], rightSide[column.property], ascending));
    this.filteredItems = itemsList;
  }
  getDefaultColumns(item) {
    const keys = Object.keys(item);
    return keys.filter((key) => typeof item[key] !== "object").map((key) => ({ label: capitalizeFirstLetter(key), property: key }));
  }
  setShowDetail(rowIdentifier, isShowDetail) {
    const isRowIndex = typeof rowIdentifier === "number" && this.items[rowIdentifier];
    const row = isRowIndex ? this.items[rowIdentifier] : rowIdentifier;
    row.$showDetail = isShowDetail;
  }
  collapseAllItems(items) {
    for (const item of items) {
      if (item.$showDetail) {
        this.setShowDetail(item, false);
        this.emitExpandEvents(item);
      }
    }
  }
  configAfterSelectRow(rows, row) {
    if (this.singleSelect) {
      this.unselectOtherRows(rows, row);
    } else if (!this.hideSelectAll) {
      this.selectAll = this.isEverySelected(rows);
    }
  }
  emitExpandEvents(row) {
    row.$showDetail ? this.expanded.emit(row) : this.collapsed.emit(row);
  }
  emitSelectAllEvents(selectAll, rows) {
    selectAll ? this.allSelected.emit(rows) : this.allUnselected.emit(rows);
  }
  emitSelectEvents(row) {
    row.$selected ? this.selected.emit(row) : this.unselected.emit(row);
  }
  getColumnColor(row, column) {
    const columnColor = column.color;
    return isTypeof(columnColor, "function") ? columnColor(row, column.property) : columnColor;
  }
  // Retorna a coluna da lista de colunas que é do tipo detail
  getColumnMasterDetail() {
    return this.columns.find((col) => col.type === "detail");
  }
  // Colunas que são inseridas no <head> da tabela
  getMainColumns() {
    return this.validColumns.filter((col) => col.visible !== false);
  }
  // Retorna as colunas com status
  getSubtitleColumns() {
    return this.columns.filter((col) => col.type === "subtitle");
  }
  isEverySelected(items) {
    const someCheckedOrIndeterminate = (item) => item.$selected || item.$selected === null;
    const everyChecked = (item) => item.$selected;
    if (items.every(everyChecked)) {
      return true;
    }
    if (items.some(someCheckedOrIndeterminate)) {
      return null;
    }
    return false;
  }
  onChangeColumns() {
    this.setMainColumns();
    this.setColumnMasterDetail();
    this.setSubtitleColumns();
    this.getFilteredColumns();
  }
  setColumnLink() {
    this.columns.forEach((column) => {
      if (column["type"] === "link" && !column["link"]) {
        column["link"] = "link";
      }
    });
  }
  setColumnMasterDetail() {
    this.columnMasterDetail = this.getColumnMasterDetail();
  }
  setMainColumns() {
    this.mainColumns = this.getMainColumns();
    this.hasMainColumns = !!this.mainColumns.length;
    this.allColumnsWidthPixels = this.verifyWidthColumnsPixels();
  }
  setSubtitleColumns() {
    this.subtitleColumns = this.getSubtitleColumns();
  }
  unselectOtherRows(rows, row) {
    rows.forEach((item) => {
      if (item !== row) {
        item.$selected = false;
      }
    });
  }
  verifyInteractiveColumns() {
    const hasLinkOrDetail = this.columns.find((column) => column.type === "link" || column.type === "detail");
    if (this.spacing === "small" && (this.selectable || hasLinkOrDetail || this.visibleActions.length > 0)) {
      this.spacing = PoTableColumnSpacing.Medium;
    }
  }
  verifyWidthColumnsPixels() {
    return this.hasMainColumns ? this.mainColumns.every((column) => column.width && column.width.includes("px")) : false;
  }
  setService(service, method) {
    if (service && isTypeof(service, "string")) {
      this.poTableService.setUrl(service, method);
    }
  }
  getFilteredParams(queryParams) {
    const { page, pageSize, sortStore } = this;
    const filteredParams = {};
    const order = this.getOrderParam(sortStore);
    const params = __spreadValues({ page, pageSize, order }, queryParams);
    for (const key in params) {
      if (params.hasOwnProperty(key) && params[key] !== void 0) {
        filteredParams[key] = params[key];
      }
    }
    return filteredParams;
  }
  getOrderParam(sort = { type: void 0 }) {
    const { column, type } = sort;
    if (!column) {
      return;
    }
    if (type === PoTableColumnSortType.Descending) {
      return `-${column.property}`;
    }
    return `${column.property}`;
  }
  removePropertyFixed(arr) {
    return arr.map((obj) => {
      if (obj.hasOwnProperty("fixed")) {
        obj.fixed = false;
      }
      return obj;
    });
  }
  static ɵfac = function PoTableBaseComponent_Factory(t) {
    return new (t || _PoTableBaseComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoTableService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTableBaseComponent, inputs: { hideColumnsManager: [InputFlags.HasDecoratorInputTransform, "p-hide-columns-manager", "hideColumnsManager", convertToBoolean], hideBatchActions: [InputFlags.HasDecoratorInputTransform, "p-hide-batch-actions", "hideBatchActions", convertToBoolean], hideActionFixedColumns: [InputFlags.None, "p-hide-action-fixed-columns", "hideActionFixedColumns"], hideTableSearch: [InputFlags.HasDecoratorInputTransform, "p-hide-table-search", "hideTableSearch", convertToBoolean], autoCollapse: [InputFlags.HasDecoratorInputTransform, "p-auto-collapse", "autoCollapse", convertToBoolean], loadingShowMore: [InputFlags.HasDecoratorInputTransform, "p-loading-show-more", "loadingShowMore", convertToBoolean], sort: [InputFlags.HasDecoratorInputTransform, "p-sort", "sort", convertToBoolean], showMoreDisabled: [InputFlags.HasDecoratorInputTransform, "p-show-more-disabled", "showMoreDisabled", convertToBoolean], striped: [InputFlags.HasDecoratorInputTransform, "p-striped", "striped", convertToBoolean], hideSelectAll: [InputFlags.HasDecoratorInputTransform, "p-hide-select-all", "hideSelectAll", convertToBoolean], singleSelect: [InputFlags.HasDecoratorInputTransform, "p-single-select", "singleSelect", convertToBoolean], selectableEntireLine: [InputFlags.HasDecoratorInputTransform, "p-selectable-entire-line", "selectableEntireLine", convertToBoolean], actionRight: [InputFlags.HasDecoratorInputTransform, "p-actions-right", "actionRight", convertToBoolean], maxColumns: [InputFlags.None, "p-max-columns", "maxColumns"], filterType: [InputFlags.None, "p-filter-type", "filterType"], items: [InputFlags.None, "p-items", "items"], columns: [InputFlags.None, "p-columns", "columns"], container: [InputFlags.None, "p-container", "container"], paramDeleteApi: [InputFlags.None, "p-param-delete-api", "paramDeleteApi"], height: [InputFlags.None, "p-height", "height"], hideDetail: [InputFlags.None, "p-hide-detail", "hideDetail"], literals: [InputFlags.None, "p-literals", "literals"], loading: [InputFlags.None, "p-loading", "loading"], actions: [InputFlags.None, "p-actions", "actions"], selectable: [InputFlags.None, "p-selectable", "selectable"], infiniteScroll: [InputFlags.None, "p-infinite-scroll", "infiniteScroll"], infiniteScrollDistance: [InputFlags.None, "p-infinite-scroll-distance", "infiniteScrollDistance"], serviceApi: [InputFlags.None, "p-service-api", "serviceApi"], serviceDeleteApi: [InputFlags.None, "p-service-delete", "serviceDeleteApi"], spacing: [InputFlags.None, "p-spacing", "spacing"], filteredColumns: [InputFlags.None, "p-filtered-columns", "filteredColumns"], draggable: [InputFlags.None, "p-draggable", "draggable"] }, outputs: { allSelected: "p-all-selected", allUnselected: "p-all-unselected", collapsed: "p-collapsed", expanded: "p-expanded", eventDelete: "p-delete-items", selected: "p-selected", showMore: "p-show-more", sortBy: "p-sort-by", unselected: "p-unselected", changeVisibleColumns: "p-change-visible-columns", columnRestoreManager: "p-restore-column-manager" }, features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableBaseComponent, [{
    type: Directive
  }], () => [{ type: PoDateService }, { type: PoLanguageService }, { type: PoTableService }], { hideColumnsManager: [{
    type: Input,
    args: [{ alias: "p-hide-columns-manager", transform: convertToBoolean }]
  }], hideBatchActions: [{
    type: Input,
    args: [{ alias: "p-hide-batch-actions", transform: convertToBoolean }]
  }], hideActionFixedColumns: [{
    type: Input,
    args: ["p-hide-action-fixed-columns"]
  }], hideTableSearch: [{
    type: Input,
    args: [{ alias: "p-hide-table-search", transform: convertToBoolean }]
  }], autoCollapse: [{
    type: Input,
    args: [{ alias: "p-auto-collapse", transform: convertToBoolean }]
  }], loadingShowMore: [{
    type: Input,
    args: [{ alias: "p-loading-show-more", transform: convertToBoolean }]
  }], sort: [{
    type: Input,
    args: [{ alias: "p-sort", transform: convertToBoolean }]
  }], showMoreDisabled: [{
    type: Input,
    args: [{ alias: "p-show-more-disabled", transform: convertToBoolean }]
  }], striped: [{
    type: Input,
    args: [{ alias: "p-striped", transform: convertToBoolean }]
  }], hideSelectAll: [{
    type: Input,
    args: [{ alias: "p-hide-select-all", transform: convertToBoolean }]
  }], singleSelect: [{
    type: Input,
    args: [{ alias: "p-single-select", transform: convertToBoolean }]
  }], selectableEntireLine: [{
    type: Input,
    args: [{ alias: "p-selectable-entire-line", transform: convertToBoolean }]
  }], actionRight: [{
    type: Input,
    args: [{ alias: "p-actions-right", transform: convertToBoolean }]
  }], maxColumns: [{
    type: Input,
    args: ["p-max-columns"]
  }], filterType: [{
    type: Input,
    args: ["p-filter-type"]
  }], allSelected: [{
    type: Output,
    args: ["p-all-selected"]
  }], allUnselected: [{
    type: Output,
    args: ["p-all-unselected"]
  }], collapsed: [{
    type: Output,
    args: ["p-collapsed"]
  }], expanded: [{
    type: Output,
    args: ["p-expanded"]
  }], eventDelete: [{
    type: Output,
    args: ["p-delete-items"]
  }], selected: [{
    type: Output,
    args: ["p-selected"]
  }], showMore: [{
    type: Output,
    args: ["p-show-more"]
  }], sortBy: [{
    type: Output,
    args: ["p-sort-by"]
  }], unselected: [{
    type: Output,
    args: ["p-unselected"]
  }], changeVisibleColumns: [{
    type: Output,
    args: ["p-change-visible-columns"]
  }], columnRestoreManager: [{
    type: Output,
    args: ["p-restore-column-manager"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }], container: [{
    type: Input,
    args: ["p-container"]
  }], paramDeleteApi: [{
    type: Input,
    args: ["p-param-delete-api"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], hideDetail: [{
    type: Input,
    args: ["p-hide-detail"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], loading: [{
    type: Input,
    args: ["p-loading"]
  }], actions: [{
    type: Input,
    args: ["p-actions"]
  }], selectable: [{
    type: Input,
    args: ["p-selectable"]
  }], infiniteScroll: [{
    type: Input,
    args: ["p-infinite-scroll"]
  }], infiniteScrollDistance: [{
    type: Input,
    args: ["p-infinite-scroll-distance"]
  }], serviceApi: [{
    type: Input,
    args: ["p-service-api"]
  }], serviceDeleteApi: [{
    type: Input,
    args: ["p-service-delete"]
  }], spacing: [{
    type: Input,
    args: ["p-spacing"]
  }], filteredColumns: [{
    type: Input,
    args: ["p-filtered-columns"]
  }], draggable: [{
    type: Input,
    args: ["p-draggable"]
  }] });
})();
var PoTableCellTemplateDirective = class _PoTableCellTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do cell template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoTableCellTemplateDirective_Factory(t) {
    return new (t || _PoTableCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTableCellTemplateDirective, selectors: [["", "p-table-cell-template", ""]] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-table-cell-template]"
    }]
  }], () => [{ type: TemplateRef }], null);
})();
var PoTableColumnTemplateDirective = class _PoTableColumnTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Variável responsável por armazenar a property da coluna da tabela que será adicionado o template.
   *
   * Caso não seja informada esta propriedade, serão apresentados normalmente os dados da coluna.
   */
  targetProperty;
  // Necessário manter templateRef para o funcionamento do column template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoTableColumnTemplateDirective_Factory(t) {
    return new (t || _PoTableColumnTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTableColumnTemplateDirective, selectors: [["", "p-table-column-template", ""]], inputs: { targetProperty: [InputFlags.None, "p-property", "targetProperty"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-table-column-template]"
    }]
  }], () => [{ type: TemplateRef }], { targetProperty: [{
    type: Input,
    args: ["p-property"]
  }] });
})();
var PoTableRowTemplateDirective = class _PoTableRowTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Função que deve retornar um valor booleano, informando se apresentará o template da linha.
   * Serão passados o objeto da linha e o indice da mesma por parâmetro, para que seja possível
   * tomar uma decisão a partir do objeto da linha corrente.
   *
   * Caso não ser utilizado esta propriedade, serão apresentados todos os detalhes das linhas.
   *
   * @default `true`
   */
  poTableRowTemplateShow;
  _tableRowTemplateArrowDirection = PoTableRowTemplateArrowDirection.Left;
  /**
   * @optional
   *
   * @description
   *
   * Propriedade responsável por informar a posição do colapse que abrirá os detalhes da linha.
   *
   * @default `'LEFT'`
   */
  set tableRowTemplateArrowDirection(value) {
    value = value?.toUpperCase();
    this._tableRowTemplateArrowDirection = Object.values(PoTableRowTemplateArrowDirection).includes(value) ? value : PoTableRowTemplateArrowDirection.Left;
  }
  get tableRowTemplateArrowDirection() {
    return this._tableRowTemplateArrowDirection;
  }
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoTableRowTemplateDirective_Factory(t) {
    return new (t || _PoTableRowTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTableRowTemplateDirective, selectors: [["", "p-table-row-template", ""]], inputs: { poTableRowTemplateShow: [InputFlags.None, "p-table-row-template-show", "poTableRowTemplateShow"], tableRowTemplateArrowDirection: [InputFlags.None, "p-table-row-template-arrow-direction", "tableRowTemplateArrowDirection"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableRowTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-table-row-template]"
    }]
  }], () => [{ type: TemplateRef }], { poTableRowTemplateShow: [{
    type: Input,
    args: ["p-table-row-template-show"]
  }], tableRowTemplateArrowDirection: [{
    type: Input,
    args: ["p-table-row-template-arrow-direction"]
  }] });
})();
var _c0$V = ["noColumnsHeader"];
var _c1$n = ["popup"];
var _c2$b = ["tableFooter"];
var _c3$6 = ["tableWrapper"];
var _c4$3 = ["tableTemplate"];
var _c5 = ["tableVirtualScroll"];
var _c6 = ["columnManager"];
var _c7 = ["columnBatchActions"];
var _c8 = ["columnActionLeft"];
var _c9 = ["filterInput"];
var _c10 = ["poSearchInput"];
var _c11 = ["columnManagerTarget"];
var _c12 = ["columnManagerTargetFixed"];
var _c13 = ["actionsIconElement"];
var _c14 = ["actionsElement"];
function PoTableComponent_div_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r29 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r29.literals.noItem);
  }
}
function PoTableComponent_div_1_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r30 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r30.literals.oneItem);
  }
}
function PoTableComponent_div_1_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r31 = ɵɵnextContext(2);
    ɵɵtextInterpolate2("", ctx_r31.itemsSelected.length, " ", ctx_r31.literals.multipleItems, "");
  }
}
function PoTableComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r33 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22, 23)(2, "div", 24)(3, "strong");
    ɵɵtemplate(4, PoTableComponent_div_1_ng_template_4_Template, 1, 1, "ng-template", 25)(5, PoTableComponent_div_1_ng_template_5_Template, 1, 1, "ng-template", 26)(6, PoTableComponent_div_1_ng_template_6_Template, 1, 2, "ng-template", 27);
    ɵɵelementEnd()();
    ɵɵelementStart(7, "div", 28)(8, "po-button", 29);
    ɵɵlistener("p-click", function PoTableComponent_div_1_Template_po_button_p_click_8_listener() {
      ɵɵrestoreView(_r33);
      ɵɵnextContext();
      const _r27 = ɵɵreference(30);
      return ɵɵresetView(_r27.open());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngPlural", ctx_r0.itemsSelected.length);
    ɵɵadvance(6);
    ɵɵproperty("p-danger", true)("p-disabled", ctx_r0.itemsSelected.length > 1 && ctx_r0.serviceDeleteApi !== void 0)("p-label", ctx_r0.literals.delete);
  }
}
function PoTableComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 30, 31)(2, "po-button", 32, 33);
    ɵɵlistener("p-click", function PoTableComponent_div_2_Template_po_button_p_click_2_listener() {
      ɵɵrestoreView(_r37);
      const ctx_r36 = ɵɵnextContext();
      return ɵɵresetView(ctx_r36.onOpenColumnManager());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("p-aria-label", ctx_r1.literals.columnsManager)("p-tooltip", ctx_r1.literals.columnsManager);
  }
}
function PoTableComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r39 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 34)(1, "po-search", 35);
    ɵɵlistener("p-filtered-items-change", function PoTableComponent_div_3_Template_po_search_p_filtered_items_change_1_listener($event) {
      ɵɵrestoreView(_r39);
      const ctx_r38 = ɵɵnextContext();
      return ɵɵresetView(ctx_r38.onFilteredItemsChange($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-items", ctx_r2.items)("p-filter-keys", ctx_r2.filteredColumns)("p-filter-type", ctx_r2.filterType);
  }
}
function PoTableComponent_po_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_po_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 36);
    ɵɵtemplate(1, PoTableComponent_po_container_4_ng_container_1_Template, 1, 0, "ng-container", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r5 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r5);
  }
}
function PoTableComponent_ng_template_5_po_loading_overlay_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-loading-overlay", 45);
  }
  if (rf & 2) {
    const ctx_r41 = ɵɵnextContext(2);
    ɵɵproperty("p-text", ctx_r41.literals.loadingData)("p-size", ctx_r41.sizeLoading);
  }
}
function PoTableComponent_ng_template_5_div_5_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_5_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 46)(1, "div", 47, 48);
    ɵɵtemplate(3, PoTableComponent_ng_template_5_div_5_ng_container_3_Template, 1, 0, "ng-container", 37);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r43 = ɵɵnextContext(2);
    const _r10 = ɵɵreference(11);
    ɵɵstyleProp("height", ctx_r43.heightTableContainer, "px");
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", _r10);
  }
}
function PoTableComponent_ng_template_5_div_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_5_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoTableComponent_ng_template_5_div_6_ng_container_1_Template, 1, 0, "ng-container", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r8 = ɵɵreference(9);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r8);
  }
}
function PoTableComponent_ng_template_5_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "po-table-subtitle-footer", 51);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r50 = ctx.$implicit;
    const ctx_r49 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-literals", ctx_r49.literals)("p-subtitles", column_r50.subtitles);
  }
}
function PoTableComponent_ng_template_5_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 49);
    ɵɵtemplate(1, PoTableComponent_ng_template_5_div_7_ng_container_1_Template, 2, 2, "ng-container", 50);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r45 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r45.subtitleColumns)("ngForTrackBy", ctx_r45.trackBy);
  }
}
function PoTableComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, PoTableComponent_ng_template_5_po_loading_overlay_1_Template, 1, 2, "po-loading-overlay", 38);
    ɵɵelementStart(2, "div", 39)(3, "div", 40, 41);
    ɵɵtemplate(5, PoTableComponent_ng_template_5_div_5_Template, 4, 3, "div", 42)(6, PoTableComponent_ng_template_5_div_6_Template, 2, 1, "div", 43);
    ɵɵelementEnd()()();
    ɵɵtemplate(7, PoTableComponent_ng_template_5_div_7_Template, 2, 2, "div", 44);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("po-table-container-sticky", ctx_r4.loading);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.loading);
    ɵɵadvance(2);
    ɵɵstyleProp("opacity", ctx_r4.tableOpacity);
    ɵɵclassProp("po-table-header-fixed-columns-pixels", ctx_r4.allColumnsWidthPixels);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r4.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasFooter);
  }
}
function PoTableComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r53 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 52, 53)(2, "po-button", 54);
    ɵɵlistener("p-click", function PoTableComponent_div_7_Template_po_button_p_click_2_listener() {
      ɵɵrestoreView(_r53);
      const ctx_r52 = ɵɵnextContext();
      return ɵɵresetView(ctx_r52.onShowMore());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵclassProp("po-invisible", ctx_r6.showMore.observers.length === 0 && !ctx_r6.hasService);
    ɵɵadvance(2);
    ɵɵproperty("p-disabled", ctx_r6.showMoreDisabled)("p-label", ctx_r6.literals.loadMoreData)("p-loading", ctx_r6.loadingShowMore);
  }
}
function PoTableComponent_ng_template_8_th_3_po_checkbox_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r69 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 68);
    ɵɵlistener("p-change", function PoTableComponent_ng_template_8_th_3_po_checkbox_2_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r69);
      const ctx_r68 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r68.selectAllRows());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r67 = ɵɵnextContext(3);
    ɵɵproperty("p-checkboxValue", ctx_r67.selectAll === null ? "mixed" : ctx_r67.selectAll);
  }
}
function PoTableComponent_ng_template_8_th_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 66)(1, "div");
    ɵɵtemplate(2, PoTableComponent_ng_template_8_th_3_po_checkbox_2_Template, 1, 1, "po-checkbox", 67);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r54 = ɵɵnextContext(2);
    ɵɵstyleProp("pointer-events", ctx_r54.hideSelectAll ? "none" : "auto");
    ɵɵadvance();
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r54.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r54.hideSelectAll);
  }
}
function PoTableComponent_ng_template_8_th_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 69);
  }
}
function PoTableComponent_ng_template_8_th_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", null, 70);
  }
  if (rf & 2) {
    const ctx_r56 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-master-detail", !ctx_r56.isSingleAction)("po-table-header-single-action", ctx_r56.isSingleAction);
  }
}
function PoTableComponent_ng_template_8_th_6_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_th_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 71, 72);
    ɵɵtemplate(2, PoTableComponent_ng_template_8_th_6_ng_container_2_Template, 1, 0, "ng-container", 61);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r57 = ɵɵnextContext(2);
    const _r21 = ɵɵreference(23);
    const _r23 = ɵɵreference(25);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r57.height)("ngIfThen", _r21)("ngIfElse", _r23);
  }
}
function PoTableComponent_ng_template_8_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_template_8_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 77);
    ɵɵelement(2, "circle", 78)(3, "circle", 79)(4, "circle", 80)(5, "circle", 81)(6, "circle", 82)(7, "circle", 83);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function PoTableComponent_ng_template_8_ng_template_8_th_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c15 = (a0) => ({ "po-table-header-sorted": a0 });
var _c16 = (a0) => ({ $implicit: a0 });
function PoTableComponent_ng_template_8_ng_template_8_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r79 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 74);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_template_8_th_0_Template_th_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r79);
      const column_r74 = restoredCtx.$implicit;
      const ctx_r78 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r78.sortColumn(column_r74));
    });
    ɵɵpipe(1, "lowercase");
    ɵɵpipe(2, "titlecase");
    ɵɵelementStart(3, "div", 75);
    ɵɵtemplate(4, PoTableComponent_ng_template_8_ng_template_8_th_0_ng_container_4_Template, 8, 0, "ng-container", 43)(5, PoTableComponent_ng_template_8_ng_template_8_th_0_ng_container_5_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r74 = ctx.$implicit;
    const ctx_r73 = ɵɵnextContext(3);
    const _r19 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r74.width)("max-width", column_r74.width)("min-width", column_r74.width);
    ɵɵclassProp("po-clickable", ctx_r73.sort && column_r74.sortable !== false || ctx_r73.hasService)("po-table-header-subtitle", column_r74.type === "subtitle")("po-table-column-drag-box", ctx_r73.isDraggable);
    ɵɵproperty("ngClass", ɵɵpureFunction1(29, _c15, ctx_r73.sort && ctx_r73.JSON.stringify(ctx_r73.sortedColumn == null ? null : ctx_r73.sortedColumn.property) === ctx_r73.JSON.stringify(column_r74) && (ctx_r73.sortedColumn.ascending || !ctx_r73.sortedColumn.ascending)))("cdkDragDisabled", column_r74.fixed ? "true" : "false")("pFrozenColumn", column_r74.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(1, 25, column_r74.label || ɵɵpipeBind1(2, 27, column_r74.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r73.height)("po-table-header-flex-right", column_r74.type === "currency" || column_r74.type === "number")("po-table-header-flex-center", column_r74.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r73.isDraggable && !column_r74.fixed);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r19)("ngTemplateOutletContext", ɵɵpureFunction1(31, _c16, column_r74));
  }
}
function PoTableComponent_ng_template_8_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_template_8_th_0_Template, 6, 33, "th", 73);
  }
  if (rf & 2) {
    const ctx_r59 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r59.mainColumns)("ngForTrackBy", ctx_r59.trackBy);
  }
}
function PoTableComponent_ng_template_8_ng_template_10_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_template_10_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r85 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 85);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_template_10_th_0_Template_th_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r85);
      const column_r81 = restoredCtx.$implicit;
      const ctx_r84 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r84.sortColumn(column_r81));
    });
    ɵɵpipe(1, "lowercase");
    ɵɵpipe(2, "titlecase");
    ɵɵelementStart(3, "div", 75);
    ɵɵtemplate(4, PoTableComponent_ng_template_8_ng_template_10_th_0_ng_container_4_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r81 = ctx.$implicit;
    const ctx_r80 = ɵɵnextContext(3);
    const _r19 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r81.width)("max-width", column_r81.width)("min-width", column_r81.width);
    ɵɵclassProp("po-clickable", ctx_r80.sort && column_r81.sortable !== false || ctx_r80.hasService)("po-table-header-subtitle", column_r81.type === "subtitle");
    ɵɵproperty("ngClass", ɵɵpureFunction1(25, _c15, ctx_r80.sort && ctx_r80.JSON.stringify(ctx_r80.sortedColumn == null ? null : ctx_r80.sortedColumn.property) === ctx_r80.JSON.stringify(column_r81) && (ctx_r80.sortedColumn.ascending || !ctx_r80.sortedColumn.ascending)))("pFrozenColumn", column_r81.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(1, 21, column_r81.label || ɵɵpipeBind1(2, 23, column_r81.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r80.height)("po-table-header-flex-right", column_r81.type === "currency" || column_r81.type === "number")("po-table-header-flex-center", column_r81.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r19)("ngTemplateOutletContext", ɵɵpureFunction1(27, _c16, column_r81));
  }
}
function PoTableComponent_ng_template_8_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_template_10_th_0_Template, 5, 29, "th", 84);
  }
  if (rf & 2) {
    const ctx_r61 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r61.mainColumns)("ngForTrackBy", ctx_r61.trackBy);
  }
}
function PoTableComponent_ng_template_8_th_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 69);
  }
}
function PoTableComponent_ng_template_8_th_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th");
  }
  if (rf & 2) {
    const ctx_r64 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-single-action", ctx_r64.isSingleAction)("po-table-header-actions", !ctx_r64.isSingleAction);
  }
}
function PoTableComponent_ng_template_8_tbody_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 86)(1, "tr", 87)(2, "td", 88)(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r65 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("colSpan", ctx_r65.columnCount);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r65.literals.noData, " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 66);
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_2_ng_container_1_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r89 = ɵɵnextContext(3);
    const _r15 = ɵɵreference(17);
    const _r17 = ɵɵreference(19);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r89.singleSelect ? _r15 : _r17)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c16, row_r87));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_3_ng_template_1_Template(rf, ctx) {
}
var _c17 = (a0, a1) => ({ row: a0, rowIndex: a1 });
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r103 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 94);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_3_Template_td_click_0_listener() {
      ɵɵrestoreView(_r103);
      const row_r87 = ɵɵnextContext().$implicit;
      const ctx_r101 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r101.toggleDetail(row_r87));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_3_ng_template_1_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r104 = ɵɵnextContext();
    const row_r87 = ctx_r104.$implicit;
    const rowIndex_r88 = ctx_r104.index;
    ɵɵnextContext(3);
    const _r13 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r13)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r87, rowIndex_r88));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_4_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_container_15_tbody_1_4_ng_template_0_Template, 0, 0, "ng-template", 95);
  }
  if (rf & 2) {
    const ctx_r106 = ɵɵnextContext();
    const row_r87 = ctx_r106.$implicit;
    const rowIndex_r88 = ctx_r106.index;
    ɵɵnextContext(3);
    const _r25 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r87, rowIndex_r88));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_5_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r110 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 94);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_5_Template_td_click_0_listener() {
      ɵɵrestoreView(_r110);
      const row_r87 = ɵɵnextContext().$implicit;
      const ctx_r108 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r108.toggleDetail(row_r87));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_5_ng_template_1_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r111 = ɵɵnextContext();
    const row_r87 = ctx_r111.$implicit;
    const rowIndex_r88 = ctx_r111.index;
    ɵɵnextContext(3);
    const _r13 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r13)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r87, rowIndex_r88));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_2_ng_container_1_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r114 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r114.getTemplate(column_r112))("ngTemplateOutletContext", ɵɵpureFunction1(2, _c16, ctx_r114.getCellData(row_r87, column_r112)));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c18 = (a0, a1) => ({ row: a0, column: a1 });
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_3_ng_container_1_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r115 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r115.tableCellTemplate == null ? null : ctx_r115.tableCellTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c18, row_r87, column_r112));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r116 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r116.getBooleanLabel(ctx_r116.getCellData(row_r87, column_r112), column_r112), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r117 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind4(2, 1, ctx_r117.getCellData(row_r87, column_r112), column_r112.format, "symbol", "1.2-2"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r118 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r118.getCellData(row_r87, column_r112), column_r112.format || "dd/MM/yyyy"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "po_time");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r119 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r119.getCellData(row_r87, column_r112), column_r112.format || "HH:mm:ss.ffffff"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r120 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r120.getCellData(row_r87, column_r112), column_r112.format || "dd/MM/yyyy HH:mm:ss"), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r121 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r121.formatNumber(ctx_r121.getCellData(row_r87, column_r112), column_r112.format), " ");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_po_table_column_link_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r147 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-column-link", 102);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_po_table_column_link_10_Template_po_table_column_link_click_0_listener($event) {
      ɵɵrestoreView(_r147);
      const column_r112 = ɵɵnextContext().$implicit;
      const row_r87 = ɵɵnextContext().$implicit;
      const ctx_r145 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r145.onClickLink($event, row_r87, column_r112));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r122 = ɵɵnextContext(3);
    ɵɵproperty("p-action", column_r112.action)("p-disabled", ctx_r122.checkDisabled(row_r87, column_r112))("p-link", row_r87[column_r112.link])("p-row", row_r87)("p-value", ctx_r122.getCellData(row_r87, column_r112));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_po_table_column_icon_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-table-column-icon", 103);
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r123 = ɵɵnextContext(3);
    ɵɵproperty("p-column", column_r112)("p-icons", ctx_r123.getColumnIcons(row_r87, column_r112))("p-row", row_r87);
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-subtitle-circle", 104);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r124 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-subtitle", ctx_r124.getSubtitleColumn(row_r87, column_r112));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-column-label", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r125 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-value", ctx_r125.getColumnLabel(row_r87, column_r112));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r112 = ɵɵnextContext().$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r126 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r126.getCellData(row_r87, column_r112));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r160 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 96);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_Template_td_click_0_listener() {
      ɵɵrestoreView(_r160);
      const row_r87 = ɵɵnextContext().$implicit;
      const ctx_r159 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r159.hasSelectableRow() ? ctx_r159.selectRow(row_r87) : "javascript:;");
    });
    ɵɵelementStart(1, "div", 97);
    ɵɵlistener("mouseenter", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_Template_div_mouseenter_1_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r160);
      const column_r112 = restoredCtx.$implicit;
      const row_r87 = ɵɵnextContext().$implicit;
      const ctx_r162 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r162.tooltipMouseEnter($event, column_r112, row_r87));
    })("mouseleave", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_Template_div_mouseleave_1_listener() {
      ɵɵrestoreView(_r160);
      const ctx_r164 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r164.tooltipMouseLeave());
    });
    ɵɵtemplate(2, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_2_Template, 2, 4, "span", 98)(3, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_3_Template, 2, 5, "span", 98)(4, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_4_Template, 2, 1, "span", 98)(5, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_5_Template, 3, 6, "span", 98)(6, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_6_Template, 3, 4, "span", 98)(7, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_7_Template, 3, 4, "span", 98)(8, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_8_Template, 3, 4, "span", 98)(9, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_9_Template, 2, 1, "span", 98)(10, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_po_table_column_link_10_Template, 1, 5, "po-table-column-link", 99)(11, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_po_table_column_icon_11_Template, 1, 3, "po-table-column-icon", 100)(12, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_12_Template, 2, 1, "span", 98)(13, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_13_Template, 2, 1, "span", 98)(14, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_span_14_Template, 2, 1, "span", 101);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r112 = ctx.$implicit;
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r93 = ɵɵnextContext(3);
    ɵɵstyleProp("width", column_r112.width)("max-width", column_r112.width)("min-width", column_r112.width);
    ɵɵclassProp("po-table-column", column_r112.type !== "icon")("po-table-column-right", column_r112.type === "currency" || column_r112.type === "number")("po-table-column-center", column_r112.type === "subtitle")("po-table-column-icons", column_r112.type === "icon");
    ɵɵproperty("pFrozenColumn", column_r112.fixed)("ngClass", ctx_r93.getClassColor(row_r87, column_r112));
    ɵɵadvance();
    ɵɵproperty("ngSwitch", column_r112.type)("p-tooltip", ctx_r93.tooltipText)("p-append-in-body", true);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "columnTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cellTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "boolean");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "currency");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "time");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dateTime");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "link");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "icon");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "label");
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_7_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r169 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 94);
    ɵɵlistener("click", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_7_Template_td_click_0_listener() {
      ɵɵrestoreView(_r169);
      const row_r87 = ɵɵnextContext().$implicit;
      const ctx_r167 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r167.toggleDetail(row_r87));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_7_ng_template_1_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r170 = ɵɵnextContext();
    const row_r87 = ctx_r170.$implicit;
    const rowIndex_r88 = ctx_r170.index;
    ɵɵnextContext(3);
    const _r13 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r13)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r87, rowIndex_r88));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_8_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_8_ng_container_15_tbody_1_8_ng_template_0_Template, 0, 0, "ng-template", 95);
  }
  if (rf & 2) {
    const ctx_r172 = ɵɵnextContext();
    const row_r87 = ctx_r172.$implicit;
    const rowIndex_r88 = ctx_r172.index;
    ɵɵnextContext(3);
    const _r25 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r87, rowIndex_r88));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_9_ng_template_2_Template(rf, ctx) {
}
var _c19 = (a0, a1) => ({ $implicit: a0, rowIndex: a1 });
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "td", 106);
    ɵɵtemplate(2, PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_9_ng_template_2_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r174 = ɵɵnextContext();
    const row_r87 = ctx_r174.$implicit;
    const rowIndex_r88 = ctx_r174.index;
    const ctx_r96 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r96.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r96.tableRowTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c19, row_r87, rowIndex_r88));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r176 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr")(1, "td", 107)(2, "po-table-detail", 108);
    ɵɵlistener("p-select-row", function PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_10_Template_po_table_detail_p_select_row_2_listener($event) {
      ɵɵrestoreView(_r176);
      const ctx_r175 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r175.selectDetailRow($event));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r87 = ɵɵnextContext().$implicit;
    const ctx_r97 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r97.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("p-selectable", ctx_r97.selectable && !ctx_r97.detailHideSelect)("p-detail", ctx_r97.columnMasterDetail.detail)("p-items", row_r87[ctx_r97.nameColumnDetail]);
  }
}
function PoTableComponent_ng_template_8_ng_container_15_tbody_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 86)(1, "tr", 90);
    ɵɵtemplate(2, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_2_Template, 2, 4, "td", 91)(3, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_3_Template, 2, 5, "td", 92)(4, PoTableComponent_ng_template_8_ng_container_15_tbody_1_4_Template, 1, 5, null, 43)(5, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_5_Template, 2, 5, "td", 92)(6, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_6_Template, 15, 31, "td", 93)(7, PoTableComponent_ng_template_8_ng_container_15_tbody_1_td_7_Template, 2, 5, "td", 92)(8, PoTableComponent_ng_template_8_ng_container_15_tbody_1_8_Template, 1, 5, null, 43);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_9_Template, 3, 6, "tr", 43)(10, PoTableComponent_ng_template_8_ng_container_15_tbody_1_tr_10_Template, 3, 4, "tr", 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r87 = ctx.$implicit;
    const rowIndex_r88 = ctx.index;
    const ctx_r86 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵclassProp("po-table-row-active", row_r87.$selected || row_r87.$selected === null && ctx_r86.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.columnMasterDetail && !ctx_r86.hideDetail && !ctx_r86.hasRowTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r86.actionRight && (ctx_r86.visibleActions.length > 1 || ctx_r86.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.hasRowTemplate && !ctx_r86.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r86.mainColumns)("ngForTrackBy", ctx_r86.trackBy);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.actionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.hasMainColumns && ctx_r86.hasRowTemplate && row_r87.$showDetail && ctx_r86.isShowRowTemplate(row_r87, rowIndex_r88));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r86.hasMainColumns && ctx_r86.isShowMasterDetail(row_r87));
  }
}
function PoTableComponent_ng_template_8_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_8_ng_container_15_tbody_1_Template, 11, 12, "tbody", 89);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r66 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r66.filteredItems)("ngForTrackBy", ctx_r66.trackBy);
  }
}
var _c20 = (a0, a1, a2, a3) => ({ "po-table-interactive": a0, "po-table-selectable": a1, "po-table-striped": a2, "po-table-data-fixed-columns": a3 });
var _c21 = (a0, a1) => ({ "no-hover": a0, "po-table-column-drag": a1 });
function PoTableComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r179 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "table", 55)(1, "thead")(2, "tr", 56);
    ɵɵlistener("cdkDropListDropped", function PoTableComponent_ng_template_8_Template_tr_cdkDropListDropped_2_listener($event) {
      ɵɵrestoreView(_r179);
      const ctx_r178 = ɵɵnextContext();
      return ɵɵresetView(ctx_r178.drop($event));
    });
    ɵɵtemplate(3, PoTableComponent_ng_template_8_th_3_Template, 3, 5, "th", 57)(4, PoTableComponent_ng_template_8_th_4_Template, 1, 0, "th", 58)(5, PoTableComponent_ng_template_8_th_5_Template, 2, 4, "th", 59)(6, PoTableComponent_ng_template_8_th_6_Template, 3, 3, "th", 60)(7, PoTableComponent_ng_template_8_ng_container_7_Template, 1, 0, "ng-container", 61)(8, PoTableComponent_ng_template_8_ng_template_8_Template, 1, 2, "ng-template", null, 62, ɵɵtemplateRefExtractor)(10, PoTableComponent_ng_template_8_ng_template_10_Template, 1, 2, "ng-template", null, 63, ɵɵtemplateRefExtractor)(12, PoTableComponent_ng_template_8_th_12_Template, 1, 0, "th", 58)(13, PoTableComponent_ng_template_8_th_13_Template, 1, 4, "th", 64);
    ɵɵelementEnd()();
    ɵɵtemplate(14, PoTableComponent_ng_template_8_tbody_14_Template, 5, 2, "tbody", 65)(15, PoTableComponent_ng_template_8_ng_container_15_Template, 2, 2, "ng-container", 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const _r60 = ɵɵreference(9);
    const _r62 = ɵɵreference(11);
    const ctx_r7 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction4(16, _c20, ctx_r7.selectable || ctx_r7.sort, ctx_r7.selectable, ctx_r7.striped, ctx_r7.applyFixedColumns()));
    ɵɵattribute("p-spacing", ctx_r7.spacing);
    ɵɵadvance(2);
    ɵɵclassProp("po-table-header", !ctx_r7.height);
    ɵɵproperty("ngClass", ɵɵpureFunction2(21, _c21, ctx_r7.hideSelectAll, ctx_r7.isDraggable));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r7.hasSelectableColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r7.hasMasterDetailColumn || ctx_r7.hasRowTemplate) && !ctx_r7.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r7.actionRight && (ctx_r7.visibleActions.length > 1 || ctx_r7.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r7.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r7.isDraggable || ctx_r7.hasSomeFixed())("ngIfThen", _r60)("ngIfElse", _r62);
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r7.hasRowTemplateWithArrowDirectionRight && (ctx_r7.hasVisibleActions || ctx_r7.hideColumnsManager));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r7.hasVisibleActions && ctx_r7.actionRight && (ctx_r7.visibleActions.length > 1 || ctx_r7.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r7.hasItems || !ctx_r7.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r7.hasMainColumns);
  }
}
function PoTableComponent_ng_template_10_th_5_po_checkbox_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r196 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 68);
    ɵɵlistener("p-change", function PoTableComponent_ng_template_10_th_5_po_checkbox_2_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r196);
      const ctx_r195 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r195.selectAllRows());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r194 = ɵɵnextContext(3);
    ɵɵproperty("p-checkboxValue", ctx_r194.selectAll === null ? "mixed" : ctx_r194.selectAll);
  }
}
function PoTableComponent_ng_template_10_th_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 66)(1, "div");
    ɵɵtemplate(2, PoTableComponent_ng_template_10_th_5_po_checkbox_2_Template, 1, 1, "po-checkbox", 67);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r181 = ɵɵnextContext(2);
    ɵɵstyleProp("pointer-events", ctx_r181.hideSelectAll ? "none" : "auto");
    ɵɵadvance();
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r181.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r181.hideSelectAll);
  }
}
function PoTableComponent_ng_template_10_th_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 69);
  }
}
function PoTableComponent_ng_template_10_th_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", null, 70);
  }
  if (rf & 2) {
    const ctx_r183 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-master-detail", !ctx_r183.isSingleAction)("po-table-header-single-action", ctx_r183.isSingleAction);
  }
}
function PoTableComponent_ng_template_10_th_8_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_th_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 71, 72);
    ɵɵtemplate(2, PoTableComponent_ng_template_10_th_8_ng_container_2_Template, 1, 0, "ng-container", 61);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r184 = ɵɵnextContext(2);
    const _r21 = ɵɵreference(23);
    const _r23 = ɵɵreference(25);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r184.height)("ngIfThen", _r21)("ngIfElse", _r23);
  }
}
function PoTableComponent_ng_template_10_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 77);
    ɵɵelement(2, "circle", 78)(3, "circle", 79)(4, "circle", 80)(5, "circle", 81)(6, "circle", 82)(7, "circle", 83);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c22 = (a0) => ({ "width": a0 });
function PoTableComponent_ng_template_10_ng_template_10_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r206 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 116);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_template_10_th_0_Template_th_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r206);
      const column_r201 = restoredCtx.$implicit;
      const ctx_r205 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r205.sortColumn(column_r201));
    });
    ɵɵpipe(1, "lowercase");
    ɵɵpipe(2, "titlecase");
    ɵɵelementStart(3, "div", 75);
    ɵɵtemplate(4, PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_4_Template, 8, 0, "ng-container", 43)(5, PoTableComponent_ng_template_10_ng_template_10_th_0_ng_container_5_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r201 = ctx.$implicit;
    const ctx_r200 = ɵɵnextContext(3);
    const _r19 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r201.width)("max-width", column_r201.width)("min-width", column_r201.width);
    ɵɵclassProp("po-clickable", ctx_r200.sort && column_r201.sortable !== false || ctx_r200.hasService)("po-table-header-subtitle", column_r201.type === "subtitle")("po-table-column-drag-box", ctx_r200.isDraggable);
    ɵɵproperty("ngClass", ɵɵpureFunction1(30, _c15, ctx_r200.sort && ctx_r200.JSON.stringify(ctx_r200.sortedColumn == null ? null : ctx_r200.sortedColumn.property) === ctx_r200.JSON.stringify(column_r201) && (ctx_r200.sortedColumn.ascending || !ctx_r200.sortedColumn.ascending)))("ngStyle", ɵɵpureFunction1(32, _c22, !ctx_r200.hasItems ? "100%" : ctx_r200.applyFixedColumns() ? column_r201.width : "auto"))("cdkDragDisabled", column_r201.fixed ? "true" : "false")("pFrozenColumn", column_r201.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(1, 26, column_r201.label || ɵɵpipeBind1(2, 28, column_r201.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r200.height)("po-table-header-flex-right", column_r201.type === "currency" || column_r201.type === "number")("po-table-header-flex-center", column_r201.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r200.isDraggable && !column_r201.fixed);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r19)("ngTemplateOutletContext", ɵɵpureFunction1(34, _c16, column_r201));
  }
}
function PoTableComponent_ng_template_10_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_template_10_th_0_Template, 6, 36, "th", 115);
  }
  if (rf & 2) {
    const ctx_r186 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r186.mainColumns)("ngForTrackBy", ctx_r186.trackBy);
  }
}
function PoTableComponent_ng_template_10_ng_template_12_th_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_template_12_th_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r212 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 118);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_template_12_th_0_Template_th_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r212);
      const column_r208 = restoredCtx.$implicit;
      const ctx_r211 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r211.sortColumn(column_r208));
    });
    ɵɵpipe(1, "lowercase");
    ɵɵpipe(2, "titlecase");
    ɵɵelementStart(3, "div", 75);
    ɵɵtemplate(4, PoTableComponent_ng_template_10_ng_template_12_th_0_ng_container_4_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r208 = ctx.$implicit;
    const ctx_r207 = ɵɵnextContext(3);
    const _r19 = ɵɵreference(21);
    ɵɵstyleProp("width", column_r208.width)("max-width", column_r208.width)("min-width", column_r208.width);
    ɵɵclassProp("po-clickable", ctx_r207.sort && column_r208.sortable !== false || ctx_r207.hasService)("po-table-header-subtitle", column_r208.type === "subtitle");
    ɵɵproperty("ngClass", ɵɵpureFunction1(26, _c15, ctx_r207.sort && ctx_r207.JSON.stringify(ctx_r207.sortedColumn == null ? null : ctx_r207.sortedColumn.property) === ctx_r207.JSON.stringify(column_r208) && (ctx_r207.sortedColumn.ascending || !ctx_r207.sortedColumn.ascending)))("ngStyle", ɵɵpureFunction1(28, _c22, !ctx_r207.hasItems ? "100%" : ctx_r207.applyFixedColumns() ? column_r208.width : "auto"))("pFrozenColumn", column_r208.fixed);
    ɵɵattribute("data-po-table-column-name", ɵɵpipeBind1(1, 22, column_r208.label || ɵɵpipeBind1(2, 24, column_r208.property)));
    ɵɵadvance(3);
    ɵɵclassProp("po-table-header-fixed-inner", ctx_r207.height)("po-table-header-flex-right", column_r208.type === "currency" || column_r208.type === "number")("po-table-header-flex-center", column_r208.type === "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r19)("ngTemplateOutletContext", ɵɵpureFunction1(30, _c16, column_r208));
  }
}
function PoTableComponent_ng_template_10_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_template_12_th_0_Template, 5, 32, "th", 117);
  }
  if (rf & 2) {
    const ctx_r188 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r188.mainColumns)("ngForTrackBy", ctx_r188.trackBy);
  }
}
function PoTableComponent_ng_template_10_th_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 69);
  }
}
function PoTableComponent_ng_template_10_th_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th");
  }
  if (rf & 2) {
    const ctx_r191 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-header-single-action", ctx_r191.isSingleAction)("po-table-header-actions", !ctx_r191.isSingleAction);
  }
}
function PoTableComponent_ng_template_10_tbody_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 86)(1, "tr", 87)(2, "td", 88)(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r192 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("colSpan", ctx_r192.columnCount);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r192.literals.noData, " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 66);
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_ng_container_1_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r216 = ɵɵnextContext(3);
    const _r15 = ɵɵreference(17);
    const _r17 = ɵɵreference(19);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r216.singleSelect ? _r15 : _r17)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c16, row_r214));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r230 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 94);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_Template_td_click_0_listener() {
      ɵɵrestoreView(_r230);
      const row_r214 = ɵɵnextContext().$implicit;
      const ctx_r228 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r228.toggleDetail(row_r214));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_ng_template_1_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r231 = ɵɵnextContext();
    const row_r214 = ctx_r231.$implicit;
    const rowIndex_r215 = ctx_r231.index;
    ɵɵnextContext(3);
    const _r13 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r13)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r214, rowIndex_r215));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_ng_template_0_Template, 0, 0, "ng-template", 95);
  }
  if (rf & 2) {
    const ctx_r233 = ɵɵnextContext();
    const row_r214 = ctx_r233.$implicit;
    const rowIndex_r215 = ctx_r233.index;
    ɵɵnextContext(3);
    const _r25 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r214, rowIndex_r215));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r237 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 94);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template_td_click_0_listener() {
      ɵɵrestoreView(_r237);
      const row_r214 = ɵɵnextContext().$implicit;
      const ctx_r235 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r235.toggleDetail(row_r214));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_ng_template_1_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r238 = ɵɵnextContext();
    const row_r214 = ctx_r238.$implicit;
    const rowIndex_r215 = ctx_r238.index;
    ɵɵnextContext(3);
    const _r13 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r13)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r214, rowIndex_r215));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_2_ng_container_1_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r241 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r241.getTemplate(column_r239))("ngTemplateOutletContext", ɵɵpureFunction1(2, _c16, ctx_r241.getCellData(row_r214, column_r239)));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_3_ng_container_1_Template, 1, 0, "ng-container", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r242 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r242.tableCellTemplate == null ? null : ctx_r242.tableCellTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c18, row_r214, column_r239));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r243 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r243.getBooleanLabel(ctx_r243.getCellData(row_r214, column_r239), column_r239), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r244 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind4(2, 1, ctx_r244.getCellData(row_r214, column_r239), column_r239.format, "symbol", "1.2-2"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r245 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r245.getCellData(row_r214, column_r239), column_r239.format || "dd/MM/yyyy"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "po_time");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r246 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r246.getCellData(row_r214, column_r239), column_r239.format || "HH:mm:ss.ffffff"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r247 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r247.getCellData(row_r214, column_r239), column_r239.format || "dd/MM/yyyy HH:mm:ss"), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r248 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r248.formatNumber(ctx_r248.getCellData(row_r214, column_r239), column_r239.format), " ");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_po_table_column_link_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r274 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-column-link", 102);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_po_table_column_link_10_Template_po_table_column_link_click_0_listener($event) {
      ɵɵrestoreView(_r274);
      const column_r239 = ɵɵnextContext().$implicit;
      const row_r214 = ɵɵnextContext().$implicit;
      const ctx_r272 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r272.onClickLink($event, row_r214, column_r239));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r249 = ɵɵnextContext(3);
    ɵɵproperty("p-action", column_r239.action)("p-disabled", ctx_r249.checkDisabled(row_r214, column_r239))("p-link", row_r214[column_r239.link])("p-row", row_r214)("p-value", ctx_r249.getCellData(row_r214, column_r239));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_po_table_column_icon_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-table-column-icon", 103);
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r250 = ɵɵnextContext(3);
    ɵɵproperty("p-column", column_r239)("p-icons", ctx_r250.getColumnIcons(row_r214, column_r239))("p-row", row_r214);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-subtitle-circle", 104);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r251 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-subtitle", ctx_r251.getSubtitleColumn(row_r214, column_r239));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "po-table-column-label", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r252 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("p-value", ctx_r252.getColumnLabel(row_r214, column_r239));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r239 = ɵɵnextContext().$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r253 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r253.getCellData(row_r214, column_r239));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r287 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 121);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template_td_click_0_listener() {
      ɵɵrestoreView(_r287);
      const row_r214 = ɵɵnextContext().$implicit;
      const ctx_r286 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r286.hasSelectableRow() ? ctx_r286.selectRow(row_r214) : "javascript:;");
    });
    ɵɵelementStart(1, "div", 97);
    ɵɵlistener("mouseenter", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template_div_mouseenter_1_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r287);
      const column_r239 = restoredCtx.$implicit;
      const row_r214 = ɵɵnextContext().$implicit;
      const ctx_r289 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r289.tooltipMouseEnter($event, column_r239, row_r214));
    })("mouseleave", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template_div_mouseleave_1_listener() {
      ɵɵrestoreView(_r287);
      const ctx_r291 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r291.tooltipMouseLeave());
    });
    ɵɵtemplate(2, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_2_Template, 2, 4, "span", 98)(3, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_3_Template, 2, 5, "span", 98)(4, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_4_Template, 2, 1, "span", 98)(5, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_5_Template, 3, 6, "span", 98)(6, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_6_Template, 3, 4, "span", 98)(7, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_7_Template, 3, 4, "span", 98)(8, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_8_Template, 3, 4, "span", 98)(9, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_9_Template, 2, 1, "span", 98)(10, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_po_table_column_link_10_Template, 1, 5, "po-table-column-link", 99)(11, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_po_table_column_icon_11_Template, 1, 3, "po-table-column-icon", 100)(12, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_12_Template, 2, 1, "span", 98)(13, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_13_Template, 2, 1, "span", 98)(14, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_span_14_Template, 2, 1, "span", 101);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r239 = ctx.$implicit;
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r220 = ɵɵnextContext(3);
    ɵɵstyleProp("width", column_r239.width)("max-width", column_r239.width)("min-width", column_r239.width);
    ɵɵclassProp("po-table-column", column_r239.type !== "icon")("po-table-column-right", column_r239.type === "currency" || column_r239.type === "number")("po-table-column-center", column_r239.type === "subtitle")("po-table-column-icons", column_r239.type === "icon");
    ɵɵproperty("ngClass", ctx_r220.getClassColor(row_r214, column_r239))("pFrozenColumn", column_r239.fixed);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", column_r239.type)("p-tooltip", ctx_r220.tooltipText)("p-append-in-body", true);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "columnTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "cellTemplate");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "boolean");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "currency");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "time");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dateTime");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "link");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "icon");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "subtitle");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "label");
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_7_ng_template_1_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r296 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 94);
    ɵɵlistener("click", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_7_Template_td_click_0_listener() {
      ɵɵrestoreView(_r296);
      const row_r214 = ɵɵnextContext().$implicit;
      const ctx_r294 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r294.toggleDetail(row_r214));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_7_ng_template_1_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r297 = ɵɵnextContext();
    const row_r214 = ctx_r297.$implicit;
    const rowIndex_r215 = ctx_r297.index;
    ɵɵnextContext(3);
    const _r13 = ɵɵreference(15);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r13)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r214, rowIndex_r215));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_8_ng_template_0_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_10_ng_container_17_tbody_1_8_ng_template_0_Template, 0, 0, "ng-template", 95);
  }
  if (rf & 2) {
    const ctx_r299 = ɵɵnextContext();
    const row_r214 = ctx_r299.$implicit;
    const rowIndex_r215 = ctx_r299.index;
    ɵɵnextContext(3);
    const _r25 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", _r25)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c17, row_r214, rowIndex_r215));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_ng_template_2_Template(rf, ctx) {
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr")(1, "td", 106);
    ɵɵtemplate(2, PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_ng_template_2_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r301 = ɵɵnextContext();
    const row_r214 = ctx_r301.$implicit;
    const rowIndex_r215 = ctx_r301.index;
    const ctx_r223 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r223.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r223.tableRowTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c19, row_r214, rowIndex_r215));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r303 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr")(1, "td", 107)(2, "po-table-detail", 108);
    ɵɵlistener("p-select-row", function PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_10_Template_po_table_detail_p_select_row_2_listener($event) {
      ɵɵrestoreView(_r303);
      const ctx_r302 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r302.selectDetailRow($event));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r214 = ɵɵnextContext().$implicit;
    const ctx_r224 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("colSpan", ctx_r224.columnCountForMasterDetail);
    ɵɵadvance();
    ɵɵproperty("p-selectable", ctx_r224.selectable && !ctx_r224.detailHideSelect)("p-detail", ctx_r224.columnMasterDetail.detail)("p-items", row_r214[ctx_r224.nameColumnDetail]);
  }
}
function PoTableComponent_ng_template_10_ng_container_17_tbody_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tbody", 86)(1, "tr", 90);
    ɵɵtemplate(2, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_2_Template, 2, 4, "td", 91)(3, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_3_Template, 2, 5, "td", 92)(4, PoTableComponent_ng_template_10_ng_container_17_tbody_1_4_Template, 1, 5, null, 43)(5, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_5_Template, 2, 5, "td", 92)(6, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_6_Template, 15, 31, "td", 120)(7, PoTableComponent_ng_template_10_ng_container_17_tbody_1_td_7_Template, 2, 5, "td", 92)(8, PoTableComponent_ng_template_10_ng_container_17_tbody_1_8_Template, 1, 5, null, 43);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_9_Template, 3, 6, "tr", 43)(10, PoTableComponent_ng_template_10_ng_container_17_tbody_1_tr_10_Template, 3, 4, "tr", 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r214 = ctx.$implicit;
    const rowIndex_r215 = ctx.index;
    const ctx_r213 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵclassProp("po-table-row-active", row_r214.$selected || row_r214.$selected === null && ctx_r213.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.selectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.columnMasterDetail && !ctx_r213.hideDetail && !ctx_r213.hasRowTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r213.actionRight && (ctx_r213.visibleActions.length > 1 || ctx_r213.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.hasRowTemplate && !ctx_r213.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r213.mainColumns)("ngForTrackBy", ctx_r213.trackBy);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.actionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.hasMainColumns && ctx_r213.hasRowTemplate && row_r214.$showDetail && ctx_r213.isShowRowTemplate(row_r214, rowIndex_r215));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r213.hasMainColumns && ctx_r213.isShowMasterDetail(row_r214));
  }
}
function PoTableComponent_ng_template_10_ng_container_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoTableComponent_ng_template_10_ng_container_17_tbody_1_Template, 11, 12, "tbody", 119);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r193 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("cdkVirtualForOf", ctx_r193.filteredItems)("cdkVirtualForTrackBy", ctx_r193.trackBy);
  }
}
function PoTableComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r306 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "cdk-virtual-scroll-viewport", 109, 110)(2, "table", 55)(3, "thead", 111)(4, "tr", 112);
    ɵɵlistener("cdkDropListDropped", function PoTableComponent_ng_template_10_Template_tr_cdkDropListDropped_4_listener($event) {
      ɵɵrestoreView(_r306);
      const ctx_r305 = ɵɵnextContext();
      return ɵɵresetView(ctx_r305.drop($event));
    });
    ɵɵtemplate(5, PoTableComponent_ng_template_10_th_5_Template, 3, 5, "th", 57)(6, PoTableComponent_ng_template_10_th_6_Template, 1, 0, "th", 58)(7, PoTableComponent_ng_template_10_th_7_Template, 2, 4, "th", 59)(8, PoTableComponent_ng_template_10_th_8_Template, 3, 3, "th", 60)(9, PoTableComponent_ng_template_10_ng_container_9_Template, 1, 0, "ng-container", 61)(10, PoTableComponent_ng_template_10_ng_template_10_Template, 1, 2, "ng-template", null, 113, ɵɵtemplateRefExtractor)(12, PoTableComponent_ng_template_10_ng_template_12_Template, 1, 2, "ng-template", null, 114, ɵɵtemplateRefExtractor)(14, PoTableComponent_ng_template_10_th_14_Template, 1, 0, "th", 58)(15, PoTableComponent_ng_template_10_th_15_Template, 1, 4, "th", 64);
    ɵɵelementEnd()();
    ɵɵtemplate(16, PoTableComponent_ng_template_10_tbody_16_Template, 5, 2, "tbody", 65)(17, PoTableComponent_ng_template_10_ng_container_17_Template, 2, 2, "ng-container", 43);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const _r187 = ɵɵreference(11);
    const _r189 = ɵɵreference(13);
    const ctx_r9 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r9.heightTableContainer, "px");
    ɵɵproperty("itemSize", ctx_r9.itemSize)("minBufferPx", ctx_r9.heightTableContainer < 100 ? 100 : ctx_r9.heightTableContainer)("maxBufferPx", ctx_r9.heightTableContainer < 200 ? 200 : ctx_r9.heightTableContainer);
    ɵɵadvance(2);
    ɵɵproperty("ngClass", ɵɵpureFunction4(22, _c20, ctx_r9.selectable || ctx_r9.sort, ctx_r9.selectable, ctx_r9.striped, ctx_r9.applyFixedColumns()));
    ɵɵattribute("p-spacing", ctx_r9.spacing);
    ɵɵadvance();
    ɵɵstyleProp("top", ctx_r9.inverseOfTranslation);
    ɵɵadvance();
    ɵɵclassProp("po-table-header", !ctx_r9.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r9.hasSelectableColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r9.hasMasterDetailColumn || ctx_r9.hasRowTemplate) && !ctx_r9.hasRowTemplateWithArrowDirectionRight);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r9.actionRight && (ctx_r9.visibleActions.length > 1 || ctx_r9.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r9.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r9.isDraggable || ctx_r9.hasSomeFixed())("ngIfThen", _r187)("ngIfElse", _r189);
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r9.hasRowTemplateWithArrowDirectionRight && (ctx_r9.hasVisibleActions || ctx_r9.hideColumnsManager));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r9.hasVisibleActions && ctx_r9.actionRight && (ctx_r9.visibleActions.length > 1 || ctx_r9.isSingleAction));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r9.hasItems || !ctx_r9.hasMainColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r9.hasMainColumns);
  }
}
function PoTableComponent_ng_template_14_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 123);
  }
  if (rf & 2) {
    const row_r307 = ɵɵnextContext().row;
    ɵɵclassProp("po-icon-arrow-up", row_r307.$showDetail)("po-icon-arrow-down", !row_r307.$showDetail);
  }
}
function PoTableComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_14_span_0_Template, 1, 4, "span", 122);
  }
  if (rf & 2) {
    const row_r307 = ctx.row;
    const rowIndex_r308 = ctx.rowIndex;
    const ctx_r12 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r12.containsMasterDetail(row_r307) && !ctx_r12.hasRowTemplate || ctx_r12.isShowRowTemplate(row_r307, rowIndex_r308) && ctx_r12.hasRowTemplate);
  }
}
function PoTableComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r313 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-radio", 124);
    ɵɵlistener("p-change-selected", function PoTableComponent_ng_template_16_Template_po_radio_p_change_selected_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r313);
      const row_r311 = restoredCtx.$implicit;
      const ctx_r312 = ɵɵnextContext();
      return ɵɵresetView(ctx_r312.selectRow(row_r311));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r311 = ctx.$implicit;
    const ctx_r14 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r14.idRadio)("p-checked", row_r311.$selected);
  }
}
function PoTableComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r316 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 125);
    ɵɵlistener("p-change", function PoTableComponent_ng_template_18_Template_po_checkbox_p_change_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r316);
      const row_r314 = restoredCtx.$implicit;
      const ctx_r315 = ɵɵnextContext();
      return ɵɵresetView(ctx_r315.selectable ? ctx_r315.selectRow(row_r314) : "javascript:;");
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r314 = ctx.$implicit;
    ɵɵproperty("p-checkboxValue", row_r314.$selected);
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 129);
    ɵɵelement(2, "path", 130);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 129);
    ɵɵelement(2, "path", 131);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function PoTableComponent_ng_template_20_span_4_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 129);
    ɵɵelement(2, "path", 132);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function PoTableComponent_ng_template_20_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, PoTableComponent_ng_template_20_span_4_ng_container_1_Template, 3, 0, "ng-container", 43)(2, PoTableComponent_ng_template_20_span_4_ng_container_2_Template, 3, 0, "ng-container", 43)(3, PoTableComponent_ng_template_20_span_4_ng_container_3_Template, 3, 0, "ng-container", 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r317 = ɵɵnextContext().$implicit;
    const ctx_r319 = ɵɵnextContext();
    ɵɵclassProp("po-table-header-icon-unselected", ctx_r319.JSON.stringify(ctx_r319.sortedColumn == null ? null : ctx_r319.sortedColumn.property) !== ctx_r319.JSON.stringify(column_r317))("po-table-header-icon-descending", ctx_r319.JSON.stringify(ctx_r319.sortedColumn == null ? null : ctx_r319.sortedColumn.property) === ctx_r319.JSON.stringify(column_r317) && ctx_r319.sortedColumn.ascending)("po-table-header-icon-ascending", ctx_r319.JSON.stringify(ctx_r319.sortedColumn == null ? null : ctx_r319.sortedColumn.property) === ctx_r319.JSON.stringify(column_r317) && !ctx_r319.sortedColumn.ascending);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r319.JSON.stringify(ctx_r319.sortedColumn == null ? null : ctx_r319.sortedColumn.property) !== ctx_r319.JSON.stringify(column_r317));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r319.JSON.stringify(ctx_r319.sortedColumn == null ? null : ctx_r319.sortedColumn.property) === ctx_r319.JSON.stringify(column_r317) && ctx_r319.sortedColumn.ascending);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r319.JSON.stringify(ctx_r319.sortedColumn == null ? null : ctx_r319.sortedColumn.property) === ctx_r319.JSON.stringify(column_r317) && !ctx_r319.sortedColumn.ascending);
  }
}
function PoTableComponent_ng_template_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r325 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 126, 127);
    ɵɵlistener("mouseenter", function PoTableComponent_ng_template_20_Template_span_mouseenter_0_listener($event) {
      ɵɵrestoreView(_r325);
      const ctx_r324 = ɵɵnextContext();
      return ɵɵresetView(ctx_r324.tooltipMouseEnter($event));
    })("mouseleave", function PoTableComponent_ng_template_20_Template_span_mouseleave_0_listener() {
      ɵɵrestoreView(_r325);
      const ctx_r326 = ɵɵnextContext();
      return ɵɵresetView(ctx_r326.tooltipMouseLeave());
    });
    ɵɵtext(2);
    ɵɵpipe(3, "titlecase");
    ɵɵelementEnd();
    ɵɵtemplate(4, PoTableComponent_ng_template_20_span_4_Template, 4, 9, "span", 128);
  }
  if (rf & 2) {
    const column_r317 = ctx.$implicit;
    const ctx_r18 = ɵɵnextContext();
    ɵɵproperty("p-tooltip", ctx_r18.tooltipText)("p-append-in-body", true);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", column_r317.label || ɵɵpipeBind1(3, 4, column_r317.property), " ");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r18.sort && column_r317.sortable !== false);
  }
}
function PoTableComponent_ng_template_22_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 133);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r20 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r20.headerWidth, "px");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r20.hasValidColumns ? ctx_r20.literals.noVisibleColumn : ctx_r20.literals.noColumns, " ");
  }
}
function PoTableComponent_ng_template_24_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r22 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r22.hasValidColumns ? ctx_r22.literals.noVisibleColumn : ctx_r22.literals.noColumns, "\n");
  }
}
function PoTableComponent_ng_template_26_td_0_div_1_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 140);
  }
  if (rf & 2) {
    const ctx_r332 = ɵɵnextContext(4);
    ɵɵproperty("p-icon", ctx_r332.firstAction.icon);
  }
}
function PoTableComponent_ng_template_26_td_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r335 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 138);
    ɵɵlistener("click", function PoTableComponent_ng_template_26_td_0_div_1_Template_div_click_0_listener() {
      ɵɵrestoreView(_r335);
      const row_r327 = ɵɵnextContext(2).row;
      const ctx_r333 = ɵɵnextContext();
      return ɵɵresetView(ctx_r333.executeTableAction(row_r327, ctx_r333.firstAction));
    });
    ɵɵtemplate(1, PoTableComponent_ng_template_26_td_0_div_1_po_icon_1_Template, 1, 1, "po-icon", 139);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r327 = ɵɵnextContext(2).row;
    const ctx_r331 = ɵɵnextContext();
    ɵɵclassProp("po-table-action-disabled", ctx_r331.firstAction.disabled ? ctx_r331.validateTableAction(row_r327, ctx_r331.firstAction) : false);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r331.firstAction.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r331.firstAction.label, " ");
  }
}
function PoTableComponent_ng_template_26_td_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 136);
    ɵɵtemplate(1, PoTableComponent_ng_template_26_td_0_div_1_Template, 3, 4, "div", 137);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r329 = ɵɵnextContext(2);
    ɵɵstyleProp("width", ctx_r329.height && ctx_r329.actionRight ? ctx_r329.getWidthColumnManager() : "", "px")("max-width", ctx_r329.height && !ctx_r329.actionRight ? ctx_r329.getColumnWidthActionsLeft() : "", "px")("width", ctx_r329.height && !ctx_r329.actionRight ? ctx_r329.getColumnWidthActionsLeft() : "", "px");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r329.firstAction.visible !== false);
  }
}
function PoTableComponent_ng_template_26_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r340 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 141)(1, "span", 142, 143);
    ɵɵlistener("click", function PoTableComponent_ng_template_26_td_1_Template_span_click_1_listener() {
      ɵɵrestoreView(_r340);
      const _r337 = ɵɵreference(2);
      const row_r327 = ɵɵnextContext().row;
      const ctx_r338 = ɵɵnextContext();
      return ɵɵresetView(ctx_r338.togglePopup(row_r327, _r337));
    });
    ɵɵelementEnd()();
  }
}
function PoTableComponent_ng_template_26_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTableComponent_ng_template_26_td_0_Template, 2, 7, "td", 134)(1, PoTableComponent_ng_template_26_td_1_Template, 3, 0, "td", 135);
  }
  if (rf & 2) {
    const ctx_r24 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r24.isSingleAction);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r24.visibleActions.length > 1);
  }
}
function PoTableComponent_po_table_column_manager_28_Template(rf, ctx) {
  if (rf & 1) {
    const _r342 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-table-column-manager", 144);
    ɵɵlistener("p-visible-columns-change", function PoTableComponent_po_table_column_manager_28_Template_po_table_column_manager_p_visible_columns_change_0_listener($event) {
      ɵɵrestoreView(_r342);
      const ctx_r341 = ɵɵnextContext();
      return ɵɵresetView(ctx_r341.onVisibleColumnsChange($event));
    })("p-change-visible-columns", function PoTableComponent_po_table_column_manager_28_Template_po_table_column_manager_p_change_visible_columns_0_listener($event) {
      ɵɵrestoreView(_r342);
      const ctx_r343 = ɵɵnextContext();
      return ɵɵresetView(ctx_r343.onChangeVisibleColumns($event));
    })("p-initial-columns", function PoTableComponent_po_table_column_manager_28_Template_po_table_column_manager_p_initial_columns_0_listener($event) {
      ɵɵrestoreView(_r342);
      const ctx_r344 = ɵɵnextContext();
      return ɵɵresetView(ctx_r344.onColumnRestoreManager($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r26 = ɵɵnextContext();
    ɵɵproperty("p-columns", ctx_r26.columns)("p-max-columns", ctx_r26.maxColumns)("p-target", ctx_r26.columnManagerTarget)("p-last-visible-columns-selected", ctx_r26.lastVisibleColumnsSelected)("p-hide-action-fixed-columns", ctx_r26.hideActionFixedColumns)("p-columns-default", ctx_r26.initialColumns);
  }
}
var PoTableComponent = class _PoTableComponent extends PoTableBaseComponent {
  changeDetector;
  decimalPipe;
  router;
  defaultService;
  tableRowTemplate;
  tableCellTemplate;
  tableColumnTemplates;
  noColumnsHeader;
  poPopupComponent;
  modalDelete;
  tableFooterElement;
  tableWrapperElement;
  tableTemplate;
  tableVirtualScroll;
  columnManager;
  columnBatchActions;
  columnActionLeft;
  actionsIconElement;
  actionsElement;
  filterInput;
  poSearchInput;
  viewPort;
  poNotification = inject(PoNotificationService);
  heightTableContainer;
  heightTableVirtual;
  popupTarget;
  tableOpacity = 0;
  tooltipText;
  itemSize = 48;
  lastVisibleColumnsSelected;
  tagColor;
  idRadio;
  inputFieldValue = "";
  JSON;
  newOrderColumns;
  sizeLoading = "sm";
  headerWidth;
  close = {
    action: () => {
      this.modalDelete.close();
    },
    label: this.literals.cancel,
    danger: true
  };
  confirm = {
    action: () => {
      this.deleteItems();
    },
    label: this.literals.delete
  };
  _columnManagerTarget;
  _columnManagerTargetFixed;
  differ;
  footerHeight;
  headerHeight;
  timeoutResize;
  visibleElement = false;
  scrollEvent$;
  subscriptionScrollEvent;
  subscriptionService = new Subscription();
  clickListener;
  resizeListener;
  set columnManagerTarget(value) {
    this._columnManagerTarget = value;
    this.changeDetector.detectChanges();
  }
  get columnManagerTarget() {
    return this._columnManagerTarget;
  }
  set columnManagerTargetFixed(value) {
    this._columnManagerTargetFixed = value;
    this.changeDetector.detectChanges();
  }
  get columnManagerTargetFixed() {
    return this._columnManagerTargetFixed;
  }
  constructor(poDate, differs, renderer, poLanguageService, changeDetector, decimalPipe, router, defaultService) {
    super(poDate, poLanguageService, defaultService);
    this.changeDetector = changeDetector;
    this.decimalPipe = decimalPipe;
    this.router = router;
    this.defaultService = defaultService;
    this.JSON = JSON;
    this.differ = differs.find([]).create(null);
    this.clickListener = renderer.listen("document", "click", () => {
    });
    this.resizeListener = renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  get hasRowTemplateWithArrowDirectionRight() {
    return this.tableRowTemplate?.tableRowTemplateArrowDirection === PoTableRowTemplateArrowDirection.Right;
  }
  get columnCount() {
    const columnCount = this.mainColumns.length + (this.actions.length > 0 ? 1 : 0) + (this.selectable ? 1 : 0) + (!this.hideDetail && this.columnMasterDetail !== void 0 ? 1 : 0);
    return columnCount || 1;
  }
  get columnCountForMasterDetail() {
    return this.mainColumns.length + 1 + (this.actions.length > 0 ? 1 : 0) + (this.selectable ? 1 : 0);
  }
  get detailHideSelect() {
    const masterDetail = this.columnMasterDetail;
    return masterDetail && masterDetail.detail ? masterDetail.detail.hideSelect : false;
  }
  get hasVisibleActions() {
    return !!this.visibleActions.length;
  }
  get firstAction() {
    return this.visibleActions && this.visibleActions[0];
  }
  get hasFooter() {
    return this.hasItems && this.hasVisibleSubtitleColumns;
  }
  get hasMasterDetailColumn() {
    return this.hasMainColumns && this.hasItems && !this.hideDetail && !!(this.columnMasterDetail || this.hasRowTemplate);
  }
  get hasRowTemplate() {
    return !!this.tableRowTemplate;
  }
  get hasSelectableColumn() {
    return this.selectable && this.hasItems && this.hasMainColumns;
  }
  get hasValidColumns() {
    return !!this.validColumns.length;
  }
  get hasVisibleSubtitleColumns() {
    return this.subtitleColumns.some((column) => column.visible !== false);
  }
  get isSingleAction() {
    return this.visibleActions.length === 1;
  }
  get isDraggable() {
    return this.draggable;
  }
  get inverseOfTranslation() {
    if (!this.viewPort || !this.viewPort["_renderedContentOffset"]) {
      return "-0px";
    }
    const offset = this.viewPort["_renderedContentOffset"];
    return `-${offset}px`;
  }
  ngOnInit() {
    this.idRadio = `po-radio-${uuid()}`;
  }
  changeHeaderWidth() {
    if (this.noColumnsHeader) {
      this.headerWidth = this.noColumnsHeader?.nativeElement.offsetWidth;
    }
    this.changeDetector.detectChanges();
  }
  ngAfterViewInit() {
    this.initialized = true;
    this.changeHeaderWidth();
    this.changeSizeLoading();
    this.applyFixedColumns();
  }
  showMoreInfiniteScroll({ target }) {
    const scrollPosition = target.offsetHeight + target.scrollTop;
    if (!this.showMoreDisabled && scrollPosition >= target.scrollHeight * (this.infiniteScrollDistance / 110)) {
      this.onShowMore();
    }
  }
  ngDoCheck() {
    this.applyFixedColumns();
    this.checkChangesItems();
    this.verifyCalculateHeightTableContainer();
    if (this.tableWrapperElement?.nativeElement.offsetWidth && !this.visibleElement && this.initialized) {
      this.debounceResize();
      this.checkInfiniteScroll();
      this.visibleElement = true;
    }
  }
  ngOnDestroy() {
    this.removeListeners();
    this.subscriptionService?.unsubscribe();
  }
  /**
   * Método responsável por realizar busca no serviço de dados podendo informar filtros e com o retorno, atualiza a tabela.
   *
   * Caso não seja informado parâmetro, nada será adicionado ao GET, conforme abaixo:
   * ```
   * url + ?page=1&pageSize=10
   * ```
   * > Obs: os parâmetros `page` e `pageSize` sempre serão chamados independente de ser enviados outros parâmetros.
   *
   * Caso sejam informados os parâmetros `{ name: 'JOHN', age: '23' }`, todos serão adicionados ao GET, conforme abaixo:
   * ```
   * url + ?page=1&pageSize=10&name=JOHN&age=23
   * ```
   *
   * @param { { key: value } } queryParams Formato do objeto a ser enviado.
   * > Pode ser utilizada qualquer string como key, e qualquer string ou number como value.
   */
  applyFilters(queryParams) {
    this.page = 1;
    this.initializeData(queryParams);
  }
  /**
   * Verifica se columns possuem a propriedade width.
   */
  applyFixedColumns() {
    return !this.columns.some((column) => !column.width);
  }
  /**
   * Método que colapsa uma linha com detalhe quando executada.
   *
   * @param { number } rowIndex Índice da linha que será colapsada.
   * > Ao reordenar os dados da tabela, o valor contido neste índice será alterado conforme a ordenação.
   */
  collapse(rowIndex) {
    this.setShowDetail(rowIndex, false);
  }
  /**
   * Método que expande uma linha com detalhe quando executada.
   *
   * @param { number } rowIndex Índice da linha que será expandida.
   * > Ao reordenar os dados da tabela, o valor contido neste índice será alterado conforme a ordenação.
   */
  expand(rowIndex) {
    this.setShowDetail(rowIndex, true);
  }
  /**
   * Retorna as linhas do `po-table` que estão selecionadas.
   */
  getSelectedRows() {
    return this.items.filter((item) => item.$selected);
  }
  /**
   * Retorna as linhas do `po-table` que não estão selecionadas.
   */
  getUnselectedRows() {
    return this.items.filter((item) => !item.$selected);
  }
  /**
   * Desmarca as linhas que estão selecionadas.
   */
  unselectRows() {
    const columnDetail = this.nameColumnDetail;
    this.items.forEach((item) => {
      const detailItems = columnDetail ? item[columnDetail] : null;
      if (Array.isArray(detailItems)) {
        detailItems.forEach((detailItem) => {
          detailItem.$selected = false;
        });
      }
      item.$selected = false;
    });
    this.selectAll = false;
  }
  checkDisabled(row, column) {
    return column.disabled ? column.disabled(row) : false;
  }
  containsMasterDetail(row) {
    return row[this.nameColumnDetail] && row[this.nameColumnDetail].length;
  }
  executeTableAction(row, tableAction) {
    if (!row.disabled && !this.validateTableAction(row, tableAction)) {
      tableAction.action(row);
      this.toggleRowAction(row);
    }
  }
  /**
   * Desmarca uma linha que está selecionada.
   */
  unselectRowItem(itemfn) {
    this.toggleSelect(itemfn, false);
    if (this.items.every((item) => !item.$selected)) {
      this.selectAll = false;
    } else {
      this.selectAll = null;
    }
  }
  /**
   * Seleciona uma linha do 'po-table'.
   */
  selectRowItem(itemfn) {
    this.toggleSelect(itemfn, true);
    if (this.items.every((item) => item.$selected)) {
      this.selectAll = true;
    } else {
      this.selectAll = null;
    }
  }
  /**
   * Método responsável pela exclusão de itens em lote.
   * Caso a tabela esteja executando a propriedade `p-service-delete`, será necessário excluir 1 item por vez.
   *
   * Ao utilizar `p-service-delete` mas sem a propriedade `p-service-api`, será responsabilidade do usuário o tratamento
   * após a requisição DELETE ser executada.
   *
   * Caso a tabela utilize `p-height` e esteja sem serviço, é necessário a reatribuição dos itens utilizando o evento `(p-delete-items)`, por exemplo:
   *
   * ```
   *<po-table
   *  (p-delete-items)="items = $event"
   * >
   *</po-table>
   * ```
   */
  deleteItems() {
    const newItems = [...this.items];
    const newItemsFiltered = [...newItems].filter((item) => !item.$selected);
    if (!this.serviceDeleteApi) {
      this.deleteItemsLocal(newItems, newItemsFiltered);
    } else {
      this.deleteItemsService(newItemsFiltered);
    }
  }
  formatNumber(value, format) {
    if (!format) {
      return value;
    }
    return this.decimalPipe.transform(value, format);
  }
  getCellData(row, column) {
    const arrayProperty = column.property.split(".");
    if (arrayProperty.length > 1) {
      const nestedProperties = arrayProperty;
      let value = row;
      for (const property of nestedProperties) {
        value = value[property] || value[property] === 0 ? value[property] : "";
      }
      return value;
    } else {
      return row[column.property];
    }
  }
  getBooleanLabel(rowValue, columnBoolean) {
    if (rowValue || rowValue === false || rowValue === 0) {
      rowValue = convertToBoolean(rowValue);
      if (columnBoolean.boolean) {
        return rowValue ? columnBoolean.boolean.trueLabel || "Sim" : columnBoolean.boolean.falseLabel || "Não";
      } else {
        return rowValue ? "Sim" : "Não";
      }
    }
    return rowValue;
  }
  getColumnIcons(row, column) {
    const rowIcons = this.getCellData(row, column);
    if (column.icons) {
      if (Array.isArray(rowIcons)) {
        return this.mergeCustomIcons(rowIcons, column.icons);
      } else {
        return this.findCustomIcon(rowIcons, column);
      }
    }
    return rowIcons;
  }
  getColumnLabel(row, columnLabel) {
    return columnLabel.labels.find((labelItem) => this.getCellData(row, columnLabel) === labelItem.value);
  }
  getSubtitleColumn(row, subtitleColumn) {
    return subtitleColumn.subtitles.find((subtitleItem) => this.getCellData(row, subtitleColumn) === subtitleItem.value);
  }
  isShowMasterDetail(row) {
    return !this.hideDetail && this.nameColumnDetail && row.$showDetail && this.containsMasterDetail(row) && !this.hasRowTemplate;
  }
  isShowRowTemplate(row, index) {
    if (this.tableRowTemplate && this.tableRowTemplate.poTableRowTemplateShow) {
      return this.tableRowTemplate.poTableRowTemplateShow(row, index);
    }
    return true;
  }
  onClickLink(event, row, column) {
    if (!this.checkDisabled(row, column)) {
      event.stopPropagation();
    }
  }
  onChangeVisibleColumns(columns) {
    this.changeVisibleColumns.emit(columns);
  }
  onColumnRestoreManager(value) {
    this.columnRestoreManager.emit(value);
  }
  onVisibleColumnsChange(columns) {
    this.columns = columns;
    this.changeDetector.detectChanges();
  }
  tooltipMouseEnter(event, column, row) {
    this.tooltipText = void 0;
    if (event.target.offsetWidth < event.target.scrollWidth && event.target.innerText.trim()) {
      return this.tooltipText = event.target.innerText;
    }
    if (column) {
      this.checkingIfColumnHasTooltip(column, row);
    }
  }
  tooltipMouseLeave() {
    this.tooltipText = void 0;
  }
  togglePopup(row, targetRef) {
    this.popupTarget = targetRef;
    this.changeDetector.detectChanges();
    this.poPopupComponent.toggle(row);
  }
  trackBy(index) {
    return index;
  }
  validateTableAction(row, tableAction) {
    if (typeof tableAction.disabled === "function") {
      return tableAction.disabled(row);
    } else {
      return tableAction.disabled;
    }
  }
  onOpenColumnManager() {
    this.lastVisibleColumnsSelected = [...this.columns];
  }
  onFilteredItemsChange(items) {
    if (this.sortedColumn.property) {
      this.sortArray(this.sortedColumn.property, this.sortedColumn.ascending, items);
    } else {
      this.filteredItems = items;
    }
  }
  /**
   * Método que remove um item da tabela.
   *
   * @param { number | { key: value } } item Índice da linha ou o item que será removido.
   * > Ao remover o item, a linha que o representa será excluída da tabela.
   */
  removeItem(item) {
    if (item instanceof Object) {
      this.items = this.items.filter((filterItem) => filterItem !== item);
    } else if (typeof item === "number") {
      const index = item;
      this.items.splice(index, 1);
    }
  }
  /**
   * Método que atualiza um item da tabela.
   *
   * @param { number | { key: value } } item Índice da linha ou o item que será atualizado.
   * @param { { key: value } } updatedItem Item que foi atualizado.
   * > Ao atualizar o item, a informação será alterada na tabela.
   */
  updateItem(item, updatedItem) {
    if (typeof item === "number") {
      this.items.splice(item, 1, updatedItem);
    } else {
      const index = this.items.findIndex((indexItem) => indexItem === item);
      this.items.splice(index, 1, updatedItem);
    }
  }
  drop(event) {
    if (!this.mainColumns[event.currentIndex].fixed) {
      moveItemInArray(this.mainColumns, event.previousIndex, event.currentIndex);
      if (this.hideColumnsManager === false) {
        this.newOrderColumns = this.mainColumns;
        const detail = this.columns.filter((item) => item.property === "detail")[0];
        if (detail !== void 0) {
          this.newOrderColumns.push(detail);
        }
        this.columns.map((item, index) => {
          if (!item.visible) {
            this.newOrderColumns.splice(index, 0, item);
          }
        });
        this.columns = this.newOrderColumns;
        this.onVisibleColumnsChange(this.newOrderColumns);
      }
    }
  }
  getTemplate(column) {
    const template = this.tableColumnTemplates.find((tableColumnTemplate) => tableColumnTemplate.targetProperty === column.property);
    if (!template) {
      console.warn(`Não foi possível encontrar o template para a coluna: ${column.property}, por gentileza informe a propriedade [p-property]`);
      return null;
    }
    return template.templateRef;
  }
  getWidthColumnManager() {
    return this.columnManager?.nativeElement.offsetWidth;
  }
  getColumnWidthActionsLeft() {
    return this.columnActionLeft?.nativeElement.offsetWidth;
  }
  hasSomeFixed() {
    return this.columns.some((item) => item.fixed === true);
  }
  calculateHeightTableContainer(height) {
    const value = parseFloat(height);
    this.heightTableContainer = value ? value - this.getHeightTableFooter() : void 0;
    this.heightTableVirtual = this.heightTableContainer ? this.heightTableContainer - this.itemSize : void 0;
    this.setTableOpacity(1);
    this.changeDetector.detectChanges();
  }
  verifyCalculateHeightTableContainer() {
    if (this.height && this.verifyChangeHeightInFooter()) {
      this.footerHeight = this.getHeightTableFooter();
      this.calculateHeightTableContainer(this.height);
    }
  }
  checkInfiniteScroll() {
    if (this.hasInfiniteScroll()) {
      if (this.tableVirtualScroll.nativeElement.scrollHeight >= this.height) {
        this.includeInfiniteScroll();
      } else {
        this.infiniteScroll = false;
      }
    }
    this.changeDetector.detectChanges();
  }
  changesAfterDelete(newItemsFiltered) {
    this.selectAll = false;
    this.setSelectedList();
    this.modalDelete.close();
    this.poNotification.success(this.literals.deleteSuccessful);
    this.eventDelete.emit(newItemsFiltered);
  }
  changeSizeLoading() {
    const tableHeight = this.tableWrapperElement?.nativeElement?.offsetHeight;
    if (tableHeight <= 150) {
      this.sizeLoading = "sm";
    } else if (tableHeight > 150 && tableHeight < 260) {
      this.sizeLoading = "md";
    } else {
      this.sizeLoading = "lg";
    }
  }
  checkChangesItems() {
    const changesItems = this.differ.diff(this.items);
    if (changesItems && this.selectAll) {
      this.selectAll = null;
    }
    if (changesItems && !this.hasColumns && this.hasItems) {
      this.columns = this.getDefaultColumns(this.items[0]);
    }
  }
  checkingIfColumnHasTooltip(column, row) {
    if (column.type === "link" && column.tooltip && !this.checkDisabled(row, column)) {
      return this.tooltipText = column.tooltip;
    }
    if (column.type === "label") {
      const columnLabel = this.getColumnLabel(row, column);
      return this.tooltipText = columnLabel?.tooltip;
    }
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      this.setTableOpacity(1);
    });
  }
  deleteItemsLocal(newItems, newItemsFiltered) {
    if (this.height) {
      this.items = newItemsFiltered;
    } else {
      let index = this.items.length - 1;
      newItems.slice().reverse().forEach((item) => {
        if (item.$selected) {
          this.removeItem(index);
        }
        index--;
      });
    }
    this.changesAfterDelete(newItemsFiltered);
    this.onFilteredItemsChange(newItemsFiltered);
  }
  deleteItemsService(newItemsFiltered) {
    this.subscriptionService.add(this.defaultService.deleteItem(this.paramDeleteApi, this.itemsSelected[0][this.paramDeleteApi]).subscribe({
      next: (value) => {
        if (this.hasService) {
          const filteredParams = __spreadProps(__spreadValues({}, this.paramsFilter), {
            pageSize: newItemsFiltered.length + 1,
            page: 1
          });
          this.loading = true;
          this.subscriptionService.add(this.defaultService.getFilteredItems(filteredParams).subscribe((items) => {
            this.setTableResponseProperties(items);
          }));
        }
        this.items = newItemsFiltered;
        this.changesAfterDelete(newItemsFiltered);
      },
      error: (error) => {
        this.poNotification.error(this.literals.deleteApiError);
        this.modalDelete.close();
        this.eventDelete.emit(this.items);
      }
    }));
  }
  findCustomIcon(rowIcons, column) {
    const customIcon = column.icons.find((icon) => rowIcons === icon.value);
    return customIcon ? [customIcon] : void 0;
  }
  getHeightTableFooter() {
    return this.tableFooterElement ? this.tableFooterElement.nativeElement.offsetHeight : 0;
  }
  hasInfiniteScroll() {
    return this.infiniteScroll && this.hasItems && !this.subscriptionScrollEvent && this.height && this.tableVirtualScroll.nativeElement.scrollHeight;
  }
  includeInfiniteScroll() {
    this.scrollEvent$ = this.defaultService.scrollListener(this.tableVirtualScroll.nativeElement);
    this.subscriptionScrollEvent = this.scrollEvent$.subscribe((event) => this.showMoreInfiniteScroll(event));
    this.changeDetector.detectChanges();
  }
  mergeCustomIcons(rowIcons, customIcons) {
    const mergedIcons = [];
    rowIcons.forEach((columnValue) => {
      const foundCustomIcon = customIcons.find((customIcon) => columnValue === customIcon.icon || columnValue === customIcon.value);
      foundCustomIcon ? mergedIcons.push(foundCustomIcon) : mergedIcons.push(columnValue);
    });
    return mergedIcons;
  }
  removeListeners() {
    if (this.resizeListener) {
      this.resizeListener();
    }
    if (this.clickListener) {
      this.clickListener();
    }
    if (this.subscriptionScrollEvent) {
      this.subscriptionScrollEvent.unsubscribe();
    }
  }
  setTableOpacity(value) {
    this.tableOpacity = value;
  }
  verifyChangeHeightInFooter() {
    return this.footerHeight !== this.getHeightTableFooter();
  }
  toggleSelect(compare, selectValue) {
    if (typeof compare !== "function") {
      this.items.forEach((item) => {
        if (item === compare) {
          item.$selected = selectValue;
        }
      });
    } else {
      this.items.forEach((item) => {
        if (compare(item)) {
          item.$selected = selectValue;
        }
      });
    }
  }
  static ɵfac = function PoTableComponent_Factory(t) {
    return new (t || _PoTableComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(PoTableService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableComponent, selectors: [["po-table"]], contentQueries: function PoTableComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoTableRowTemplateDirective, 7);
      ɵɵcontentQuery(dirIndex, PoTableCellTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, PoTableColumnTemplateDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableRowTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableCellTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableColumnTemplates = _t);
    }
  }, viewQuery: function PoTableComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$V, 5, ElementRef);
      ɵɵviewQuery(_c1$n, 5);
      ɵɵviewQuery(PoModalComponent, 7);
      ɵɵviewQuery(_c2$b, 5, ElementRef);
      ɵɵviewQuery(_c3$6, 5, ElementRef);
      ɵɵviewQuery(_c4$3, 5, ElementRef);
      ɵɵviewQuery(_c5, 5, ElementRef);
      ɵɵviewQuery(_c6, 5, ElementRef);
      ɵɵviewQuery(_c7, 5, ElementRef);
      ɵɵviewQuery(_c8, 5, ElementRef);
      ɵɵviewQuery(_c9, 5);
      ɵɵviewQuery(_c10, 7, ElementRef);
      ɵɵviewQuery(CdkVirtualScrollViewport, 5);
      ɵɵviewQuery(_c11, 5);
      ɵɵviewQuery(_c12, 5);
      ɵɵviewQuery(_c13, 5, ElementRef);
      ɵɵviewQuery(_c14, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noColumnsHeader = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPopupComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalDelete = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableFooterElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableWrapperElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableVirtualScroll = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnManager = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnBatchActions = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnActionLeft = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poSearchInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewPort = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnManagerTarget = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnManagerTargetFixed = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionsIconElement = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionsElement = _t);
    }
  }, features: [ɵɵProvidersFeature([PoDateService]), ɵɵInheritDefinitionFeature], decls: 33, vars: 14, consts: [[1, "po-table-actions"], ["class", "po-table-actions-batch-actions", 4, "ngIf"], ["class", "po-table-actions-column-manager", 4, "ngIf"], ["class", "po-table-search", 4, "ngIf"], ["p-no-padding", "", 4, "ngIf", "ngIfElse"], ["tableContainerTemplate", ""], ["class", "po-row po-table-footer-show-more", 3, "po-invisible", 4, "ngIf"], ["tableTemplate", ""], ["tableVirtualScrollTemplate", ""], [3, "p-actions", "p-target"], ["popup", ""], ["poTableColumnDetail", ""], ["inputRadio", ""], ["inputCheckbox", ""], ["contentHeaderTemplate", ""], ["noColumnsWithHeight", ""], ["noColumnsWithoutHeight", ""], ["ActionsColumnTemplate", ""], [3, "p-columns", "p-max-columns", "p-target", "p-last-visible-columns-selected", "p-hide-action-fixed-columns", "p-columns-default", "p-visible-columns-change", "p-change-visible-columns", "p-initial-columns", 4, "ngIf"], [3, "p-title", "p-primary-action", "p-secondary-action", "p-click-out"], ["modalDelete", ""], [1, "po-font-text-large"], [1, "po-table-actions-batch-actions"], ["columnBatchActions", ""], [1, "po-table-actions-batch-actions__label", 3, "ngPlural"], ["ngPluralCase", "=0"], ["ngPluralCase", "=1"], ["ngPluralCase", "other"], [1, "po-table-actions-batch-actions__buttons"], ["p-icon", "po-icon-delete", 3, "p-danger", "p-disabled", "p-label", "p-click"], [1, "po-table-actions-column-manager"], ["columnManager", ""], ["p-icon", "po-icon-settings", "p-kind", "tertiary", "p-tooltip-position", "left", 3, "p-aria-label", "p-tooltip", "p-click"], ["columnManagerTarget", ""], [1, "po-table-search"], [3, "p-items", "p-filter-keys", "p-filter-type", "p-filtered-items-change"], ["p-no-padding", ""], [4, "ngTemplateOutlet"], [3, "p-text", "p-size", 4, "ngIf"], [1, "po-table-main-container"], [1, "po-table-wrapper"], ["tableWrapper", ""], ["class", "po-table-container", 3, "height", 4, "ngIf"], [4, "ngIf"], ["class", "po-table-footer", 4, "ngIf"], [3, "p-text", "p-size"], [1, "po-table-container"], [1, "po-table-container-fixed-inner"], ["poTableTbody", ""], [1, "po-table-footer"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-literals", "p-subtitles"], [1, "po-row", "po-table-footer-show-more"], ["tableFooter", ""], [1, "po-offset-xl-4", "po-offset-lg-4", "po-offset-md-3", "po-lg-4", "po-md-6", 3, "p-disabled", "p-label", "p-loading", "p-click"], [1, "po-table", 3, "ngClass"], ["cdkDropList", "", "cdkDropListOrientation", "horizontal", 3, "ngClass", "cdkDropListDropped"], ["class", "po-table-column-selectable", 3, "pointer-events", 4, "ngIf"], ["class", "po-table-header-column po-table-header-master-detail", 4, "ngIf"], [3, "po-table-header-master-detail", "po-table-header-single-action", 4, "ngIf"], ["class", "po-table-header-column po-text-center", 4, "ngIf"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["tableDefaultThDragDrop", ""], ["tableDefaultThDefault", ""], [3, "po-table-header-single-action", "po-table-header-actions", 4, "ngIf"], ["class", "po-table-group-row", 4, "ngIf"], [1, "po-table-column-selectable"], ["name", "selectAll", 3, "p-checkboxValue", "p-change", 4, "ngIf"], ["name", "selectAll", 3, "p-checkboxValue", "p-change"], [1, "po-table-header-column", "po-table-header-master-detail"], ["columnActionLeft", ""], [1, "po-table-header-column", "po-text-center"], ["noColumnsHeader", ""], ["class", "po-table-header-ellipsis p-element po-frozen-column", "cdkDrag", "", "cdkDragLockAxis", "x", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "po-table-header-subtitle", "po-table-column-drag-box", "cdkDragDisabled", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["cdkDrag", "", "cdkDragLockAxis", "x", 1, "po-table-header-ellipsis", "p-element", "po-frozen-column", 3, "ngClass", "cdkDragDisabled", "pFrozenColumn", "click"], [1, "po-table-header-flex"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkDragHandle", "", "width", "24", "height", "24", "viewBox", "0 0 24 24", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["cx", "9", "cy", "6", "r", "2", "fill", "black"], ["cx", "15", "cy", "6", "r", "2", "fill", "black"], ["cx", "9", "cy", "12", "r", "2", "fill", "black"], ["cx", "15", "cy", "12", "r", "2", "fill", "black"], ["cx", "9", "cy", "18", "r", "2", "fill", "black"], ["cx", "15", "cy", "18", "r", "2", "fill", "black"], ["class", "po-table-header-ellipsis p-element po-frozen-column", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "po-table-header-subtitle", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-header-ellipsis", "p-element", "po-frozen-column", 3, "ngClass", "pFrozenColumn", "click"], [1, "po-table-group-row"], [1, "po-table-row", "po-table-row-no-data"], [1, "po-table-no-data", "po-text-center", 3, "colSpan"], ["class", "po-table-group-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-row"], ["class", "po-table-column-selectable", 4, "ngIf"], ["class", "po-table-column-detail-toggle", 3, "click", 4, "ngIf"], ["class", "p-element po-frozen-column", 3, "width", "max-width", "min-width", "po-table-column", "po-table-column-right", "po-table-column-center", "po-table-column-icons", "pFrozenColumn", "ngClass", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-column-detail-toggle", 3, "click"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "p-element", "po-frozen-column", 3, "pFrozenColumn", "ngClass", "click"], [1, "po-table-column-cell", "po-table-body-ellipsis", "notranslate", 3, "ngSwitch", "p-tooltip", "p-append-in-body", "mouseenter", "mouseleave"], [4, "ngSwitchCase"], [3, "p-action", "p-disabled", "p-link", "p-row", "p-value", "click", 4, "ngSwitchCase"], [3, "p-column", "p-icons", "p-row", 4, "ngSwitchCase"], [4, "ngSwitchDefault"], [3, "p-action", "p-disabled", "p-link", "p-row", "p-value", "click"], [3, "p-column", "p-icons", "p-row"], [3, "p-subtitle"], [3, "p-value"], [1, "po-table-row-template-container", 3, "colSpan"], [1, "po-table-column-detail", 3, "colSpan"], [3, "p-selectable", "p-detail", "p-items", "p-select-row"], [3, "itemSize", "minBufferPx", "maxBufferPx"], ["tableVirtualScroll", ""], [1, "po-table-header-sticky"], ["cdkDropList", "", "cdkDropListOrientation", "horizontal", 3, "cdkDropListDropped"], ["tableVirtualScrollThDragDrop", ""], ["tableVirtualScrollThDefault", ""], ["class", "po-table-header-ellipsis p-element po-frozen-column", "cdkDrag", "", "cdkDragLockAxis", "x", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "ngStyle", "po-table-header-subtitle", "po-table-column-drag-box", "cdkDragDisabled", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["cdkDrag", "", "cdkDragLockAxis", "x", 1, "po-table-header-ellipsis", "p-element", "po-frozen-column", 3, "ngClass", "ngStyle", "cdkDragDisabled", "pFrozenColumn", "click"], ["class", "po-table-header-ellipsis p-element po-frozen-column example-box", 3, "width", "max-width", "min-width", "po-clickable", "ngClass", "ngStyle", "po-table-header-subtitle", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "po-table-header-ellipsis", "p-element", "po-frozen-column", "example-box", 3, "ngClass", "ngStyle", "pFrozenColumn", "click"], ["class", "po-table-group-row", 4, "cdkVirtualFor", "cdkVirtualForOf", "cdkVirtualForTrackBy"], ["class", "p-element po-frozen-column", 3, "width", "max-width", "min-width", "po-table-column", "po-table-column-right", "po-table-column-center", "po-table-column-icons", "ngClass", "pFrozenColumn", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "p-element", "po-frozen-column", 3, "ngClass", "pFrozenColumn", "click"], ["class", "po-icon po-clickable", 3, "po-icon-arrow-up", "po-icon-arrow-down", 4, "ngIf"], [1, "po-icon", "po-clickable"], [3, "name", "p-checked", "p-change-selected"], ["name", "checkbox", 3, "p-checkboxValue", "p-change"], [1, "po-table-header-ellipsis", 3, "p-tooltip", "p-append-in-body", "mouseenter", "mouseleave"], ["columnHeader", ""], [3, "po-table-header-icon-unselected", "po-table-header-icon-descending", "po-table-header-icon-ascending", 4, "ngIf"], ["width", "24", "height", "24", "viewBox", "0 0 24 24", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M18.2929 15.2929L17 16.5858L17 10C17 9.44772 16.5523 9 16 9C15.4477 9 15 9.44772 15 10L15 16.5858L13.7071 15.2929C13.3166 14.9024 12.6834 14.9024 12.2929 15.2929C11.9024 15.6834 11.9024 16.3166 12.2929 16.7071L15.2929 19.7071C15.6834 20.0976 16.3166 20.0976 16.7071 19.7071L19.7071 16.7071C20.0976 16.3166 20.0976 15.6834 19.7071 15.2929C19.3166 14.9024 18.6834 14.9024 18.2929 15.2929ZM5.70716 8.7071L7.00006 7.4142L7.00003 14C7.00002 14.5523 7.44774 15 8.00002 15C8.55231 15 9.00002 14.5523 9.00003 14L9.00006 7.41418L10.2929 8.70707C10.6835 9.09759 11.3166 9.09758 11.7072 8.70706C12.0977 8.31653 12.0977 7.68336 11.7072 7.29284L8.70718 4.29286C8.31665 3.90234 7.68349 3.90235 7.29296 4.29287L4.29295 7.29289C3.90242 7.68342 3.90242 8.31658 4.29294 8.70711C4.68347 9.09763 5.31663 9.09762 5.70716 8.7071Z", "fill", "#1D1D30"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M11 9.41421L9.70711 10.7071C9.31658 11.0976 8.68342 11.0976 8.29289 10.7071C7.90237 10.3166 7.90237 9.68342 8.29289 9.29289L11.2929 6.29289C11.6834 5.90237 12.3166 5.90237 12.7071 6.29289L15.7071 9.29289C16.0976 9.68342 16.0976 10.3166 15.7071 10.7071C15.3166 11.0976 14.6834 11.0976 14.2929 10.7071L13 9.41421V16C13 16.5523 12.5523 17 12 17C11.4477 17 11 16.5523 11 16V9.41421Z", "fill", "black"], ["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M9.70711 13.2929L11 14.5858V7C11 6.44772 11.4477 6 12 6C12.5523 6 13 6.44772 13 7V14.5858L14.2929 13.2929C14.6834 12.9024 15.3166 12.9024 15.7071 13.2929C16.0976 13.6834 16.0976 14.3166 15.7071 14.7071L12.7071 17.7071C12.3166 18.0976 11.6834 18.0976 11.2929 17.7071L8.29289 14.7071C7.90237 14.3166 7.90237 13.6834 8.29289 13.2929C8.68342 12.9024 9.31658 12.9024 9.70711 13.2929Z", "fill", "black"], [1, "po-table-header-fixed-inner"], ["class", "po-table-column po-table-column-single-action", 3, "width", "max-width", 4, "ngIf"], ["class", "po-table-column-actions", 4, "ngIf"], [1, "po-table-column", "po-table-column-single-action"], ["class", "po-table-single-action po-clickable", 3, "po-table-action-disabled", "click", 4, "ngIf"], [1, "po-table-single-action", "po-clickable", 3, "click"], ["class", "po-table-single-action-content", 3, "p-icon", 4, "ngIf"], [1, "po-table-single-action-content", 3, "p-icon"], [1, "po-table-column-actions"], [1, "po-icon", "po-icon-more", "po-clickable", 3, "click"], ["popupTarget", ""], [3, "p-columns", "p-max-columns", "p-target", "p-last-visible-columns-selected", "p-hide-action-fixed-columns", "p-columns-default", "p-visible-columns-change", "p-change-visible-columns", "p-initial-columns"]], template: function PoTableComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoTableComponent_div_1_Template, 9, 4, "div", 1)(2, PoTableComponent_div_2_Template, 4, 2, "div", 2)(3, PoTableComponent_div_3_Template, 2, 3, "div", 3);
      ɵɵelementEnd();
      ɵɵtemplate(4, PoTableComponent_po_container_4_Template, 2, 1, "po-container", 4)(5, PoTableComponent_ng_template_5_Template, 8, 10, "ng-template", null, 5, ɵɵtemplateRefExtractor)(7, PoTableComponent_div_7_Template, 3, 5, "div", 6)(8, PoTableComponent_ng_template_8_Template, 16, 24, "ng-template", null, 7, ɵɵtemplateRefExtractor)(10, PoTableComponent_ng_template_10_Template, 18, 27, "ng-template", null, 8, ɵɵtemplateRefExtractor);
      ɵɵelement(12, "po-popup", 9, 10);
      ɵɵtemplate(14, PoTableComponent_ng_template_14_Template, 1, 1, "ng-template", null, 11, ɵɵtemplateRefExtractor)(16, PoTableComponent_ng_template_16_Template, 1, 2, "ng-template", null, 12, ɵɵtemplateRefExtractor)(18, PoTableComponent_ng_template_18_Template, 1, 1, "ng-template", null, 13, ɵɵtemplateRefExtractor)(20, PoTableComponent_ng_template_20_Template, 5, 6, "ng-template", null, 14, ɵɵtemplateRefExtractor)(22, PoTableComponent_ng_template_22_Template, 2, 3, "ng-template", null, 15, ɵɵtemplateRefExtractor)(24, PoTableComponent_ng_template_24_Template, 1, 1, "ng-template", null, 16, ɵɵtemplateRefExtractor)(26, PoTableComponent_ng_template_26_Template, 2, 2, "ng-template", null, 17, ɵɵtemplateRefExtractor)(28, PoTableComponent_po_table_column_manager_28_Template, 1, 6, "po-table-column-manager", 18);
      ɵɵelementStart(29, "po-modal", 19, 20)(31, "p", 21);
      ɵɵtext(32);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      const _r5 = ɵɵreference(6);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasValidColumns && ctx.itemsSelected.length > 0 && !ctx.hideBatchActions);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasValidColumns && !ctx.hideColumnsManager);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hideTableSearch && ctx.hasValidColumns);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.container)("ngIfElse", _r5);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.infiniteScroll);
      ɵɵadvance(5);
      ɵɵproperty("p-actions", ctx.actions)("p-target", ctx.popupTarget);
      ɵɵadvance(16);
      ɵɵproperty("ngIf", !ctx.hideColumnsManager);
      ɵɵadvance();
      ɵɵproperty("p-title", ctx.literals.delete)("p-primary-action", ctx.confirm)("p-secondary-action", ctx.close)("p-click-out", true);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.literals.bodyDelete);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableComponent, [{
    type: Component,
    args: [{ selector: "po-table", providers: [PoDateService], template: `<div class="po-table-actions">
  <div
    #columnBatchActions
    *ngIf="hasValidColumns && itemsSelected.length > 0 && !hideBatchActions"
    class="po-table-actions-batch-actions"
  >
    <div [ngPlural]="itemsSelected.length" class="po-table-actions-batch-actions__label">
      <strong>
        <ng-template ngPluralCase="=0">{{ literals.noItem }}</ng-template>
        <ng-template ngPluralCase="=1">{{ literals.oneItem }}</ng-template>
        <ng-template ngPluralCase="other">{{ itemsSelected.length }} {{ literals.multipleItems }}</ng-template>
      </strong>
    </div>

    <div class="po-table-actions-batch-actions__buttons">
      <po-button
        p-icon="po-icon-delete"
        [p-danger]="true"
        [p-disabled]="itemsSelected.length > 1 && serviceDeleteApi !== undefined"
        [p-label]="literals.delete"
        (p-click)="modalDelete.open()"
      ></po-button>
    </div>
  </div>

  <div #columnManager *ngIf="hasValidColumns && !hideColumnsManager" class="po-table-actions-column-manager">
    <po-button
      #columnManagerTarget
      p-icon="po-icon-settings"
      p-kind="tertiary"
      p-tooltip-position="left"
      [p-aria-label]="literals.columnsManager"
      [p-tooltip]="literals.columnsManager"
      (p-click)="onOpenColumnManager()"
    ></po-button>
  </div>

  <div *ngIf="!hideTableSearch && hasValidColumns" class="po-table-search">
    <po-search
      [p-items]="items"
      [p-filter-keys]="filteredColumns"
      [p-filter-type]="filterType"
      (p-filtered-items-change)="onFilteredItemsChange($event)"
    >
    </po-search>
  </div>
</div>
<po-container *ngIf="container; else tableContainerTemplate" p-no-padding>
  <ng-container *ngTemplateOutlet="tableContainerTemplate"></ng-container>
</po-container>

<ng-template #tableContainerTemplate>
  <div [class.po-table-container-sticky]="loading">
    <po-loading-overlay *ngIf="loading" [p-text]="literals.loadingData" [p-size]="sizeLoading"></po-loading-overlay>
    <div class="po-table-main-container">
      <div
        #tableWrapper
        class="po-table-wrapper"
        [class.po-table-header-fixed-columns-pixels]="allColumnsWidthPixels"
        [style.opacity]="tableOpacity"
      >
        <div *ngIf="height" class="po-table-container" [style.height.px]="heightTableContainer">
          <div #poTableTbody class="po-table-container-fixed-inner">
            <ng-container *ngTemplateOutlet="tableVirtualScrollTemplate"></ng-container>
          </div>
        </div>

        <div *ngIf="!height">
          <ng-container *ngTemplateOutlet="tableTemplate"></ng-container>
        </div>
      </div>
    </div>
  </div>

  <div class="po-table-footer" *ngIf="hasFooter">
    <ng-container *ngFor="let column of subtitleColumns; trackBy: trackBy">
      <po-table-subtitle-footer [p-literals]="literals" [p-subtitles]="column.subtitles"> </po-table-subtitle-footer>
    </ng-container>
  </div>
</ng-template>

<!-- Show More Button -->
<div
  *ngIf="!infiniteScroll"
  class="po-row po-table-footer-show-more"
  [class.po-invisible]="showMore.observers.length === 0 && !hasService"
  #tableFooter
>
  <po-button
    class="po-offset-xl-4 po-offset-lg-4 po-offset-md-3 po-lg-4 po-md-6"
    [p-disabled]="showMoreDisabled"
    [p-label]="literals.loadMoreData"
    [p-loading]="loadingShowMore"
    (p-click)="onShowMore()"
  >
  </po-button>
</div>

<!-- Table default-->
<ng-template #tableTemplate>
  <table
    class="po-table"
    [ngClass]="{
      'po-table-interactive': selectable || sort,
      'po-table-selectable': selectable,
      'po-table-striped': striped,
      'po-table-data-fixed-columns': applyFixedColumns()
    }"
    [attr.p-spacing]="spacing"
  >
    <thead>
      <tr
        [ngClass]="{ 'no-hover': hideSelectAll, 'po-table-column-drag': this.isDraggable }"
        [class.po-table-header]="!height"
        cdkDropList
        cdkDropListOrientation="horizontal"
        (cdkDropListDropped)="drop($event)"
      >
        <th
          *ngIf="hasSelectableColumn"
          [style.pointer-events]="hideSelectAll ? 'none' : 'auto'"
          class="po-table-column-selectable"
        >
          <div [class.po-table-header-fixed-inner]="height">
            <po-checkbox
              name="selectAll"
              *ngIf="!hideSelectAll"
              (p-change)="selectAllRows()"
              [p-checkboxValue]="selectAll === null ? 'mixed' : selectAll"
            ></po-checkbox>
          </div>
        </th>

        <th
          *ngIf="(hasMasterDetailColumn || hasRowTemplate) && !hasRowTemplateWithArrowDirectionRight"
          class="po-table-header-column po-table-header-master-detail"
        ></th>

        <!-- Coluna criada para caso as ações fiquem no lado esquerdo -->
        <th
          #columnActionLeft
          *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
          [class.po-table-header-master-detail]="!isSingleAction"
          [class.po-table-header-single-action]="isSingleAction"
        ></th>

        <th *ngIf="!hasMainColumns" #noColumnsHeader class="po-table-header-column po-text-center">
          <ng-container *ngIf="height; then noColumnsWithHeight; else noColumnsWithoutHeight"> </ng-container>
        </th>

        <ng-container
          *ngIf="this.isDraggable || hasSomeFixed(); then tableDefaultThDragDrop; else tableDefaultThDefault"
        >
        </ng-container>
        <ng-template #tableDefaultThDragDrop>
          <th
            *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
            class="po-table-header-ellipsis p-element po-frozen-column"
            [style.width]="column.width"
            [style.max-width]="column.width"
            [style.min-width]="column.width"
            [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
            [class.po-clickable]="(sort && column.sortable !== false) || hasService"
            [ngClass]="{
              'po-table-header-sorted':
                sort &&
                JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                (sortedColumn.ascending || !sortedColumn.ascending)
            }"
            [class.po-table-header-subtitle]="column.type === 'subtitle'"
            [class.po-table-column-drag-box]="this.isDraggable"
            (click)="sortColumn(column)"
            cdkDrag
            cdkDragLockAxis="x"
            [cdkDragDisabled]="column.fixed ? 'true' : 'false'"
            [pFrozenColumn]="column.fixed"
          >
            <div
              class="po-table-header-flex"
              [class.po-table-header-fixed-inner]="height"
              [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
              [class.po-table-header-flex-center]="column.type === 'subtitle'"
            >
              <ng-container *ngIf="this.isDraggable && !column.fixed">
                <svg
                  cdkDragHandle
                  width="24"
                  height="24"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <circle cx="9" cy="6" r="2" fill="black" />
                  <circle cx="15" cy="6" r="2" fill="black" />
                  <circle cx="9" cy="12" r="2" fill="black" />
                  <circle cx="15" cy="12" r="2" fill="black" />
                  <circle cx="9" cy="18" r="2" fill="black" />
                  <circle cx="15" cy="18" r="2" fill="black" />
                </svg>
              </ng-container>
              <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
            </div>
          </th>
        </ng-template>
        <ng-template #tableDefaultThDefault>
          <th
            *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
            class="po-table-header-ellipsis p-element po-frozen-column"
            [style.width]="column.width"
            [style.max-width]="column.width"
            [style.min-width]="column.width"
            [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
            [class.po-clickable]="(sort && column.sortable !== false) || hasService"
            [ngClass]="{
              'po-table-header-sorted':
                sort &&
                JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                (sortedColumn.ascending || !sortedColumn.ascending)
            }"
            [class.po-table-header-subtitle]="column.type === 'subtitle'"
            (click)="sortColumn(column)"
            [pFrozenColumn]="column.fixed"
          >
            <div
              class="po-table-header-flex"
              [class.po-table-header-fixed-inner]="height"
              [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
              [class.po-table-header-flex-center]="column.type === 'subtitle'"
            >
              <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
            </div>
          </th>
        </ng-template>

        <th
          *ngIf="hasRowTemplateWithArrowDirectionRight && (hasVisibleActions || hideColumnsManager)"
          class="po-table-header-column po-table-header-master-detail"
        ></th>

        <th
          *ngIf="hasVisibleActions && actionRight && (visibleActions.length > 1 || isSingleAction)"
          [class.po-table-header-single-action]="isSingleAction"
          [class.po-table-header-actions]="!isSingleAction"
        ></th>
      </tr>
    </thead>

    <tbody class="po-table-group-row" *ngIf="!hasItems || !hasMainColumns">
      <tr class="po-table-row po-table-row-no-data">
        <td [colSpan]="columnCount" class="po-table-no-data po-text-center">
          <span> {{ literals.noData }} </span>
        </td>
      </tr>
    </tbody>

    <ng-container *ngIf="hasMainColumns">
      <tbody class="po-table-group-row" *ngFor="let row of filteredItems; let rowIndex = index; trackBy: trackBy">
        <tr class="po-table-row" [class.po-table-row-active]="row.$selected || (row.$selected === null && selectable)">
          <td *ngIf="selectable" class="po-table-column-selectable">
            <ng-container *ngTemplateOutlet="singleSelect ? inputRadio : inputCheckbox; context: { $implicit: row }">
            </ng-container>
          </td>

          <!-- Valida se a origem do detail é pelo input do po-table -->
          <td
            *ngIf="columnMasterDetail && !hideDetail && !hasRowTemplate"
            class="po-table-column-detail-toggle"
            (click)="toggleDetail(row)"
          >
            <ng-template
              [ngTemplateOutlet]="poTableColumnDetail"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>

          <!-- Coluna com as ações na esquerda (padrão)-->
          <ng-template
            *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
            [ngTemplateOutlet]="ActionsColumnTemplate"
            [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
          >
          </ng-template>

          <!-- Valida se a origem do detail é pela diretiva -->
          <td
            *ngIf="hasRowTemplate && !hasRowTemplateWithArrowDirectionRight"
            class="po-table-column-detail-toggle"
            (click)="toggleDetail(row)"
          >
            <ng-template
              [ngTemplateOutlet]="poTableColumnDetail"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>

          <td
            *ngFor="let column of mainColumns; let columnIndex = index; trackBy: trackBy"
            [style.width]="column.width"
            [style.max-width]="column.width"
            [style.min-width]="column.width"
            [class.po-table-column]="column.type !== 'icon'"
            [class.po-table-column-right]="column.type === 'currency' || column.type === 'number'"
            [class.po-table-column-center]="column.type === 'subtitle'"
            [class.po-table-column-icons]="column.type === 'icon'"
            [pFrozenColumn]="column.fixed"
            class="p-element po-frozen-column"
            [ngClass]="getClassColor(row, column)"
            (click)="hasSelectableRow() ? selectRow(row) : 'javascript:;'"
          >
            <div
              class="po-table-column-cell po-table-body-ellipsis notranslate"
              [ngSwitch]="column.type"
              [p-tooltip]="tooltipText"
              [p-append-in-body]="true"
              (mouseenter)="tooltipMouseEnter($event, column, row)"
              (mouseleave)="tooltipMouseLeave()"
            >
              <span *ngSwitchCase="'columnTemplate'">
                <ng-container *ngTemplateOutlet="getTemplate(column); context: { $implicit: getCellData(row, column) }">
                </ng-container>
              </span>

              <span *ngSwitchCase="'cellTemplate'">
                <ng-container *ngTemplateOutlet="tableCellTemplate?.templateRef; context: { row: row, column: column }">
                </ng-container>
              </span>

              <span *ngSwitchCase="'boolean'">
                {{ getBooleanLabel(getCellData(row, column), column) }}
              </span>

              <span *ngSwitchCase="'currency'">
                {{ getCellData(row, column) | currency: column.format : 'symbol' : '1.2-2' }}
              </span>

              <span *ngSwitchCase="'date'">
                {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy' }}
              </span>

              <span *ngSwitchCase="'time'">
                {{ getCellData(row, column) | po_time: column.format || 'HH:mm:ss.ffffff' }}
              </span>

              <span *ngSwitchCase="'dateTime'">
                {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy HH:mm:ss' }}
              </span>

              <span *ngSwitchCase="'number'">
                {{ formatNumber(getCellData(row, column), column.format) }}
              </span>

              <po-table-column-link
                *ngSwitchCase="'link'"
                [p-action]="column.action"
                [p-disabled]="checkDisabled(row, column)"
                [p-link]="row[column.link]"
                [p-row]="row"
                [p-value]="getCellData(row, column)"
                (click)="onClickLink($event, row, column)"
              >
              </po-table-column-link>

              <po-table-column-icon
                *ngSwitchCase="'icon'"
                [p-column]="column"
                [p-icons]="getColumnIcons(row, column)"
                [p-row]="row"
              >
              </po-table-column-icon>

              <span *ngSwitchCase="'subtitle'">
                <po-table-subtitle-circle [p-subtitle]="getSubtitleColumn(row, column)"></po-table-subtitle-circle>
              </span>
              <span *ngSwitchCase="'label'">
                <po-table-column-label [p-value]="getColumnLabel(row, column)"> </po-table-column-label>
              </span>
              <span *ngSwitchDefault>{{ getCellData(row, column) }}</span>
            </div>
          </td>

          <td
            *ngIf="hasRowTemplateWithArrowDirectionRight"
            class="po-table-column-detail-toggle"
            (click)="toggleDetail(row)"
          >
            <ng-template
              [ngTemplateOutlet]="poTableColumnDetail"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>

          <!-- Coluna de açoes na direita -->
          <ng-template
            *ngIf="actionRight"
            [ngTemplateOutlet]="ActionsColumnTemplate"
            [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
          >
          </ng-template>
        </tr>

        <tr *ngIf="hasMainColumns && hasRowTemplate && row.$showDetail && isShowRowTemplate(row, rowIndex)">
          <td class="po-table-row-template-container" [colSpan]="columnCountForMasterDetail">
            <ng-template
              [ngTemplateOutlet]="tableRowTemplate.templateRef"
              [ngTemplateOutletContext]="{ $implicit: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </td>
        </tr>

        <tr *ngIf="hasMainColumns && isShowMasterDetail(row)">
          <td class="po-table-column-detail" [colSpan]="columnCountForMasterDetail">
            <po-table-detail
              [p-selectable]="selectable && !detailHideSelect"
              [p-detail]="columnMasterDetail.detail"
              [p-items]="row[nameColumnDetail]"
              (p-select-row)="selectDetailRow($event)"
            >
            </po-table-detail>
          </td>
        </tr>
      </tbody>
    </ng-container>
  </table>
</ng-template>

<!-- Table with virtual scroll -->
<ng-template #tableVirtualScrollTemplate>
  <cdk-virtual-scroll-viewport
    #tableVirtualScroll
    [itemSize]="itemSize"
    [style.height.px]="heightTableContainer"
    [minBufferPx]="heightTableContainer < 100 ? 100 : heightTableContainer"
    [maxBufferPx]="heightTableContainer < 200 ? 200 : heightTableContainer"
  >
    <table
      class="po-table"
      [ngClass]="{
        'po-table-interactive': selectable || sort,
        'po-table-selectable': selectable,
        'po-table-striped': striped,
        'po-table-data-fixed-columns': applyFixedColumns()
      }"
      [attr.p-spacing]="spacing"
    >
      <thead class="po-table-header-sticky" [style.top]="inverseOfTranslation">
        <tr
          [class.po-table-header]="!height"
          cdkDropList
          cdkDropListOrientation="horizontal"
          (cdkDropListDropped)="drop($event)"
        >
          <th
            *ngIf="hasSelectableColumn"
            [style.pointer-events]="hideSelectAll ? 'none' : 'auto'"
            class="po-table-column-selectable"
          >
            <div [class.po-table-header-fixed-inner]="height">
              <po-checkbox
                name="selectAll"
                *ngIf="!hideSelectAll"
                (p-change)="selectAllRows()"
                [p-checkboxValue]="selectAll === null ? 'mixed' : selectAll"
              ></po-checkbox>
            </div>
          </th>

          <th
            *ngIf="(hasMasterDetailColumn || hasRowTemplate) && !hasRowTemplateWithArrowDirectionRight"
            class="po-table-header-column po-table-header-master-detail"
          ></th>

          <!-- Coluna criada para caso as ações fiquem no lado esquerdo -->
          <th
            #columnActionLeft
            *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
            [class.po-table-header-master-detail]="!isSingleAction"
            [class.po-table-header-single-action]="isSingleAction"
          ></th>

          <th *ngIf="!hasMainColumns" #noColumnsHeader class="po-table-header-column po-text-center">
            <ng-container *ngIf="height; then noColumnsWithHeight; else noColumnsWithoutHeight"> </ng-container>
          </th>

          <ng-container
            *ngIf="
              this.isDraggable || hasSomeFixed();
              then tableVirtualScrollThDragDrop;
              else tableVirtualScrollThDefault
            "
          >
          </ng-container>
          <ng-template #tableVirtualScrollThDragDrop>
            <th
              *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
              class="po-table-header-ellipsis p-element po-frozen-column"
              [style.width]="column.width"
              [style.max-width]="column.width"
              [style.min-width]="column.width"
              [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
              [class.po-clickable]="(sort && column.sortable !== false) || hasService"
              [ngClass]="{
                'po-table-header-sorted':
                  sort &&
                  JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                  (sortedColumn.ascending || !sortedColumn.ascending)
              }"
              [ngStyle]="{ 'width': !hasItems ? '100%' : applyFixedColumns() ? column.width : 'auto' }"
              [class.po-table-header-subtitle]="column.type === 'subtitle'"
              [class.po-table-column-drag-box]="this.isDraggable"
              (click)="sortColumn(column)"
              cdkDrag
              cdkDragLockAxis="x"
              [cdkDragDisabled]="column.fixed ? 'true' : 'false'"
              [pFrozenColumn]="column.fixed"
            >
              <div
                class="po-table-header-flex"
                [class.po-table-header-fixed-inner]="height"
                [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
                [class.po-table-header-flex-center]="column.type === 'subtitle'"
              >
                <ng-container *ngIf="this.isDraggable && !column.fixed">
                  <svg
                    cdkDragHandle
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <circle cx="9" cy="6" r="2" fill="black" />
                    <circle cx="15" cy="6" r="2" fill="black" />
                    <circle cx="9" cy="12" r="2" fill="black" />
                    <circle cx="15" cy="12" r="2" fill="black" />
                    <circle cx="9" cy="18" r="2" fill="black" />
                    <circle cx="15" cy="18" r="2" fill="black" />
                  </svg>
                </ng-container>
                <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
              </div>
            </th>
          </ng-template>
          <ng-template #tableVirtualScrollThDefault>
            <th
              *ngFor="let column of mainColumns; let i = index; trackBy: trackBy"
              class="po-table-header-ellipsis p-element po-frozen-column example-box"
              [style.width]="column.width"
              [style.max-width]="column.width"
              [style.min-width]="column.width"
              [attr.data-po-table-column-name]="column.label || (column.property | titlecase) | lowercase"
              [class.po-clickable]="(sort && column.sortable !== false) || hasService"
              [ngClass]="{
                'po-table-header-sorted':
                  sort &&
                  JSON.stringify(sortedColumn?.property) === JSON.stringify(column) &&
                  (sortedColumn.ascending || !sortedColumn.ascending)
              }"
              [ngStyle]="{ 'width': !hasItems ? '100%' : applyFixedColumns() ? column.width : 'auto' }"
              [class.po-table-header-subtitle]="column.type === 'subtitle'"
              (click)="sortColumn(column)"
              [pFrozenColumn]="column.fixed"
            >
              <div
                class="po-table-header-flex"
                [class.po-table-header-fixed-inner]="height"
                [class.po-table-header-flex-right]="column.type === 'currency' || column.type === 'number'"
                [class.po-table-header-flex-center]="column.type === 'subtitle'"
              >
                <ng-container *ngTemplateOutlet="contentHeaderTemplate; context: { $implicit: column }"> </ng-container>
              </div>
            </th>
          </ng-template>

          <th
            *ngIf="hasRowTemplateWithArrowDirectionRight && (hasVisibleActions || hideColumnsManager)"
            class="po-table-header-column po-table-header-master-detail"
          ></th>

          <th
            *ngIf="hasVisibleActions && actionRight && (visibleActions.length > 1 || isSingleAction)"
            [class.po-table-header-single-action]="isSingleAction"
            [class.po-table-header-actions]="!isSingleAction"
          ></th>
        </tr>
      </thead>

      <tbody class="po-table-group-row" *ngIf="!hasItems || !hasMainColumns">
        <tr class="po-table-row po-table-row-no-data">
          <td [colSpan]="columnCount" class="po-table-no-data po-text-center">
            <span> {{ literals.noData }} </span>
          </td>
        </tr>
      </tbody>

      <ng-container *ngIf="hasMainColumns">
        <tbody
          class="po-table-group-row"
          *cdkVirtualFor="let row of filteredItems; let rowIndex = index; trackBy: trackBy"
        >
          <tr
            class="po-table-row"
            [class.po-table-row-active]="row.$selected || (row.$selected === null && selectable)"
          >
            <td *ngIf="selectable" class="po-table-column-selectable">
              <ng-container *ngTemplateOutlet="singleSelect ? inputRadio : inputCheckbox; context: { $implicit: row }">
              </ng-container>
            </td>

            <!-- Valida se a origem do detail é pelo input do po-table -->
            <td
              *ngIf="columnMasterDetail && !hideDetail && !hasRowTemplate"
              class="po-table-column-detail-toggle"
              (click)="toggleDetail(row)"
            >
              <ng-template
                [ngTemplateOutlet]="poTableColumnDetail"
                [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>

            <!-- Coluna com as ações na esquerda (padrão)-->
            <ng-template
              *ngIf="!actionRight && (visibleActions.length > 1 || isSingleAction)"
              [ngTemplateOutlet]="ActionsColumnTemplate"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>

            <!-- Valida se a origem do detail é pela diretiva -->
            <td
              *ngIf="hasRowTemplate && !hasRowTemplateWithArrowDirectionRight"
              class="po-table-column-detail-toggle"
              (click)="toggleDetail(row)"
            >
              <ng-template
                [ngTemplateOutlet]="poTableColumnDetail"
                [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>

            <td
              *ngFor="let column of mainColumns; let columnIndex = index; trackBy: trackBy"
              [style.width]="column.width"
              [style.max-width]="column.width"
              [style.min-width]="column.width"
              [class.po-table-column]="column.type !== 'icon'"
              [class.po-table-column-right]="column.type === 'currency' || column.type === 'number'"
              [class.po-table-column-center]="column.type === 'subtitle'"
              [class.po-table-column-icons]="column.type === 'icon'"
              [ngClass]="getClassColor(row, column)"
              [pFrozenColumn]="column.fixed"
              class="p-element po-frozen-column"
              (click)="hasSelectableRow() ? selectRow(row) : 'javascript:;'"
            >
              <div
                class="po-table-column-cell po-table-body-ellipsis notranslate"
                [ngSwitch]="column.type"
                [p-tooltip]="tooltipText"
                [p-append-in-body]="true"
                (mouseenter)="tooltipMouseEnter($event, column, row)"
                (mouseleave)="tooltipMouseLeave()"
              >
                <span *ngSwitchCase="'columnTemplate'">
                  <ng-container
                    *ngTemplateOutlet="getTemplate(column); context: { $implicit: getCellData(row, column) }"
                  >
                  </ng-container>
                </span>

                <span *ngSwitchCase="'cellTemplate'">
                  <ng-container
                    *ngTemplateOutlet="tableCellTemplate?.templateRef; context: { row: row, column: column }"
                  >
                  </ng-container>
                </span>

                <span *ngSwitchCase="'boolean'">
                  {{ getBooleanLabel(getCellData(row, column), column) }}
                </span>

                <span *ngSwitchCase="'currency'">
                  {{ getCellData(row, column) | currency: column.format : 'symbol' : '1.2-2' }}
                </span>

                <span *ngSwitchCase="'date'">
                  {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy' }}
                </span>

                <span *ngSwitchCase="'time'">
                  {{ getCellData(row, column) | po_time: column.format || 'HH:mm:ss.ffffff' }}
                </span>

                <span *ngSwitchCase="'dateTime'">
                  {{ getCellData(row, column) | date: column.format || 'dd/MM/yyyy HH:mm:ss' }}
                </span>

                <span *ngSwitchCase="'number'">
                  {{ formatNumber(getCellData(row, column), column.format) }}
                </span>

                <po-table-column-link
                  *ngSwitchCase="'link'"
                  [p-action]="column.action"
                  [p-disabled]="checkDisabled(row, column)"
                  [p-link]="row[column.link]"
                  [p-row]="row"
                  [p-value]="getCellData(row, column)"
                  (click)="onClickLink($event, row, column)"
                >
                </po-table-column-link>

                <po-table-column-icon
                  *ngSwitchCase="'icon'"
                  [p-column]="column"
                  [p-icons]="getColumnIcons(row, column)"
                  [p-row]="row"
                >
                </po-table-column-icon>

                <span *ngSwitchCase="'subtitle'">
                  <po-table-subtitle-circle [p-subtitle]="getSubtitleColumn(row, column)"></po-table-subtitle-circle>
                </span>
                <span *ngSwitchCase="'label'">
                  <po-table-column-label [p-value]="getColumnLabel(row, column)"> </po-table-column-label>
                </span>
                <span *ngSwitchDefault>{{ getCellData(row, column) }}</span>
              </div>
            </td>

            <td
              *ngIf="hasRowTemplateWithArrowDirectionRight"
              class="po-table-column-detail-toggle"
              (click)="toggleDetail(row)"
            >
              <ng-template
                [ngTemplateOutlet]="poTableColumnDetail"
                [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>

            <!-- Coluna de açoes na direita -->
            <ng-template
              *ngIf="actionRight"
              [ngTemplateOutlet]="ActionsColumnTemplate"
              [ngTemplateOutletContext]="{ row: row, rowIndex: rowIndex }"
            >
            </ng-template>
          </tr>

          <tr *ngIf="hasMainColumns && hasRowTemplate && row.$showDetail && isShowRowTemplate(row, rowIndex)">
            <td class="po-table-row-template-container" [colSpan]="columnCountForMasterDetail">
              <ng-template
                [ngTemplateOutlet]="tableRowTemplate.templateRef"
                [ngTemplateOutletContext]="{ $implicit: row, rowIndex: rowIndex }"
              >
              </ng-template>
            </td>
          </tr>

          <tr *ngIf="hasMainColumns && isShowMasterDetail(row)">
            <td class="po-table-column-detail" [colSpan]="columnCountForMasterDetail">
              <po-table-detail
                [p-selectable]="selectable && !detailHideSelect"
                [p-detail]="columnMasterDetail.detail"
                [p-items]="row[nameColumnDetail]"
                (p-select-row)="selectDetailRow($event)"
              >
              </po-table-detail>
            </td>
          </tr>
        </tbody>
      </ng-container>
    </table>
  </cdk-virtual-scroll-viewport>
</ng-template>

<po-popup #popup [p-actions]="actions" [p-target]="popupTarget"> </po-popup>

<ng-template #poTableColumnDetail let-row="row" let-rowIndex="rowIndex">
  <span
    *ngIf="(containsMasterDetail(row) && !hasRowTemplate) || (isShowRowTemplate(row, rowIndex) && hasRowTemplate)"
    class="po-icon po-clickable"
    [class.po-icon-arrow-up]="row.$showDetail"
    [class.po-icon-arrow-down]="!row.$showDetail"
  >
  </span>
</ng-template>

<ng-template #inputRadio let-row>
  <po-radio [name]="idRadio" [p-checked]="row.$selected" (p-change-selected)="selectRow(row)"></po-radio>
</ng-template>

<ng-template #inputCheckbox let-row>
  <po-checkbox
    name="checkbox"
    (p-change)="selectable ? selectRow(row) : 'javascript:;'"
    [p-checkboxValue]="row.$selected"
  ></po-checkbox>
</ng-template>

<ng-template #contentHeaderTemplate let-column>
  <span
    #columnHeader
    class="po-table-header-ellipsis"
    [p-tooltip]="tooltipText"
    [p-append-in-body]="true"
    (mouseenter)="tooltipMouseEnter($event)"
    (mouseleave)="tooltipMouseLeave()"
  >
    {{ column.label || (column.property | titlecase) }}
  </span>

  <span
    *ngIf="sort && column.sortable !== false"
    [class.po-table-header-icon-unselected]="JSON.stringify(sortedColumn?.property) !== JSON.stringify(column)"
    [class.po-table-header-icon-descending]="
      JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && sortedColumn.ascending
    "
    [class.po-table-header-icon-ascending]="
      JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && !sortedColumn.ascending
    "
  >
    <ng-container *ngIf="JSON.stringify(sortedColumn?.property) !== JSON.stringify(column)">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M18.2929 15.2929L17 16.5858L17 10C17 9.44772 16.5523 9 16 9C15.4477 9 15 9.44772 15 10L15 16.5858L13.7071 15.2929C13.3166 14.9024 12.6834 14.9024 12.2929 15.2929C11.9024 15.6834 11.9024 16.3166 12.2929 16.7071L15.2929 19.7071C15.6834 20.0976 16.3166 20.0976 16.7071 19.7071L19.7071 16.7071C20.0976 16.3166 20.0976 15.6834 19.7071 15.2929C19.3166 14.9024 18.6834 14.9024 18.2929 15.2929ZM5.70716 8.7071L7.00006 7.4142L7.00003 14C7.00002 14.5523 7.44774 15 8.00002 15C8.55231 15 9.00002 14.5523 9.00003 14L9.00006 7.41418L10.2929 8.70707C10.6835 9.09759 11.3166 9.09758 11.7072 8.70706C12.0977 8.31653 12.0977 7.68336 11.7072 7.29284L8.70718 4.29286C8.31665 3.90234 7.68349 3.90235 7.29296 4.29287L4.29295 7.29289C3.90242 7.68342 3.90242 8.31658 4.29294 8.70711C4.68347 9.09763 5.31663 9.09762 5.70716 8.7071Z"
          fill="#1D1D30"
        />
      </svg>
    </ng-container>

    <ng-container *ngIf="JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && sortedColumn.ascending">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M11 9.41421L9.70711 10.7071C9.31658 11.0976 8.68342 11.0976 8.29289 10.7071C7.90237 10.3166 7.90237 9.68342 8.29289 9.29289L11.2929 6.29289C11.6834 5.90237 12.3166 5.90237 12.7071 6.29289L15.7071 9.29289C16.0976 9.68342 16.0976 10.3166 15.7071 10.7071C15.3166 11.0976 14.6834 11.0976 14.2929 10.7071L13 9.41421V16C13 16.5523 12.5523 17 12 17C11.4477 17 11 16.5523 11 16V9.41421Z"
          fill="black"
        />
      </svg>
    </ng-container>

    <ng-container *ngIf="JSON.stringify(sortedColumn?.property) === JSON.stringify(column) && !sortedColumn.ascending">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M9.70711 13.2929L11 14.5858V7C11 6.44772 11.4477 6 12 6C12.5523 6 13 6.44772 13 7V14.5858L14.2929 13.2929C14.6834 12.9024 15.3166 12.9024 15.7071 13.2929C16.0976 13.6834 16.0976 14.3166 15.7071 14.7071L12.7071 17.7071C12.3166 18.0976 11.6834 18.0976 11.2929 17.7071L8.29289 14.7071C7.90237 14.3166 7.90237 13.6834 8.29289 13.2929C8.68342 12.9024 9.31658 12.9024 9.70711 13.2929Z"
          fill="black"
        />
      </svg>
    </ng-container>
  </span>
</ng-template>

<ng-template #noColumnsWithHeight>
  <div class="po-table-header-fixed-inner" [style.width.px]="headerWidth">
    {{ hasValidColumns ? literals.noVisibleColumn : literals.noColumns }}
  </div>
</ng-template>

<ng-template #noColumnsWithoutHeight>
  {{ hasValidColumns ? literals.noVisibleColumn : literals.noColumns }}
</ng-template>

<!-- Template de ações -->
<ng-template #ActionsColumnTemplate let-row="row" let-rowIndex="rowIndex">
  <td
    *ngIf="isSingleAction"
    class="po-table-column po-table-column-single-action"
    [style.width.px]="height && actionRight ? getWidthColumnManager() : ''"
    [style.max-width.px]="height && !actionRight ? getColumnWidthActionsLeft() : ''"
    [style.width.px]="height && !actionRight ? getColumnWidthActionsLeft() : ''"
  >
    <div
      *ngIf="firstAction.visible !== false"
      class="po-table-single-action po-clickable"
      [class.po-table-action-disabled]="firstAction.disabled ? validateTableAction(row, firstAction) : false"
      (click)="executeTableAction(row, firstAction)"
    >
      <po-icon *ngIf="firstAction.icon" class="po-table-single-action-content" [p-icon]="firstAction.icon"></po-icon>
      {{ firstAction.label }}
    </div>
  </td>

  <td *ngIf="visibleActions.length > 1" class="po-table-column-actions">
    <span #popupTarget class="po-icon po-icon-more po-clickable" (click)="togglePopup(row, popupTarget)"></span>
  </td>
</ng-template>

<po-table-column-manager
  *ngIf="!hideColumnsManager"
  [p-columns]="columns"
  [p-max-columns]="maxColumns"
  [p-target]="columnManagerTarget"
  [p-last-visible-columns-selected]="lastVisibleColumnsSelected"
  [p-hide-action-fixed-columns]="hideActionFixedColumns"
  (p-visible-columns-change)="onVisibleColumnsChange($event)"
  (p-change-visible-columns)="onChangeVisibleColumns($event)"
  [p-columns-default]="initialColumns"
  (p-initial-columns)="onColumnRestoreManager($event)"
>
</po-table-column-manager>

<po-modal
  #modalDelete
  [p-title]="literals.delete"
  [p-primary-action]="confirm"
  [p-secondary-action]="close"
  [p-click-out]="true"
>
  <p class="po-font-text-large">{{ literals.bodyDelete }}</p>
</po-modal>
` }]
  }], () => [{ type: PoDateService }, { type: IterableDiffers }, { type: Renderer2 }, { type: PoLanguageService }, { type: ChangeDetectorRef }, { type: DecimalPipe }, { type: Router }, { type: PoTableService }], { tableRowTemplate: [{
    type: ContentChild,
    args: [PoTableRowTemplateDirective, { static: true }]
  }], tableCellTemplate: [{
    type: ContentChild,
    args: [PoTableCellTemplateDirective]
  }], tableColumnTemplates: [{
    type: ContentChildren,
    args: [PoTableColumnTemplateDirective]
  }], noColumnsHeader: [{
    type: ViewChild,
    args: ["noColumnsHeader", { read: ElementRef }]
  }], poPopupComponent: [{
    type: ViewChild,
    args: ["popup"]
  }], modalDelete: [{
    type: ViewChild,
    args: [PoModalComponent, { static: true }]
  }], tableFooterElement: [{
    type: ViewChild,
    args: ["tableFooter", { read: ElementRef, static: false }]
  }], tableWrapperElement: [{
    type: ViewChild,
    args: ["tableWrapper", { read: ElementRef, static: false }]
  }], tableTemplate: [{
    type: ViewChild,
    args: ["tableTemplate", { read: ElementRef, static: false }]
  }], tableVirtualScroll: [{
    type: ViewChild,
    args: ["tableVirtualScroll", { read: ElementRef, static: false }]
  }], columnManager: [{
    type: ViewChild,
    args: ["columnManager", { read: ElementRef, static: false }]
  }], columnBatchActions: [{
    type: ViewChild,
    args: ["columnBatchActions", { read: ElementRef, static: false }]
  }], columnActionLeft: [{
    type: ViewChild,
    args: ["columnActionLeft", { read: ElementRef, static: false }]
  }], actionsIconElement: [{
    type: ViewChildren,
    args: ["actionsIconElement", { read: ElementRef }]
  }], actionsElement: [{
    type: ViewChildren,
    args: ["actionsElement", { read: ElementRef }]
  }], filterInput: [{
    type: ViewChild,
    args: ["filterInput"]
  }], poSearchInput: [{
    type: ViewChild,
    args: ["poSearchInput", { read: ElementRef, static: true }]
  }], viewPort: [{
    type: ViewChild,
    args: [CdkVirtualScrollViewport, { static: false }]
  }], columnManagerTarget: [{
    type: ViewChild,
    args: ["columnManagerTarget"]
  }], columnManagerTargetFixed: [{
    type: ViewChild,
    args: ["columnManagerTargetFixed"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableComponent, { className: "PoTableComponent", filePath: "lib/components/po-table/po-table.component.ts", lineNumber: 105 });
})();
function PoTableDetailComponent_thead_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 6);
  }
}
function PoTableDetailComponent_thead_1_th_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 7)(1, "div", 8);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const detail_r4 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("po-table-header-flex-right", detail_r4.type === "currency" || detail_r4.type === "number");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.getColumnTitleLabel(detail_r4), " ");
  }
}
function PoTableDetailComponent_thead_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead")(1, "tr");
    ɵɵtemplate(2, PoTableDetailComponent_thead_1_th_2_Template, 1, 0, "th", 3);
    ɵɵelement(3, "th", 4);
    ɵɵtemplate(4, PoTableDetailComponent_thead_1_th_4_Template, 3, 3, "th", 5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.isSelectable);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.detail.columns);
  }
}
function PoTableDetailComponent_tr_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "td", 13);
    ɵɵelementStart(2, "td", 14)(3, "po-checkbox", 15);
    ɵɵlistener("click", function PoTableDetailComponent_tr_3_ng_container_1_Template_po_checkbox_click_3_listener() {
      ɵɵrestoreView(_r12);
      const item_r5 = ɵɵnextContext().$implicit;
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.onSelectRow(item_r5));
    })("p-change", function PoTableDetailComponent_tr_3_ng_container_1_Template_po_checkbox_p_change_3_listener() {
      ɵɵrestoreView(_r12);
      const item_r5 = ɵɵnextContext().$implicit;
      const ctx_r13 = ɵɵnextContext();
      return ɵɵresetView(ctx_r13.onSelectRow(item_r5));
    });
    ɵɵtwoWayListener("ngModelChange", function PoTableDetailComponent_tr_3_ng_container_1_Template_po_checkbox_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r12);
      const item_r5 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(item_r5.$selected, $event) || (item_r5.$selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext().$implicit;
    ɵɵadvance(3);
    ɵɵtwoWayProperty("ngModel", item_r5.$selected);
  }
}
function PoTableDetailComponent_tr_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 16);
  }
}
function PoTableDetailComponent_tr_3_td_4_strong_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "strong");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const ctx_r19 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r19.getColumnTitleLabel(detail_r18), ": ");
  }
}
function PoTableDetailComponent_tr_3_td_4_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "currency");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r20 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind4(2, 1, ctx_r20.getDetailData(item_r5, detail_r18), detail_r18.format, "symbol", "1.2-2"));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r21 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, ctx_r21.getDetailData(item_r5, detail_r18), detail_r18.format || "dd/MM/yyyy"));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "po_time");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r22 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind2(2, 1, ctx_r22.getDetailData(item_r5, detail_r18), detail_r18.format || "HH:mm:ss.ffffff"));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "date");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r23 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r23.getDetailData(item_r5, detail_r18), detail_r18.format || "dd/MM/yyyy HH:mm:ss"), " ");
  }
}
function PoTableDetailComponent_tr_3_td_4_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r24 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r24.formatNumberDetail(ctx_r24.getDetailData(item_r5, detail_r18), detail_r18.format));
  }
}
function PoTableDetailComponent_tr_3_td_4_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ɵɵnextContext().$implicit;
    const item_r5 = ɵɵnextContext().$implicit;
    const ctx_r25 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r25.getDetailData(item_r5, detail_r18));
  }
}
function PoTableDetailComponent_tr_3_td_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r40 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 17);
    ɵɵlistener("click", function PoTableDetailComponent_tr_3_td_4_Template_td_click_0_listener() {
      ɵɵrestoreView(_r40);
      const item_r5 = ɵɵnextContext().$implicit;
      const ctx_r39 = ɵɵnextContext();
      return ɵɵresetView(ctx_r39.isSelectable ? ctx_r39.onSelectRow(item_r5) : "javascript:;");
    });
    ɵɵtemplate(1, PoTableDetailComponent_tr_3_td_4_strong_1_Template, 2, 1, "strong", 1);
    ɵɵelementContainerStart(2, 18);
    ɵɵtemplate(3, PoTableDetailComponent_tr_3_td_4_span_3_Template, 3, 6, "span", 19)(4, PoTableDetailComponent_tr_3_td_4_span_4_Template, 3, 4, "span", 19)(5, PoTableDetailComponent_tr_3_td_4_span_5_Template, 3, 4, "span", 19)(6, PoTableDetailComponent_tr_3_td_4_span_6_Template, 3, 4, "span", 19)(7, PoTableDetailComponent_tr_3_td_4_span_7_Template, 2, 1, "span", 19)(8, PoTableDetailComponent_tr_3_td_4_span_8_Template, 2, 1, "span", 20);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r18 = ctx.$implicit;
    const ctx_r9 = ɵɵnextContext(2);
    ɵɵclassProp("po-table-column-right", ctx_r9.typeHeaderTop && (detail_r18.type === "currency" || detail_r18.type === "number"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r9.typeHeaderInline);
    ɵɵadvance();
    ɵɵproperty("ngSwitch", detail_r18.type);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "currency");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "time");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "dateTime");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
  }
}
function PoTableDetailComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 9);
    ɵɵtemplate(1, PoTableDetailComponent_tr_3_ng_container_1_Template, 4, 1, "ng-container", 10)(2, PoTableDetailComponent_tr_3_ng_template_2_Template, 1, 0, "ng-template", null, 11, ɵɵtemplateRefExtractor)(4, PoTableDetailComponent_tr_3_td_4_Template, 9, 9, "td", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const _r8 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-table-row-active", item_r5.$selected && ctx_r1.isSelectable);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isSelectable)("ngIfElse", _r8);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.detailColumns);
  }
}
var PoTableDetailComponent = class _PoTableDetailComponent {
  decimalPipe;
  /**
   * Lista de itens do _detail_ da tabela.
   */
  items;
  /**
   * Define se a tabela possui a opção de `selectable` habilitada.
   */
  isSelectable = false;
  /**
   * @optional
   *
   * @description
   *
   * Ação executada ao selecionar ou desmarcar a seleção de uma linha de detalhe do `po-table`.
   */
  selectRow = new EventEmitter();
  _detail;
  /**
   * Configuração da linha de detalhes.
   */
  set detail(value) {
    this._detail = this.returnPoTableDetailObject(value);
  }
  get detail() {
    return this._detail;
  }
  constructor(decimalPipe) {
    this.decimalPipe = decimalPipe;
  }
  get detailColumns() {
    return this.detail?.columns || [];
  }
  get typeHeaderInline() {
    return this.detail && !this.detail["typeHeader"] || this.detail["typeHeader"] === "inline";
  }
  get typeHeaderTop() {
    return this.detail && this.detail["typeHeader"] === "top";
  }
  formatNumberDetail(value, format) {
    if (!format) {
      return value;
    }
    return this.decimalPipe.transform(value, format);
  }
  getColumnTitleLabel(detail) {
    return detail.label || capitalizeFirstLetter(detail.property);
  }
  getDetailData(item, detail) {
    const arrayProperty = detail.property.split(".");
    if (arrayProperty.length > 1) {
      const nestedProperties = arrayProperty;
      let value = item;
      for (const property of nestedProperties) {
        value = value[property] || value[property] === 0 ? value[property] : "";
      }
      return value;
    } else {
      return item[detail.property];
    }
  }
  onSelectRow(item) {
    item.$selected = !item.$selected;
    this.selectRow.emit(item);
  }
  returnPoTableDetailObject(value) {
    if (value && isTypeof(value, "object")) {
      if (value.columns) {
        value.columns.forEach((column) => column.property = column.property || column.column);
      }
      if (Array.isArray(value)) {
        return { columns: value };
      }
      if (value.columns) {
        return value;
      }
    }
  }
  static ɵfac = function PoTableDetailComponent_Factory(t) {
    return new (t || _PoTableDetailComponent)(ɵɵdirectiveInject(DecimalPipe));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableDetailComponent, selectors: [["po-table-detail"]], inputs: { items: [InputFlags.None, "p-items", "items"], isSelectable: [InputFlags.None, "p-selectable", "isSelectable"], detail: [InputFlags.None, "p-detail", "detail"] }, outputs: { selectRow: "p-select-row" }, decls: 4, vars: 2, consts: [[1, "po-table-master-detail"], [4, "ngIf"], ["class", "po-table-detail-row", 3, "po-table-row-active", 4, "ngFor", "ngForOf"], ["class", "po-table-header po-table-column-selectable", 4, "ngIf"], [1, "po-table-header", "po-table-header-column", "po-table-header-master-detail"], ["class", "po-table-header po-table-header-ellipsis", 4, "ngFor", "ngForOf"], [1, "po-table-header", "po-table-column-selectable"], [1, "po-table-header", "po-table-header-ellipsis"], [1, "po-table-header-flex"], [1, "po-table-detail-row"], [4, "ngIf", "ngIfElse"], ["masterDetailSpace", ""], ["class", "po-table-column-master-detail po-table-master-detail-label", 3, "po-table-column-right", "click", 4, "ngFor", "ngForOf"], [1, "po-table-column-master-detail-space-checkbox"], [1, "po-table-column", "po-table-column-selectable"], ["name", "checkbox", 3, "ngModel", "click", "p-change", "ngModelChange"], [1, "po-table-column-master-detail-space"], [1, "po-table-column-master-detail", "po-table-master-detail-label", 3, "click"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"]], template: function PoTableDetailComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "table", 0);
      ɵɵtemplate(1, PoTableDetailComponent_thead_1_Template, 5, 2, "thead", 1);
      ɵɵelementStart(2, "tbody");
      ɵɵtemplate(3, PoTableDetailComponent_tr_3_Template, 5, 5, "tr", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.typeHeaderTop);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.items);
    }
  }, dependencies: [NgForOf, NgIf, NgSwitch, NgSwitchCase, NgSwitchDefault, NgControlStatus, NgModel, PoCheckboxComponent, CurrencyPipe, DatePipe, PoTimePipe], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableDetailComponent, [{
    type: Component,
    args: [{ selector: "po-table-detail", template: `<table class="po-table-master-detail">
  <thead *ngIf="typeHeaderTop">
    <tr>
      <th class="po-table-header po-table-column-selectable" *ngIf="isSelectable"></th>
      <th class="po-table-header po-table-header-column po-table-header-master-detail"></th>
      <th class="po-table-header po-table-header-ellipsis" *ngFor="let detail of detail.columns">
        <div
          class="po-table-header-flex"
          [class.po-table-header-flex-right]="detail.type === 'currency' || detail.type === 'number'"
        >
          {{ getColumnTitleLabel(detail) }}
        </div>
      </th>
    </tr>
  </thead>
  <tbody>
    <tr
      class="po-table-detail-row"
      [class.po-table-row-active]="item.$selected && isSelectable"
      *ngFor="let item of items"
    >
      <ng-container *ngIf="isSelectable; else masterDetailSpace">
        <td class="po-table-column-master-detail-space-checkbox"></td>
        <td class="po-table-column po-table-column-selectable">
          <po-checkbox
            name="checkbox"
            (click)="onSelectRow(item)"
            (p-change)="onSelectRow(item)"
            [(ngModel)]="item.$selected"
          ></po-checkbox>
        </td>
      </ng-container>

      <ng-template #masterDetailSpace>
        <td class="po-table-column-master-detail-space"></td>
      </ng-template>

      <td
        class="po-table-column-master-detail po-table-master-detail-label"
        (click)="isSelectable ? onSelectRow(item) : 'javascript:;'"
        *ngFor="let detail of detailColumns"
        [class.po-table-column-right]="typeHeaderTop && (detail.type === 'currency' || detail.type === 'number')"
      >
        <strong *ngIf="typeHeaderInline"> {{ getColumnTitleLabel(detail) }}: </strong>

        <ng-container [ngSwitch]="detail.type">
          <span *ngSwitchCase="'currency'">{{
            getDetailData(item, detail) | currency: detail.format : 'symbol' : '1.2-2'
          }}</span>
          <span *ngSwitchCase="'date'">{{ getDetailData(item, detail) | date: detail.format || 'dd/MM/yyyy' }}</span>
          <span *ngSwitchCase="'time'">{{
            getDetailData(item, detail) | po_time: detail.format || 'HH:mm:ss.ffffff'
          }}</span>
          <span *ngSwitchCase="'dateTime'">
            {{ getDetailData(item, detail) | date: detail.format || 'dd/MM/yyyy HH:mm:ss' }}
          </span>
          <span *ngSwitchCase="'number'">{{ formatNumberDetail(getDetailData(item, detail), detail.format) }}</span>
          <span *ngSwitchDefault>{{ getDetailData(item, detail) }}</span>
        </ng-container>
      </td>
    </tr>
  </tbody>
</table>
` }]
  }], () => [{ type: DecimalPipe }], { items: [{
    type: Input,
    args: ["p-items"]
  }], isSelectable: [{
    type: Input,
    args: ["p-selectable"]
  }], selectRow: [{
    type: Output,
    args: ["p-select-row"]
  }], detail: [{
    type: Input,
    args: ["p-detail"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableDetailComponent, { className: "PoTableDetailComponent", filePath: "lib/components/po-table/po-table-detail/po-table-detail.component.ts", lineNumber: 20 });
})();
var PoTableSubtitleCircleComponent = class _PoTableSubtitleCircleComponent {
  poColorPaletteService;
  /** Esconde a tooltip. */
  hideTitle = false;
  _subtitle;
  /** Objeto com os dados da legenda. */
  set subtitle(subtitle) {
    if (subtitle) {
      subtitle.color = this.poColorPaletteService.getColor(subtitle);
    }
    this._subtitle = subtitle;
  }
  get subtitle() {
    return this._subtitle;
  }
  constructor(poColorPaletteService) {
    this.poColorPaletteService = poColorPaletteService;
  }
  static ɵfac = function PoTableSubtitleCircleComponent_Factory(t) {
    return new (t || _PoTableSubtitleCircleComponent)(ɵɵdirectiveInject(PoColorPaletteService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableSubtitleCircleComponent, selectors: [["po-table-subtitle-circle"]], inputs: { hideTitle: [InputFlags.None, "p-hide-title", "hideTitle"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"] }, decls: 2, vars: 5, consts: [[3, "title"]], template: function PoTableSubtitleCircleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "span", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("po-table-subtitle-circle po-", ctx.subtitle == null ? null : ctx.subtitle.color, "");
      ɵɵproperty("title", ctx.hideTitle ? "" : ctx.subtitle == null ? null : ctx.subtitle.label);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.subtitle == null ? null : ctx.subtitle.content, "\n");
    }
  }, encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableSubtitleCircleComponent, [{
    type: Component,
    args: [{ selector: "po-table-subtitle-circle", changeDetection: ChangeDetectionStrategy.OnPush, template: `<span [title]="hideTitle ? '' : subtitle?.label" class="po-table-subtitle-circle po-{{ subtitle?.color }}">
  {{ subtitle?.content }}
</span>
` }]
  }], () => [{ type: PoColorPaletteService }], { hideTitle: [{
    type: Input,
    args: ["p-hide-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableSubtitleCircleComponent, { className: "PoTableSubtitleCircleComponent", filePath: "lib/components/po-table/po-table-subtitle-circle/po-table-subtitle-circle.component.ts", lineNumber: 18 });
})();
function PoTableShowSubtitleComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "po-table-subtitle-circle", 7);
    ɵɵelementStart(2, "span", 8);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const subtitle_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("p-subtitle", subtitle_r2);
    ɵɵadvance(2);
    ɵɵtextInterpolate(subtitle_r2.label);
  }
}
var PoTableShowSubtitleComponent = class _PoTableShowSubtitleComponent {
  /** Objeto com os dados da legenda. */
  subtitles;
  /** Propriedade que recebe as literais definidas no `po-table`. */
  literals;
  static ɵfac = function PoTableShowSubtitleComponent_Factory(t) {
    return new (t || _PoTableShowSubtitleComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableShowSubtitleComponent, selectors: [["po-table-show-subtitle"]], inputs: { subtitles: [InputFlags.None, "p-subtitles", "subtitles"], literals: [InputFlags.None, "p-literals", "literals"] }, decls: 7, vars: 3, consts: [[1, "po-table-footer-show-subtitle", 3, "click"], [1, "po-table-footer-show-subtitle-container"], [1, "po-table-show-subtitle"], ["p-size", "sm", 3, "p-title"], ["modal", ""], ["class", "po-table-subtitle-footer-modal po-row", 4, "ngFor", "ngForOf"], [1, "po-table-subtitle-footer-modal", "po-row"], ["p-hide-title", "true", 3, "p-subtitle"], [1, "po-table-subtitle-text"]], template: function PoTableShowSubtitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r3 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoTableShowSubtitleComponent_Template_div_click_0_listener() {
        ɵɵrestoreView(_r3);
        const _r0 = ɵɵreference(5);
        return ɵɵresetView(_r0.open());
      });
      ɵɵelementStart(1, "div", 1)(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd()()();
      ɵɵelementStart(4, "po-modal", 3, 4);
      ɵɵtemplate(6, PoTableShowSubtitleComponent_div_6_Template, 4, 2, "div", 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.literals.seeCompleteSubtitle);
      ɵɵadvance();
      ɵɵproperty("p-title", ctx.literals.completeSubtitle);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.subtitles);
    }
  }, dependencies: [NgForOf, PoModalComponent, PoTableSubtitleCircleComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableShowSubtitleComponent, [{
    type: Component,
    args: [{ selector: "po-table-show-subtitle", template: '<div class="po-table-footer-show-subtitle" (click)="modal.open()">\n  <div class="po-table-footer-show-subtitle-container">\n    <span class="po-table-show-subtitle">{{ literals.seeCompleteSubtitle }}</span>\n  </div>\n</div>\n\n<po-modal #modal p-size="sm" [p-title]="literals.completeSubtitle">\n  <div *ngFor="let subtitle of subtitles" class="po-table-subtitle-footer-modal po-row">\n    <po-table-subtitle-circle p-hide-title="true" [p-subtitle]="subtitle"> </po-table-subtitle-circle>\n    <span class="po-table-subtitle-text">{{ subtitle.label }}</span>\n  </div>\n</po-modal>\n' }]
  }], null, { subtitles: [{
    type: Input,
    args: ["p-subtitles"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableShowSubtitleComponent, { className: "PoTableShowSubtitleComponent", filePath: "lib/components/po-table/po-table-show-subtitle/po-table-show-subtitle.component.ts", lineNumber: 16 });
})();
function PoTableSubtitleFooterComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelement(1, "po-table-subtitle-circle", 4);
    ɵɵelementStart(2, "span", 5);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const subtitle_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("p-subtitle", subtitle_r2);
    ɵɵadvance(2);
    ɵɵtextInterpolate(subtitle_r2.label);
  }
}
function PoTableSubtitleFooterComponent_po_table_show_subtitle_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-table-show-subtitle", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-literals", ctx_r1.literals)("p-subtitles", ctx_r1.subtitles);
  }
}
var PoTableSubtitleFooterComponent = class _PoTableSubtitleFooterComponent {
  element;
  renderer;
  /** Propriedade que recebe as literais definidas no `po-table`. */
  literals;
  /** Propriedade que recebe as legendas definidas no `PoTableSubtitleCircleComponent`. */
  subtitles;
  showSubtitle;
  resizeListener;
  isVisible;
  timeoutResize;
  constructor(element, renderer) {
    this.element = element;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.initializeResizeListener();
    this.debounceResize();
  }
  ngDoCheck() {
    if (!this.isVisible && this.getContainerSize() > 0) {
      this.toggleShowCompleteSubtitle();
      this.isVisible = true;
    }
  }
  ngOnDestroy() {
    this.removeResizeListener();
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      this.toggleShowCompleteSubtitle();
    });
  }
  getContainerSize() {
    return this.element.nativeElement.querySelector(".po-table-subtitle-footer-container").offsetWidth;
  }
  getItemsSize() {
    const items = this.element.nativeElement.querySelectorAll(".po-table-subtitle-footer");
    return Array.from(items).map((item) => item["offsetWidth"]).reduce((a, b) => a + b, 16);
  }
  initializeResizeListener() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  removeResizeListener() {
    this.resizeListener();
  }
  toggleShowCompleteSubtitle() {
    const containerSize = this.getContainerSize();
    const itemsSize = this.getItemsSize();
    this.showSubtitle = itemsSize > containerSize;
  }
  static ɵfac = function PoTableSubtitleFooterComponent_Factory(t) {
    return new (t || _PoTableSubtitleFooterComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTableSubtitleFooterComponent, selectors: [["po-table-subtitle-footer"]], inputs: { literals: [InputFlags.None, "p-literals", "literals"], subtitles: [InputFlags.None, "p-subtitles", "subtitles"] }, decls: 3, vars: 2, consts: [[1, "po-table-subtitle-footer-container"], ["class", "po-table-subtitle-footer", 4, "ngFor", "ngForOf"], [3, "p-literals", "p-subtitles", 4, "ngIf"], [1, "po-table-subtitle-footer"], ["p-hide-title", "true", 3, "p-subtitle"], [1, "po-table-subtitle-text"], [3, "p-literals", "p-subtitles"]], template: function PoTableSubtitleFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoTableSubtitleFooterComponent_div_1_Template, 4, 2, "div", 1)(2, PoTableSubtitleFooterComponent_po_table_show_subtitle_2_Template, 1, 2, "po-table-show-subtitle", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.subtitles);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showSubtitle);
    }
  }, dependencies: [NgForOf, NgIf, PoTableShowSubtitleComponent, PoTableSubtitleCircleComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableSubtitleFooterComponent, [{
    type: Component,
    args: [{ selector: "po-table-subtitle-footer", template: '<div class="po-table-subtitle-footer-container">\n  <div *ngFor="let subtitle of subtitles" class="po-table-subtitle-footer">\n    <po-table-subtitle-circle p-hide-title="true" [p-subtitle]="subtitle"> </po-table-subtitle-circle>\n    <span class="po-table-subtitle-text">{{ subtitle.label }}</span>\n  </div>\n  <po-table-show-subtitle *ngIf="showSubtitle" [p-literals]="literals" [p-subtitles]="subtitles">\n  </po-table-show-subtitle>\n</div>\n' }]
  }], () => [{ type: ElementRef }, { type: Renderer2 }], { literals: [{
    type: Input,
    args: ["p-literals"]
  }], subtitles: [{
    type: Input,
    args: ["p-subtitles"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTableSubtitleFooterComponent, { className: "PoTableSubtitleFooterComponent", filePath: "lib/components/po-table/po-table-subtitle-footer/po-table-subtitle-footer.component.ts", lineNumber: 16 });
})();
var PoSwitchModule = class _PoSwitchModule {
  static ɵfac = function PoSwitchModule_Factory(t) {
    return new (t || _PoSwitchModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoSwitchModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoFieldContainerModule, PoLabelModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSwitchModule, [{
    type: NgModule,
    args: [{
      declarations: [PoSwitchComponent],
      exports: [PoSwitchComponent],
      imports: [CommonModule, FormsModule, PoFieldContainerModule, PoLabelModule, PoIconModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoSwitchModule, { declarations: [PoSwitchComponent], imports: [CommonModule, FormsModule, PoFieldContainerModule, PoLabelModule, PoIconModule], exports: [PoSwitchComponent] });
})();
var PoTableColumnFrozenDirective = class _PoTableColumnFrozenDirective {
  el;
  renderer;
  _frozen = true;
  get frozen() {
    return this._frozen;
  }
  set frozen(val) {
    this._frozen = val;
    if (!val) {
      this.renderer.removeClass(this.el.nativeElement, "po-table-column-fixed");
    } else {
      this.updateStickyPosition();
    }
  }
  alignFrozen = "left";
  constructor(el, renderer) {
    this.el = el;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      this.updateStickyPosition();
    }, 300);
  }
  ngOnChanges(changes) {
    if (changes.frozen.previousValue && !changes.frozen.currentValue) {
      setTimeout(() => {
        this.resizeColumns();
      }, 100);
    }
  }
  /* istanbul ignore next */
  updateStickyPosition() {
    if (this._frozen) {
      if (this.alignFrozen === "right") {
        let right = 0;
        const next = this.el.nativeElement.nextElementSibling;
        if (next) {
          right = this.getOuterWidth(next) + (parseFloat(next.style.right) || 0);
        }
        this.el.nativeElement.style.right = right + "px";
      } else {
        let left = 0;
        const prev = this.el.nativeElement.previousElementSibling;
        if (prev && !prev.classList.contains("po-table-column-selectable") && !prev.classList.contains("po-table-column-actions") && !prev.classList.contains("po-table-column-detail-toggle") && !prev.classList.contains("po-table-header-master-detail")) {
          left = this.getOuterWidth(prev) + (parseFloat(prev.style.left) || 0);
        }
        this.el.nativeElement.style.left = left - 1 + "px";
        this.renderer.addClass(this.el.nativeElement, "po-table-column-fixed");
      }
      const filterRow = this.el.nativeElement.parentElement.nextElementSibling;
      if (filterRow) {
        const index = this.index(this.el.nativeElement);
        if (filterRow.children && filterRow.children[index]) {
          filterRow.children[index].style.left = this.el.nativeElement.style.left;
          filterRow.children[index].style.right = this.el.nativeElement.style.right;
        }
      }
    }
  }
  /* istanbul ignore next */
  resizeColumns() {
    const currentElement = this.el.nativeElement;
    const prevElements = [];
    let prevElement = currentElement.previousElementSibling;
    while (prevElement && prevElement.classList.contains("po-table-column-fixed")) {
      prevElements.push(prevElement);
      prevElement = prevElement.previousElementSibling;
    }
    if (prevElements.length >= 2) {
      let leftAccumulator = 0;
      for (let i = prevElements.length - 1; i >= 0; i--) {
        const prevWidth = this.getOuterWidth(prevElements[i], true);
        prevElements[i].style.left = leftAccumulator - 1 + "px";
        leftAccumulator += prevWidth;
      }
    }
  }
  getOuterWidth(el, margin) {
    let width = el.offsetWidth;
    if (margin) {
      const style2 = getComputedStyle(el);
      width += parseFloat(style2.marginLeft) + parseFloat(style2.marginRight);
    }
    return width - 1;
  }
  index(element) {
    const children = element.parentNode.childNodes;
    let num = 0;
    for (let i = 0; i < children.length; i++) {
      if (children[i] === element) {
        return num;
      }
      if (children[i].nodeType === 1) {
        num++;
      }
    }
    return -1;
  }
  static ɵfac = function PoTableColumnFrozenDirective_Factory(t) {
    return new (t || _PoTableColumnFrozenDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTableColumnFrozenDirective, selectors: [["", "pFrozenColumn", ""]], hostAttrs: [1, "p-element"], hostVars: 2, hostBindings: function PoTableColumnFrozenDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("po-frozen-column", ctx.frozen);
    }
  }, inputs: { frozen: [InputFlags.None, "pFrozenColumn", "frozen"], alignFrozen: "alignFrozen" }, features: [ɵɵNgOnChangesFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableColumnFrozenDirective, [{
    type: Directive,
    args: [{
      selector: "[pFrozenColumn]",
      host: {
        class: "p-element",
        "[class.po-frozen-column]": "frozen"
      }
    }]
  }], () => [{ type: ElementRef }, { type: Renderer2 }], { frozen: [{
    type: Input,
    args: ["pFrozenColumn"]
  }], alignFrozen: [{
    type: Input
  }] });
})();
var PoComboFilterMode;
(function(PoComboFilterMode2) {
  PoComboFilterMode2[PoComboFilterMode2["startsWith"] = 0] = "startsWith";
  PoComboFilterMode2[PoComboFilterMode2["contains"] = 1] = "contains";
  PoComboFilterMode2[PoComboFilterMode2["endsWith"] = 2] = "endsWith";
})(PoComboFilterMode || (PoComboFilterMode = {}));
var PoComboOptionTemplateDirective = class _PoComboOptionTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoComboOptionTemplateDirective_Factory(t) {
    return new (t || _PoComboOptionTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoComboOptionTemplateDirective, selectors: [["", "p-combo-option-template", ""]] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboOptionTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-combo-option-template]"
    }]
  }], () => [{ type: TemplateRef }], null);
})();
var poComboLiteralsDefault = {
  en: {
    noData: "No data found",
    chooseOption: "Choose an option",
    clear: "Clear"
  },
  es: {
    noData: "Datos no encontrados",
    chooseOption: "Elija una opción",
    clear: "limpia"
  },
  pt: {
    noData: "Nenhum dado encontrado",
    chooseOption: "Escolha uma opção",
    clear: "Apagar"
  },
  ru: {
    noData: "Данные не найдены",
    chooseOption: "Выберите опцию",
    clear: "чистый"
  }
};
var PO_COMBO_DEBOUNCE_TIME_DEFAULT = 400;
var PO_COMBO_FIELD_LABEL_DEFAULT = "label";
var PO_COMBO_FIELD_VALUE_DEFAULT = "value";
var PoComboBaseComponent = class _PoComboBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Label no componente. */
  label;
  /** Texto de apoio para o campo. */
  help;
  /** Nome do componente. */
  name;
  /**
   * @optional
   *
   * @description
   * Nesta propriedade deve ser informada a URL do serviço em que será realizado o filtro para carregamento da lista de
   * itens no componente.
   * Caso haja a necessidade de customização, então pode ser informado um serviço implementando a interface PoComboFilter.
   *
   * Caso utilizado uma URL, o serviço deve ser retornado no padrão API TOTVS e utiliza as propriedades
   * `p-field-label` e `p-field-value` para a construção da lista de itens.
   *
   * Quando utilizada uma URL de serviço, então será concatenada nesta URL o valor que deseja-se filtrar da seguinte forma:
   * ```
   * url + ?filter=Peter
   * ```
   *
   * Se for definida a propriedade `p-filter-params`, a mesma também será concatenada. Por exemplo, para o
   * parâmetro `{ age: 23 }` a URL ficaria:
   *
   * ```
   * url + ?page=1&pageSize=20&age=23&filter=Peter
   * ```
   */
  filterService;
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro ativa a funcionalidade de scroll infinito para o combo, Ao chegar ao fim da tabela executará nova busca dos dados conforme paginação.
   *
   * @default `false`
   */
  set infiniteScroll(value) {
    this._infiniteScroll = convertToBoolean(value);
  }
  get infiniteScroll() {
    return this._infiniteScroll;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o percentual necessário para disparar o evento `show-more`, que é responsável por carregar mais dados no combo. Caso o valor seja maior que 100 ou menor que 0, o valor padrão será 100%.
   *
   * **Exemplos**
   * - p-infinite-scroll-distance = 80: Quando atingir 80% do scroll do combo, o `show-more` será disparado.
   */
  set infiniteScrollDistance(value) {
    this._infiniteScrollDistance = value > 100 || value < 0 ? 100 : value;
  }
  get infiniteScrollDistance() {
    return this._infiniteScrollDistance;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o ícone que será exibido no início do campo.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-combo p-icon="po-icon-user" p-label="PO combo"></po-combo>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-combo p-icon="fa fa-podcast" p-label="PO combo"></po-combo>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-combo [p-icon]="template" p-label="combo template ionic"></po-combo>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /** Se verdadeiro, o campo receberá um botão para ser limpo. */
  clean;
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro, o evento `p-change` receberá como argumento o `PoComboOption` referente à opção selecionada.
   *
   * @default `false`
   */
  emitObjectValue = false;
  /**
   * @optional
   *
   * @description
   *
   * Se verdadeiro, desabilitará a busca de um item via TAB.
   *
   * @default `false`
   */
  disabledTabFilter = false;
  /**
   * @optional
   *
   * @description
   *
   * Define que o filtro no primeiro clique será removido.
   *
   * > Caso o combo tenha um valor padrão de inicialização, o primeiro clique
   * no componente retornará todos os itens da lista e não apenas o item inicialiazado.
   *
   * @default `false`
   */
  removeInitialFilter = false;
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informada uma função que será disparada quando houver alterações no ngModel. A função receberá como argumento o model modificado.
   *
   * > Pode-se optar pelo recebimento do objeto selecionado ao invés do model através da propriedade `p-emit-object-value`.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-combo ... [ngModel]="comboModel" (ngModelChange)="comboModel = $event"> </po-combo>
   * ```
   *
   */
  ngModelChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informada uma função que será disparada quando houver alterações no Search input. A função receberá como argumento o input modificado.
   *
   */
  inputChange = new EventEmitter();
  cacheOptions = [];
  defaultService;
  firstInWriteValue = true;
  isFirstFilter = true;
  isFiltering = false;
  keyupSubscribe;
  onModelChange;
  previousSearchValue = "";
  selectedOption;
  selectedValue;
  selectedView;
  service;
  visibleOptions = [];
  page = 1;
  pageSize = 10;
  loading = false;
  dynamicLabel = "label";
  dynamicValue = "value";
  cacheStaticOptions = [];
  comboOptionsList = [];
  onModelTouched = null;
  _changeOnEnter = false;
  _debounceTime = 400;
  _disabled = false;
  _disabledInitFilter = false;
  _fieldLabel = "label";
  _fieldValue = "value";
  _filterMinlength = 0;
  _filterMode = PoComboFilterMode.startsWith;
  _filterParams;
  _literals;
  _options = [];
  _placeholder = "";
  _required = false;
  _sort = false;
  language;
  _infiniteScrollDistance = 100;
  _infiniteScroll = false;
  // utilizado para fazer o controle de atualizar o model.
  // não deve forçar a atualização se o gatilho for o writeValue para não deixar o campo dirty.
  fromWriteValue = false;
  validatorChange;
  /** Mensagem apresentada enquanto o campo estiver vazio. */
  set placeholder(value) {
    this._placeholder = value || this.literals.chooseOption;
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @optional
   *
   * @description
   * Esta propriedade define em quanto tempo (em milissegundos), aguarda para acionar o evento de filtro após cada pressionamento de tecla.
   * Será utilizada apenas quando houver serviço (`p-filter-service`).
   *
   * @default `400`
   */
  set debounceTime(value) {
    const parsedValue = parseInt(value, 10);
    this._debounceTime = !isNaN(parsedValue) && parsedValue > 0 ? parsedValue : PO_COMBO_DEBOUNCE_TIME_DEFAULT;
  }
  get debounceTime() {
    return this._debounceTime;
  }
  /**
   * @optional
   *
   * @description
   * Desabilita o filtro inicial no serviço, que é executado no primeiro clique no campo.
   *
   * @default `false`
   *
   */
  set disabledInitFilter(value) {
    this._disabledInitFilter = convertToBoolean(value);
  }
  get disabledInitFilter() {
    return this._disabledInitFilter;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo valor de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * PoComboOption.
   *
   * @default `value`
   */
  set fieldValue(value) {
    if (!this.service && !this.filterService) {
      this.dynamicValue = value;
    }
    this._fieldValue = value || PO_COMBO_FIELD_VALUE_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldValue = this._fieldValue;
    }
  }
  get fieldValue() {
    return this._fieldValue;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * PoComboOption.
   *
   * @default `label`
   */
  set fieldLabel(value) {
    if (!this.service && !this.filterService) {
      this.dynamicLabel = value;
    }
    this._fieldLabel = value || PO_COMBO_FIELD_LABEL_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldLabel = this._fieldLabel;
    }
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /**
   * @optional
   *
   * @description
   * Valor mínimo de caracteres para realizar o filtro no serviço.
   *
   * @default `0`
   */
  set filterMinlength(value) {
    const parseValue = typeof value === "string" ? parseInt(value, 10) : value;
    this._filterMinlength = Number.isInteger(parseValue) ? parseValue : 0;
  }
  get filterMinlength() {
    return this._filterMinlength;
  }
  /**
   * @optional
   *
   * @description
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.selectedValue);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   * Indica que o evento `p-change` só será disparado ao clicar ou pressionar a tecla "Enter" sobre uma opção selecionada.
   *
   * @default `false`
   */
  set changeOnEnter(changeOnEnter) {
    this._changeOnEnter = convertToBoolean(changeOnEnter);
  }
  get changeOnEnter() {
    return this._changeOnEnter;
  }
  /**
   * @optional
   *
   * @description
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
    this.validateModel(this.selectedValue);
  }
  get disabled() {
    return this._disabled;
  }
  /** Indica que a lista definida na propriedade p-options será ordenada pela descrição. */
  set sort(sort) {
    this._sort = convertToBoolean(sort);
    this.comboListDefinitions();
  }
  get sort() {
    return this._sort;
  }
  /**
   * Nesta propriedade define a lista de opções do `po-combo`.
   *
   * > A lista pode ser definida utilizando um array com o valor representando o `value` e o `label` das seguintes formas:
   *
   * ```
   * <po-combo name="combo" p-label="PO Combo" [p-options]="[{value: 1, label: 'One'}, {value: 2, label: 'two'}]"> </po-combo>
   * ```
   *
   * ```
   * <po-combo name="combo" p-label="PO Combo" [p-options]="[{name: 'Roger', age: 28}, {name: 'Anne', age: 35}]" p-field-label="name" p-field-value="age"> </po-combo>
   * ```
   *
   * - Aconselha-se utilizar valores distintos no `label` e `value` dos itens.
   */
  set options(options) {
    this._options = Array.isArray(options) ? options : [];
    this.comboListDefinitions();
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no filtro da lista de seleção: `startsWith`, `contains` ou `endsWith`.
   *
   * > Quando utilizar a propriedade `p-filter-service` esta propriedade será ignorada.
   *
   * @default `startsWith`
   */
  set filterMode(filterMode) {
    this._filterMode = filterMode in PoComboFilterMode ? filterMode : PoComboFilterMode.startsWith;
    switch (this._filterMode.toString()) {
      case "startsWith":
        this._filterMode = PoComboFilterMode.startsWith;
        break;
      case "contains":
        this._filterMode = PoComboFilterMode.contains;
        break;
      case "endsWith":
        this._filterMode = PoComboFilterMode.endsWith;
        break;
    }
  }
  get filterMode() {
    return this._filterMode;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor que será repassado como parâmetro para a URL ou aos métodos do serviço que implementam a interface *PoComboFilter*.
   *
   * > Caso a lista contenha agrupamentos, os mesmos só serão exibidos se houver no mínimo uma opção que corresponda à pesquisa.
   */
  set filterParams(filterParams) {
    this._filterParams = filterParams || filterParams === 0 || filterParams === false ? filterParams : void 0;
  }
  get filterParams() {
    return this._filterParams;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-combo`.
   *
   * Para utilizar basta passar a literal que deseja customizar:
   *
   * ```
   *  const customLiterals: PoComboLiterals = {
   *    noData: 'Nenhum valor'
   *  };
   * ```
   *
   * E para carregar a literal customizada, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-combo
   *   [p-literals]="customLiterals">
   * </po-combo>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poComboLiteralsDefault[poLocaleDefault]), poComboLiteralsDefault[this.language]), value);
    } else {
      this._literals = poComboLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poComboLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se o componente irá guardar o valor do model para evitar requisições repetidas.
   *
   * > Caso o valor seja `false`, o componente fará uma nova requisição mesmo que o valor procurado seja o mesmo do model.
   *
   * @default `true`
   */
  cache = true;
  /**
   * @optional
   *
   * @description
   *
   * Define que o dropdown do combo será incluido no body da página e não suspenso com a caixa de texto do componente.
   * Opção necessária para o caso de uso do componente em páginas que necessitam renderizar o combo fora do conteúdo principal.
   *
   * > Obs: O uso dessa propriedade pode acarretar na perda sequencial da tabulação da página
   *
   * @default `false`
   */
  appendBox = false;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  get isOptionGroupList() {
    return this._options.length && this._options[0].hasOwnProperty("options");
  }
  ngOnInit() {
    this.dynamicValue = this.checkIfService("value");
    this.dynamicLabel = this.checkIfService("label");
    this.updateComboList();
  }
  onInitService() {
    if (this.filterService) {
      this.setService(this.filterService);
      this.initInputObservable();
    }
  }
  setService(service) {
    if (service) {
      if (isTypeof(service, "object")) {
        this.service = service;
      } else {
        this.service = this.defaultService;
        this.service.configProperties(service, this.fieldLabel, this.fieldValue);
      }
    }
  }
  compareMethod(search, option, filterMode) {
    switch (filterMode) {
      case PoComboFilterMode.startsWith:
        return this.startsWith(search, option);
      case PoComboFilterMode.contains:
        return this.contains(search, option);
      case PoComboFilterMode.endsWith:
        return this.endsWith(search, option);
    }
  }
  startsWith(search, option) {
    return option[this.dynamicLabel].toLowerCase().startsWith(search.toLowerCase());
  }
  contains(search, option) {
    return option[this.dynamicLabel].toLowerCase().indexOf(search.toLowerCase()) > -1;
  }
  endsWith(search, option) {
    return option[this.dynamicLabel].toLowerCase().endsWith(search.toLowerCase());
  }
  getOptionFromValue(value, options) {
    return options ? options.find((option) => this.isEqual(option[this.dynamicValue], value)) : null;
  }
  getOptionFromLabel(label, options) {
    if (options) {
      return options.find((option) => option[this.dynamicLabel].toString().toLowerCase() === label.toString().toLowerCase());
    } else {
      return null;
    }
  }
  updateSelectedValue(option, isUpdateModel = true) {
    const optionLabel = option && option[this.dynamicLabel] || "";
    this.updateInternalVariables(option);
    if (this.changeOnEnter && isUpdateModel) {
      this.setInputValue(optionLabel);
    } else if (!this.changeOnEnter) {
      this.setInputValue(optionLabel);
    }
    if (isUpdateModel) {
      const optionValue = option?.[this.dynamicValue] !== void 0 ? option[this.dynamicValue] : void 0;
      this.updateModel(optionValue);
    }
  }
  callModelChange(value) {
    return this.onModelChange ? this.onModelChange(value) : this.ngModelChange.emit(value);
  }
  isEqual(value, inputValue) {
    if ((value || value === 0) && inputValue) {
      return value.toString() === inputValue.toString();
    }
    if (value === null && inputValue !== null || value === void 0 && inputValue !== void 0) {
      value = `${value}`;
    }
    return value === inputValue;
  }
  searchForLabel(search, options, filterMode) {
    if (search && options && options.length) {
      const newOptions = [];
      let addedOptionsGroupTitle = false;
      let optionsGroupTitle;
      options.forEach((option) => {
        if ("options" in option) {
          addedOptionsGroupTitle = false;
          return optionsGroupTitle = option;
        }
        if (option[this.dynamicLabel] && (this.compareMethod(search, option, filterMode) || this.service)) {
          if (this.isOptionGroupList && !addedOptionsGroupTitle) {
            newOptions.push(optionsGroupTitle);
            addedOptionsGroupTitle = true;
          }
          newOptions.push(option);
        }
      });
      this.selectedView = newOptions[this.isOptionGroupList ? 1 : 0];
      this.updateComboList(newOptions);
    } else {
      this.updateComboList();
    }
  }
  updateComboList(options) {
    const copyOptions = options || [...this.comboOptionsList];
    let newOptions;
    if (this.removeInitialFilter) {
      newOptions = copyOptions;
    } else {
      newOptions = !options && !this.infiniteScroll && this.selectedValue ? [__spreadValues({}, this.selectedOption)] : copyOptions;
    }
    this.visibleOptions = newOptions;
    if (!this.selectedView && this.visibleOptions.length) {
      this.selectedView = copyOptions.find((option) => option[this.dynamicValue] !== void 0);
    }
  }
  getNextOption(value, options, reverse = false) {
    const optionsList = reverse ? options.slice(0).reverse() : options.slice(0);
    let optionFound = null;
    let found = false;
    for (const option of optionsList) {
      if (option[this.dynamicValue] && !optionFound) {
        optionFound = option;
      }
      if (option[this.dynamicValue] && found) {
        return option;
      }
      if (this.isEqual(option[this.dynamicValue], value)) {
        found = true;
      }
    }
    return optionFound;
  }
  getIndexSelectedView() {
    for (let i = 0; i < this.visibleOptions.length; i++) {
      if (this.compareObjects(this.visibleOptions[i], this.selectedView)) {
        return i;
      }
    }
    return null;
  }
  compareObjects(obj1, obj2) {
    return JSON.stringify(obj1) === JSON.stringify(obj2);
  }
  verifyValidOption() {
    const inputValue = this.getInputValue();
    const optionFound = this.getOptionFromLabel(inputValue, this.comboOptionsList);
    if (!this.service) {
      this.updateComboList([...this.cacheStaticOptions]);
    }
    if (optionFound && optionFound[this.dynamicValue] !== this.selectedValue) {
      this.updateSelectedValue(optionFound);
      this.previousSearchValue = optionFound[this.dynamicLabel];
    } else if (this.selectedValue && this.selectedOption && this.selectedOption[this.dynamicLabel] !== inputValue) {
      this.updateSelectedValueWithOldOption();
      this.previousSearchValue = this.selectedOption[this.dynamicLabel];
      return;
    } else if (inputValue && !optionFound) {
      const isInputValueDiffSelectedLabel = !!(this.selectedOption && this.selectedOption[this.dynamicLabel] !== inputValue);
      this.updateSelectedValue(null, isInputValueDiffSelectedLabel || this.changeOnEnter);
      this.previousSearchValue = "";
      return;
    }
  }
  // Recebe as alterações do model
  writeValue(value) {
    this.fromWriteValue = true;
    if (validValue(value) && !this.service && this.comboOptionsList && this.comboOptionsList.length) {
      const option = this.getOptionFromValue(value, this.comboOptionsList);
      this.updateSelectedValue(option);
      this.updateComboList();
      this.removeInitialFilter = false;
      return;
    }
    if (value && this.service) {
      return this.getObjectByValue(value);
    } else {
      this.updateSelectedValue(null);
      this.updateComboList();
      this.updateHasNext();
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  clear(value) {
    this.callModelChange(value);
    this.updateSelectedValue(null);
    this.updateComboList();
    this.initInputObservable();
    this.updateHasNext();
    if (this.service || this.filterService) {
      this.keyupSubscribe.unsubscribe();
    }
  }
  configAfterSetFilterService(service) {
    if (service) {
      this.comboOptionsList = [];
      this.unsubscribeKeyupObservable();
      this.onInitService();
    } else {
      this.service = void 0;
      this.comboOptionsList = this.cacheStaticOptions;
    }
    this.visibleOptions = [];
    this.isFirstFilter = true;
  }
  unsubscribeKeyupObservable() {
    if (this.keyupSubscribe) {
      this.keyupSubscribe.unsubscribe();
    }
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  comboListDefinitions() {
    this.comboOptionsList = this.options.length > 0 ? this.listingComboOptions(this.options) : this.options;
    this.cacheStaticOptions = this.comboOptionsList;
    this.updateComboList();
  }
  checkIfService(dynamicValue) {
    if ((this.service || this.filterService) && dynamicValue === "label") {
      return PO_COMBO_FIELD_LABEL_DEFAULT;
    }
    if ((this.service || this.filterService) && dynamicValue === "value") {
      return PO_COMBO_FIELD_VALUE_DEFAULT;
    }
    if (!this.service && dynamicValue === "label") {
      return this.fieldLabel;
    }
    if (!this.service && dynamicValue === "value") {
      return this.fieldValue;
    }
  }
  compareOptions(dynamicLabel) {
    return function(optionA, optionB) {
      const labelA = optionA[dynamicLabel].toString().toLowerCase();
      const labelB = optionB[dynamicLabel].toString().toLowerCase();
      return labelA < labelB ? -1 : labelA > labelB ? 1 : 0;
    };
  }
  hasDuplicatedOption(options, currentOption, accumulatedGroupOptions) {
    if (accumulatedGroupOptions) {
      return accumulatedGroupOptions.some((option) => option[this.dynamicLabel] === currentOption);
    } else {
      return options.some((option) => option[this.dynamicValue] === currentOption);
    }
  }
  listingComboOptions(comboOptions) {
    const comboOptionsList = comboOptions.concat();
    const verifiedComboOptionsList = this.verifyComboOptions(comboOptionsList);
    this.sortOptions(verifiedComboOptionsList);
    if (this.isOptionGroupList && verifiedComboOptionsList.length > 0) {
      return this.verifyComboOptionsGroup(verifiedComboOptionsList);
    }
    return verifiedComboOptionsList;
  }
  sortOptions(comboOptionsList) {
    if (comboOptionsList.length > 0 && this.sort) {
      return comboOptionsList.sort(this.compareOptions(this.dynamicLabel));
    }
  }
  validateValue(currentOption, verifyingOptionsGroup = false) {
    const { options } = currentOption;
    if (this.isOptionGroupList) {
      return validValue(currentOption[this.dynamicLabel]) && options && options.length > 0 || verifyingOptionsGroup === true && validValue(currentOption[this.dynamicValue]);
    }
    return validValue(currentOption[this.dynamicValue]) && !options;
  }
  verifyComboOptions(comboOptions, verifyingOptionsGroup = false, accumulatedGroupOptions) {
    return comboOptions.reduce((accumulatedOptions, currentOption) => {
      if (!this.verifyIfHasLabel(currentOption) || this.hasDuplicatedOption(accumulatedOptions, currentOption[this.dynamicValue] || currentOption[this.dynamicLabel], accumulatedGroupOptions) || !this.validateValue(currentOption, verifyingOptionsGroup)) {
        return accumulatedOptions;
      }
      accumulatedOptions.push(currentOption);
      return accumulatedOptions;
    }, []);
  }
  verifyComboOptionsGroup(comboOptionsList) {
    return comboOptionsList.reduce((accumulatedGroupOptions, currentOption) => {
      const { options } = currentOption;
      const verifiedComboOptionsGroupList = this.verifyComboOptions(options, true, accumulatedGroupOptions);
      if (verifiedComboOptionsGroupList.length > 0) {
        this.sortOptions(verifiedComboOptionsGroupList);
        accumulatedGroupOptions.push({ label: currentOption[this.dynamicLabel], options: true }, ...verifiedComboOptionsGroupList);
      }
      return accumulatedGroupOptions;
    }, []);
  }
  verifyIfHasLabel(currentOption = {}) {
    const { options } = currentOption;
    if (this.isOptionGroupList && options && !currentOption[this.dynamicLabel] || !currentOption[this.dynamicLabel] && !currentOption[this.dynamicValue] || !this.isOptionGroupList && options) {
      return false;
    }
    if (!currentOption[this.dynamicLabel]) {
      currentOption[this.dynamicLabel] = currentOption[this.dynamicValue].toString();
      return true;
    }
    return true;
  }
  updateInternalVariables(option) {
    if (option) {
      this.selectedView = option;
      this.selectedOption = option;
    } else {
      this.selectedView = void 0;
      this.selectedOption = void 0;
    }
  }
  updateModel(value) {
    if (value !== this.selectedValue) {
      if (!this.fromWriteValue) {
        this.callModelChange(value);
      }
      this.change.emit(this.emitObjectValue ? this.selectedOption : value);
    }
    this.selectedValue = value;
    this.fromWriteValue = false;
  }
  updateSelectedValueWithOldOption() {
    const oldOption = this.getOptionFromValue(this.selectedValue, this.comboOptionsList);
    if (oldOption && oldOption[this.dynamicLabel]) {
      return this.updateSelectedValue(oldOption);
    }
  }
  updateHasNext() {
    if (this.service && this.infiniteScroll) {
      this.defaultService.hasNext = true;
    }
  }
  static ɵfac = function PoComboBaseComponent_Factory(t) {
    return new (t || _PoComboBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoComboBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"], name: "name", filterService: [InputFlags.None, "p-filter-service", "filterService"], infiniteScroll: [InputFlags.None, "p-infinite-scroll", "infiniteScroll"], infiniteScrollDistance: [InputFlags.None, "p-infinite-scroll-distance", "infiniteScrollDistance"], icon: [InputFlags.None, "p-icon", "icon"], optional: [InputFlags.None, "p-optional", "optional"], clean: [InputFlags.HasDecoratorInputTransform, "p-clean", "clean", convertToBoolean], emitObjectValue: [InputFlags.HasDecoratorInputTransform, "p-emit-object-value", "emitObjectValue", convertToBoolean], disabledTabFilter: [InputFlags.HasDecoratorInputTransform, "p-disabled-tab-filter", "disabledTabFilter", convertToBoolean], removeInitialFilter: [InputFlags.None, "p-remove-initial-filter", "removeInitialFilter"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], debounceTime: [InputFlags.None, "p-debounce-time", "debounceTime"], disabledInitFilter: [InputFlags.None, "p-disabled-init-filter", "disabledInitFilter"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], filterMinlength: [InputFlags.None, "p-filter-minlength", "filterMinlength"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], changeOnEnter: [InputFlags.None, "p-change-on-enter", "changeOnEnter"], disabled: [InputFlags.None, "p-disabled", "disabled"], sort: [InputFlags.None, "p-sort", "sort"], options: [InputFlags.None, "p-options", "options"], filterMode: [InputFlags.None, "p-filter-mode", "filterMode"], filterParams: [InputFlags.None, "p-filter-params", "filterParams"], literals: [InputFlags.None, "p-literals", "literals"], cache: [InputFlags.HasDecoratorInputTransform, "p-cache", "cache", convertToBoolean], appendBox: [InputFlags.HasDecoratorInputTransform, "p-append-in-body", "appendBox", convertToBoolean] }, outputs: { change: "p-change", ngModelChange: "ngModelChange", inputChange: "p-input-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], filterService: [{
    type: Input,
    args: ["p-filter-service"]
  }], infiniteScroll: [{
    type: Input,
    args: ["p-infinite-scroll"]
  }], infiniteScrollDistance: [{
    type: Input,
    args: ["p-infinite-scroll-distance"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], clean: [{
    type: Input,
    args: [{ alias: "p-clean", transform: convertToBoolean }]
  }], emitObjectValue: [{
    type: Input,
    args: [{ alias: "p-emit-object-value", transform: convertToBoolean }]
  }], disabledTabFilter: [{
    type: Input,
    args: [{ alias: "p-disabled-tab-filter", transform: convertToBoolean }]
  }], removeInitialFilter: [{
    type: Input,
    args: ["p-remove-initial-filter"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], ngModelChange: [{
    type: Output,
    args: ["ngModelChange"]
  }], inputChange: [{
    type: Output,
    args: ["p-input-change"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], debounceTime: [{
    type: Input,
    args: ["p-debounce-time"]
  }], disabledInitFilter: [{
    type: Input,
    args: ["p-disabled-init-filter"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], filterMinlength: [{
    type: Input,
    args: ["p-filter-minlength"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], changeOnEnter: [{
    type: Input,
    args: ["p-change-on-enter"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], sort: [{
    type: Input,
    args: ["p-sort"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], filterMode: [{
    type: Input,
    args: ["p-filter-mode"]
  }], filterParams: [{
    type: Input,
    args: ["p-filter-params"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], cache: [{
    type: Input,
    args: [{ alias: "p-cache", transform: convertToBoolean }]
  }], appendBox: [{
    type: Input,
    args: [{ alias: "p-append-in-body", transform: convertToBoolean }]
  }] });
})();
var PoComboFilterService = class _PoComboFilterService {
  http;
  fieldLabel = "label";
  fieldValue = "value";
  hasNext = true;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  _url;
  messages = [];
  get url() {
    return this._url;
  }
  constructor(http) {
    this.http = http;
  }
  getFilteredData(param, filterParams) {
    const params = this.prepareParams(param, filterParams);
    return this.http.get(`${this.url}`, { responseType: "json", params, headers: this.headers }).pipe(tap((res) => this.hasNext = res["hasNext"]), map((response) => this.parseToArrayComboOption(response.items)));
  }
  getObjectByValue(value, filterParams) {
    const filterParamsValidated = validateObjectType(filterParams);
    return this.http.get(`${this.url}/${value}`, { params: filterParamsValidated, headers: this.headers }).pipe(map((item) => this.parseToComboOption(item)));
  }
  configProperties(url, fieldLabel, fieldValue) {
    this._url = url;
    this.fieldLabel = fieldLabel;
    this.fieldValue = fieldValue;
  }
  scrollListener(componentListner) {
    return fromEvent(componentListner, "scroll").pipe(debounceTime(100));
  }
  prepareParams(param, filterParams) {
    const { page, pageSize, value } = param;
    const filterParamsValidated = validateObjectType(filterParams);
    return page ? __spreadProps(__spreadValues({}, filterParamsValidated), { page, pageSize, filter: value }) : __spreadProps(__spreadValues({}, filterParamsValidated), { filter: value });
  }
  parseToArrayComboOption(items) {
    if (items && items.length > 0) {
      const parsedOptions = items.map((item) => this.parseToComboOption(item));
      this.displayMessages();
      return parsedOptions;
    }
    return [];
  }
  parseToComboOption(item) {
    if (!item?.[this.fieldValue]) {
      this.addMessage(item, this.fieldValue);
      return { value: "" };
    }
    const label = item[this.fieldLabel];
    const value = item[this.fieldValue];
    return { label, value };
  }
  addMessage(item, property) {
    this.messages.push(`Cannot read property "${property}" of ${JSON.stringify(item)},
      see [p-field-value] property at https://po-ui.io/documentation/po-combo`);
  }
  displayMessages() {
    if (this.messages.length) {
      this.messages.forEach((message) => console.error(message));
      this.messages = [];
    }
  }
  static ɵfac = function PoComboFilterService_Factory(t) {
    return new (t || _PoComboFilterService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoComboFilterService, factory: _PoComboFilterService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboFilterService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var _c0$U = ["containerElement"];
var _c1$m = ["contentElement"];
var _c2$a = ["iconArrow"];
var _c3$5 = ["inp"];
var _c4$2 = ["poListbox"];
function PoComboComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵelement(1, "po-icon", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r1.disabled);
    ɵɵproperty("p-icon", ctx_r1.icon);
  }
}
function PoComboComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("click", function PoComboComponent_div_7_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext();
      ctx_r12.clear(null);
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function PoComboComponent_div_7_Template_div_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r14 = ɵɵnextContext();
      ctx_r14.clearAndFocus();
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "span", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r3.literals.clean);
    ɵɵadvance();
    ɵɵclassProp("po-border-focused", !ctx_r3.disabled && ctx_r3.comboOpen);
  }
}
function PoComboComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoComboComponent_ng_template_11_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoComboComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoComboComponent_ng_template_11_ng_container_0_Template, 1, 0, "ng-container", 19);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r11 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", _r11);
  }
}
function PoComboComponent_ng_template_13_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoComboComponent_ng_template_13_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoComboComponent_ng_template_13_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 19);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r11 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", _r11);
  }
}
function PoComboComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoComboComponent_ng_template_13_ng_template_0_Template, 1, 1, "ng-template", 20);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r0 = ɵɵreference(2);
    ɵɵproperty("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayOpen", true);
  }
}
function PoComboComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 21, 22)(2, "po-listbox", 23, 24);
    ɵɵlistener("p-selectcombo-item", function PoComboComponent_ng_template_16_Template_po_listbox_p_selectcombo_item_2_listener($event) {
      ɵɵrestoreView(_r22);
      const ctx_r21 = ɵɵnextContext();
      return ɵɵresetView(ctx_r21.onOptionClick($event, $event.event));
    })("p-update-infinite-scroll", function PoComboComponent_ng_template_16_Template_po_listbox_p_update_infinite_scroll_2_listener() {
      ɵɵrestoreView(_r22);
      const ctx_r23 = ɵɵnextContext();
      return ɵɵresetView(ctx_r23.showMoreInfiniteScroll());
    })("p-close", function PoComboComponent_ng_template_16_Template_po_listbox_p_close_2_listener() {
      ɵɵrestoreView(_r22);
      const ctx_r24 = ɵɵnextContext();
      return ɵɵresetView(ctx_r24.onCloseCombo());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext();
    ɵɵproperty("hidden", !ctx_r10.comboOpen && !ctx_r10.isServerSearching);
    ɵɵadvance(2);
    ɵɵproperty("p-items", ctx_r10.visibleOptions)("p-field-value", ctx_r10.dynamicValue)("p-field-label", ctx_r10.dynamicLabel)("p-template", ctx_r10.comboOptionTemplate)("p-search-value", ctx_r10.getInputValue())("p-infinite-loading", ctx_r10.infiniteLoading)("p-infinite-scroll", ctx_r10.infiniteScroll)("p-filtering", ctx_r10.isFiltering)("p-cache", ctx_r10.cache)("p-filter-mode", ctx_r10.filterMode)("p-visible", ctx_r10.comboOpen)("p-is-searching", ctx_r10.isServerSearching)("p-should-mark-letter", ctx_r10.shouldMarkLetters)("p-compare-cache", ctx_r10.compareObjects(ctx_r10.cacheOptions, ctx_r10.visibleOptions))("p-combo-service", ctx_r10.service)("p-infinite-scroll-distance", ctx_r10.infiniteScrollDistance);
  }
}
var poComboContainerOffset = 8;
var poComboContainerPositionDefault = "bottom";
var PoComboComponent = class _PoComboComponent extends PoComboBaseComponent {
  element;
  differs;
  defaultService;
  renderer;
  changeDetector;
  controlPosition;
  comboOptionTemplate;
  containerElement;
  contentElement;
  iconElement;
  inputEl;
  poListbox;
  comboIcon = "po-icon-arrow-down";
  comboOpen = false;
  differ;
  id = `po-combo[${uuid()}]`;
  isProcessingValueByTab = false;
  scrollTop = 0;
  shouldMarkLetters = true;
  infiniteLoading = false;
  _isServerSearching = false;
  lastKey;
  clickoutListener;
  eventResizeListener;
  filterSubscription;
  getSubscription;
  subscriptionScrollEvent;
  constructor(element, differs, defaultService, renderer, changeDetector, controlPosition, languageService) {
    super(languageService);
    this.element = element;
    this.differs = differs;
    this.defaultService = defaultService;
    this.renderer = renderer;
    this.changeDetector = changeDetector;
    this.controlPosition = controlPosition;
    this.differ = differs.find([]).create(null);
  }
  set isServerSearching(value) {
    if (value) {
      this._isServerSearching = value;
      this.changeDetector.detectChanges();
      this.setContainerPosition();
      this.initializeListeners();
    } else {
      this._isServerSearching = value;
    }
  }
  get isServerSearching() {
    return this._isServerSearching;
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  ngOnChanges(changes) {
    if (changes.debounceTime) {
      this.unsubscribeKeyupObservable();
      this.initInputObservable();
    }
    if (changes.filterService) {
      this.configAfterSetFilterService(this.filterService);
    }
  }
  ngOnDestroy() {
    this.removeListeners();
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.getSubscription) {
      this.getSubscription.unsubscribe();
    }
    if (this.infiniteScroll) {
      this.subscriptionScrollEvent?.unsubscribe();
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoComboComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoComboComponent, { static: true }) combo: PoComboComponent;
   *
   * focusCombo() {
   *   this.combo.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  onBlur() {
    this.onModelTouched?.();
  }
  onKeyDown(event) {
    const key = event.keyCode;
    const inputValue = event.target.value;
    if (event.shiftKey && key === PoKeyCodeEnum.tab) {
      this.controlComboVisibility(false);
      return;
    }
    if (this.service && key === PoKeyCodeEnum.tab && inputValue && !this.disabledTabFilter) {
      this.controlComboVisibility(false);
      return this.getObjectByValue(inputValue);
    }
    if (key === PoKeyCodeEnum.arrowDown) {
      event.preventDefault();
      if (this.visibleOptions.length) {
        this.focusItem();
      }
      this.controlComboVisibility(true);
      this.isFiltering = this.changeOnEnter ? this.isFiltering : false;
      return;
    }
    if (key === PoKeyCodeEnum.enter && this.selectedView && this.comboOpen) {
      const isUpdateModel = this.selectedView.value !== this.selectedValue || inputValue !== this.selectedView.label;
      this.controlComboVisibility(false);
      this.updateSelectedValue(this.selectedView, isUpdateModel);
      this.isFiltering = false;
      if (!this.service) {
        this.updateComboList([...this.cacheStaticOptions]);
      }
      return;
    }
    if (key === PoKeyCodeEnum.enter) {
      this.controlComboVisibility(true);
    }
    if (key === PoKeyCodeEnum.esc) {
      if (key === this.lastKey) {
        this.lastKey = "";
        if (this.selectedValue) {
          this.clearAndFocus();
        }
        return;
      } else {
        this.onCloseCombo();
      }
    }
    this.lastKey = event.keyCode;
  }
  onKeyUp(event) {
    const key = event.keyCode || event.which;
    const inputValue = event.target.value;
    const isValidKey = key !== PoKeyCodeEnum.arrowUp && key !== PoKeyCodeEnum.arrowDown && key !== PoKeyCodeEnum.enter && key !== PoKeyCodeEnum.esc && key !== PoKeyCodeEnum.tab;
    if (isValidKey) {
      if (inputValue) {
        if (!this.service && this.previousSearchValue !== inputValue) {
          this.shouldMarkLetters = true;
          this.isFiltering = true;
          this.searchForLabel(inputValue, this.comboOptionsList, this.filterMode);
          this.inputChange.emit(inputValue);
        }
      } else {
        const useDefaultOptionsService = this.service && this.selectedValue && this.selectedOption.label === this.previousSearchValue;
        this.updateSelectedValue(null);
        if (!this.service) {
          this.updateComboList();
        } else if (useDefaultOptionsService) {
          this.updateComboList([...this.cacheOptions]);
        }
        this.isFiltering = false;
      }
      if (this.previousSearchValue !== inputValue) {
        this.changeDetector.detectChanges();
        this.controlComboVisibility(true);
      }
    }
    this.previousSearchValue = inputValue;
  }
  initInputObservable() {
    if (this.service) {
      const keyupObservable = fromEvent(this.inputEl.nativeElement, "keyup").pipe(filter((e) => this.isValidCharacterToSearch(e.keyCode)), map((e) => e.currentTarget.value), distinctUntilChanged(), tap(() => {
        this.shouldMarkLetters = false;
      }), debounceTime(this.debounceTime));
      this.keyupSubscribe = keyupObservable.subscribe((value) => {
        if (value.length >= this.filterMinlength || !value) {
          this.controlApplyFilter(value);
        }
      });
    }
  }
  controlApplyFilter(value, isArrowDown) {
    if (!this.isProcessingValueByTab && (!this.selectedOption || value !== this.selectedOption[this.dynamicLabel]) || !this.cache) {
      this.defaultService.hasNext = true;
      this.page = this.setPage();
      this.options = [];
      this.applyFilter(value, true, isArrowDown);
    }
    this.isProcessingValueByTab = false;
  }
  applyFilter(value, reset = false, isArrowDown) {
    if (this.defaultService.hasNext) {
      this.controlComboVisibility(false, reset);
      this.isServerSearching = true;
      const param = this.infiniteScroll ? { property: this.fieldLabel, value, page: this.page, pageSize: this.pageSize } : { property: this.fieldLabel, value };
      this.filterSubscription = this.service.getFilteredData(param, this.filterParams).subscribe((items) => {
        this.setOptionsByApplyFilter(value, items, reset);
        if (isArrowDown) {
          this.focusItem();
        }
      }, (error) => this.onErrorFilteredData());
    }
  }
  setOptionsByApplyFilter(value, items, reset = false) {
    this.shouldMarkLetters = true;
    this.isServerSearching = false;
    this.infiniteLoading = false;
    this.options = this.prepareOptions(items);
    this.searchForLabel(value, items, this.filterMode);
    this.changeDetector.detectChanges();
    this.controlComboVisibility(true, reset);
    if (this.isFirstFilter) {
      this.isFirstFilter = !this.isFirstFilter;
      this.cacheOptions = this.comboOptionsList;
    }
  }
  getObjectByValue(value) {
    if (this.selectedValue !== value && this.selectedOption?.[this.dynamicLabel] !== value) {
      this.isProcessingValueByTab = true;
      this.getSubscription = this.service.getObjectByValue(value, this.filterParams).subscribe((item) => this.updateOptionByFilteredValue(item), (error) => this.onErrorGetObjectByValue());
    }
  }
  updateOptionByFilteredValue(item) {
    if (item) {
      this.options = [item];
      this.onOptionClick(item);
    } else {
      this.updateSelectedValue(null);
    }
    setTimeout(() => {
      this.isProcessingValueByTab = false;
    }, this.debounceTime);
  }
  toggleComboVisibility(isButton) {
    if (this.disabled) {
      return;
    }
    if (this.service && !this.disabledInitFilter) {
      this.applyFilterInFirstClick();
    }
    this.controlComboVisibility(!this.comboOpen, false, isButton);
  }
  applyFilterInFirstClick() {
    if (this.isFirstFilter && !this.selectedValue) {
      this.options = [];
      const scrollingControl = this.setScrollingControl();
      this.applyFilter("", scrollingControl);
    }
  }
  controlComboVisibility(toOpen, reset = false, isButton) {
    toOpen ? this.open(reset, isButton) : this.close(reset);
  }
  onCloseCombo() {
    this.controlComboVisibility(false);
    this.inputEl.nativeElement.focus();
  }
  onOptionClick(option, event) {
    const inputValue = this.getInputValue();
    const isUpdateModel = option[this.dynamicValue] !== this.selectedValue || !!(this.selectedView && inputValue !== this.selectedView[this.dynamicLabel]);
    if (event) {
      event.stopPropagation();
    }
    this.updateSelectedValue(option, isUpdateModel);
    this.controlComboVisibility(false);
    if (!this.service) {
      this.updateComboList([...this.cacheStaticOptions]);
    }
    this.previousSearchValue = this.selectedView[this.dynamicLabel];
    this.inputEl.nativeElement.focus();
  }
  calculateScrollTop(selectedItem, index) {
    if (!selectedItem.length || index <= 1) {
      return 0;
    } else {
      return selectedItem[0].offsetTop;
    }
  }
  getInputValue() {
    return this.inputEl.nativeElement.value;
  }
  setInputValue(value) {
    this.inputEl.nativeElement.value = value;
  }
  wasClickedOnToggle(event) {
    if (this.comboOpen && !this.inputEl.nativeElement.contains(event.target) && !this.iconElement.nativeElement.contains(event.target) && (!this.contentElement || !this.contentElement.nativeElement.contains(event.target))) {
      this.controlComboVisibility(false);
      this.verifyValidOption();
      this.selectedView = this.changeOnEnter && !this.selectedValue ? void 0 : this.selectedView;
    } else {
      if (this.service && !this.getInputValue() && !this.isFirstFilter) {
        const scrollingControl = this.setScrollingControl();
        this.applyFilter("", scrollingControl);
      }
    }
  }
  isValidCharacterToSearch(keyCode) {
    return keyCode !== 9 && // tab
    keyCode !== 13 && // entet
    keyCode !== 16 && // shift
    keyCode !== 17 && // ctrl
    keyCode !== 18 && // alt
    keyCode !== 20 && // capslock
    keyCode !== 27 && // esc
    keyCode !== 37 && // seta
    keyCode !== 38 && // seta
    keyCode !== 39 && // seta
    keyCode !== 40 && // seta
    keyCode !== 93;
  }
  searchOnEnterOrArrow(event, value) {
    if ((event.key === "ArrowDown" || event.key === "Enter") && this.service && !this.selectedView && value.length >= this.filterMinlength) {
      this.controlApplyFilter(value, event.key === "ArrowDown");
    }
  }
  showMoreInfiniteScroll() {
    if (this.defaultService.hasNext) {
      this.infiniteLoading = true;
    }
    this.page++;
    this.applyFilter("", true);
  }
  clearAndFocus() {
    this.clear(null);
    this.inputEl.nativeElement.focus();
  }
  adjustContainerPosition() {
    this.controlPosition.adjustPosition(poComboContainerPositionDefault);
  }
  close(reset) {
    this.comboOpen = false;
    if (!reset) {
      if (!this.getInputValue()) {
        this.page = this.setPage();
        this.defaultService.hasNext = true;
      }
      if (this.infiniteScroll) {
        this.options = this.setOptions();
      }
    }
    this.changeDetector.detectChanges();
    this.comboIcon = "po-icon-arrow-down";
    this.removeListeners();
    this.isFiltering = false;
    this.renderer.removeClass(this.inputEl.nativeElement, "po-combo-input-focus");
  }
  initializeListeners() {
    this.removeListeners();
    this.clickoutListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnToggle(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      setTimeout(() => this.adjustContainerPosition(), 250);
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onErrorGetObjectByValue() {
    this.updateOptionByFilteredValue(null);
  }
  onScroll = () => {
    this.adjustContainerPosition();
  };
  onErrorFilteredData() {
    this.isServerSearching = false;
    this.updateComboList([]);
    this.controlComboVisibility(true);
  }
  open(reset, isButton) {
    this.comboOpen = true;
    if (!reset && this.infiniteScroll) {
      if (!this.getInputValue()) {
        this.page = 1;
      }
      this.options = this.setOptions();
    }
    this.changeDetector.detectChanges();
    this.comboIcon = "po-icon-arrow-up";
    this.initializeListeners();
    isButton ? this.renderer.addClass(this.inputEl.nativeElement, "po-combo-input-focus") : this.inputEl.nativeElement.focus();
    this.setContainerPosition();
  }
  removeListeners() {
    if (this.clickoutListener) {
      this.clickoutListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setContainerPosition() {
    this.controlPosition.setElements(this.containerElement.nativeElement, poComboContainerOffset, this.inputEl, ["top", "bottom"], true);
    this.adjustContainerPosition();
  }
  setOptions() {
    return this.getInputValue() ? this.options : [];
  }
  prepareOptions(items) {
    return this.infiniteScroll ? [...this.options, ...items] : items;
  }
  setPage() {
    return this.infiniteScroll ? 1 : void 0;
  }
  setScrollingControl() {
    return this.infiniteScroll ? true : false;
  }
  focusItem() {
    this.poListbox?.listboxItemList?.nativeElement.focus();
    setTimeout(() => {
      let item;
      if (this.selectedValue) {
        item = document.querySelector('.po-listbox-item[aria-selected="true"]');
      } else {
        item = document.querySelectorAll(".po-listbox-item")[0];
      }
      this.poListbox?.listboxItemList?.nativeElement.focus();
      item?.focus();
    });
  }
  static ɵfac = function PoComboComponent_Factory(t) {
    return new (t || _PoComboComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoComboFilterService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoComboComponent, selectors: [["po-combo"]], contentQueries: function PoComboComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoComboOptionTemplateDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.comboOptionTemplate = _t.first);
    }
  }, viewQuery: function PoComboComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$U, 5, ElementRef);
      ɵɵviewQuery(_c1$m, 5, ElementRef);
      ɵɵviewQuery(_c2$a, 7, ElementRef);
      ɵɵviewQuery(_c3$5, 7, ElementRef);
      ɵɵviewQuery(_c4$2, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poListbox = _t.first);
    }
  }, features: [ɵɵProvidersFeature([
    PoComboFilterService,
    PoControlPositionService,
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoComboComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoComboComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 18, vars: 33, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], ["cdkOverlayOrigin", "", 1, "po-field-container-content", "po-combo-container-content"], ["trigger", "cdkOverlayOrigin"], ["class", "po-field-icon-container-left", 4, "ngIf"], ["autocomplete", "off", "type", "text", 1, "po-combo-input", 3, "ngClass", "disabled", "id", "placeholder", "required", "click", "keyup", "blur", "keydown"], ["inp", ""], [1, "po-field-icon-container-right"], ["tabindex", "0", "role", "button", "class", "po-combo-clean", 3, "click", "keydown.enter", 4, "ngIf"], [1, "po-icon", "po-field-icon", "po-icon-input", 3, "click"], ["iconArrow", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], ["dropdownDefault", ""], ["dropdownCDK", ""], [3, "p-help", "p-disabled"], ["dropdownListbox", ""], [1, "po-field-icon-container-left"], [1, "po-field-icon", "po-icon-input", 3, "p-icon"], ["tabindex", "0", "role", "button", 1, "po-combo-clean", 3, "click", "keydown.enter"], [1, "po-icon", "po-field-icon", "po-icon-clear-content"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen"], [1, "po-combo-container", 3, "hidden"], ["containerElement", ""], ["p-type", "option", 3, "p-items", "p-field-value", "p-field-label", "p-template", "p-search-value", "p-infinite-loading", "p-infinite-scroll", "p-filtering", "p-cache", "p-filter-mode", "p-visible", "p-is-searching", "p-should-mark-letter", "p-compare-cache", "p-combo-service", "p-infinite-scroll-distance", "p-selectcombo-item", "p-update-infinite-scroll", "p-close"], ["poListbox", "", "contentElement", ""]], template: function PoComboComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1, 2);
      ɵɵtemplate(3, PoComboComponent_div_3_Template, 2, 3, "div", 3);
      ɵɵelementStart(4, "input", 4, 5);
      ɵɵlistener("click", function PoComboComponent_Template_input_click_4_listener() {
        return ctx.toggleComboVisibility();
      })("keyup", function PoComboComponent_Template_input_keyup_4_listener($event) {
        return ctx.onKeyUp($event);
      })("blur", function PoComboComponent_Template_input_blur_4_listener() {
        return ctx.onBlur();
      })("keyup", function PoComboComponent_Template_input_keyup_4_listener($event) {
        return ctx.searchOnEnterOrArrow($event, $event.target.value);
      })("keydown", function PoComboComponent_Template_input_keydown_4_listener($event) {
        return ctx.onKeyDown($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 6);
      ɵɵtemplate(7, PoComboComponent_div_7_Template, 2, 3, "div", 7);
      ɵɵelementStart(8, "span", 8, 9);
      ɵɵlistener("click", function PoComboComponent_Template_span_click_8_listener() {
        return ctx.toggleComboVisibility(true);
      });
      ɵɵelementEnd()()();
      ɵɵtemplate(10, PoComboComponent_ng_container_10_Template, 1, 0, "ng-container", 10)(11, PoComboComponent_ng_template_11_Template, 1, 1, "ng-template", null, 11, ɵɵtemplateRefExtractor)(13, PoComboComponent_ng_template_13_Template, 1, 2, "ng-template", null, 12, ɵɵtemplateRefExtractor);
      ɵɵelement(15, "po-field-container-bottom", 13);
      ɵɵelementEnd();
      ɵɵtemplate(16, PoComboComponent_ng_template_16_Template, 5, 17, "ng-template", null, 14, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(5);
      const _r7 = ɵɵreference(12);
      const _r9 = ɵɵreference(14);
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-left", ctx.icon);
      ɵɵproperty("ngClass", ctx.clean && _r2.value ? "po-input-double-icon-right" : "po-input-icon-right")("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("required", ctx.required);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && _r2.value);
      ɵɵadvance();
      ɵɵclassProp("po-field-icon-disabled", ctx.disabled)("po-icon-arrow-up", ctx.comboOpen)("po-icon-arrow-down", !ctx.comboOpen)("po-field-icon", !ctx.disabled)("po-combo-default-border", !ctx.disabled && _r2.value)("po-combo-background-arrow-up", !ctx.disabled && ctx.comboOpen);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.appendBox)("ngIfThen", _r9)("ngIfElse", _r7);
      ɵɵadvance(5);
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, dependencies: [NgClass, NgIf, NgTemplateOutlet, CdkConnectedOverlay, CdkOverlayOrigin, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent, PoListBoxComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComboComponent, [{
    type: Component,
    args: [{ selector: "po-combo", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      PoComboFilterService,
      PoControlPositionService,
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoComboComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoComboComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div cdkOverlayOrigin #trigger="cdkOverlayOrigin" class="po-field-container-content po-combo-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon class="po-field-icon po-icon-input" [class.po-field-icon-disabled]="disabled" [p-icon]="icon"></po-icon>
    </div>

    <input
      #inp
      class="po-combo-input"
      [ngClass]="clean && inp.value ? 'po-input-double-icon-right' : 'po-input-icon-right'"
      [class.po-input-icon-left]="icon"
      autocomplete="off"
      type="text"
      [attr.name]="name"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [required]="required"
      (click)="toggleComboVisibility()"
      (keyup)="onKeyUp($event)"
      (blur)="onBlur()"
      (keyup)="searchOnEnterOrArrow($event, $event.target.value)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <div
        tabindex="0"
        role="button"
        [attr.aria-label]="literals.clean"
        *ngIf="clean && !disabled && inp.value"
        class="po-combo-clean"
        (click)="clear(null); $event.preventDefault()"
        (keydown.enter)="clearAndFocus(); $event.preventDefault()"
      >
        <span
          [class.po-border-focused]="!disabled && comboOpen"
          class="po-icon po-field-icon po-icon-clear-content"
        ></span>
      </div>
      <span
        #iconArrow
        class="po-icon po-field-icon po-icon-input"
        [class.po-field-icon-disabled]="disabled"
        [class.po-icon-arrow-up]="comboOpen"
        [class.po-icon-arrow-down]="!comboOpen"
        [class.po-field-icon]="!disabled"
        [class.po-combo-default-border]="!disabled && inp.value"
        [class.po-combo-background-arrow-up]="!disabled && comboOpen"
        (click)="toggleComboVisibility(true)"
      >
      </span>
    </div>
  </div>

  <ng-container *ngIf="appendBox; then dropdownCDK; else dropdownDefault"> </ng-container>

  <ng-template #dropdownDefault>
    <ng-container *ngTemplateOutlet="dropdownListbox"> </ng-container>
  </ng-template>

  <ng-template #dropdownCDK>
    <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="trigger" [cdkConnectedOverlayOpen]="true">
      <ng-container *ngTemplateOutlet="dropdownListbox"></ng-container>
    </ng-template>
  </ng-template>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>
</po-field-container>

<ng-template #dropdownListbox>
  <div #containerElement class="po-combo-container" [hidden]="!comboOpen && !isServerSearching">
    <po-listbox
      #poListbox
      #contentElement
      p-type="option"
      [p-items]="visibleOptions"
      [p-field-value]="dynamicValue"
      [p-field-label]="dynamicLabel"
      [p-template]="comboOptionTemplate"
      [p-search-value]="getInputValue()"
      [p-infinite-loading]="infiniteLoading"
      [p-infinite-scroll]="infiniteScroll"
      [p-filtering]="isFiltering"
      [p-cache]="cache"
      (p-selectcombo-item)="onOptionClick($event, $event.event)"
      [p-filter-mode]="filterMode"
      [p-visible]="comboOpen"
      [p-is-searching]="isServerSearching"
      [p-should-mark-letter]="shouldMarkLetters"
      [p-compare-cache]="compareObjects(cacheOptions, visibleOptions)"
      [p-combo-service]="service"
      [p-infinite-scroll-distance]="infiniteScrollDistance"
      (p-update-infinite-scroll)="showMoreInfiniteScroll()"
      (p-close)="onCloseCombo()"
    ></po-listbox>
  </div>
</ng-template>
` }]
  }], () => [{ type: ElementRef }, { type: IterableDiffers }, { type: PoComboFilterService }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: PoControlPositionService }, { type: PoLanguageService }], { comboOptionTemplate: [{
    type: ContentChild,
    args: [PoComboOptionTemplateDirective, { static: true }]
  }], containerElement: [{
    type: ViewChild,
    args: ["containerElement", { read: ElementRef }]
  }], contentElement: [{
    type: ViewChild,
    args: ["contentElement", { read: ElementRef }]
  }], iconElement: [{
    type: ViewChild,
    args: ["iconArrow", { read: ElementRef, static: true }]
  }], inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: true }]
  }], poListbox: [{
    type: ViewChild,
    args: ["poListbox"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoComboComponent, { className: "PoComboComponent", filePath: "lib/components/po-field/po-combo/po-combo.component.ts", lineNumber: 102 });
})();
var poDatepickerRangeLiteralsDefault = {
  en: {
    invalidFormat: "Date in invalid format",
    startDateGreaterThanEndDate: "Start date greater than end date",
    invalidDate: "Invalid date",
    dateOutOfPeriod: "Date out of period"
  },
  es: {
    invalidFormat: "Fecha en formato no válido",
    startDateGreaterThanEndDate: "Fecha de inicio mayor que fecha final",
    invalidDate: "Fecha invalida",
    dateOutOfPeriod: "Fecha fuera de período"
  },
  pt: {
    invalidFormat: "Data no formato inválido",
    startDateGreaterThanEndDate: "Data inicial maior que data final",
    invalidDate: "Data inválida",
    dateOutOfPeriod: "Data fora do período"
  },
  ru: {
    invalidFormat: "Дата в неверном формате",
    startDateGreaterThanEndDate: "Дата начала больше даты окончания",
    invalidDate: "Недействительная дата",
    dateOutOfPeriod: "дата вне периода"
  }
};
var PoDatepickerRangeBaseComponent = class _PoDatepickerRangeBaseComponent {
  poDateService;
  languageService;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Texto de apoio do campo.
   */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Rótulo do campo.
   */
  label;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do campo.
   */
  onChange = new EventEmitter();
  errorMessage = "";
  dateRange = { start: "", end: "" };
  format = "dd/mm/yyyy";
  isDateRangeInputFormatValid = true;
  isStartDateRangeInputValid = true;
  onTouchedModel;
  poMaskObject;
  _clean = false;
  _disabled;
  _endDate;
  _literals;
  _maxDate;
  _minDate;
  _noAutocomplete = false;
  _readonly = false;
  _required = false;
  _startDate;
  _locale;
  language;
  onChangeModel;
  validatorChange;
  get isDateRangeInputValid() {
    return this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita ação para limpar o campo.
   *
   * @default `false`
   */
  set clean(clean) {
    this._clean = convertToBoolean(clean);
  }
  get clean() {
    return this._clean;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o campo.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.validateModel(this.dateRange);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Data final.
   */
  set endDate(date) {
    this._endDate = this.convertPatternDateFormat(date);
    this.dateRange.end = this.endDate;
    this.updateScreenByModel(this.dateRange);
    this.updateModel(this.dateRange);
  }
  get endDate() {
    return this._endDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-datepicker-range`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoDatepickerRangeLiterals = {
   *    invalidFormat: 'Date in inconsistent format',
   *    startDateGreaterThanEndDate: 'End date less than start date'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoDatepickerRangeLiterals = {
   *    invalidFormat: 'Date in inconsistent format'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-datepicker-range
   *   [p-literals]="customLiterals">
   * </po-datepicker-range>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poDatepickerRangeLiteralsDefault[poLocaleDefault]), poDatepickerRangeLiteralsDefault[this.language]), value);
    } else {
      this._literals = poDatepickerRangeLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poDatepickerRangeLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data mínima para o `po-datepicker-range`.
   */
  set minDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 0, 0, 0);
      setYearFrom0To100(date, year);
      this._minDate = date;
    } else {
      this._minDate = convertIsoToDate(value, true, false);
    }
  }
  get minDate() {
    return this._minDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma data máxima para o `po-datepicker-range`.
   */
  set maxDate(value) {
    if (value instanceof Date) {
      const year = value.getFullYear();
      const date = new Date(year, value.getMonth(), value.getDate(), 23, 59, 59);
      setYearFrom0To100(date, year);
      this._maxDate = date;
    } else {
      this._maxDate = convertIsoToDate(value, false, true);
    }
  }
  get maxDate() {
    return this._maxDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente leitura.
   *
   * @default `false`
   */
  set readonly(value) {
    this._readonly = convertToBoolean(value);
    this.validateModel(this.dateRange);
  }
  get readonly() {
    return this._readonly;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.dateRange);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   *
   * Data inicial.
   */
  set startDate(date) {
    this._startDate = this.convertPatternDateFormat(date);
    this.dateRange.start = this.startDate;
    this.updateScreenByModel(this.dateRange);
    this.updateModel(this.dateRange);
  }
  get startDate() {
    return this._startDate;
  }
  /**
   * @optional
   *
   * @description
   *
   * Idioma que o calendário utilizará para exibir as datas.
   *
   * > O locale padrão será recuperado com base no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set locale(value) {
    if (value) {
      this._locale = value.length >= 2 ? value : poLocaleDefault;
      this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    } else {
      this._locale = this.language;
      this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.languageService.getDateSeparator(this.locale)));
    }
  }
  get locale() {
    return this._locale || this.language;
  }
  constructor(poDateService, languageService) {
    this.poDateService = poDateService;
    this.languageService = languageService;
    this.language = languageService.getShortLanguage();
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangeModel = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouchedModel = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(control) {
    const value = control.value || {};
    const startDate = value.start ? this.convertPatternDateFormat(value.start) : "";
    const endDate = value.end ? this.convertPatternDateFormat(value.end) : "";
    if (this.requiredDateRangeFailed(startDate, endDate)) {
      this.errorMessage = "";
      return {
        required: {
          valid: false
        }
      };
    }
    if (!this.verifyValidDate(startDate, endDate)) {
      this.errorMessage = this.literals.invalidDate;
      return {
        date: {
          valid: false
        }
      };
    }
    if (this.dateRangeObjectFailed(control.value) || this.dateRangeFormatFailed(startDate, endDate)) {
      this.errorMessage = this.literals.invalidFormat;
      return {
        date: {
          valid: false
        }
      };
    }
    if (this.dateRangeFailed(startDate, endDate)) {
      this.errorMessage = this.literals.startDateGreaterThanEndDate;
      return {
        date: {
          valid: false
        }
      };
    }
    if (startDate && !this.validateDateInRange(startDate) || endDate && !this.validateDateInRange(endDate)) {
      this.errorMessage = this.literals.dateOutOfPeriod;
      return {
        date: {
          valid: false
        }
      };
    }
    return null;
  }
  validateDateInRange(startDate) {
    return validateDateRange(convertIsoToDate(startDate, false, false), this._minDate, this._maxDate);
  }
  writeValue(dateRange) {
    this.resetDateRangeInputValidation();
    if (!dateRange || this.dateRangeObjectFailed(dateRange)) {
      this.dateRange = { start: "", end: "" };
    }
    if (!dateRange) {
      this.validateModel(this.dateRange);
    }
    if (this.dateRangeObjectFailed(dateRange)) {
      this.updateModel(dateRange);
    }
    if (this.isDateRangeObject(dateRange)) {
      this.dateRange = {
        start: this.convertPatternDateFormat(dateRange.start),
        end: this.convertPatternDateFormat(dateRange.end)
      };
      this.updateModel(this.dateRange);
    }
    this.updateScreenByModel(this.dateRange);
  }
  // Retorna um objeto do tipo PoMask com a mascara configurada.
  buildMask(format = this.format) {
    let mask = format.toUpperCase();
    mask = mask.replace(/DD/g, "99");
    mask = mask.replace(/MM/g, "99");
    mask = mask.replace(/YYYY/g, "9999");
    return new PoMask(mask, true);
  }
  dateFormatFailed(value) {
    return value && !this.poDateService.isValidIso(value);
  }
  // Executa a função onChange
  updateModel(value) {
    const model = typeof value === "object" ? __spreadValues({}, value) : value;
    if (this.onChangeModel) {
      this.onChangeModel(model);
    }
  }
  validateModel(value) {
    const model = __spreadValues({}, value);
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  verifyValidDate(startDate, endDate) {
    if (startDate !== "" && endDate !== "") {
      return this.dateIsValid(startDate) && this.dateIsValid(endDate);
    } else if (startDate !== "") {
      return this.dateIsValid(startDate);
    } else {
      return this.dateIsValid(endDate);
    }
  }
  convertPatternDateFormat(value) {
    if (value instanceof Date) {
      return this.poDateService.convertDateToISO(value);
    }
    return value;
  }
  dateRangeFailed(startDate, endDate) {
    return !this.poDateService.isDateRangeValid(endDate, startDate) || !this.isStartDateRangeInputValid;
  }
  dateRangeFormatFailed(startDate, endDate) {
    return this.dateFormatFailed(endDate) || this.dateFormatFailed(startDate) || !this.isDateRangeInputFormatValid;
  }
  dateRangeObjectFailed(value) {
    return value && !this.isDateRangeObject(value);
  }
  isDateRangeObject(value) {
    return value && value.hasOwnProperty("start") && value.hasOwnProperty("end");
  }
  requiredDateRangeFailed(startDate, endDate) {
    return this.isDateRangeInputValid && requiredFailed(this.required, this.disabled, startDate) && requiredFailed(this.required, this.disabled, endDate);
  }
  dateIsValid(date) {
    const [strYear, strMonth, strDay] = date.split("-");
    const year = Number(strYear);
    const month = Number(strMonth);
    const day = Number(strDay);
    if (month === 1 || month === 3 || month === 5 || month === 7 || month === 8 || month === 10 || month === 12) {
      return day < 1 || day > 31 ? false : true;
    } else if (month === 4 || month === 6 || month === 9 || month === 11) {
      return day < 1 || day > 30 ? false : true;
    } else {
      if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) {
        return day < 1 || day > 29 ? false : true;
      } else {
        return day < 1 || day > 28 ? false : true;
      }
    }
  }
  static ɵfac = function PoDatepickerRangeBaseComponent_Factory(t) {
    return new (t || _PoDatepickerRangeBaseComponent)(ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDatepickerRangeBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], help: [InputFlags.None, "p-help", "help"], label: [InputFlags.None, "p-label", "label"], optional: [InputFlags.None, "p-optional", "optional"], clean: [InputFlags.None, "p-clean", "clean"], disabled: [InputFlags.None, "p-disabled", "disabled"], endDate: [InputFlags.None, "p-end-date", "endDate"], literals: [InputFlags.None, "p-literals", "literals"], minDate: [InputFlags.None, "p-min-date", "minDate"], maxDate: [InputFlags.None, "p-max-date", "maxDate"], noAutocomplete: [InputFlags.None, "p-no-autocomplete", "noAutocomplete"], readonly: [InputFlags.None, "p-readonly", "readonly"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], startDate: [InputFlags.None, "p-start-date", "startDate"], locale: [InputFlags.None, "p-locale", "locale"] }, outputs: { onChange: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerRangeBaseComponent, [{
    type: Directive
  }], () => [{ type: PoDateService }, { type: PoLanguageService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], onChange: [{
    type: Output,
    args: ["p-change"]
  }], clean: [{
    type: Input,
    args: ["p-clean"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], endDate: [{
    type: Input,
    args: ["p-end-date"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], minDate: [{
    type: Input,
    args: ["p-min-date"]
  }], maxDate: [{
    type: Input,
    args: ["p-max-date"]
  }], noAutocomplete: [{
    type: Input,
    args: ["p-no-autocomplete"]
  }], readonly: [{
    type: Input,
    args: ["p-readonly"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], startDate: [{
    type: Input,
    args: ["p-start-date"]
  }], locale: [{
    type: Input,
    args: ["p-locale"]
  }] });
})();
var _c0$T = ["dateRangeField"];
var _c1$l = ["endDateInput"];
var _c2$9 = ["startDateInput"];
var _c3$4 = ["iconCalendar"];
var _c4$1 = ["calendarPicker"];
function PoDatepickerRangeComponent_po_clean_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 15);
    ɵɵlistener("p-change-event", function PoDatepickerRangeComponent_po_clean_12_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.clear());
    });
    ɵɵelementEnd();
  }
}
function PoDatepickerRangeComponent_ng_container_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 16, 17)(3, "po-calendar", 18);
    ɵɵlistener("ngModelChange", function PoDatepickerRangeComponent_ng_container_17_Template_po_calendar_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.onCalendarChange($event));
    });
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngModel", ctx_r5.dateRange)("p-max-date", ctx_r5.maxDate)("p-min-date", ctx_r5.minDate)("p-locale", ctx_r5.locale);
  }
}
var arrowLeftKey = 37;
var arrowRightKey = 39;
var backspaceKey = 8;
var poDatepickerRangeDateLengthDefault = 10;
var poCalendarContentOffset = 8;
var poCalendarPositionDefault = "bottom-left";
var providers$5 = [
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoDatepickerRangeComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoDatepickerRangeComponent),
    multi: true
  },
  PoControlPositionService
];
var PoDatepickerRangeComponent = class _PoDatepickerRangeComponent extends PoDatepickerRangeBaseComponent {
  changeDetector;
  controlPosition;
  renderer;
  cd;
  poLanguageService;
  dateRangeField;
  endDateInput;
  startDateInput;
  iconCalendar;
  calendarPicker;
  isCalendarVisible = false;
  clickListener;
  eventResizeListener;
  poDatepickerRangeElement;
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  get enableCleaner() {
    return this.clean && (this.startDateInputValue || this.endDateInputValue) && !this.disabled && !this.readonly;
  }
  get endDateInputName() {
    return "end-date";
  }
  get endDateInputValue() {
    return this.endDateInput.nativeElement.value;
  }
  get getErrorMessage() {
    return this.errorMessage !== "" && this.hasInvalidClass() ? this.errorMessage : "";
  }
  get isDateRangeInputUncompleted() {
    return this.endDateInputValue.length < poDatepickerRangeDateLengthDefault && this.startDateInputValue.length < poDatepickerRangeDateLengthDefault;
  }
  get isDirtyDateRangeInput() {
    return this.endDateInputValue.length > 0 || this.startDateInputValue.length > 0;
  }
  get startDateInputName() {
    return "start-date";
  }
  get startDateInputValue() {
    return this.startDateInput.nativeElement.value;
  }
  constructor(changeDetector, controlPosition, renderer, cd, poLanguageService, poDateService, poDatepickerRangeElement) {
    super(poDateService, poLanguageService);
    this.changeDetector = changeDetector;
    this.controlPosition = controlPosition;
    this.renderer = renderer;
    this.cd = cd;
    this.poLanguageService = poLanguageService;
    this.poDatepickerRangeElement = poDatepickerRangeElement;
  }
  static getKeyCode(event) {
    return event.keyCode || event.which;
  }
  static getTargetElement(event) {
    return event.target || event.srcElement;
  }
  static isValidKey(keyCode) {
    const isNumericKey = keyCode >= 48 && keyCode <= 57;
    const isNumericNumpadKey = keyCode >= 96 && keyCode <= 105;
    return isNumericKey || isNumericNumpadKey;
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  ngOnInit() {
    this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.poLanguageService.getDateSeparator(this.locale)));
  }
  ngOnChanges(changes) {
    if (changes.minDate || changes.maxDate) {
      this.validateModel(this.dateRange);
    }
    if (changes.locale) {
      if (this.dateRange) {
        this.updateScreenByModel(this.dateRange);
      }
      this.poMaskObject = this.buildMask(replaceFormatSeparator(this.format, this.poLanguageService.getDateSeparator(this.locale)));
    }
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  clear() {
    this.resetDateRangeInputValidation();
    this.dateRange = { start: "", end: "" };
    this.updateScreenByModel(this.dateRange);
    this.updateModel(this.dateRange);
  }
  eventOnClick($event) {
    this.poMaskObject.click($event);
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoDatepickerRangeComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoDatepickerRangeComponent, { static: true }) datepickerRange: PoDatepickerRangeComponent;
   *
   * focusDatepickerRange() {
   *   this.datepickerRange.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.startDateInput.nativeElement.focus();
    }
  }
  onBlur(event) {
    this.onTouchedModel?.();
    const isStartDateTargetEvent = event.target.name === this.startDateInputName;
    this.updateModelByScreen(isStartDateTargetEvent);
    this.removeFocusFromDatePickerRangeField();
  }
  onCalendarChange({ start, end }) {
    const isStartDateTargetEvent = start && !end;
    this.updateScreenByModel({ start: start || "", end: end || "" });
    this.updateModelByScreen(isStartDateTargetEvent, start || "", end || "");
    if (start && end) {
      setTimeout(() => {
        this.isCalendarVisible = false;
        this.cd.markForCheck();
      }, 300);
    }
  }
  onFocus(event) {
    this.applyFocusOnDatePickerRangeField();
    this.poMaskObject.resetPositions(event);
  }
  onKeydown(event) {
    if (this.readonly) {
      return;
    }
    if (this.isSetFocusOnBackspace(event)) {
      event.preventDefault();
      this.setFocusOnBackspace();
    } else {
      this.poMaskObject.keydown(event);
    }
  }
  onKeyup(event) {
    if (this.readonly) {
      return;
    }
    const isStartDateTargetEvent = event.target.name === this.startDateInputName;
    this.setFocus(event);
    this.poMaskObject.keyup(event);
    this.updateModelWhenComplete(isStartDateTargetEvent, this.startDateInputValue, this.endDateInputValue);
  }
  resetDateRangeInputValidation() {
    this.isStartDateRangeInputValid = true;
    this.isDateRangeInputFormatValid = true;
  }
  toggleCalendar() {
    if (this.disabled || this.readonly) {
      return;
    }
    this.isCalendarVisible = !this.isCalendarVisible;
    this.changeDetector.detectChanges();
    if (this.isCalendarVisible) {
      this.setCalendarPosition();
      this.initializeListeners();
    } else {
      this.removeListeners();
    }
  }
  updateScreenByModel(model) {
    const dateRange = { start: model.start, end: model.end };
    const isStartDateValid = this.poDateService.isDateRangeValid(dateRange.end, dateRange.start);
    const isDateValid = (date) => !this.dateFormatFailed(date) && isStartDateValid;
    const endDateFormated = isDateValid(dateRange.end) ? this.formatModelToScreen(dateRange.end) : "";
    const startDateFormated = isDateValid(dateRange.start) ? this.formatModelToScreen(dateRange.start) : "";
    this.endDateInput.nativeElement.value = endDateFormated;
    this.startDateInput.nativeElement.value = startDateFormated;
    this.changeDetector.detectChanges();
  }
  applyFocusOnDatePickerRangeField() {
    this.dateRangeField.nativeElement.classList.add("po-datepicker-range-field-focused");
  }
  formatDate(format, day = "", month = "", year = "") {
    let dateFormatted = replaceFormatSeparator(format || this.format, this.poLanguageService.getDateSeparator(this.locale));
    day = day && day.includes("T") ? day.slice(0, 2) : day;
    dateFormatted = dateFormatted.replace("dd", ("0" + day).slice(-2));
    dateFormatted = dateFormatted.replace("mm", ("0" + month).slice(-2));
    dateFormatted = dateFormatted.replace("yyyy", String(year));
    return dateFormatted;
  }
  formatScreenToModel(value = "") {
    const [day, month, year] = value.split(this.poLanguageService.getDateSeparator(this.locale));
    return value ? this.formatDate("yyyy-mm-dd", day, month, year) : "";
  }
  formatModelToScreen(value = "") {
    const [year, month, day] = value.split("-");
    return value ? this.formatDate(this.format, day, month, year) : "";
  }
  getDateRangeFormatValidation(startDate, endDate, isStartDateTargetEvent) {
    this.setDateRangeInputValidation(startDate, endDate);
    return {
      isValid: this.isDateRangeInputFormatValid && this.isStartDateRangeInputValid && this.verifyValidDate(startDate, endDate),
      dateRangeModel: this.getValidatedModel(startDate, endDate, isStartDateTargetEvent)
    };
  }
  getValidatedModel(startDate, endDate, isStartDateTargetEvent) {
    const dateRangeModel = { start: "", end: "" };
    dateRangeModel.end = (isStartDateTargetEvent || this.isStartDateRangeInputValid) && !this.dateFormatFailed(endDate) ? endDate : "";
    dateRangeModel.start = (!isStartDateTargetEvent || this.isStartDateRangeInputValid) && !this.dateFormatFailed(startDate) ? startDate : "";
    return dateRangeModel;
  }
  hasAttrCalendar(element) {
    const attrCalendar = "attr-calendar";
    return element?.hasAttribute(attrCalendar) || element?.parentElement?.hasAttribute(attrCalendar);
  }
  hasInvalidClass() {
    return this.poDatepickerRangeElement.nativeElement.classList.contains("ng-invalid") && this.poDatepickerRangeElement.nativeElement.classList.contains("ng-dirty");
  }
  initializeListeners() {
    this.clickListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnPicker(event);
    });
    this.eventResizeListener = this.renderer.listen("window", "resize", () => {
      this.isCalendarVisible = false;
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  isEqualBeforeValue(startDate, endDate) {
    return this.isDateRangeInputFormatValid && endDate === this.dateRange.end && startDate === this.dateRange.start;
  }
  isSetFocusOnBackspace(event) {
    return event.target.name === this.endDateInputName && this.endDateInput.nativeElement.selectionStart === 0 && this.endDateInput.nativeElement.selectionEnd === 0 && event.keyCode === backspaceKey;
  }
  onScroll = () => {
    if (this.isCalendarVisible) {
      this.controlPosition.adjustPosition(poCalendarPositionDefault);
    }
  };
  removeFocusFromDatePickerRangeField() {
    this.dateRangeField.nativeElement.classList.remove("po-datepicker-range-field-focused");
  }
  setDateRangeInputValidation(startDate, endDate) {
    this.isStartDateRangeInputValid = this.poDateService.isDateRangeValid(endDate, startDate);
    this.isDateRangeInputFormatValid = !this.dateFormatFailed(startDate) && !this.dateFormatFailed(endDate);
  }
  setFocus(event) {
    const inputElement = _PoDatepickerRangeComponent.getTargetElement(event);
    const keyCode = _PoDatepickerRangeComponent.getKeyCode(event);
    const inputName = inputElement["name"];
    this.setFocusOnArrowLeft(keyCode, inputName);
    this.setFocusOnArrowRight(keyCode, inputName, inputElement);
    this.setFocusOnStartDateCompleted(keyCode, inputName);
  }
  setFocusAndPosition(position, inputElement, selectionRange) {
    this.focusOnElement(inputElement);
    setTimeout(() => {
      inputElement.nativeElement.setSelectionRange(selectionRange, selectionRange);
      this.poMaskObject.initialPosition = position;
      this.poMaskObject.finalPosition = position;
    });
  }
  focusOnElement(inputElement) {
    inputElement.nativeElement.focus();
  }
  removeListeners() {
    if (this.clickListener) {
      this.clickListener();
    }
    if (this.eventResizeListener) {
      this.eventResizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
  }
  setCalendarPosition() {
    this.controlPosition.setElements(this.calendarPicker.nativeElement, poCalendarContentOffset, this.dateRangeField, ["bottom-left", "bottom-right", "top-left", "top-right"], false, true);
    this.controlPosition.adjustPosition(poCalendarPositionDefault);
  }
  setFocusOnArrowLeft(keyCode, inputName) {
    const isCursorAtStartOfInput = this.endDateInput.nativeElement.selectionStart === 0;
    if (inputName === this.endDateInputName && isCursorAtStartOfInput && keyCode === arrowLeftKey) {
      const inputLength = this.startDateInput.nativeElement.value.length;
      this.setFocusAndPosition(inputLength, this.startDateInput, inputLength);
    }
  }
  setFocusOnArrowRight(keyCode, inputName, inputElement) {
    const isCursorAtEndOfInput = this.startDateInput.nativeElement.selectionStart === inputElement.value.length;
    if (inputName === this.startDateInputName && isCursorAtEndOfInput && keyCode === arrowRightKey) {
      this.setFocusAndPosition(0, this.endDateInput, 0);
    }
  }
  setFocusOnBackspace() {
    const inputLength = this.startDateInput.nativeElement.value.length;
    this.startDateInput.nativeElement.value = this.startDateInputValue.slice(0, -1);
    this.setFocusAndPosition(inputLength, this.startDateInput, inputLength);
  }
  setFocusOnStartDateCompleted(keyCode, inputName) {
    const isLastKeyPressed = this.startDateInput.nativeElement.selectionStart === poDatepickerRangeDateLengthDefault;
    const isNewDateCompleted = this.startDateInputValue.length === poDatepickerRangeDateLengthDefault && isLastKeyPressed;
    const isValidKey = _PoDatepickerRangeComponent.isValidKey(keyCode);
    if (inputName === this.startDateInputName && isNewDateCompleted && isValidKey) {
      this.setFocusAndPosition(0, this.endDateInput, 0);
    }
  }
  updateModelWhenComplete(isStartDateTargetEvent, startDate, endDate) {
    const endDateFormatted = this.formatScreenToModel(endDate);
    const startDateFormatted = this.formatScreenToModel(startDate);
    const dateFormatValidation = this.getDateRangeFormatValidation(startDateFormatted, endDateFormatted, isStartDateTargetEvent);
    if (this.isEqualBeforeValue(startDateFormatted, endDateFormatted)) {
      this.resetDateRangeInputValidation();
      this.validateModel(this.dateRange);
      return;
    }
    if (dateFormatValidation.isValid) {
      this.dateRange = { start: startDateFormatted, end: endDateFormatted };
      this.updateModel(this.dateRange);
      this.onChange.emit(__spreadValues({}, this.dateRange));
    }
  }
  updateModelByScreen(isStartDateTargetEvent, startDate, endDate) {
    const endDateFormatted = endDate || this.formatScreenToModel(this.endDateInputValue);
    const startDateFormatted = startDate || this.formatScreenToModel(this.startDateInputValue);
    if (this.isDateRangeInputUncompleted && this.isDirtyDateRangeInput) {
      this.updateModel(this.dateRange);
      return;
    }
    if (this.isEqualBeforeValue(startDateFormatted, endDateFormatted)) {
      this.resetDateRangeInputValidation();
      this.validateModel(this.dateRange);
      return;
    }
    const dateFormatValidation = this.getDateRangeFormatValidation(startDateFormatted, endDateFormatted, isStartDateTargetEvent);
    if (dateFormatValidation.isValid) {
      this.dateRange = { start: startDateFormatted, end: endDateFormatted };
      this.updateModel(this.dateRange);
      this.onChange.emit(__spreadValues({}, this.dateRange));
    }
    if (!dateFormatValidation.isValid && this.verifyFormattedDates(startDateFormatted, endDateFormatted)) {
      this.dateRange = __spreadValues({}, dateFormatValidation.dateRangeModel);
      this.updateModel(dateFormatValidation.dateRangeModel);
    }
  }
  verifyFormattedDates(start, end) {
    return !!start || !!end;
  }
  wasClickedOnPicker(event) {
    if (!this.isCalendarVisible) {
      return;
    }
    if (!this.calendarPicker.nativeElement.contains(event.target) && !this.iconCalendar.nativeElement.contains(event.target) && !this.hasAttrCalendar(event.target)) {
      this.isCalendarVisible = false;
    }
    this.cd.markForCheck();
  }
  static ɵfac = function PoDatepickerRangeComponent_Factory(t) {
    return new (t || _PoDatepickerRangeComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoDateService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDatepickerRangeComponent, selectors: [["po-datepicker-range"]], viewQuery: function PoDatepickerRangeComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$T, 7, ElementRef);
      ɵɵviewQuery(_c1$l, 7, ElementRef);
      ɵɵviewQuery(_c2$9, 7, ElementRef);
      ɵɵviewQuery(_c3$4, 7, ElementRef);
      ɵɵviewQuery(_c4$1, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dateRangeField = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.endDateInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.startDateInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconCalendar = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.calendarPicker = _t.first);
    }
  }, features: [ɵɵProvidersFeature(providers$5), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 18, vars: 31, consts: [[3, "p-disabled", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-datepicker-range-field", "po-input"], ["dateRangeField", ""], [1, "po-datepicker-range-start-date"], ["maxlength", "10", "type", "text", 1, "po-datepicker-range-input", 3, "autocomplete", "disabled", "name", "readonly", "blur", "focus", "keydown", "keyup", "click"], ["startDateInput", ""], [1, "po-datepicker-range-separator"], [1, "po-datepicker-range-end-date"], ["endDateInput", ""], [1, "po-datepicker-range-icon"], ["class", "po-icon-input", 3, "p-change-event", 4, "ngIf"], [3, "click"], ["iconCalendar", ""], [3, "p-help", "p-disabled", "p-error-pattern"], [4, "ngIf"], [1, "po-icon-input", 3, "p-change-event"], [1, "po-calendar-range-picker"], ["calendarPicker", ""], ["p-mode", "range", 3, "ngModel", "p-max-date", "p-min-date", "p-locale", "ngModelChange"]], template: function PoDatepickerRangeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1, 2)(3, "div", 3)(4, "input", 4, 5);
      ɵɵlistener("blur", function PoDatepickerRangeComponent_Template_input_blur_4_listener($event) {
        return ctx.onBlur($event);
      })("focus", function PoDatepickerRangeComponent_Template_input_focus_4_listener($event) {
        return ctx.onFocus($event);
      })("keydown", function PoDatepickerRangeComponent_Template_input_keydown_4_listener($event) {
        return ctx.onKeydown($event);
      })("keyup", function PoDatepickerRangeComponent_Template_input_keyup_4_listener($event) {
        return ctx.onKeyup($event);
      })("click", function PoDatepickerRangeComponent_Template_input_click_4_listener($event) {
        return ctx.eventOnClick($event);
      });
      ɵɵelementEnd()();
      ɵɵelementStart(6, "div", 6);
      ɵɵtext(7, "-");
      ɵɵelementEnd();
      ɵɵelementStart(8, "div", 7)(9, "input", 4, 8);
      ɵɵlistener("blur", function PoDatepickerRangeComponent_Template_input_blur_9_listener($event) {
        return ctx.onBlur($event);
      })("focus", function PoDatepickerRangeComponent_Template_input_focus_9_listener($event) {
        return ctx.onFocus($event);
      })("keydown", function PoDatepickerRangeComponent_Template_input_keydown_9_listener($event) {
        return ctx.onKeydown($event);
      })("keyup", function PoDatepickerRangeComponent_Template_input_keyup_9_listener($event) {
        return ctx.onKeyup($event);
      })("click", function PoDatepickerRangeComponent_Template_input_click_9_listener($event) {
        return ctx.eventOnClick($event);
      });
      ɵɵelementEnd()();
      ɵɵelementStart(11, "div", 9);
      ɵɵtemplate(12, PoDatepickerRangeComponent_po_clean_12_Template, 1, 0, "po-clean", 10);
      ɵɵelementEnd();
      ɵɵelementStart(13, "div", 9)(14, "span", 11, 12);
      ɵɵlistener("click", function PoDatepickerRangeComponent_Template_span_click_14_listener() {
        return ctx.toggleCalendar();
      });
      ɵɵelementEnd()()();
      ɵɵelement(16, "po-field-container-bottom", 13);
      ɵɵelementEnd();
      ɵɵtemplate(17, PoDatepickerRangeComponent_ng_container_17_Template, 4, 4, "ng-container", 14);
    }
    if (rf & 2) {
      ɵɵclassProp("po-date-picker-container-disabled", ctx.disabled);
      ɵɵproperty("p-disabled", ctx.disabled)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance();
      ɵɵclassProp("po-datepicker-range-field-disabled", ctx.disabled);
      ɵɵattribute("disabled", ctx.disabled);
      ɵɵadvance(3);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("name", ctx.startDateInputName)("readonly", ctx.readonly);
      ɵɵattribute("aria-label", ctx.label);
      ɵɵadvance(5);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("name", ctx.endDateInputName)("readonly", ctx.readonly);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.enableCleaner);
      ɵɵadvance(2);
      ɵɵclassMapInterpolate1("po-icon po-field-icon po-icon-calendar ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
      ɵɵclassProp("po-clickable", !ctx.disabled && !ctx.readonly)("po-field-icon-disabled", ctx.disabled || ctx.readonly);
      ɵɵadvance(2);
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorMessage);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isCalendarVisible);
    }
  }, dependencies: [NgIf, NgControlStatus, NgModel, PoCleanComponent, PoCalendarComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDatepickerRangeComponent, [{
    type: Component,
    args: [{ selector: "po-datepicker-range", providers: providers$5, changeDetection: ChangeDetectionStrategy.OnPush, template: `<po-field-container
  [class.po-date-picker-container-disabled]="disabled"
  [p-disabled]="disabled"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div
    #dateRangeField
    class="po-datepicker-range-field po-input"
    [class.po-datepicker-range-field-disabled]="disabled"
    [attr.disabled]="disabled"
  >
    <div class="po-datepicker-range-start-date">
      <input
        #startDateInput
        class="po-datepicker-range-input"
        maxlength="10"
        type="text"
        [attr.aria-label]="label"
        [autocomplete]="autocomplete"
        [disabled]="disabled"
        [name]="startDateInputName"
        [readonly]="readonly"
        (blur)="onBlur($event)"
        (focus)="onFocus($event)"
        (keydown)="onKeydown($event)"
        (keyup)="onKeyup($event)"
        (click)="eventOnClick($event)"
      />
    </div>

    <div class="po-datepicker-range-separator">-</div>

    <div class="po-datepicker-range-end-date">
      <input
        #endDateInput
        class="po-datepicker-range-input"
        maxlength="10"
        type="text"
        [autocomplete]="autocomplete"
        [disabled]="disabled"
        [name]="endDateInputName"
        [readonly]="readonly"
        (blur)="onBlur($event)"
        (focus)="onFocus($event)"
        (keydown)="onKeydown($event)"
        (keyup)="onKeyup($event)"
        (click)="eventOnClick($event)"
      />
    </div>

    <div class="po-datepicker-range-icon">
      <po-clean class="po-icon-input" *ngIf="enableCleaner" (p-change-event)="clear()"></po-clean>
    </div>

    <div class="po-datepicker-range-icon">
      <span
        #iconCalendar
        class="po-icon po-field-icon po-icon-calendar {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-clickable]="!disabled && !readonly"
        [class.po-field-icon-disabled]="disabled || readonly"
        (click)="toggleCalendar()"
      >
      </span>
    </div>
  </div>

  <po-field-container-bottom
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorMessage"
  ></po-field-container-bottom>
</po-field-container>

<ng-container *ngIf="isCalendarVisible">
  <div #calendarPicker class="po-calendar-range-picker">
    <po-calendar
      p-mode="range"
      [ngModel]="dateRange"
      [p-max-date]="maxDate"
      [p-min-date]="minDate"
      [p-locale]="locale"
      (ngModelChange)="onCalendarChange($event)"
    ></po-calendar>
  </div>
</ng-container>
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: PoControlPositionService }, { type: Renderer2 }, { type: ChangeDetectorRef }, { type: PoLanguageService }, { type: PoDateService }, { type: ElementRef }], { dateRangeField: [{
    type: ViewChild,
    args: ["dateRangeField", { read: ElementRef, static: true }]
  }], endDateInput: [{
    type: ViewChild,
    args: ["endDateInput", { read: ElementRef, static: true }]
  }], startDateInput: [{
    type: ViewChild,
    args: ["startDateInput", { read: ElementRef, static: true }]
  }], iconCalendar: [{
    type: ViewChild,
    args: ["iconCalendar", { read: ElementRef, static: true }]
  }], calendarPicker: [{
    type: ViewChild,
    args: ["calendarPicker", { read: ElementRef }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDatepickerRangeComponent, { className: "PoDatepickerRangeComponent", filePath: "lib/components/po-field/po-datepicker-range/po-datepicker-range.component.ts", lineNumber: 82 });
})();
var PoInputBaseComponent = class _PoInputBaseComponent {
  cd;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Define o ícone que será exibido no início do campo.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-input p-icon="po-icon-user" p-label="PO input"></po-input>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-input p-icon="fa fa-podcast" p-label="PO input"></po-input>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-input [p-icon]="template" p-label="input template ionic"></po-input>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Sempre emite as alterações do model mesmo quando o valor atual for igual ao valor anterior.
   *
   * @default `false`
   */
  emitAllChanges = false;
  /** Rótulo do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  /** Nome e identificador do campo. */
  name;
  /**
   * @description
   *
   * Mensagem que será apresentada quando o `pattern` ou a máscara não for satisfeita.
   *
   * > Esta mensagem não é apresentada quando o campo estiver vazio, mesmo que ele seja requerido.
   */
  errorPattern = "";
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @description
   *
   * Converte o conteúdo do campo em maiúsulo automaticamente.
   *
   */
  upperCase = false;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao sair do campo.
   */
  blur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao entrar do campo.
   */
  enter = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor e deixar o campo.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do model.
   */
  changeModel = new EventEmitter();
  type;
  onChangePropagate = null;
  objMask;
  modelLastUpdate;
  onTouched = null;
  passedWriteValue = false;
  validatorChange;
  _maxlength;
  _minlength;
  _noAutocomplete = false;
  _placeholder = "";
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * > No componente `po-password` será definido como `new-password`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Mensagem que aparecerá enquanto o campo não estiver preenchido.
   *
   * @default ''
   */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @description
   *
   * Se verdadeiro, desabilita o campo.
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  disabled = false;
  set setDisabled(disabled) {
    this.disabled = disabled === "" ? true : convertToBoolean(disabled);
    this.validateModel();
  }
  /** Indica que o campo será somente leitura. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  readonly = false;
  set setReadonly(readonly) {
    this.readonly = readonly === "" ? true : convertToBoolean(readonly);
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  required = false;
  set setRequired(required) {
    this.required = required === "" ? true : convertToBoolean(required);
    this.validateModel();
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /** Se verdadeiro, o campo receberá um botão para ser limpo. */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  clean = false;
  set setClean(clean) {
    this.clean = clean === "" ? true : convertToBoolean(clean);
  }
  /**
   * @description
   *
   * Expressão regular para validar o campo.
   * Quando o campo possuir uma máscara `(p-mask)` será automaticamente validado por ela, porém
   * é possível definir um p-pattern para substituir a validação da máscara.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  pattern;
  set setPattern(pattern) {
    this.pattern = pattern;
    this.validateModel();
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade máxima de caracteres que o campo aceita.
   */
  set maxlength(value) {
    if (!isNaN(parseInt(value, 10))) {
      this._maxlength = parseInt(value, 10);
      this.validateModel();
    } else if (!value) {
      this._maxlength = void 0;
      this.validateModel();
    }
  }
  get maxlength() {
    return this._maxlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade mínima de caracteres que o campo aceita.
   */
  set minlength(value) {
    if (!isNaN(parseInt(value, 10))) {
      this._minlength = parseInt(value, 10);
      this.validateModel();
    } else if (!value) {
      this._minlength = void 0;
      this.validateModel();
    }
  }
  get minlength() {
    return this._minlength;
  }
  /**
   * @description
   *
   * Indica uma máscara para o campo. Exemplos: (+99) (99) 99999?-9999, 99999-999, 999.999.999-99.
   * A máscara gera uma validação automática do campo, podendo esta ser substituída por um REGEX específico
   * através da propriedade p-pattern.
   * O campo será sinalizado e o formulário ficará inválido quando o valor informado estiver fora do padrão definido,
   * mesmo quando desabilitado.
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  mask = "";
  set setMask(mask) {
    this.mask = mask;
    this.objMask = new PoMask(this.mask, this.maskFormatModel);
  }
  /**
   * @description
   *
   * Indica se o `model` receberá o valor formatado pela máscara ou apenas o valor puro (sem formatação).
   *
   * @default `false`
   */
  // eslint-disable-next-line @typescript-eslint/member-ordering
  maskFormatModel = false;
  set setMaskFormatModel(maskFormatModel) {
    this.maskFormatModel = maskFormatModel === "" ? true : convertToBoolean(maskFormatModel);
    if (this.objMask instanceof PoMask) {
      this.objMask.formatModel = this.maskFormatModel;
      this.validateModel();
    }
  }
  constructor(cd) {
    this.cd = cd;
    this.objMask = new PoMask(this.mask, this.maskFormatModel);
  }
  callOnChange(value) {
    this.updateModel(value);
    this.controlChangeModelEmitter(value);
  }
  callUpdateModelWithTimeout(value) {
    setTimeout(() => this.updateModel(value));
  }
  controlChangeModelEmitter(value) {
    if (this.modelLastUpdate !== value || this.emitAllChanges) {
      this.changeModel.emit(value);
      this.modelLastUpdate = value;
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd?.markForCheck();
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangePropagate = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouched = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  updateModel(value) {
    if (this.onChangePropagate) {
      this.onChangePropagate(value);
    }
  }
  validate(c) {
    if (requiredFailed(this.required, this.disabled, this.getScreenValue())) {
      return {
        required: {
          valid: false
        }
      };
    }
    if (maxlengpoailed(this.maxlength, this.getScreenValue())) {
      return {
        maxlength: {
          valid: false
        }
      };
    }
    if (minlengpoailed(this.minlength, this.getScreenValue())) {
      return {
        minlength: {
          valid: false
        }
      };
    }
    if (patternFailed(this.pattern, c.value)) {
      this.validatePatternOnWriteValue(c.value);
      return {
        pattern: {
          valid: false
        }
      };
    }
    return this.extraValidation(c);
  }
  // Função implementada do ControlValueAccessor
  writeValue(value) {
    this.writeValueModel(value);
    this.cd?.markForCheck();
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  // utilizado para validar o pattern na inicializacao, fazendo dessa forma o campo fica sujo (dirty).
  validatePatternOnWriteValue(value) {
    if (value && this.passedWriteValue) {
      setTimeout(() => {
        this.updateModel(value);
      });
      this.passedWriteValue = false;
    }
  }
  static ɵfac = function PoInputBaseComponent_Factory(t) {
    return new (t || _PoInputBaseComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoInputBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], icon: [InputFlags.None, "p-icon", "icon"], emitAllChanges: [InputFlags.HasDecoratorInputTransform, "p-emit-all-changes", "emitAllChanges", convertToBoolean], label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"], name: "name", errorPattern: [InputFlags.None, "p-error-pattern", "errorPattern"], optional: [InputFlags.None, "p-optional", "optional"], upperCase: [InputFlags.HasDecoratorInputTransform, "p-upper-case", "upperCase", convertToBoolean], noAutocomplete: [InputFlags.None, "p-no-autocomplete", "noAutocomplete"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], setDisabled: [InputFlags.None, "p-disabled", "setDisabled"], setReadonly: [InputFlags.None, "p-readonly", "setReadonly"], setRequired: [InputFlags.None, "p-required", "setRequired"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], setClean: [InputFlags.None, "p-clean", "setClean"], setPattern: [InputFlags.None, "p-pattern", "setPattern"], maxlength: [InputFlags.None, "p-maxlength", "maxlength"], minlength: [InputFlags.None, "p-minlength", "minlength"], setMask: [InputFlags.None, "p-mask", "setMask"], setMaskFormatModel: [InputFlags.None, "p-mask-format-model", "setMaskFormatModel"] }, outputs: { blur: "p-blur", enter: "p-enter", change: "p-change", changeModel: "p-change-model" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInputBaseComponent, [{
    type: Directive
  }], () => [{ type: ChangeDetectorRef }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], emitAllChanges: [{
    type: Input,
    args: [{ alias: "p-emit-all-changes", transform: convertToBoolean }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], errorPattern: [{
    type: Input,
    args: ["p-error-pattern"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], upperCase: [{
    type: Input,
    args: [{ alias: "p-upper-case", transform: convertToBoolean }]
  }], blur: [{
    type: Output,
    args: ["p-blur"]
  }], enter: [{
    type: Output,
    args: ["p-enter"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], changeModel: [{
    type: Output,
    args: ["p-change-model"]
  }], noAutocomplete: [{
    type: Input,
    args: ["p-no-autocomplete"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], setDisabled: [{
    type: Input,
    args: ["p-disabled"]
  }], setReadonly: [{
    type: Input,
    args: ["p-readonly"]
  }], setRequired: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], setClean: [{
    type: Input,
    args: ["p-clean"]
  }], setPattern: [{
    type: Input,
    args: ["p-pattern"]
  }], maxlength: [{
    type: Input,
    args: ["p-maxlength"]
  }], minlength: [{
    type: Input,
    args: ["p-minlength"]
  }], setMask: [{
    type: Input,
    args: ["p-mask"]
  }], setMaskFormatModel: [{
    type: Input,
    args: ["p-mask-format-model"]
  }] });
})();
var _c0$S = ["inp"];
function PoDecimalComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r0.disabled);
    ɵɵproperty("p-icon", ctx_r0.icon);
  }
}
function PoDecimalComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoDecimalComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
var poDecimalDefaultDecimalsLength = 2;
var poDecimalDefaultThousandMaxlength = 13;
var poDecimalMaxDecimalsLength = 15;
var poDecimalTotalLengthLimit = 16;
var PoDecimalComponent = class _PoDecimalComponent extends PoInputBaseComponent {
  el;
  poLanguageService;
  inputEl;
  id = `po-decimal[${uuid()}]`;
  _decimalsLength = poDecimalDefaultDecimalsLength;
  _thousandMaxlength = poDecimalDefaultThousandMaxlength;
  _locale;
  _min;
  _max;
  decimalSeparator;
  fireChange = false;
  isKeyboardAndroid = false;
  minusSign = "-";
  oldDotsLength = null;
  thousandSeparator;
  valueBeforeChange;
  regex = {
    thousand: new RegExp("\\,", "g"),
    decimal: new RegExp("\\.", "g")
  };
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  /**
   * @optional
   *
   * @description
   *
   * Quantidade máxima de casas decimais.
   *
   * > **Importante:**
   * - O valor máximo permitido é 15;
   * - A soma total de `p-decimals-length` com `p-thousand-maxlength` limita-se à 16;
   * - Esta propriedade sobrepõe apenas o valor **padrão** de `p-thousand-maxlength`;
   * - Caso `p-thousand-maxlength` tenha um valor definido, esta propriedade poderá receber apenas o valor restante do limite total (16).
   *
   * @default `2`
   */
  set decimalsLength(value) {
    let decimalsLength = convertToInt(value);
    decimalsLength = this.isValueBetweenAllowed(decimalsLength, poDecimalMaxDecimalsLength) ? decimalsLength : poDecimalDefaultDecimalsLength;
    if (this.isGreaterThanTotalLengthLimit(decimalsLength, this.thousandMaxlength)) {
      this.thousandMaxlength = poDecimalTotalLengthLimit - decimalsLength;
    }
    this._decimalsLength = decimalsLength;
  }
  get decimalsLength() {
    return this._decimalsLength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Quantidade máxima de dígitos antes do separador decimal.
   *
   * > **Importante:**
   * - O valor máximo permitido é 13;
   * - A soma total de `p-decimals-length` com `p-thousand-maxlength` limita-se à 16;
   * - Esta propriedade sobrepõe o valor definido em `p-decimals-length`.
   *
   * @default `13`
   */
  set thousandMaxlength(value) {
    let thousandMaxlength = convertToInt(value);
    if (this.decimalsLength > poDecimalDefaultDecimalsLength && !thousandMaxlength) {
      thousandMaxlength = poDecimalTotalLengthLimit - this.decimalsLength;
    }
    thousandMaxlength = this.isValueBetweenAllowed(thousandMaxlength, poDecimalDefaultThousandMaxlength) ? thousandMaxlength : poDecimalDefaultThousandMaxlength;
    if (this.isGreaterThanTotalLengthLimit(this.decimalsLength, thousandMaxlength)) {
      this.decimalsLength = poDecimalTotalLengthLimit - thousandMaxlength;
    }
    this._thousandMaxlength = thousandMaxlength;
  }
  get thousandMaxlength() {
    return this._thousandMaxlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Informa o locale(país) para a formatação do valor.
   * Por padrão o valor será configurado segundo a o módulo [`I18n`](documentation/po-i18n)
   *
   * > Para ver quais linguagens suportadas acesse [`I18n`](documentation/po-i18n)
   *
   */
  set locale(locale) {
    this._locale = locale;
    this.setNumbersSeparators();
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor mínimo.
   */
  set min(value) {
    if (!isNaN(value)) {
      this._min = value;
      this.validateModel();
    } else if (!value) {
      this._min = void 0;
      this.validateModel();
    }
  }
  get min() {
    return this._min;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor máximo.
   */
  set max(value) {
    if (!isNaN(value)) {
      this._max = value;
      this.validateModel();
    } else if (!value) {
      this._max = void 0;
      this.validateModel();
    }
  }
  get max() {
    return this._max;
  }
  constructor(el, poLanguageService, cd) {
    super(cd);
    this.el = el;
    this.poLanguageService = poLanguageService;
    this.isKeyboardAndroid = !!navigator.userAgent.match(/Android/i);
  }
  ngOnInit() {
    this.setNumbersSeparators();
  }
  setNumbersSeparators() {
    const { decimalSeparator, thousandSeparator } = this.poLanguageService.getNumberSeparators(this._locale);
    this.decimalSeparator = decimalSeparator;
    this.thousandSeparator = thousandSeparator;
    this.regex = {
      thousand: new RegExp("\\" + thousandSeparator, "g"),
      decimal: new RegExp("\\" + decimalSeparator, "g")
    };
  }
  ngAfterViewInit() {
    this.verifyAutoFocus();
    this.setPaddingInput();
  }
  clear(value) {
    this.callOnChange(value);
    this.controlChangeEmitter();
  }
  extraValidation(abstractControl) {
    const value = abstractControl.value;
    const thousandValue = Math.trunc(value);
    this.errorPattern = this.errorPattern !== "Valor Inválido" ? this.errorPattern : "";
    if (minFailed(this.min, value)) {
      return {
        min: {
          valid: false
        }
      };
    }
    if (maxFailed(this.max, value)) {
      return {
        max: {
          valid: false
        }
      };
    }
    if (maxlengpoailed(this.thousandMaxlength, thousandValue) && this.thousandMaxlength < poDecimalDefaultThousandMaxlength || maxlengpoailed(poDecimalTotalLengthLimit, value)) {
      return {
        max: {
          valid: false
        }
      };
    }
    return null;
  }
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  getScreenValue() {
    return this.inputEl ? this.inputEl.nativeElement.value : "";
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && this.getScreenValue() !== "";
  }
  hasLetters(value = "") {
    return value.match(/[a-zA-Z:;+=_´`^~"'?!@#$%¨&*()><{}çÇ\[\]/\\|]+/);
  }
  hasNotSpace(value = "") {
    return value.match(/^\S*$/);
  }
  isValidNumber(event) {
    const keyValue = String.fromCharCode(event.which);
    const validKey = event.which !== 8 && event.which !== 0;
    return !this.hasLetters(keyValue) && this.hasNotSpace(keyValue) && validKey;
  }
  // função responsável por adicionar os zeroes com as casa decimais ao sair do campo.
  onBlur(event) {
    this.onTouched?.();
    const value = event.target.value;
    if (value) {
      if (this.hasLetters(value) || this.containsMoreThanOneDecimalSeparator(value)) {
        this.setViewValue("");
        this.callOnChange(void 0);
        return;
      }
      const valueWithoutThousandSeparator = this.formatValueWithoutThousandSeparator(value);
      const formatedViewValue = this.formatToViewValue(valueWithoutThousandSeparator);
      this.setViewValue(formatedViewValue);
      if (!formatedViewValue) {
        this.callOnChange(void 0);
        return;
      }
    }
    this.blur.emit();
    this.controlChangeEmitter();
  }
  onFocus(event) {
    this.valueBeforeChange = this.getScreenValue();
    this.enter.emit();
  }
  onInput(event) {
    const selectionStart = event.target.selectionStart;
    const selectionEnd = event.target.selectionEnd;
    let modelValue;
    if (this.isKeyboardAndroid) {
      this.onInputKeyboardAndroid(event);
    }
    modelValue = this.formatValueWithoutThousandSeparator(event.target.value);
    modelValue = this.addZeroBefore(modelValue);
    const viewValue = this.formatMask(modelValue);
    if (viewValue) {
      this.setViewValue(viewValue);
      this.setCursorInput(event, selectionStart, selectionEnd);
    }
    this.callOnChange(this.formatToModelValue(modelValue));
  }
  onInputKeyboardAndroid(event) {
    const inputValue = event.target.value;
    const selectionStart = event.target.selectionStart;
    const hasLetters = this.hasLetters(inputValue);
    if (hasLetters) {
      this.setViewValue(inputValue.replace(hasLetters[0], ""));
      return event.preventDefault();
    } else {
      const position = selectionStart - 1;
      const key = inputValue.charAt(position);
      this.setPositionValue(event);
      if (this.isValidKey(event, key)) {
        this.setViewValue(inputValue);
      }
    }
  }
  onKeyPress(event) {
    this.isValidKey(event);
  }
  setPaddingInput() {
    setTimeout(() => {
      const selectorIcons = ".po-field-icon-container:not(.po-field-icon-container-left) > .po-icon";
      let icons = this.el.nativeElement.querySelectorAll(selectorIcons).length;
      if (this.clean) {
        icons++;
      }
      if (icons) {
        this.inputEl.nativeElement.style.paddingRight = `${icons * 36}px`;
      }
    });
  }
  writeValueModel(value) {
    let formatedViewValue;
    if (this.inputEl) {
      if (value || value === 0) {
        formatedViewValue = this.formatToViewValue(value);
        this.setViewValue(formatedViewValue);
      } else {
        this.setViewValue("");
      }
    }
    if (formatedViewValue) {
      this.change.emit(value);
    }
  }
  getErrorPatternMessage() {
    return this.errorPattern !== "" && this.hasInvalidClass() ? this.errorPattern : "";
  }
  // responsável por adicionar 0 antes da virgula (decimalSeparator).
  addZeroBefore(value) {
    const isDecimalSeparator = value === this.decimalSeparator;
    return isDecimalSeparator ? `0${value}` : value;
  }
  containsComma(value) {
    return value.includes(this.decimalSeparator);
  }
  containsMoreThanOneDecimalSeparator(value = "") {
    const foundComma = value.match(this.regex.decimal);
    return !!(foundComma && foundComma.length > 1);
  }
  controlChangeEmitter() {
    const elementValue = this.getScreenValue();
    if (elementValue !== this.valueBeforeChange) {
      this.fireChange = true;
      setTimeout(() => {
        this.change.emit(elementValue);
      }, 200);
    }
  }
  formatMask(value) {
    if (value.match(this.regex.decimal)) {
      const regex = new RegExp(`(\\d)(?=(\\d{3})+(?!\\d)${this.decimalSeparator})`, "g");
      return value.toString().replace(regex, `$1${this.thousandSeparator}`);
    }
    return value.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${this.thousandSeparator}`);
  }
  formatToModelValue(value) {
    const formattedValue = this.replaceCommaToDot(value);
    const parsedValue = formattedValue ? parseFloat(Number(formattedValue).toFixed(this.decimalsLength)) : void 0;
    return parsedValue === 0 || parsedValue ? parsedValue : void 0;
  }
  formatToViewValue(value) {
    value = this.replaceCommaToDot(value);
    const numberValue = Number(value).toFixed(this.decimalsLength);
    const valueBeforeDot = this.getValueBeforeSeparator(numberValue, ".");
    const valueAfterDot = this.getValueAfterSeparator(numberValue, ".");
    const formatedNumber = this.formatMask(valueBeforeDot);
    if (formatedNumber === "NaN") {
      return "";
    }
    if (this.decimalsLength === 0) {
      return formatedNumber;
    } else {
      return `${formatedNumber}${this.decimalSeparator}${valueAfterDot}`;
    }
  }
  formatValueWithoutThousandSeparator(value = "") {
    return value.toString().replace(this.regex.thousand, "");
  }
  getValueAfterSeparator(value = "", separator) {
    return value.split(separator)[1] || "";
  }
  getValueBeforeSeparator(value = "", separator) {
    return value.split(separator)[0] || "";
  }
  hasLessDot(value) {
    if (value) {
      const dots = value.match(this.regex.thousand);
      const dotsLength = dots && dots.length;
      if (dotsLength < this.oldDotsLength) {
        this.oldDotsLength = dotsLength;
        return true;
      }
    }
    if (!value) {
      this.oldDotsLength = null;
    }
    return false;
  }
  hasMoreDot(value) {
    if (value) {
      const dots = value.match(this.regex.thousand);
      const dotsLength = dots && dots.length;
      if (dotsLength > this.oldDotsLength) {
        this.oldDotsLength = dotsLength;
        return true;
      }
    }
    if (!value) {
      this.oldDotsLength = null;
    }
    return false;
  }
  hasMinusSignInvalidPosition(event) {
    const keyIsMinusSign = event.key === this.minusSign;
    const selectionStart = event.target.selectionStart;
    return keyIsMinusSign && selectionStart !== 0;
  }
  isInvalidKey(event, charCode) {
    const isInvalidNumber = !this.isValidNumber(event);
    return this.verifyInsertComma(event) || this.verifyThousandLength(event) || this.verifyValueAfterComma(event) || this.verifyInsertMinusSign(event) || this.hasMinusSignInvalidPosition(event) || isInvalidNumber || this.validateCursorPositionBeforeSeparator(event) || this.verifyDecimalLengthIsZeroAndKeyPressedIsComma(charCode);
  }
  isGreaterThanTotalLengthLimit(decimalsMaxLength, thousandMaxlength) {
    return decimalsMaxLength + thousandMaxlength > poDecimalTotalLengthLimit;
  }
  isKeyDecimalSeparator(event) {
    return event.key === this.decimalSeparator || event.char === this.decimalSeparator;
  }
  isPositionAfterDecimalSeparator(positionCursor, value) {
    const indexComma = value && value.indexOf(this.decimalSeparator);
    if (indexComma && this.decimalsLength > 0) {
      return positionCursor > indexComma;
    }
  }
  isSelectionStartDifferentSelectionEnd(target) {
    return target.selectionStart !== target.selectionEnd;
  }
  isValidKey(event, key) {
    const charCode = event.which || event.keyCode;
    const validKey = event.which === 8 || event.which === 0;
    if (validKey && !this.isKeyboardAndroid) {
      return;
    }
    if (key) {
      event.key = key;
    }
    if (this.isInvalidKey(event, charCode)) {
      event.preventDefault();
      return false;
    }
    return true;
  }
  isValueBetweenAllowed(value, maxAllowed) {
    return value >= 0 && value <= maxAllowed;
  }
  // Quando decimalsLength for 0 não deve permitir informar vírgula (decimalSeparator)
  verifyDecimalLengthIsZeroAndKeyPressedIsComma(charCode) {
    return charCode === 44 && this.decimalsLength === 0;
  }
  verifyAutoFocus() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  setInitialSelectionRange(target, selectionStart, selectionEnd) {
    if (selectionStart === 1 && selectionEnd === 1) {
      return target.setSelectionRange(selectionStart + 1, selectionEnd + 1);
    }
    return target.setSelectionRange(selectionStart - 1, selectionEnd - 1);
  }
  replaceAt(value, index, replace) {
    return value.substring(0, index) + replace + value.substring(index + 1);
  }
  replaceCommaToDot(value = "") {
    if (this.decimalSeparator === ",") {
      value = value.toString().replace(this.regex.decimal, ".");
    }
    return value;
  }
  setCursorInput(event, selectionStart, selectionEnd) {
    const target = event.target;
    const viewValue = target.value;
    if (this.hasMoreDot(viewValue) || viewValue === "0" + this.decimalSeparator) {
      return target.setSelectionRange(selectionStart + 1, selectionEnd + 1);
    }
    if (this.hasLessDot(viewValue)) {
      this.setInitialSelectionRange(target, selectionStart, selectionEnd);
    }
    return target.setSelectionRange(selectionStart, selectionEnd);
  }
  setPositionValue(event) {
    const value = event.target.value;
    const position = event.target.selectionStart - 1;
    if (position > 0 && event.key === this.minusSign) {
      event.target.value = value.substring(0, position) + value.substr(position + 1);
    }
  }
  setViewValue(value) {
    this.inputEl.nativeElement.value = value;
  }
  validateCursorPositionBeforeSeparator(event) {
    const target = event.target;
    const originalValue = this.formatValueWithoutThousandSeparator(target.value);
    const valueBeforeSeparator = this.getValueBeforeSeparator(target.value, this.decimalSeparator);
    const valueBeforeSeparatorOriginal = this.getValueBeforeSeparator(originalValue, this.decimalSeparator);
    if (this.isSelectionStartDifferentSelectionEnd(target)) {
      return false;
    }
    return target.selectionStart <= valueBeforeSeparator.length && valueBeforeSeparatorOriginal.length === this.thousandMaxlength && !this.isKeyDecimalSeparator(event);
  }
  verifyThousandLength(event) {
    const target = event.target;
    const originalValue = this.formatValueWithoutThousandSeparator(target.value);
    const valueBeforeSeparatorOriginal = this.getValueBeforeSeparator(originalValue, this.decimalSeparator);
    if (this.isSelectionStartDifferentSelectionEnd(target)) {
      return false;
    }
    return valueBeforeSeparatorOriginal.length >= this.thousandMaxlength && !this.isKeyDecimalSeparator(event) && this.isPositionAfterDecimalSeparator(target.selectionStart - this.decimalsLength, target.value);
  }
  verifyInsertComma(e) {
    const hasComma = this.containsComma(e.target.value);
    return hasComma && e.key === this.decimalSeparator;
  }
  verifyInsertMinusSign(event) {
    const value = event.target.value;
    const indexMinusSign = value.lastIndexOf(this.minusSign) !== -1;
    const positionMinusSign = value.lastIndexOf("-");
    const occurancesMinusSign = value.match(new RegExp("-", "g"));
    if (this.isKeyboardAndroid && indexMinusSign && occurancesMinusSign.length > 1) {
      event.target.value = this.replaceAt(value, positionMinusSign, "");
    }
    return indexMinusSign && event.key === this.minusSign;
  }
  verifyValueAfterComma(event) {
    const value = event.target.value;
    const selectionStart = event.target.selectionStart;
    const valueAfterSeparator = this.getValueAfterSeparator(value, this.decimalSeparator);
    return this.isPositionAfterDecimalSeparator(selectionStart, value) && valueAfterSeparator.length >= this.decimalsLength;
  }
  static ɵfac = function PoDecimalComponent_Factory(t) {
    return new (t || _PoDecimalComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDecimalComponent, selectors: [["po-decimal"]], viewQuery: function PoDecimalComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$S, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    }
  }, inputs: { decimalsLength: [InputFlags.None, "p-decimals-length", "decimalsLength"], thousandMaxlength: [InputFlags.None, "p-thousand-maxlength", "thousandMaxlength"], locale: [InputFlags.None, "p-locale", "locale"], min: [InputFlags.None, "p-min", "min"], max: [InputFlags.None, "p-max", "max"] }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoDecimalComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoDecimalComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 8, vars: 24, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], ["inputmode", "decimal", "type", "text", 1, "po-input", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "blur", "focus", "input", "keypress"], ["inp", ""], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-field-icon-container-left"], [1, "po-field-icon", "po-icon-input", 3, "p-icon"], [1, "po-icon-input", 3, "p-element-ref", "p-change-event"]], template: function PoDecimalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1);
      ɵɵtemplate(2, PoDecimalComponent_div_2_Template, 2, 3, "div", 2);
      ɵɵelementStart(3, "input", 3, 4);
      ɵɵlistener("blur", function PoDecimalComponent_Template_input_blur_3_listener($event) {
        return ctx.onBlur($event);
      })("focus", function PoDecimalComponent_Template_input_focus_3_listener($event) {
        return ctx.onFocus($event);
      })("input", function PoDecimalComponent_Template_input_input_3_listener($event) {
        return ctx.onInput($event);
      })("keypress", function PoDecimalComponent_Template_input_keypress_3_listener($event) {
        return ctx.onKeyPress($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵtemplate(6, PoDecimalComponent_po_clean_6_Template, 1, 1, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelement(7, "po-field-container-bottom", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required);
      ɵɵattribute("max", ctx.max)("min", ctx.min)("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPatternMessage());
    }
  }, dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDecimalComponent, [{
    type: Component,
    args: [{ selector: "po-decimal", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoDecimalComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoDecimalComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon class="po-field-icon po-icon-input" [class.po-field-icon-disabled]="disabled" [p-icon]="icon"></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.max]="max"
      [attr.min]="min"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      inputmode="decimal"
      type="text"
      (blur)="onBlur($event)"
      (focus)="onFocus($event)"
      (input)="onInput($event)"
      (keypress)="onKeyPress($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled" [p-error-pattern]="getErrorPatternMessage()">
  </po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: PoLanguageService }, { type: ChangeDetectorRef }], { inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: true }]
  }], decimalsLength: [{
    type: Input,
    args: ["p-decimals-length"]
  }], thousandMaxlength: [{
    type: Input,
    args: ["p-thousand-maxlength"]
  }], locale: [{
    type: Input,
    args: ["p-locale"]
  }], min: [{
    type: Input,
    args: ["p-min"]
  }], max: [{
    type: Input,
    args: ["p-max"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDecimalComponent, { className: "PoDecimalComponent", filePath: "lib/components/po-field/po-decimal/po-decimal.component.ts", lineNumber: 81 });
})();
var _c0$R = ["inp"];
var PoInputGeneric = class _PoInputGeneric extends PoInputBaseComponent {
  inputEl;
  type = "text";
  el;
  valueBeforeChange;
  timeoutChange;
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  constructor(el, cd) {
    super(cd);
    this.el = el;
  }
  onKeydown(e) {
    if (this.mask && !this.readonly && e.target.keyCode !== 229) {
      this.eventOnBlur(e);
      this.objMask.keydown(e);
      if (this.passedWriteValue) {
        this.validateClassesForMask(true);
      }
    }
  }
  onKeyup(e) {
    if (this.mask && !this.readonly) {
      if (e.target.keyCode !== 229) {
        this.eventOnBlur(e);
        this.objMask.keyup(e);
      }
      this.callOnChange(this.objMask.valueToModel);
    }
  }
  ngAfterViewInit() {
    this.afterViewInit();
  }
  afterViewInit() {
    this.verifyAutoFocus();
    if (this.type !== "password") {
      this.setPaddingInput();
    }
  }
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  setPaddingInput() {
    setTimeout(() => {
      const selectorIcons = ".po-field-icon-container:not(.po-field-icon-container-left) > .po-icon";
      let icons = this.el.nativeElement.querySelectorAll(selectorIcons).length;
      if (this.clean) {
        icons++;
      }
      if (icons) {
        this.inputEl.nativeElement.style.paddingRight = `${icons * 36}px`;
      }
    });
  }
  verifyAutoFocus() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  eventOnInput(e) {
    let value = "";
    if (!this.mask) {
      value = this.validMaxLength(this.maxlength, e.target.value);
      this.inputEl.nativeElement.value = value;
    } else {
      this.objMask.blur(e);
      this.inputEl.nativeElement.value = this.objMask.valueToInput;
      value = this.objMask.valueToModel;
    }
    this.inputEl.nativeElement.value = this.upperCase ? String(this.inputEl.nativeElement.value).toUpperCase() : this.inputEl.nativeElement.value;
    value = this.upperCase ? value.toUpperCase() : value;
    this.callOnChange(value);
  }
  validMaxLength(maxlength, value) {
    return (maxlength || maxlength === 0) && value.length > maxlength ? value.toString().substring(0, maxlength) : value;
  }
  eventOnFocus(e) {
    this.valueBeforeChange = this.inputEl.nativeElement.value;
    this.enter.emit();
  }
  eventOnBlur(e) {
    this.onTouched?.();
    if (this.mask) {
      this.objMask.blur(e);
    }
    if (e.type === "blur") {
      this.blur.emit();
      this.controlChangeEmitter();
    }
  }
  controlChangeEmitter() {
    const elementValue = this.inputEl.nativeElement.value;
    if (elementValue !== this.valueBeforeChange) {
      clearTimeout(this.timeoutChange);
      this.timeoutChange = setTimeout(() => {
        this.change.emit(elementValue);
      }, 200);
    }
  }
  eventOnClick(e) {
    if (this.mask) {
      this.objMask.click(e);
    }
  }
  hasInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && this.inputEl.nativeElement.value !== "";
  }
  getErrorPattern() {
    return this.errorPattern !== "" && this.hasInvalidClass() ? this.errorPattern : "";
  }
  validateClassesForPattern() {
    const value = this.getScreenValue();
    const element = this.el.nativeElement;
    if (value && !this.verifyPattern(this.pattern, value)) {
      element.classList.add("ng-invalid");
      element.classList.add("ng-dirty");
    } else {
      element.classList.remove("ng-invalid");
    }
  }
  validateClassesForMask(keyDown = false) {
    const element = this.el.nativeElement;
    const elementValue = this.inputEl.nativeElement.value;
    if (!keyDown && !elementValue) {
      element.classList.add("ng-invalid-mask");
    } else {
      element.classList.remove("ng-invalid-mask");
    }
  }
  verifyPattern(pattern, value) {
    return new RegExp(pattern).test(value);
  }
  clear(value) {
    this.callOnChange(value);
    this.controlChangeEmitter();
  }
  writeValueModel(value) {
    this.passedWriteValue = true;
    if (this.inputEl) {
      if (value) {
        if (this.mask) {
          this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
          if (this.objMask.formatModel) {
            this.callUpdateModelWithTimeout(this.objMask.valueToModel);
          }
        } else {
          this.inputEl.nativeElement.value = value;
        }
      } else {
        this.inputEl.nativeElement.value = "";
      }
    }
    if (value) {
      this.validateInitMask();
      this.changeModel.emit(value);
    }
  }
  getScreenValue() {
    const screenValue = this.inputEl && this.inputEl.nativeElement.value || void 0;
    if (this.type === "number") {
      const parsedValue = parseFloat(screenValue);
      return parsedValue || parsedValue === 0 ? parsedValue : null;
    } else {
      return screenValue;
    }
  }
  validateInitMask() {
    if (this.mask) {
      this.validateClassesForMask();
    }
  }
  static ɵfac = function PoInputGeneric_Factory(t) {
    return new (t || _PoInputGeneric)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoInputGeneric, viewQuery: function PoInputGeneric_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$R, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    }
  }, hostBindings: function PoInputGeneric_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function PoInputGeneric_keydown_HostBindingHandler($event) {
        return ctx.onKeydown($event);
      })("keyup", function PoInputGeneric_keyup_HostBindingHandler($event) {
        return ctx.onKeyup($event);
      });
    }
  }, features: [ɵɵInheritDefinitionFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInputGeneric, [{
    type: Directive
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], { inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: true }]
  }], onKeydown: [{
    type: HostListener,
    args: ["keydown", ["$event"]]
  }], onKeyup: [{
    type: HostListener,
    args: ["keyup", ["$event"]]
  }] });
})();
function PoEmailComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-field-icon ", ctx_r0.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
    ɵɵclassProp("po-field-icon-disabled", ctx_r0.disabled);
    ɵɵproperty("p-icon", ctx_r0.icon);
  }
}
function PoEmailComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoEmailComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2.disabled ? "po-icon-input-disabled" : "po-icon-input");
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
var providers$4 = [
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoEmailComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoEmailComponent),
    multi: true
  }
];
var PoEmailComponent = class _PoEmailComponent extends PoInputGeneric {
  id = `po-email[${uuid()}]`;
  icon = "po-icon-mail";
  type = "email";
  // Consideramos o uso do nosso pattern com a seguinte expressão.
  // Antes do símbolo @:
  // - não há limite de caracteres.
  // - não pode haver espaços em branco, caracteres acentuados, caracteres especiais ou símbolos.
  // - pode começar com letras, números, hífen ou undescore (underline).
  //
  // Depois do símbolo @:
  // - o domínio tem um limite de até 66 caracteres após um separador.
  // - separador deve ser um 'ponto' (.).
  // - o primeiro bloco pode conter letras, números, hífen ou underscore (underline).
  // - após o primeiro separador é permitido apenas letras.
  // - não pode haver espaços em branco, caracteres acentuados, caracteres especiais ou símbolos.
  //
  // Limite total de 254 caracteres para o e-mail.
  //
  // As recomendações foram consultadas nas RFC 1034, RFC 5321 e RFC 5322.
  //
  // RFC 1034 - https://datatracker.ietf.org/doc/html/rfc1034#section-3
  // RFC 5321 - https://datatracker.ietf.org/doc/html/rfc5321#section-4.5.3.1
  // RFC 5322 - https://datatracker.ietf.org/doc/html/rfc5322#section-3.4
  pattern = "^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([A-Za-z]{2,66}(?:\\.[A-Za-z]{2})?)$";
  mask = "";
  listener = this.validateClassesForPattern.bind(this);
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
    this.maxlength = 254;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      if (!this.onChangePropagate) {
        this.inputEl.nativeElement.addEventListener("keyup", this.listener);
      }
    });
    super.ngAfterViewInit();
  }
  ngOnDestroy() {
    if (!this.onChangePropagate) {
      this.inputEl.nativeElement.removeEventListener("keyup", this.listener);
    }
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoEmailComponent_Factory(t) {
    return new (t || _PoEmailComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoEmailComponent, selectors: [["po-email"]], features: [ɵɵProvidersFeature(providers$4), ɵɵInheritDefinitionFeature], decls: 8, vars: 23, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], [1, "po-input", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type", "blur", "click", "focus", "input"], ["inp", ""], [1, "po-field-icon-container-right"], [3, "class", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-field-icon-container-left"], [3, "p-icon"], [3, "p-element-ref", "p-change-event"]], template: function PoEmailComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1);
      ɵɵtemplate(2, PoEmailComponent_div_2_Template, 2, 6, "div", 2);
      ɵɵelementStart(3, "input", 3, 4);
      ɵɵlistener("blur", function PoEmailComponent_Template_input_blur_3_listener($event) {
        return ctx.eventOnBlur($event);
      })("click", function PoEmailComponent_Template_input_click_3_listener($event) {
        return ctx.eventOnClick($event);
      })("focus", function PoEmailComponent_Template_input_focus_3_listener($event) {
        return ctx.eventOnFocus($event);
      })("input", function PoEmailComponent_Template_input_input_3_listener($event) {
        return ctx.eventOnInput($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵtemplate(6, PoEmailComponent_po_clean_6_Template, 1, 4, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelement(7, "po-field-container-bottom", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern());
    }
  }, dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoEmailComponent, [{
    type: Component,
    args: [{ selector: "po-email", changeDetection: ChangeDetectionStrategy.OnPush, providers: providers$4, template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
        [p-icon]="icon"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="{{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
  ></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoEmailComponent, { className: "PoEmailComponent", filePath: "lib/components/po-field/po-email/po-email.component.ts", lineNumber: 63 });
})();
var _c0$Q = ["inp"];
function PoInputComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-field-icon ", ctx_r0.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
    ɵɵclassProp("po-field-icon-disabled", ctx_r0.disabled);
    ɵɵproperty("p-icon", ctx_r0.icon);
  }
}
function PoInputComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoInputComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2.disabled ? "po-icon-input-disabled" : "po-icon-input");
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
var PoInputComponent = class _PoInputComponent extends PoInputGeneric {
  inp;
  id = `po-input[${uuid()}]`;
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoInputComponent_Factory(t) {
    return new (t || _PoInputComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoInputComponent, selectors: [["po-input"]], viewQuery: function PoInputComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$Q, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inp = _t.first);
    }
  }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoInputComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoInputComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 8, vars: 23, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], [1, "po-input", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type", "blur", "click", "focus", "input"], ["inp", ""], [1, "po-field-icon-container-right"], [3, "class", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-field-icon-container-left"], [3, "p-icon"], [3, "p-element-ref", "p-change-event"]], template: function PoInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1);
      ɵɵtemplate(2, PoInputComponent_div_2_Template, 2, 6, "div", 2);
      ɵɵelementStart(3, "input", 3, 4);
      ɵɵlistener("blur", function PoInputComponent_Template_input_blur_3_listener($event) {
        return ctx.eventOnBlur($event);
      })("click", function PoInputComponent_Template_input_click_3_listener($event) {
        return ctx.eventOnClick($event);
      })("focus", function PoInputComponent_Template_input_focus_3_listener($event) {
        return ctx.eventOnFocus($event);
      })("input", function PoInputComponent_Template_input_input_3_listener($event) {
        return ctx.eventOnInput($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵtemplate(6, PoInputComponent_po_clean_6_Template, 1, 4, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelement(7, "po-field-container-bottom", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern());
    }
  }, dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInputComponent, [{
    type: Component,
    args: [{ selector: "po-input", providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoInputComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoInputComponent),
        multi: true
      }
    ], changeDetection: ChangeDetectionStrategy.OnPush, template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
        [p-icon]="icon"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="{{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
  ></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], { inp: [{
    type: ViewChild,
    args: ["inp", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoInputComponent, { className: "PoInputComponent", filePath: "lib/components/po-field/po-input/po-input.component.ts", lineNumber: 52 });
})();
function PoLoginComponent_po_clean_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 8);
    ɵɵlistener("p-change-event", function PoLoginComponent_po_clean_7_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
var providers$3 = [
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoLoginComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoLoginComponent),
    multi: true
  }
];
var PoLoginComponent = class _PoLoginComponent extends PoInputGeneric {
  id = `po-login[${uuid()}]`;
  type = "text";
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoLoginComponent_Factory(t) {
    return new (t || _PoLoginComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLoginComponent, selectors: [["po-login"]], features: [ɵɵProvidersFeature(providers$3), ɵɵInheritDefinitionFeature], decls: 9, vars: 25, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-field-icon-container-left"], [1, "po-input", "po-input-icon-left", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type", "blur", "click", "focus", "input"], ["inp", ""], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-icon-input", 3, "p-element-ref", "p-change-event"]], template: function PoLoginComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "div", 2);
      ɵɵelement(3, "span");
      ɵɵelementEnd();
      ɵɵelementStart(4, "input", 3, 4);
      ɵɵlistener("blur", function PoLoginComponent_Template_input_blur_4_listener($event) {
        return ctx.eventOnBlur($event);
      })("click", function PoLoginComponent_Template_input_click_4_listener($event) {
        return ctx.eventOnClick($event);
      })("focus", function PoLoginComponent_Template_input_focus_4_listener($event) {
        return ctx.eventOnFocus($event);
      })("input", function PoLoginComponent_Template_input_input_4_listener($event) {
        return ctx.eventOnInput($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5);
      ɵɵtemplate(7, PoLoginComponent_po_clean_7_Template, 1, 1, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelement(8, "po-field-container-bottom", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(3);
      ɵɵclassMapInterpolate1("po-icon po-field-icon po-icon-user ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
      ɵɵclassProp("po-field-icon-disabled", ctx.disabled);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-right", ctx.clean);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern());
    }
  }, dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLoginComponent, [{
    type: Component,
    args: [{ selector: "po-login", changeDetection: ChangeDetectionStrategy.OnPush, providers: providers$3, template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-field-icon-container-left">
      <span
        class="po-icon po-field-icon po-icon-user {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
      ></span>
    </div>

    <input
      #inp
      class="po-input po-input-icon-left"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled" [p-error-pattern]="getErrorPattern()">
  </po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLoginComponent, { className: "PoLoginComponent", filePath: "lib/components/po-field/po-login/po-login.component.ts", lineNumber: 54 });
})();
var poLookupLiteralsDefault = {
  en: {
    modalPrimaryActionLabel: "Select",
    modalSecondaryActionLabel: "Cancel",
    modalPlaceholder: "Search",
    modalTitle: "Select a record",
    modalTableNoColumns: poTableLiteralsDefault.en.noColumns,
    modalTableNoData: poTableLiteralsDefault.en.noData,
    modalTableLoadingData: poTableLiteralsDefault.en.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.en.loadMoreData,
    modalAdvancedSearch: "Advanced search",
    modalAdvancedSearchTitle: "Advanced search",
    modalAdvancedSearchPrimaryActionLabel: "Filter",
    modalAdvancedSearchSecondaryActionLabel: "Return",
    modalDisclaimerGroupTitle: "Presenting results filtered by:"
  },
  es: {
    modalPrimaryActionLabel: "Seleccionar",
    modalSecondaryActionLabel: "Cancelar",
    modalPlaceholder: "Buscar",
    modalTitle: "Seleccione un registro",
    modalTableNoColumns: poTableLiteralsDefault.es.noColumns,
    modalTableNoData: poTableLiteralsDefault.es.noData,
    modalTableLoadingData: poTableLiteralsDefault.es.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.es.loadMoreData,
    modalAdvancedSearch: "Búsqueda Avanzada",
    modalAdvancedSearchTitle: "Búsqueda Avanzada",
    modalAdvancedSearchPrimaryActionLabel: "Filtrar",
    modalAdvancedSearchSecondaryActionLabel: "Vuelve",
    modalDisclaimerGroupTitle: "Presentar resultados filtrados por:"
  },
  pt: {
    modalPrimaryActionLabel: "Selecionar",
    modalSecondaryActionLabel: "Cancelar",
    modalPlaceholder: "Pesquisar",
    modalTitle: "Selecione um registro",
    modalTableNoColumns: poTableLiteralsDefault.pt.noColumns,
    modalTableNoData: poTableLiteralsDefault.pt.noData,
    modalTableLoadingData: poTableLiteralsDefault.pt.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.pt.loadMoreData,
    modalAdvancedSearch: "Busca avançada",
    modalAdvancedSearchTitle: "Busca Avançada",
    modalAdvancedSearchPrimaryActionLabel: "Filtrar",
    modalAdvancedSearchSecondaryActionLabel: "Voltar",
    modalDisclaimerGroupTitle: "Apresentando resultados filtrados por:"
  },
  ru: {
    modalPrimaryActionLabel: "Выбрать",
    modalSecondaryActionLabel: "Отменить",
    modalPlaceholder: "Поиск",
    modalTitle: "Выберите запись",
    modalTableNoColumns: poTableLiteralsDefault.ru.noColumns,
    modalTableNoData: poTableLiteralsDefault.ru.noData,
    modalTableLoadingData: poTableLiteralsDefault.ru.loadingData,
    modalTableLoadMoreData: poTableLiteralsDefault.ru.loadMoreData,
    modalAdvancedSearch: "Расширенный поиск",
    modalAdvancedSearchTitle: "Расширенный поиск",
    modalAdvancedSearchPrimaryActionLabel: "Фильтр",
    modalAdvancedSearchSecondaryActionLabel: "Назад",
    modalDisclaimerGroupTitle: "Представленные результаты отфильтрованы по:"
  }
};
var PoLookupModalBaseComponent = class _PoLookupModalBaseComponent {
  changeDetector;
  poModal;
  poTable;
  /**
   * Objeto com os campos que serão criados no busca avançada.
   *
   * > Caso não seja passado um objeto ou então ele esteja em branco o link de busca avançada ficará escondido.
   *
   * Exemplo de URL com busca avançada: http://localhost:3000/v1/heroes?filter=&page=1&pageSize=10`&name=Tony%20Stark&nickname=Homem%20de%20Ferro&email=irnman@marvel.com`
   *
   * Caso algum parâmetro seja uma lista, a concatenação é feita utilizando virgula.
   * Exemplo: http://localhost:3000/v1/heroes?filter=&page=1&pageSize=10`&name=Tony%20Stark,Peter%20Parker,Gohan`
   *
   */
  advancedFilters;
  /**
   * Lista das colunas da tabela.
   * Essa propriedade deve receber um array de objetos que implementam a interface PoLookupColumn.
   */
  columns;
  /** Lista de itens da tabela. */
  items;
  /** Classe de serviço com a implementação do cliente. */
  filterService;
  /** Classe de serviço com a implementação do cliente. */
  filterParams;
  /** Se verdadeiro, esconde o gerenciador de tarefas, responsável pela definição de quais colunas serão exibidas. */
  hideColumnsManager = false;
  /** Se verdadeiro, ativa a funcionalidade de scroll infinito para a tabela exibida no retorno da consulta. */
  infiniteScroll = false;
  /** Se verdadeiro, ativa a funcionalidade de multipla seleção. */
  multiple = false;
  /** Evento utilizado ao selecionar um registro da tabela. */
  model = new EventEmitter();
  /** Classe de serviço com items selecionados */
  selectedItems;
  /** Indica a coluna que será utilizada como descrição do campo e como filtro dentro da janela. */
  fieldLabel;
  /**
   * @description
   *
   * Indica a coluna que será utilizada como valor do campo.
   *
   * > Atenção: Caso não seja passada ou tenha o conteúdo incorreto, não irá atualizar o model do formulário.
   */
  fieldValue;
  /**
   * @optional
   *
   * @description
   * Evento disparado ao fechar o popover do gerenciador de colunas após alterar as colunas visíveis.
   *
   * O componente envia como parâmetro um array de string com as colunas visíveis atualizadas.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  changeVisibleColumns = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no botão de restaurar padrão no gerenciador de colunas.
   *
   * O componente envia como parâmetro um array de string com as colunas configuradas inicialmente.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  columnRestoreManager = new EventEmitter();
  hasNext = true;
  isLoading = false;
  page = 1;
  pageSize = 10;
  searchValue = "";
  tableLiterals;
  // Propriedade da modal de busca avançada:
  advancedFilterModalTitle = "";
  dynamicFormValue = {};
  disclaimer;
  disclaimerGroup;
  isAdvancedFilter = false;
  primaryActionAdvancedFilter;
  secondaryActionAdvancedFilter;
  selecteds = [];
  sort;
  filterSubscription;
  searchSubscription;
  showMoreSubscription;
  disclaimerLabel;
  _literals;
  _title;
  language = poLocaleDefault;
  // eslint-disable-next-line @typescript-eslint/member-ordering
  primaryAction = {
    action: () => {
      let selectedsItems = [];
      if (!this.multiple) {
        this.items.forEach((element) => {
          if (element["$selected"]) {
            selectedsItems.push(element);
          }
        });
      } else {
        selectedsItems = this.selecteds;
      }
      this.model.emit(selectedsItems);
      this.poModal.close();
    },
    label: this.literals.modalPrimaryActionLabel
  };
  // eslint-disable-next-line @typescript-eslint/member-ordering
  secondaryAction = {
    action: () => {
      this.model.emit(null);
      this.poModal.close();
    },
    label: this.literals.modalSecondaryActionLabel
  };
  /** Objeto com as literais usadas no `po-lookup-modal`. */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poLookupLiteralsDefault[poLocaleDefault]), poLookupLiteralsDefault[this.language]), value);
      if (value.modalTitle) {
        this.title = this.literals.modalTitle;
      }
    } else {
      this._literals = poLookupLiteralsDefault[this.language];
    }
    this.primaryAction.label = this.literals.modalPrimaryActionLabel;
    this.secondaryAction.label = this.literals.modalSecondaryActionLabel;
    this.setTableLiterals();
  }
  get literals() {
    return this._literals || poLookupLiteralsDefault[this.language];
  }
  /** Título da modal. */
  set title(value) {
    this._title = isTypeof(value, "string") ? value : this.literals.modalTitle;
  }
  get title() {
    return this._title;
  }
  constructor(languageService, changeDetector) {
    this.changeDetector = changeDetector;
    this.language = languageService.getShortLanguage();
  }
  ngOnDestroy() {
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.searchSubscription) {
      this.searchSubscription.unsubscribe();
    }
    if (this.showMoreSubscription) {
      this.showMoreSubscription.unsubscribe();
    }
  }
  ngOnInit() {
    this.setAdvancedFilterModalProperties();
    this.initializeData();
    this.setTableLiterals();
  }
  createDisclaimer() {
    this.disclaimerGroup.disclaimers = [];
    this.searchValue = "";
    for (const [key, value] of Object.entries(this.dynamicFormValue)) {
      this.addDisclaimer(value, key);
    }
    if (!Object.values(this.dynamicFormValue).some((v) => v !== null && typeof v !== "undefined")) {
      this.initializeData();
    }
  }
  addDisclaimer(value, property) {
    this.disclaimerLabel = "";
    const fieldFilter = this.advancedFilters.find((filter2) => filter2.property === property);
    this.disclaimer = { property };
    this.disclaimer.value = value;
    const labelProperty = fieldFilter.label || capitalizeFirstLetter(fieldFilter.property);
    if (fieldFilter.type === "currency" && value) {
      this.formatValueToCurrency(fieldFilter, value);
    }
    if (fieldFilter.type === "boolean" && (value === true || value === false)) {
      this.formatValueToBoolean(fieldFilter, value);
    }
    if (fieldFilter.options && value) {
      this.applyDisclaimerLabelValue(fieldFilter, value);
    }
    if (!this.disclaimerLabel) {
      this.disclaimerLabel = this.disclaimer.value;
    }
    this.disclaimer.label = `${labelProperty}: ${this.disclaimerLabel}`;
    this.disclaimerGroup.disclaimers = [...this.disclaimerGroup.disclaimers, this.disclaimer];
  }
  onChangeDisclaimerGroup() {
    if (!this.searchValue) {
      this.isLoading = true;
      this.searchValue = "";
      this.searchFilteredItems();
    }
  }
  search() {
    this.page = 1;
    if (this.searchValue) {
      this.isLoading = true;
      this.disclaimerGroup.disclaimers = [];
      this.searchFilteredItems();
    } else {
      this.initializeData();
    }
  }
  searchFilteredItems() {
    this.searchSubscription = this.getFilteredItems(this.searchValue).pipe(catchError((error) => {
      this.setLookupResponseProperties();
      return throwError(error);
    })).subscribe((data) => this.setLookupResponseProperties(data), () => {
    });
  }
  showMoreEvent() {
    this.page++;
    this.isLoading = true;
    this.showMoreSubscription = this.getFilteredItems(this.searchValue).pipe(catchError((error) => {
      this.hasNext = false;
      this.isLoading = false;
      return throwError(error);
    })).subscribe((data) => {
      this.items = [...this.items, ...data.items];
      this.hasNext = data.hasNext;
      this.isLoading = false;
      this.changeDetector.detectChanges();
      this.setSelectedItems();
    }, () => {
    });
  }
  //Método responsável por selecionar as linhas quando abre o modal.
  setSelectedItems() {
    this.selecteds.forEach((selectedItem) => {
      if (this.multiple) {
        this.poTable.selectRowItem((item) => item[this.fieldValue] === selectedItem.value);
      } else {
        this.poTable.selectRowItem((item) => item[this.fieldValue] === selectedItem[this.fieldValue]);
      }
    });
  }
  //Método responsável por criar os disclaimers quando abre o modal.
  setDisclaimersItems() {
    if (this.selectedItems && !Array.isArray(this.selectedItems)) {
      this.multiple ? this.selecteds = [{ value: this.selectedItems }] : this.selecteds = [this.selectedItems];
      return;
    }
    if (this.selectedItems && this.selectedItems.length) {
      this.selecteds = [...this.selectedItems];
    }
  }
  applyDisclaimerLabelValue(field, filterValue) {
    const values = Array.isArray(filterValue) ? filterValue : [filterValue];
    const labels = values.map((optionValue) => {
      const findOption = field.options.find((option) => option.value === optionValue);
      return findOption.label;
    });
    if (labels.join()) {
      this.disclaimerLabel = labels.join(", ");
    }
  }
  formatValueToCurrency(field, filterValue) {
    const currencyLabel = new Intl.NumberFormat(field.locale ? field.locale : this.language, {
      minimumFractionDigits: 2
    }).format(filterValue);
    this.disclaimerLabel = currencyLabel;
  }
  formatValueToBoolean(field, filterValue) {
    let labelBoolean;
    if (filterValue) {
      labelBoolean = field.booleanTrue ? field.booleanTrue : filterValue;
    } else {
      labelBoolean = field.booleanFalse ? field.booleanFalse : filterValue;
    }
    this.disclaimerLabel = `${labelBoolean}`;
  }
  setAdvancedFilterModalProperties() {
    this.advancedFilterModalTitle = this.literals.modalAdvancedSearchTitle;
    this.disclaimerGroup = {
      title: this.literals.modalDisclaimerGroupTitle,
      disclaimers: []
    };
    this.primaryActionAdvancedFilter = {
      action: () => {
        this.destroyDynamicForm();
        this.isAdvancedFilter = false;
        this.page = 1;
        this.createDisclaimer();
      },
      label: this.literals.modalAdvancedSearchPrimaryActionLabel
    };
    this.secondaryActionAdvancedFilter = {
      action: () => {
        this.destroyDynamicForm();
        this.isAdvancedFilter = false;
      },
      label: this.literals.modalAdvancedSearchSecondaryActionLabel
    };
  }
  getAdvancedFilters(advancedParams) {
    if (advancedParams && advancedParams.length > 0) {
      const filters = {};
      let validatedAdvacendFilters;
      advancedParams.forEach((filter2) => {
        filters[filter2.property] = filter2.value instanceof Array ? filter2.value.join() : filter2.value;
        validatedAdvacendFilters = __spreadValues(__spreadValues({}, validatedAdvacendFilters), filters);
      });
      return validatedAdvacendFilters;
    }
    return void 0;
  }
  getFilteredItems(filter2) {
    const filteredParams = this.getFilteredParams(filter2);
    return this.filterService.getFilteredItems(filteredParams);
  }
  getFilteredParams(filter2) {
    const { page, pageSize, filterParams, sort } = this;
    const filteredParams = {};
    const order = this.getOrderParam(sort);
    const advancedFilters = this.getAdvancedFilters(this.disclaimerGroup.disclaimers);
    const params = { filter: filter2, page, pageSize, order, filterParams, advancedFilters };
    for (const key in params) {
      if (params.hasOwnProperty(key) && params[key] !== void 0) {
        filteredParams[key] = params[key];
      }
    }
    return filteredParams;
  }
  getOrderParam(sort = { type: void 0 }) {
    const { column, type } = sort;
    if (!column) {
      return;
    }
    if (type === PoTableColumnSortType.Descending) {
      return `-${column.property}`;
    }
    return `${column.property}`;
  }
  initializeData() {
    this.isLoading = true;
    this.filterSubscription = this.getFilteredItems("").subscribe((data) => {
      this.setLookupResponseProperties(data);
    });
  }
  setLookupResponseProperties(data) {
    this.items = data?.items ?? [];
    this.hasNext = data?.hasNext ?? false;
    this.isLoading = false;
    this.changeDetector.detectChanges();
    this.setDisclaimersItems();
    this.setSelectedItems();
  }
  setTableLiterals() {
    this.tableLiterals = {
      "noColumns": this.literals.modalTableNoColumns,
      "noData": this.literals.modalTableNoData,
      "loadingData": this.literals.modalTableLoadingData,
      "loadMoreData": this.literals.modalTableLoadMoreData
    };
  }
  static ɵfac = function PoLookupModalBaseComponent_Factory(t) {
    return new (t || _PoLookupModalBaseComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoLookupModalBaseComponent, viewQuery: function PoLookupModalBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoModalComponent, 7);
      ɵɵviewQuery(PoTableComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poModal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poTable = _t.first);
    }
  }, inputs: { advancedFilters: [InputFlags.None, "p-advanced-filters", "advancedFilters"], columns: [InputFlags.None, "p-columns", "columns"], items: [InputFlags.None, "p-items", "items"], filterService: [InputFlags.None, "p-filter-service", "filterService"], filterParams: [InputFlags.None, "p-filter-params", "filterParams"], hideColumnsManager: [InputFlags.HasDecoratorInputTransform, "p-hide-columns-manager", "hideColumnsManager", convertToBoolean], infiniteScroll: [InputFlags.HasDecoratorInputTransform, "p-infinite-scroll", "infiniteScroll", convertToBoolean], multiple: [InputFlags.HasDecoratorInputTransform, "p-multiple", "multiple", convertToBoolean], selectedItems: [InputFlags.None, "p-selected-items", "selectedItems"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], literals: [InputFlags.None, "p-literals", "literals"], title: [InputFlags.None, "p-title", "title"] }, outputs: { model: "p-change-model", changeVisibleColumns: "p-change-visible-columns", columnRestoreManager: "p-restore-column-manager" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupModalBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }, { type: ChangeDetectorRef }], { poModal: [{
    type: ViewChild,
    args: [PoModalComponent, { static: true }]
  }], poTable: [{
    type: ViewChild,
    args: [PoTableComponent, { static: true }]
  }], advancedFilters: [{
    type: Input,
    args: ["p-advanced-filters"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], filterService: [{
    type: Input,
    args: ["p-filter-service"]
  }], filterParams: [{
    type: Input,
    args: ["p-filter-params"]
  }], hideColumnsManager: [{
    type: Input,
    args: [{ alias: "p-hide-columns-manager", transform: convertToBoolean }]
  }], infiniteScroll: [{
    type: Input,
    args: [{ alias: "p-infinite-scroll", transform: convertToBoolean }]
  }], multiple: [{
    type: Input,
    args: [{ alias: "p-multiple", transform: convertToBoolean }]
  }], model: [{
    type: Output,
    args: ["p-change-model"]
  }], selectedItems: [{
    type: Input,
    args: ["p-selected-items"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], changeVisibleColumns: [{
    type: Output,
    args: ["p-change-visible-columns"]
  }], columnRestoreManager: [{
    type: Output,
    args: ["p-restore-column-manager"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }] });
})();
var PoDynamicFormBaseComponent = class _PoDynamicFormBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Nome da propriedade, atribuída ao `PoDynamicFormField.property`, que iniciará o campo com foco.
   */
  autoFocus;
  /**
   * @description
   *
   * Coleção de objetos que implementam a interface `PoDynamicFormField`, para definição dos campos que serão criados
   * dinamicamente.
   *
   * > Ex: `[ { property: 'name' } ]`
   *
   * Regras de tipagem e criação dos componentes:
   *
   * - Caso o *type* informado seja *boolean* o componente criado será o `po-switch`.
   * - Caso o *type* informado seja *currency* e não seja informado um *mask* ou *pattern* o componente criado será o `po-decimal`,
   * caso seja informado um *mask* ou *pattern* o componente criado será o `po-input`.
   * - Caso o *type* informado seja *number* e não seja informado um *mask* ou *pattern* o componente criado será o `po-number`, caso seja
   * informado um *mask* ou *pattern* o componente criado será o `po-input`.
   * - Caso a lista possua a propriedade `options` e a mesma possua até 3 itens o componente criado será o `po-radio-group`
   * ou `po-checkbox-group` se informar a propriedade `optionsMulti`.
   * - Caso a mesma possua 3 ou mais itens, será criado o componente `po-select` ou, `po-multiselect` se a propriedade `optionsMulti`
   * for verdadeira.
   * - Caso o *type* informado seja *date* ou *datetime* o componente criado será o `po-datepicker`.
   * - Caso seja informado a propriedade `optionsService` o componente criado será o `po-combo`.
   * - Caso o *type* informado seja *time* o componente criado será um `po-input` podendo receber um *mask* para formatar
   * o valor exibido, caso não seja informado um *mask* o componente será criado com a máscara '99:99' por padrão.
   * - Caso a lista possua a propriedade `rows` e esta seja definida com valor maior ou igual a 3 o componente criado será
   * o `po-textarea`, caso o valor da propriedade `rows` seja menor que 3 o componente criado será o `po-input`.
   * - Caso seja informada a propriedade `secret` o componente criado será o `po-password`.
   * - Caso o *type* informado seja *string* o componente criado será o `po-input`.
   *
   * @default `[]`
   */
  fields;
  /**
   * Objeto que será utilizado como valor para exibir as informações, será recuperado e preenchido através do atributo *property*
   * dos objetos contidos na propridade `p-fields`.
   *
   * Pode iniciar com valor ou apenas com um objeto vazio que será preenchido conforme descrito acima.
   *
   * > Ex: `{ name: 'po' }`
   */
  value;
  /**
   * @optional
   *
   * @description
   *
   * Na inicialização do componente será repassado o objeto de formulário utilizado no componente,
   * podendo ser utilizado para validações e/ou detecção de mudança dos valores.
   *
   * Portanto existem duas maneiras de recuperar o formulário,
   * através de *template reference* e através do *output*, veja os exemplos abaixo:
   *
   * > *template reference*
   *
   * ```html
   *  <po-dynamic-form #dynamicForm>
   *  </po-dynamic-form>
   *
   *  <po-button p-label="Adicionar" [p-disabled]="dynamicForm?.form.invalid">
   *  </po-button>
   *
   * ```
   *
   * > *Output*
   *
   * ```html
   *  ...
   *  <po-dynamic-form (p-form)="getForm($event)">
   *  </po-dynamic-form>
   *
   *  <po-button p-label="Adicionar" [p-disabled]="dynamicForm?.invalid">
   *  </po-button>
   *  ...
   *
   * ```
   *
   * ```ts
   *  ...
   *
   *  export class AppComponent {
   *
   *    dynamicForm: NgForm;
   *
   *    getForm(form: NgForm) {
   *      this.dynamicForm = form;
   *    }
   *
   *  }
   * ```
   *
   * > Caso a propriedade `p-group-form` for verdadeira não será repassado o formulário, pois o mesmo utilizará
   * o formulário pai.
   */
  formOutput = new EventEmitter();
  /**
   * Função ou serviço que será executado na inicialização do componente.
   *
   * A propriedade aceita os seguintes tipos:
   * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.
   * - `function`: Método que será executado.
   *
   * Ao ser executado, irá receber como parâmetro o objeto informado no `p-value`.
   *
   * O retorno desta função deve ser do tipo [PoDynamicFormLoad](documentation/po-dynamic-form#po-dynamic-form-load),
   * onde o usuário poderá determinar as novas atualizações dos campos, valores e determinar o campo a ser focado.
   *
   * Por exemplo:
   *
   * ```
   * onLoadFields(): PoDynamicFormLoad {
   *
   *   return {
   *     value: { cpf: undefined },
   *     fields: [
   *       { property: 'cpf' }
   *     ],
   *     focus: 'cpf'
   *   };
   * }
   *
   * ```
   * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:
   * ```
   *  [p-load]="onLoadFields.bind(this)"
   * ```
   */
  load;
  /**
   * Função ou serviço para validar as **mudanças do formulário**.
   *
   * A propriedade aceita os seguintes tipos:
   * - `string`: *Endpoint* usado pelo componente para requisição via `POST`.
   * - `function`: Método que será executado.
   *
   * Ao ser executado, irá receber como parâmetro um objeto com o nome da propriedade
   * alterada e o novo valor, conforme a interface `PoDynamicFormFieldChanged`:
   *
   * ```
   * { property: 'property name', value: 'new value' }
   * ```
   *
   * O retorno desta função deve ser do tipo [PoDynamicFormValidation](documentation/po-dynamic-form#po-dynamic-form-validation),
   * onde o usuário poderá determinar as novas atualizações dos campos.
   * Por exemplo:
   *
   * ```
   * onChangeFields(changeValue): PoDynamicFormValidation {
   *
   * if (changeValue.property === 'state') {
   *
   *   return {
   *     value: { city: undefined },
   *     fields: [
   *       { property: 'city', options: this.getCity(changeValue.value.state) }
   *     ],
   *     focus: 'city'
   *   };
   * }
   *
   * ```
   * Para referenciar a sua função utilize a propriedade `bind`, por exemplo:
   * ```
   *  [p-validate]="this.myFunction.bind(this)"
   * ```
   *
   * > Se houver uma lista de campos para validação definida em `p-validate-fields`, a propriedade `validate` só receberá o disparo para os campos equivalentes.
   */
  validate;
  /**
   * @optional
   *
   * @description
   *
   * Lista que define os campos que irão disparar o validate do form.
   */
  validateFields;
  _groupForm = false;
  /**
   * @optional
   *
   * @description
   * Ao informar esta propriedade, o componente passará a utilizar o formulário pai para criar os `FormControl`
   * e com isso é possível recuperar o valor do formulário e suas validações a partir do formulário pai.
   *
   * ```html
   * <form #parentForm="ngForm">
   *
   *   <po-dynamic-form p-group-form [p-fields]="fields"></po-dynamic-form>
   *
   *  <po-button p-label="Adicionar" [p-disabled]="parentForm.invalid"></po-button>
   * </form>
   * ```
   */
  set groupForm(value) {
    this._groupForm = value === "" ? true : convertToBoolean(value);
  }
  get groupForm() {
    return this._groupForm;
  }
  /**
   * @optional
   *
   * @description
   *
   * Ao informar esta propriedade, o componente passará a emitir o valor a cada caractere digitado.
   *
   * Pode ser aplicado nos seguintes componentes:
   * - po-input
   * - po-number
   * - po-decimal
   * - po-textarea
   * - po-password
   *
   * Deve informar os campos que deseja receber as emissões na propriedade `p-validate-fields`.
   *
   *
   */
  validateOnInput = false;
  static ɵfac = function PoDynamicFormBaseComponent_Factory(t) {
    return new (t || _PoDynamicFormBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDynamicFormBaseComponent, inputs: { autoFocus: [InputFlags.None, "p-auto-focus", "autoFocus"], fields: [InputFlags.None, "p-fields", "fields"], value: [InputFlags.None, "p-value", "value"], load: [InputFlags.None, "p-load", "load"], validate: [InputFlags.None, "p-validate", "validate"], validateFields: [InputFlags.None, "p-validate-fields", "validateFields"], groupForm: [InputFlags.None, "p-group-form", "groupForm"], validateOnInput: [InputFlags.HasDecoratorInputTransform, "p-validate-on-input", "validateOnInput", convertToBoolean] }, outputs: { formOutput: "p-form" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormBaseComponent, [{
    type: Directive
  }], null, { autoFocus: [{
    type: Input,
    args: ["p-auto-focus"]
  }], fields: [{
    type: Input,
    args: ["p-fields"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], formOutput: [{
    type: Output,
    args: ["p-form"]
  }], load: [{
    type: Input,
    args: ["p-load"]
  }], validate: [{
    type: Input,
    args: ["p-validate"]
  }], validateFields: [{
    type: Input,
    args: ["p-validate-fields"]
  }], groupForm: [{
    type: Input,
    args: ["p-group-form"]
  }], validateOnInput: [{
    type: Input,
    args: [{ alias: "p-validate-on-input", transform: convertToBoolean }]
  }] });
})();
var PoDynamicFormOperation = class {
  http;
  constructor(http) {
    this.http = http;
  }
  execute(action, param) {
    return typeof action === "string" ? this.post(action, param) : of(action(param));
  }
  post(url, body) {
    return this.http.post(url, body);
  }
  setFormDefaultIfEmpty(validateFields) {
    return validateFields || {
      value: {},
      fields: [],
      focus: void 0
    };
  }
};
var PoDynamicFormLoadService = class _PoDynamicFormLoadService extends PoDynamicFormOperation {
  constructor(http) {
    super(http);
  }
  createAndUpdateFieldsForm(loadedFields = [], fields = []) {
    return [...loadedFields].reduce((updatedFields, field) => {
      const index = updatedFields.findIndex((updatedField) => updatedField.property === field.property);
      const hasProperty = index >= 0;
      if (hasProperty) {
        updatedFields[index] = __spreadValues(__spreadValues({}, fields[index]), field);
      } else {
        updatedFields.push(field);
      }
      return updatedFields;
    }, [...fields]);
  }
  executeLoad(load, value) {
    return this.execute(load, value).pipe(map((loadedFormdData) => this.setFormDefaultIfEmpty(loadedFormdData)));
  }
  static ɵfac = function PoDynamicFormLoadService_Factory(t) {
    return new (t || _PoDynamicFormLoadService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoDynamicFormLoadService, factory: _PoDynamicFormLoadService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormLoadService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var PoDynamicFormValidationService = class _PoDynamicFormValidationService extends PoDynamicFormOperation {
  constructor(http) {
    super(http);
  }
  sendFieldChange(field, value) {
    const changedValue = { property: field.property, value };
    return this.execute(field.validate, changedValue).pipe(map((validateFields) => this.setFieldDefaultIfEmpty(validateFields)));
  }
  sendFormChange(validate, field, value) {
    const changedValue = { property: field.property, value };
    return this.execute(validate, changedValue).pipe(map((validateFields) => this.setFormDefaultIfEmpty(validateFields)));
  }
  updateFieldsForm(validatedFields = [], fields = []) {
    return [...validatedFields].reduce((updatedFields, validatedField) => {
      const index = updatedFields.findIndex((field) => field.property === validatedField.property);
      const hasProperty = index >= 0;
      if (hasProperty) {
        updatedFields[index] = __spreadValues(__spreadValues({}, fields[index]), validatedField);
      }
      return updatedFields;
    }, [...fields]);
  }
  setFieldDefaultIfEmpty(validateFields) {
    return validateFields || {
      field: {}
    };
  }
  static ɵfac = function PoDynamicFormValidationService_Factory(t) {
    return new (t || _PoDynamicFormValidationService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoDynamicFormValidationService, factory: _PoDynamicFormValidationService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormValidationService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var _c0$P = ["fieldsComponent"];
var _c1$k = ["dynamicForm"];
function PoDynamicFormComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoDynamicFormComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dynamic-form-fields", 3, 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-auto-focus", ctx_r1.autoFocus)("p-fields", ctx_r1.fields)("p-value", ctx_r1.value);
  }
}
function PoDynamicFormComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "form", null, 5)(2, "po-dynamic-form-fields", 6, 4);
    ɵɵtwoWayListener("p-fieldsChange", function PoDynamicFormComponent_ng_template_3_Template_po_dynamic_form_fields_p_fieldsChange_2_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r8.fields, $event) || (ctx_r8.fields = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-object-value", function PoDynamicFormComponent_ng_template_3_Template_po_dynamic_form_fields_p_object_value_2_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.sendObjectValue($event));
    })("p-form-validate", function PoDynamicFormComponent_ng_template_3_Template_po_dynamic_form_fields_p_form_validate_2_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.validateForm($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtwoWayProperty("p-fields", ctx_r3.fields);
    ɵɵproperty("p-auto-focus", ctx_r3.autoFocus)("p-disabled-form", ctx_r3.disabledForm)("p-validate", ctx_r3.validate)("p-validate-fields", ctx_r3.validateFields)("p-validate-on-input", ctx_r3.validateOnInput)("p-value", ctx_r3.value);
  }
}
var PoDynamicFormComponent = class _PoDynamicFormComponent extends PoDynamicFormBaseComponent {
  changes;
  loadService;
  validationService;
  fieldsComponent;
  disabledForm;
  _form;
  onLoadSubscription;
  sendFormSubscription;
  comboOptionSubject = new Subject();
  set form(value) {
    setTimeout(() => {
      this._form = value;
      this.emitForm();
    });
  }
  get form() {
    return this._form || {};
  }
  constructor(changes, loadService, validationService) {
    super();
    this.changes = changes;
    this.loadService = loadService;
    this.validationService = validationService;
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  ngOnInit() {
    if (this.load) {
      this.loadDataOnInitialize();
    }
  }
  /**
   * Função que atribui foco ao campo desejado.
   *
   * Para utilizá-la é necessário capturar a instância do `dynamic form`, como por exemplo:
   *
   * ``` html
   * <po-dynamic-form #dynamicForm [p-fields]="fields"></po-dynamic-form>
   * ```
   *
   * ``` javascript
   * import { PoDynamicFormComponent, PoDynamicFormField } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild('dynamicForm', { static: true }) dynamicForm: PoDynamicFormComponent;
   *
   * fields: Array<PoDynamicFormField> = [
   *   { property: 'fieldOne' },
   *   { property: 'fieldTwo' }
   * ];
   *
   * fieldFocus() {
   *   this.dynamicForm.focus('fieldTwo');
   * }
   * ```
   *
   * @param {string} property Nome da propriedade atribuída ao `PoDynamicFormField.property`.
   */
  focus(property) {
    this.fieldsComponent.focus(property);
  }
  getObjectValue() {
    return this.comboOptionSubject.asObservable();
  }
  sendObjectValue(objectValue) {
    this.comboOptionSubject.next(objectValue);
  }
  validateForm(field) {
    const previousFocusElement = document.activeElement;
    this.disableForm(true);
    const errorOnValidation = () => this.disableForm(false);
    this.sendFormSubscription = this.validationService.sendFormChange(this.validate, field, this.value).subscribe(this.applyFormValidation(previousFocusElement), errorOnValidation);
  }
  applyFormUpdatesOnLoad(previousFocusElement) {
    return (dynamicFormData) => {
      this.updateModelOnLoad(dynamicFormData);
      this.disableForm(false);
      this.setFocusOnFieldByProperty(dynamicFormData.focus, previousFocusElement);
    };
  }
  applyFormValidation(previousFocusElement) {
    return (dynamicFormData) => {
      this.updateModelWithValidation(dynamicFormData);
      this.disableForm(false);
      this.setFocusOnFieldByProperty(dynamicFormData.focus, previousFocusElement);
    };
  }
  disableForm(value) {
    this.disabledForm = value;
    this.changes.detectChanges();
  }
  emitForm() {
    if (!this.groupForm && this.formOutput.observers.length) {
      this.formOutput.emit(this.form);
    }
  }
  loadDataOnInitialize() {
    const previousFocusElement = document.activeElement;
    this.disabledForm = true;
    const errorOnLoad = () => this.disabledForm = false;
    this.onLoadSubscription = this.loadService.executeLoad(this.load, this.value).subscribe(this.applyFormUpdatesOnLoad(previousFocusElement), errorOnLoad);
  }
  removeListeners() {
    if (this.onLoadSubscription) {
      this.onLoadSubscription.unsubscribe();
    }
    if (this.sendFormSubscription) {
      this.sendFormSubscription.unsubscribe();
    }
  }
  setFocusOnFieldByProperty(property, previousFocusElement) {
    if (property) {
      setTimeout(() => this.focus(property));
    } else {
      previousFocusElement["focus"]();
    }
  }
  updateModelOnLoad(loadedFormData) {
    Object.assign(this.value, loadedFormData.value);
    this.fields = this.loadService.createAndUpdateFieldsForm(loadedFormData.fields, this.fields);
  }
  updateModelWithValidation(formData) {
    Object.assign(this.value, formData.value);
    this.fieldsComponent.updatePreviousValue();
    this.fields = this.validationService.updateFieldsForm(formData.fields, this.fields);
  }
  static ɵfac = function PoDynamicFormComponent_Factory(t) {
    return new (t || _PoDynamicFormComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoDynamicFormLoadService), ɵɵdirectiveInject(PoDynamicFormValidationService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDynamicFormComponent, selectors: [["po-dynamic-form"]], viewQuery: function PoDynamicFormComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$P, 5);
      ɵɵviewQuery(_c1$k, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fieldsComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.form = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 5, vars: 3, consts: [[4, "ngIf", "ngIfThen", "ngIfElse"], ["reuseFormTemplate", ""], ["uniqueFormTemplate", ""], [3, "p-auto-focus", "p-fields", "p-value"], ["fieldsComponent", ""], ["dynamicForm", "ngForm"], [3, "p-fields", "p-auto-focus", "p-disabled-form", "p-validate", "p-validate-fields", "p-validate-on-input", "p-value", "p-fieldsChange", "p-object-value", "p-form-validate"]], template: function PoDynamicFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoDynamicFormComponent_ng_container_0_Template, 1, 0, "ng-container", 0)(1, PoDynamicFormComponent_ng_template_1_Template, 2, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, PoDynamicFormComponent_ng_template_3_Template, 4, 7, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(2);
      const _r4 = ɵɵreference(4);
      ɵɵproperty("ngIf", ctx.groupForm)("ngIfThen", _r2)("ngIfElse", _r4);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormComponent, [{
    type: Component,
    args: [{ selector: "po-dynamic-form", template: '<ng-container *ngIf="groupForm; then reuseFormTemplate; else uniqueFormTemplate"></ng-container>\n\n<ng-template #reuseFormTemplate>\n  <po-dynamic-form-fields #fieldsComponent [p-auto-focus]="autoFocus" [p-fields]="fields" [p-value]="value">\n  </po-dynamic-form-fields>\n</ng-template>\n\n<ng-template #uniqueFormTemplate>\n  <form #dynamicForm="ngForm">\n    <po-dynamic-form-fields\n      #fieldsComponent\n      [(p-fields)]="fields"\n      [p-auto-focus]="autoFocus"\n      [p-disabled-form]="disabledForm"\n      [p-validate]="validate"\n      [p-validate-fields]="validateFields"\n      [p-validate-on-input]="validateOnInput"\n      [p-value]="value"\n      (p-object-value)="sendObjectValue($event)"\n      (p-form-validate)="validateForm($event)"\n    >\n    </po-dynamic-form-fields>\n  </form>\n</ng-template>\n' }]
  }], () => [{ type: ChangeDetectorRef }, { type: PoDynamicFormLoadService }, { type: PoDynamicFormValidationService }], { fieldsComponent: [{
    type: ViewChild,
    args: ["fieldsComponent"]
  }], form: [{
    type: ViewChild,
    args: ["dynamicForm"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicFormComponent, { className: "PoDynamicFormComponent", filePath: "lib/components/po-dynamic/po-dynamic-form/po-dynamic-form.component.ts", lineNumber: 34 });
})();
var _c0$O = ["inpsearch"];
var _c1$j = ["container"];
function PoLookupModalComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16)(1, "span", 17);
    ɵɵlistener("click", function PoLookupModalComponent_div_9_Template_span_click_1_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onAdvancedFilter());
    })("keydown.enter", function PoLookupModalComponent_div_9_Template_span_keydown_enter_1_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.onAdvancedFilter());
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.literals.modalAdvancedSearch, " ");
  }
}
function PoLookupModalComponent_po_disclaimer_group_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-group", 18);
    ɵɵlistener("p-change", function PoLookupModalComponent_po_disclaimer_group_10_Template_po_disclaimer_group_p_change_0_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.onChangeDisclaimerGroup());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-disclaimers", ctx_r3.disclaimerGroup == null ? null : ctx_r3.disclaimerGroup.disclaimers)("p-title", ctx_r3.disclaimerGroup == null ? null : ctx_r3.disclaimerGroup.title);
  }
}
function PoLookupModalComponent_po_disclaimer_group_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-group", 19);
    ɵɵlistener("p-remove", function PoLookupModalComponent_po_disclaimer_group_14_Template_po_disclaimer_group_p_remove_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext();
      return ɵɵresetView(ctx_r12.onUnselectFromDisclaimer($event.removedDisclaimer));
    })("p-remove-all", function PoLookupModalComponent_po_disclaimer_group_14_Template_po_disclaimer_group_p_remove_all_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.onAllUnselected($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("p-disclaimers", ctx_r5.selecteds);
  }
}
var PoLookupModalComponent = class _PoLookupModalComponent extends PoLookupModalBaseComponent {
  componentFactory;
  inputSearchEl;
  container;
  keyUpObservable = null;
  tableHeight;
  componentRef;
  dynamicForm;
  constructor(componentFactory, poLanguage, changeDetector) {
    super(poLanguage, changeDetector);
    this.componentFactory = componentFactory;
  }
  ngOnInit() {
    super.ngOnInit();
    this.setTableHeight();
  }
  ngAfterViewInit() {
    this.initializeEventInput();
  }
  // Seleciona um item na tabela
  onSelect(item) {
    if (this.multiple) {
      this.selecteds = [...this.selecteds, __spreadValues({ value: item[this.fieldValue], label: item[this.fieldLabel] }, item)];
    } else {
      this.selecteds = [__spreadValues({ value: item[this.fieldValue], label: item[this.fieldLabel] }, item)];
    }
  }
  // Remove a seleção de um item na tabela
  onUnselect(unselectedItem) {
    this.selecteds = this.selecteds.filter((itemSelected) => itemSelected.value !== unselectedItem[this.fieldValue]);
  }
  onUnselectFromDisclaimer(removedDisclaimer) {
    this.poTable.unselectRowItem((item) => item[this.fieldValue] === removedDisclaimer.value);
  }
  // Seleciona todos os itens visíveis na tabela
  onAllSelected(items) {
    this.selecteds = items.map((item) => __spreadValues({ value: item[this.fieldValue], label: item[this.fieldLabel] }, item));
  }
  // Remove a seleção de todos os itens visíveis na tabela
  onAllUnselected(items) {
    this.poTable.unselectRows();
    this.selecteds = [];
  }
  initializeEventInput() {
    this.keyUpObservable = fromEvent(this.inputSearchEl.nativeElement, "keyup").pipe(filter((e) => this.validateEnterPressed(e)), debounceTime(400));
    this.keyUpObservable.subscribe(() => {
      this.search();
      this.changeDetector.detectChanges();
    });
  }
  openModal() {
    this.poModal.open();
  }
  sortBy(sort) {
    const order = sort.type === "ascending" ? true : false;
    sortArrayOfObjects(this.items, sort.column.property, order);
    this.sort = sort;
  }
  destroyDynamicForm() {
    if (this.componentRef) {
      this.componentRef.destroy();
    }
  }
  onAdvancedFilter() {
    this.setupModalAdvancedFilter();
    this.createDynamicForm();
  }
  setTableHeight() {
    this.tableHeight = this.infiniteScroll ? 515 : 615;
  }
  validateEnterPressed(e) {
    return e.keyCode === 13;
  }
  setupModalAdvancedFilter() {
    this.dynamicFormValue = {};
    this.isAdvancedFilter = true;
  }
  createDynamicForm() {
    const component = this.componentFactory.resolveComponentFactory(PoDynamicFormComponent);
    this.componentRef = this.container.createComponent(component);
    this.componentRef.instance.fields = this.advancedFilters;
    this.componentRef.instance.value = this.dynamicFormValue;
    this.componentRef.instance.formOutput.pipe(tap((form) => {
      this.dynamicForm = form;
      this.primaryActionAdvancedFilter.disabled = this.dynamicForm.invalid;
    }), switchMap((form) => form.valueChanges)).subscribe(() => {
      this.primaryActionAdvancedFilter.disabled = this.dynamicForm.invalid;
    });
    this.changeDetector.markForCheck();
  }
  static ɵfac = function PoLookupModalComponent_Factory(t) {
    return new (t || _PoLookupModalComponent)(ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLookupModalComponent, selectors: [["po-lookup-modal"]], viewQuery: function PoLookupModalComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$O, 5);
      ɵɵviewQuery(_c1$j, 5, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputSearchEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 18, vars: 25, consts: [["p-click-out", "false", "p-hide-close", "false", "p-size", "lg", 3, "p-primary-action", "p-secondary-action", "p-title"], [3, "hidden"], [1, "po-lookup-header", "po-pull-right", 3, "p-optional"], [1, "po-lookup-filter-content"], [1, "po-field-icon-container-right"], [1, "po-icon", "po-field-icon", "po-icon-search", "po-icon-input", 3, "click"], ["iconLookup", ""], ["name", "contentSearch", "type", "text", 1, "po-input", "po-input-icon-right", 3, "ngModel", "placeholder", "ngModelChange"], ["inpsearch", ""], ["class", "po-lookup-advanced-search", 4, "ngIf"], ["class", "po-md-12", 3, "p-disclaimers", "p-title", "p-change", 4, "ngIf"], [1, "po-row", "po-lookup-container-table"], [1, "po-md-12", 3, "p-selectable", "p-hide-detail", "p-single-select", "p-hide-action-fixed-columns", "p-sort", "p-columns", "p-height", "p-hide-columns-manager", "p-items", "p-literals", "p-loading", "p-show-more-disabled", "p-infinite-scroll", "p-selected", "p-unselected", "p-all-selected", "p-all-unselected", "p-show-more", "p-sort-by", "p-change-visible-columns", "p-restore-column-manager"], ["poTable", ""], ["class", "po-md-12", 3, "p-disclaimers", "p-remove", "p-remove-all", 4, "ngIf"], ["container", ""], [1, "po-lookup-advanced-search"], ["tabindex", "0", 1, "po-lookup-advanced-search-link", "po-icon-input", 3, "click", "keydown.enter"], [1, "po-md-12", 3, "p-disclaimers", "p-title", "p-change"], [1, "po-md-12", 3, "p-disclaimers", "p-remove", "p-remove-all"]], template: function PoLookupModalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-modal", 0)(1, "div", 1)(2, "po-field-container", 2)(3, "div", 3)(4, "div", 4)(5, "span", 5, 6);
      ɵɵlistener("click", function PoLookupModalComponent_Template_span_click_5_listener() {
        return ctx.search();
      });
      ɵɵelementEnd()();
      ɵɵelementStart(7, "input", 7, 8);
      ɵɵtwoWayListener("ngModelChange", function PoLookupModalComponent_Template_input_ngModelChange_7_listener($event) {
        ɵɵtwoWayBindingSet(ctx.searchValue, $event) || (ctx.searchValue = $event);
        return $event;
      });
      ɵɵelementEnd()();
      ɵɵtemplate(9, PoLookupModalComponent_div_9_Template, 3, 1, "div", 9);
      ɵɵelementEnd();
      ɵɵtemplate(10, PoLookupModalComponent_po_disclaimer_group_10_Template, 1, 2, "po-disclaimer-group", 10);
      ɵɵelementStart(11, "div", 11)(12, "po-table", 12, 13);
      ɵɵlistener("p-selected", function PoLookupModalComponent_Template_po_table_p_selected_12_listener($event) {
        return ctx.onSelect($event);
      })("p-unselected", function PoLookupModalComponent_Template_po_table_p_unselected_12_listener($event) {
        return ctx.onUnselect($event);
      })("p-all-selected", function PoLookupModalComponent_Template_po_table_p_all_selected_12_listener($event) {
        return ctx.onAllSelected($event);
      })("p-all-unselected", function PoLookupModalComponent_Template_po_table_p_all_unselected_12_listener($event) {
        return ctx.onAllUnselected($event);
      })("p-show-more", function PoLookupModalComponent_Template_po_table_p_show_more_12_listener() {
        return ctx.showMoreEvent();
      })("p-sort-by", function PoLookupModalComponent_Template_po_table_p_sort_by_12_listener($event) {
        return ctx.sortBy($event);
      })("p-change-visible-columns", function PoLookupModalComponent_Template_po_table_p_change_visible_columns_12_listener($event) {
        return ctx.changeVisibleColumns.emit($event);
      })("p-restore-column-manager", function PoLookupModalComponent_Template_po_table_p_restore_column_manager_12_listener($event) {
        return ctx.columnRestoreManager.emit($event);
      });
      ɵɵelementEnd()();
      ɵɵtemplate(14, PoLookupModalComponent_po_disclaimer_group_14_Template, 1, 1, "po-disclaimer-group", 14);
      ɵɵelementEnd();
      ɵɵelementStart(15, "div", 1);
      ɵɵelementContainer(16, null, 15);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("p-primary-action", ctx.isAdvancedFilter ? ctx.primaryActionAdvancedFilter : ctx.primaryAction)("p-secondary-action", ctx.isAdvancedFilter ? ctx.secondaryActionAdvancedFilter : ctx.secondaryAction)("p-title", ctx.isAdvancedFilter ? ctx.advancedFilterModalTitle : ctx.title);
      ɵɵadvance();
      ɵɵproperty("hidden", ctx.isAdvancedFilter);
      ɵɵadvance();
      ɵɵproperty("p-optional", false);
      ɵɵadvance(5);
      ɵɵtwoWayProperty("ngModel", ctx.searchValue);
      ɵɵproperty("placeholder", ctx.literals.modalPlaceholder);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.advancedFilters && ctx.advancedFilters.length > 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", !!ctx.disclaimerGroup);
      ɵɵadvance();
      ɵɵattribute("data-multiple", ctx.multiple);
      ɵɵadvance();
      ɵɵproperty("p-selectable", true)("p-hide-detail", true)("p-single-select", !ctx.multiple)("p-hide-action-fixed-columns", true)("p-sort", true)("p-columns", ctx.columns)("p-height", ctx.tableHeight)("p-hide-columns-manager", ctx.hideColumnsManager)("p-items", ctx.items)("p-literals", ctx.tableLiterals)("p-loading", ctx.isLoading)("p-show-more-disabled", !ctx.hasNext)("p-infinite-scroll", ctx.infiniteScroll);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.multiple);
      ɵɵadvance();
      ɵɵproperty("hidden", !ctx.isAdvancedFilter);
    }
  }, encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupModalComponent, [{
    type: Component,
    args: [{ selector: "po-lookup-modal", changeDetection: ChangeDetectionStrategy.OnPush, template: '<po-modal\n  p-click-out="false"\n  p-hide-close="false"\n  p-size="lg"\n  [p-primary-action]="isAdvancedFilter ? primaryActionAdvancedFilter : primaryAction"\n  [p-secondary-action]="isAdvancedFilter ? secondaryActionAdvancedFilter : secondaryAction"\n  [p-title]="isAdvancedFilter ? advancedFilterModalTitle : title"\n>\n  <div [hidden]="isAdvancedFilter">\n    <po-field-container class="po-lookup-header po-pull-right" [p-optional]="false">\n      <div class="po-lookup-filter-content">\n        <div class="po-field-icon-container-right">\n          <span #iconLookup class="po-icon po-field-icon po-icon-search po-icon-input" (click)="search()"> </span>\n        </div>\n\n        <input\n          #inpsearch\n          class="po-input po-input-icon-right"\n          name="contentSearch"\n          [(ngModel)]="searchValue"\n          [placeholder]="literals.modalPlaceholder"\n          type="text"\n        />\n      </div>\n\n      <div *ngIf="advancedFilters && advancedFilters.length > 0" class="po-lookup-advanced-search">\n        <span\n          class="po-lookup-advanced-search-link po-icon-input"\n          tabindex="0"\n          (click)="onAdvancedFilter()"\n          (keydown.enter)="onAdvancedFilter()"\n        >\n          {{ literals.modalAdvancedSearch }}\n        </span>\n      </div>\n    </po-field-container>\n\n    <!-- DISCLAIMER -->\n    <po-disclaimer-group\n      *ngIf="!!disclaimerGroup"\n      class="po-md-12"\n      [p-disclaimers]="disclaimerGroup?.disclaimers"\n      [p-title]="disclaimerGroup?.title"\n      (p-change)="onChangeDisclaimerGroup()"\n    >\n    </po-disclaimer-group>\n\n    <div class="po-row po-lookup-container-table" [attr.data-multiple]="multiple">\n      <po-table\n        #poTable\n        class="po-md-12"\n        [p-selectable]="true"\n        [p-hide-detail]="true"\n        [p-single-select]="!multiple"\n        [p-hide-action-fixed-columns]="true"\n        [p-sort]="true"\n        [p-columns]="columns"\n        [p-height]="tableHeight"\n        [p-hide-columns-manager]="hideColumnsManager"\n        [p-items]="items"\n        [p-literals]="tableLiterals"\n        [p-loading]="isLoading"\n        [p-show-more-disabled]="!hasNext"\n        [p-infinite-scroll]="infiniteScroll"\n        (p-selected)="onSelect($event)"\n        (p-unselected)="onUnselect($event)"\n        (p-all-selected)="onAllSelected($event)"\n        (p-all-unselected)="onAllUnselected($event)"\n        (p-show-more)="showMoreEvent()"\n        (p-sort-by)="sortBy($event)"\n        (p-change-visible-columns)="changeVisibleColumns.emit($event)"\n        (p-restore-column-manager)="columnRestoreManager.emit($event)"\n      >\n      </po-table>\n    </div>\n\n    <!-- DISCLAIMER -->\n    <po-disclaimer-group\n      *ngIf="multiple"\n      class="po-md-12"\n      [p-disclaimers]="selecteds"\n      (p-remove)="onUnselectFromDisclaimer($event.removedDisclaimer)"\n      (p-remove-all)="onAllUnselected($event)"\n    >\n    </po-disclaimer-group>\n  </div>\n  <div [hidden]="!isAdvancedFilter">\n    <ng-container #container> </ng-container>\n  </div>\n</po-modal>\n' }]
  }], () => [{ type: ComponentFactoryResolver$1 }, { type: PoLanguageService }, { type: ChangeDetectorRef }], { inputSearchEl: [{
    type: ViewChild,
    args: ["inpsearch"]
  }], container: [{
    type: ViewChild,
    args: ["container", { read: ViewContainerRef }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLookupModalComponent, { className: "PoLookupModalComponent", filePath: "lib/components/po-field/po-lookup/po-lookup-modal/po-lookup-modal.component.ts", lineNumber: 32 });
})();
var PoLookupFilterService = class _PoLookupFilterService {
  httpClient;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  url;
  fieldValue;
  multiple = false;
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  getFilteredItems(filteredItemsParams) {
    const _a = filteredItemsParams, { filterParams, advancedFilters } = _a, restFilteredItemsParams = __objRest(_a, ["filterParams", "advancedFilters"]);
    const validatedFilterParams = this.validateParams(filterParams);
    const validatedAdvancedFilters = this.validateParams(advancedFilters);
    const params = __spreadValues(__spreadValues(__spreadValues({}, restFilteredItemsParams), validatedFilterParams), validatedAdvancedFilters);
    return this.httpClient.get(this.url, { headers: this.headers, params });
  }
  getObjectByValue(value, filterParams) {
    const validatedFilterParams = this.validateParams(filterParams);
    let newURL;
    let encodedValue;
    if (this.multiple) {
      encodedValue = encodeURIComponent(Array.isArray(value) ? value.join(",") : value);
      newURL = `${this.url}?${this.fieldValue}=${encodedValue}`;
    } else {
      encodedValue = encodeURIComponent(value);
      newURL = `${this.url}/${encodedValue}`;
    }
    return this.httpClient.get(newURL, { headers: this.headers, params: validatedFilterParams }).pipe(map((response) => "items" in response ? response.items : response));
  }
  setConfig(url, fieldValue, multiple) {
    this.url = url;
    this.fieldValue = fieldValue;
    this.multiple = multiple;
  }
  validateParams(params) {
    return isTypeof(params, "object") && !Array.isArray(params) ? params : void 0;
  }
  static ɵfac = function PoLookupFilterService_Factory(t) {
    return new (t || _PoLookupFilterService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoLookupFilterService, factory: _PoLookupFilterService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupFilterService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var PoLookupModalService = class _PoLookupModalService {
  poComponentInjector;
  selectValueEvent = new EventEmitter();
  componentRef = null;
  constructor(poComponentInjector) {
    this.poComponentInjector = poComponentInjector;
  }
  /**
   * Método responsável por abrir a modal de busca das informações.
   *
   * @param advancedFilters {Array<PoDynamicFormField>} Objeto utilizado para criar o busca avançada.
   * @param service {PoLookupFilter} Serviço responsável por realizar a busca no serviço dos dados.
   * @param columns {Array<PoLookupColumn>} Definição das colunas na modal de busca.
   * @param filterParams {any} Valor que será repassado aos métodos do serviço para auxiliar no filtro dos dados.
   * @param title {string} Definição do título da modal.
   * @param literals {PoLookupLiterals} Literais utilizadas no componente.
   * @param selectedItems {any} Valor que está selecionado que será repassado para o modal para apresentar na tabela.
   * @param fieldLabel {string} Valor que será utilizado como descrição do campo.
   * @param fieldValue {string} Valor que será utilizado como valor do campo.
   * @param changeVisibleColumns {function} Função que será executada quando for alterada a visibilidade das colunas.
   * @param columnRestoreManager {function} Função que será executada quando for restaurar as colunas padrão.
   */
  openModal(params) {
    const { advancedFilters, service, columns, filterParams, hideColumnsManager, title, literals, infiniteScroll, multiple, selectedItems, fieldLabel, fieldValue, changeVisibleColumns, columnRestoreManager } = params;
    this.componentRef = this.poComponentInjector.createComponentInApplication(PoLookupModalComponent);
    this.componentRef.instance.advancedFilters = advancedFilters;
    this.componentRef.instance.title = title;
    this.componentRef.instance.columns = columns;
    this.componentRef.instance.filterService = service;
    this.componentRef.instance.filterParams = filterParams;
    this.componentRef.instance.literals = literals;
    this.componentRef.instance.model.subscribe(($event) => {
      this.selectValue($event);
    });
    this.componentRef.instance.infiniteScroll = infiniteScroll;
    this.componentRef.instance.multiple = multiple;
    this.componentRef.instance.selectedItems = selectedItems;
    this.componentRef.instance.fieldLabel = fieldLabel;
    this.componentRef.instance.fieldValue = fieldValue;
    this.componentRef.instance.changeVisibleColumns = changeVisibleColumns;
    this.componentRef.instance.columnRestoreManager = columnRestoreManager;
    this.componentRef.instance.hideColumnsManager = hideColumnsManager;
    this.componentRef.changeDetectorRef.detectChanges();
    this.componentRef.instance.openModal();
  }
  setChangeColumns(columns) {
    if (this.componentRef !== null) {
      this.componentRef.instance.columns = columns;
      this.componentRef.changeDetectorRef.detectChanges();
    }
  }
  // Este metodo é chamado quando é selecionado um item na lookup modal.
  selectValue(value) {
    if (value) {
      this.selectValueEvent.emit(value);
    }
    this.componentRef.destroy();
  }
  static ɵfac = function PoLookupModalService_Factory(t) {
    return new (t || _PoLookupModalService)(ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoLookupModalService, factory: _PoLookupModalService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupModalService, [{
    type: Injectable
  }], () => [{ type: PoComponentInjectorService }], null);
})();
var PoLookupBaseComponent = class _PoLookupBaseComponent {
  defaultService;
  injector;
  poLookupModalService;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * Label do campo.
   *
   * > Quando utilizar esta propriedade o seu valor será utilizado como título da modal do componente caso não tenha
   * sido definido um `modalTitle` na propriedade `p-literals`.
   */
  label;
  /**
   * @description
   *
   * Objeto com as literais usadas no `po-lookup`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoLookupLiterals = {
   *    modalPrimaryActionLabel: 'Select',
   *    modalSecondaryActionLabel: 'Cancel',
   *    modalPlaceholder: 'Search Value',
   *    modalTableNoColumns: 'No columns',
   *    modalTableNoData: 'No data',
   *    modalTableLoadingData: 'Loading data',
   *    modalTableLoadMoreData: 'Load more',
   *    modalTitle: 'Select a user',
   *    modalAdvancedSearch: 'Advanced search',
   *    modalAdvancedSearchTitle: 'Advanced search',
   *    modalAdvancedSearchPrimaryActionLabel: 'Filter',
   *    modalAdvancedSearchSecondaryActionLabel: 'Return',
   *    modalDisclaimerGroupTitle: 'Presenting results filtered by:'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoLookupLiterals = {
   *    modalPrimaryActionLabel: 'Select'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-lookup
   *   [p-literals]="customLiterals">
   * </po-lookup>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  literals;
  /** Texto de apoio do campo. */
  help;
  /** Mensagem que aparecerá enquanto o campo não estiver preenchido. */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /** Nome e Id do componente. */
  name;
  /**
   * @description
   *
   * Indica a coluna que será utilizada como valor do campo.
   *
   * > Atenção: Caso não seja passada ou tenha o conteúdo incorreto, não irá atualizar o model do formulário.
   */
  fieldValue;
  /** Indica a coluna que será utilizada como descrição do campo e como filtro dentro da janela. */
  set fieldLabel(value) {
    this._fieldLabel = value;
    this.keysDescription = [this.fieldLabel];
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /** Valor que será repassado como parâmetro para a URL ou aos métodos do serviço que implementam a interface `PoLookupFilter`. */
  filterParams;
  /**
   * @optional
   *
   * @description
   *
   * Formato de exibição do campo.
   *
   * Recebe uma função que deve retornar uma *string* com o/os valores do objeto formatados para exibição, por exemplo:
   *
   * ```
   * fieldFormat(obj) {
   *   return `${obj.id} - ${obj.name}`;
   * }
   * ```
   * > Esta propriedade sobrepõe o valor da propriedade `p-field-label` na descrição do campo.
   *
   * Pode-se informar uma lista de propriedades que deseja exibir como descrição do campo, Por exemplo:
   * ```
   * <po-lookup
   *  ...
   *  [p-field-format]="['id','nickname']"
   *  ...
   * >
   *
   * Objeto retornado:
   *   {
   *      id:123,
   *      name: 'Kakaroto',
   *      nickname: 'Goku',
   *   }
   * Apresentação no campo: 123 - Goku
   * ```
   *
   * > Será utilizado ` - ` como separador.
   */
  fieldFormat;
  /**
   * Lista das colunas da tabela.
   * Essa propriedade deve receber um array de objetos que implementam a interface PoLookupColumn.
   */
  columns;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   *
   * @optional
   *
   * @description
   *
   * Lista de objetos dos campos que serão criados na busca avançada.
   *
   * > Caso não seja passado um objeto ou então ele esteja em branco o link de busca avançada ficará escondido.
   *
   * Exemplo de URL com busca avançada:
   *
   * ```
   * url + ?page=1&pageSize=20&name=Tony%20Stark&nickname=Homem%20de%20Ferro
   * ```
   *
   * Caso algum parâmetro seja uma lista, a concatenação é feita utilizando vírgula.
   * Exemplo:
   *
   * ```
   * url + ?page=1&pageSize=20&name=Tony%20Stark,Peter%20Parker,Gohan
   * ```
   *
   */
  advancedFilters;
  /**
   * @optional
   *
   * @description
   *
   * Permite que o gerenciador de colunas, responsável pela definição de quais colunas serão exibidas, seja escondido.
   *
   * @default `false`
   */
  hideColumnsManager = false;
  /**
   * @optional
   *
   * @description
   *
   * Ativa a funcionalidade de scroll infinito para a tabela exibida no retorno da consulta.
   *
   * @default `false`
   */
  infiniteScroll = false;
  /** Exibe um ícone que permite limpar o campo. */
  clean = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite a seleção de múltiplos itens.
   *
   * > Quando habilitado o valor do campo passará a ser uma lista de valores, por exemplo: `[ 12345, 67890 ]`
   *
   * @default `false`
   */
  multiple = false;
  /**
   * @optional
   *
   * @description
   *
   * Define que a altura do componente será auto ajustável, possuindo uma altura minima porém a altura máxima será de acordo
   * com o número de itens selecionados e a extensão dos mesmos, mantendo-os sempre visíveis.
   *
   * @default `false`
   */
  autoHeight = false;
  /**
   * Evento será disparado quando ocorrer algum erro na requisição de busca do item.
   * Será passado por parâmetro o objeto de erro retornado.
   */
  onError = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento será disparado quando ocorrer alguma seleção.
   * Será passado por parâmetro o objeto com o valor selecionado.
   */
  selected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   *  Evento que será disparado ao alterar o model.
   *  Por parâmetro será passado o novo valor.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao fechar o popover do gerenciador de colunas após alterar as colunas visíveis.
   *
   * O componente envia como parâmetro um array de string com as colunas visíveis atualizadas.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  changeVisibleColumns = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Evento disparado ao clicar no botão de restaurar padrão no gerenciador de colunas.
   *
   * O componente envia como parâmetro um array de string com as colunas configuradas inicialmente.
   * Por exemplo: ["idCard", "name", "hireStatus", "age"].
   */
  columnRestoreManager = new EventEmitter();
  service;
  selectedOptions = [];
  getSubscription;
  keysDescription;
  oldValue = "";
  valueToModel;
  oldValueToModel = null;
  // eslint-disable-next-line
  onTouched = null;
  resizeListener;
  _disabled = false;
  _fieldLabel;
  _filterService;
  _noAutocomplete;
  _placeholder = "";
  _required = false;
  _autoHeight = false;
  autoHeightInitialValue;
  onChangePropagate = null;
  validatorChange;
  control;
  injectOptions = {
    self: true
  };
  /**
   * Serviço responsável por buscar os dados da tabela na janela. Pode ser informado um serviço que implemente a interface
   * `PoLookupFilter` ou uma URL.
   *
   * Quando utilizada uma URL de um serviço, será concatenada nesta URL o valor que deseja-se filtrar, por exemplo:
   *
   * ```
   * url + ?page=1&pageSize=20&filter=Peter
   * ```
   *
   * Caso utilizar ordenação, a coluna ordenada será enviada através do parâmetro `order`, por exemplo:
   * - Coluna decrescente:
   * ```
   *  url + ?page=1&pageSize=20&filter=Peter&order=-name
   * ```
   *
   * - Coluna ascendente:
   * ```
   *  url + ?page=1&pageSize=20&filter=Peter&order=name
   * ```
   *
   * Se for definido a propriedade `p-filter-params`, o mesmo também será concatenado. Por exemplo, para o
   * parâmetro `{ age: 23 }` a URL ficaria:
   *
   * ```
   * url + ?page=1&pageSize=20&age=23&filter=Peter
   * ```
   *
   * Ao iniciar o campo com valor, os registros serão buscados da seguinte forma:
   * ```
   * model = 1234;
   *
   * GET url/1234
   * ```
   *
   * Caso estiver com múltipla seleção habilitada:
   * ```
   * model = [1234, 5678]
   *
   * GET url?${fieldValue}=1234,5678
   * ```
   *
   * > Esta URL deve retornar e receber os dados no padrão de [API do PO UI](https://po-ui.io/guides/api) e utiliza os valores
   * definidos nas propriedades `p-field-label` e `p-field-value` para a construção do `po-lookup`.
   *
   * Caso o usuário digite um valor e pressione a tecla *TAB* para realizar a busca de um registro específico, o valor que se
   * deseja filtrar será codificado utilizando a função [encodeURIComponent](https://tc39.es/ecma262/#sec-encodeuricomponent-uricomponent)
   * e concatenado na URL da seguinte forma:
   *
   * ```
   * url/valor%20que%20se%20deseja%20filtrar
   * ```
   *
   * > Quando informado um serviço que implemente a interface `PoLookupFilter` o tratamento de encoding do valor a ser filtrado ficará a cargo do desenvolvedor.
   *
   */
  set filterService(filterService) {
    this._filterService = filterService;
    this.setService(this.filterService);
  }
  get filterService() {
    return this._filterService;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a propriedade nativa `autocomplete` do campo como `off`.
   *
   * @default `false`
   */
  set noAutocomplete(value) {
    this._noAutocomplete = convertToBoolean(value);
  }
  get noAutocomplete() {
    return this._noAutocomplete;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.valueToModel);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório seré exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default false
   * @optional
   */
  set disabled(disabled) {
    this._disabled = disabled === "" ? true : convertToBoolean(disabled);
  }
  get disabled() {
    return this._disabled;
  }
  constructor(defaultService, injector, poLookupModalService) {
    this.defaultService = defaultService;
    this.injector = injector;
    this.poLookupModalService = poLookupModalService;
  }
  ngOnDestroy() {
    if (this.getSubscription) {
      this.getSubscription.unsubscribe();
    }
  }
  ngOnInit() {
    this.initializeColumn();
  }
  ngAfterViewInit() {
    this.setControl();
  }
  cleanModel() {
    this.cleanViewValue();
    this.callOnChange(void 0);
  }
  ngOnChanges(changes) {
    if (changes.columns?.currentValue) {
      this.columns = changes.columns.currentValue;
      this.poLookupModalService?.setChangeColumns(this.columns);
    }
    if (changes.multiple && isTypeof(this.filterService, "string")) {
      this.service.setConfig(this.filterService, this.fieldValue, this.multiple);
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  // Função implementada do ControlValueAccessor.
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model.
  registerOnChange(func) {
    this.onChangePropagate = func;
  }
  // Função implementada do ControlValueAccessor.
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model.
  registerOnTouched(func) {
    this.onTouched = func;
  }
  // Seleciona o valor do model.
  selectValue(valueSelected) {
    this.valueToModel = valueSelected;
    this.multiple ? this.callOnChange(this.valueToModel) : this.valueToModel ? this.callOnChange(this.valueToModel[this.fieldValue]) : this.callOnChange(void 0);
    this.selected.emit(valueSelected);
  }
  callOnChange(value) {
    if (this.onChangePropagate) {
      this.onChangePropagate(value);
    }
    if (this.oldValueToModel !== this.valueToModel) {
      this.change.emit(value);
    }
    this.oldValueToModel = this.valueToModel;
  }
  searchById(value) {
    let checkedValue = value;
    if (typeof checkedValue === "string") {
      checkedValue = checkedValue.trim();
    }
    if (checkedValue !== "") {
      const oldDisable = this.disabled;
      this.disabled = true;
      if (this.control) {
        setTimeout(() => this.control.markAsPending());
      }
      this.getSubscription = this.service.getObjectByValue(value, this.filterParams).pipe(finalize(() => {
        this.disabled = oldDisable;
        if (this.control) {
          this.control.updateValueAndValidity();
        }
      })).subscribe((element) => {
        if (element?.length || !Array.isArray(element) && element) {
          if (Array.isArray(element) && element.length > 1) {
            this.setDisclaimers(element);
            this.updateVisibleItems();
          }
          this.selectModel(this.multiple ? element : [element]);
        } else {
          this.cleanModel();
        }
      }, (error) => {
        this.cleanModel();
        this.onError.emit(error);
      });
    } else {
      this.cleanModel();
    }
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(value) {
    if (value?.length || !Array.isArray(value) && value) {
      this.searchById(value);
    } else {
      this.cleanViewValue();
    }
  }
  // Retorna o Subscriber da propriedade getSubscription que ocorre
  // no evento de blur que executa o método searchEvent().
  getSubscriptionFunction() {
    return this.getSubscription;
  }
  cleanViewValue() {
    this.setDisclaimers([]);
    this.setViewValue("", {});
    this.oldValue = "";
    this.valueToModel = null;
  }
  // Formata a label do campo.
  getFormattedLabel(value) {
    return value ? this.keysDescription.map((column) => value[column]).join(" - ") : "";
  }
  // Chama o método writeValue e preenche o model.
  selectModel(options) {
    if (options.length) {
      this.selectedOptions = [...options];
      const newModel = this.multiple ? options.map((option) => option[this.fieldValue]) : options[0];
      this.selectValue(newModel);
      if (options.length === 1) {
        this.oldValue = options[0][this.fieldLabel];
        this.setViewValue(this.getFormattedLabel(options[0]), options[0]);
      }
    } else {
      this.selectValue(void 0);
      this.cleanViewValue();
    }
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  setService(service) {
    if (isTypeof(service, "object")) {
      this.service = service;
    }
    if (service && isTypeof(service, "string")) {
      this.service = this.defaultService;
      this.service.setConfig(service, this.fieldValue, this.multiple);
    }
  }
  setControl() {
    const ngControl = this.injector.get(NgControl, null, this.injectOptions);
    if (ngControl) {
      this.control = ngControl.control;
    }
  }
  initializeColumn() {
    if (this.fieldLabel) {
      this.keysDescription = [this.fieldLabel];
    } else {
      this.keysDescription = [];
      this.keysDescription = this.columns.filter((element) => element.fieldLabel).map((element) => element.property);
    }
  }
  static ɵfac = function PoLookupBaseComponent_Factory(t) {
    return new (t || _PoLookupBaseComponent)(ɵɵdirectiveInject(PoLookupFilterService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(PoLookupModalService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoLookupBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], label: [InputFlags.None, "p-label", "label"], literals: [InputFlags.None, "p-literals", "literals"], help: [InputFlags.None, "p-help", "help"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], name: "name", fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], filterParams: [InputFlags.None, "p-filter-params", "filterParams"], fieldFormat: [InputFlags.None, "p-field-format", "fieldFormat"], columns: [InputFlags.None, "p-columns", "columns"], optional: [InputFlags.None, "p-optional", "optional"], advancedFilters: [InputFlags.None, "p-advanced-filters", "advancedFilters"], hideColumnsManager: [InputFlags.HasDecoratorInputTransform, "p-hide-columns-manager", "hideColumnsManager", convertToBoolean], infiniteScroll: [InputFlags.HasDecoratorInputTransform, "p-infinite-scroll", "infiniteScroll", convertToBoolean], clean: [InputFlags.HasDecoratorInputTransform, "p-clean", "clean", convertToBoolean], multiple: [InputFlags.HasDecoratorInputTransform, "p-multiple", "multiple", convertToBoolean], autoHeight: [InputFlags.HasDecoratorInputTransform, "p-auto-height", "autoHeight", convertToBoolean], filterService: [InputFlags.None, "p-filter-service", "filterService"], noAutocomplete: [InputFlags.None, "p-no-autocomplete", "noAutocomplete"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], disabled: [InputFlags.None, "p-disabled", "disabled"] }, outputs: { onError: "p-error", selected: "p-selected", change: "p-change", changeVisibleColumns: "p-change-visible-columns", columnRestoreManager: "p-restore-column-manager" }, features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLookupFilterService }, { type: Injector, decorators: [{
    type: Inject,
    args: [Injector]
  }] }, { type: PoLookupModalService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], filterParams: [{
    type: Input,
    args: ["p-filter-params"]
  }], fieldFormat: [{
    type: Input,
    args: ["p-field-format"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], advancedFilters: [{
    type: Input,
    args: ["p-advanced-filters"]
  }], hideColumnsManager: [{
    type: Input,
    args: [{ alias: "p-hide-columns-manager", transform: convertToBoolean }]
  }], infiniteScroll: [{
    type: Input,
    args: [{ alias: "p-infinite-scroll", transform: convertToBoolean }]
  }], clean: [{
    type: Input,
    args: [{ alias: "p-clean", transform: convertToBoolean }]
  }], multiple: [{
    type: Input,
    args: [{ alias: "p-multiple", transform: convertToBoolean }]
  }], autoHeight: [{
    type: Input,
    args: [{ alias: "p-auto-height", transform: convertToBoolean }]
  }], onError: [{
    type: Output,
    args: ["p-error"]
  }], selected: [{
    type: Output,
    args: ["p-selected"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], changeVisibleColumns: [{
    type: Output,
    args: ["p-change-visible-columns"]
  }], columnRestoreManager: [{
    type: Output,
    args: ["p-restore-column-manager"]
  }], filterService: [{
    type: Input,
    args: ["p-filter-service"]
  }], noAutocomplete: [{
    type: Input,
    args: ["p-no-autocomplete"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }] });
})();
var _c0$N = ["inp"];
function PoLookupComponent_div_1_po_clean_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 11);
    ɵɵlistener("p-change-event", function PoLookupComponent_div_1_po_clean_4_Template_po_clean_p_change_event_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6.cleanModel());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("p-element-ref", ctx_r4.inputEl);
  }
}
function PoLookupComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "input", 5, 6);
    ɵɵlistener("blur", function PoLookupComponent_div_1_Template_input_blur_1_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.searchEvent());
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 7);
    ɵɵtemplate(4, PoLookupComponent_div_1_po_clean_4_Template, 1, 1, "po-clean", 8);
    ɵɵelementStart(5, "span", 9, 10);
    ɵɵlistener("click", function PoLookupComponent_div_1_Template_span_click_5_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.openLookup());
    })("focus", function PoLookupComponent_div_1_Template_span_focus_5_listener() {
      ɵɵrestoreView(_r9);
      const _r3 = ɵɵreference(2);
      return ɵɵresetView(_r3.focus());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const _r3 = ɵɵreference(2);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("id", ctx_r0.id)("ngClass", ctx_r0.clean && _r3.value ? "po-input-double-icon-right" : "po-input-icon-right")("autocomplete", ctx_r0.autocomplete)("disabled", ctx_r0.disabled)("placeholder", ctx_r0.disabled ? "" : ctx_r0.placeholder)("required", ctx_r0.required);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.clean && !ctx_r0.disabled);
    ɵɵadvance();
    ɵɵclassProp("po-field-icon", !ctx_r0.disabled)("po-field-icon-disabled", ctx_r0.disabled);
  }
}
function PoLookupComponent_ng_template_3_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r13.placeholder, " ");
  }
}
function PoLookupComponent_ng_template_3_po_disclaimer_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer", 16);
    ɵɵlistener("p-close-action", function PoLookupComponent_ng_template_3_po_disclaimer_4_Template_po_disclaimer_p_close_action_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r18);
      const disclaimer_r16 = restoredCtx.$implicit;
      const ctx_r17 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r17.closeDisclaimer(disclaimer_r16.value));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const disclaimer_r16 = ctx.$implicit;
    const ctx_r14 = ɵɵnextContext(2);
    ɵɵclassProp("po-clickable", disclaimer_r16.value === "" && !ctx_r14.disabled);
    ɵɵproperty("p-label", disclaimer_r16.label)("p-value", disclaimer_r16.value)("p-hide-close", disclaimer_r16.value === "" || ctx_r14.disabled);
  }
}
function PoLookupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "div", 12, 6);
    ɵɵtemplate(3, PoLookupComponent_ng_template_3_span_3_Template, 2, 1, "span", 13)(4, PoLookupComponent_ng_template_3_po_disclaimer_4_Template, 1, 5, "po-disclaimer", 14);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 7)(6, "span", 9, 10);
    ɵɵlistener("click", function PoLookupComponent_ng_template_3_Template_span_click_6_listener() {
      ɵɵrestoreView(_r20);
      const ctx_r19 = ɵɵnextContext();
      return ɵɵresetView(ctx_r19.openLookup());
    })("focus", function PoLookupComponent_ng_template_3_Template_span_focus_6_listener() {
      ɵɵrestoreView(_r20);
      const _r12 = ɵɵreference(2);
      return ɵɵresetView(_r12.focus());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-lookup-input-auto", ctx_r1.autoHeight)("po-lookup-input-static", !ctx_r1.autoHeight)("po-lookup-input-disabled", ctx_r1.disabled);
    ɵɵproperty("tabindex", ctx_r1.disabled ? -1 : 0);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.placeholder && !(ctx_r1.disclaimers == null ? null : ctx_r1.disclaimers.length));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.visibleDisclaimers);
    ɵɵadvance(2);
    ɵɵclassProp("po-field-icon", !ctx_r1.disabled)("po-field-icon-disabled", ctx_r1.disabled);
  }
}
var providers$2 = [
  PoLookupFilterService,
  PoLookupModalService,
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoLookupComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoLookupComponent),
    multi: true
  },
  {
    provide: NgControl,
    useExisting: forwardRef(() => PoLookupComponent),
    multi: false
  }
];
var PoLookupComponent = class _PoLookupComponent extends PoLookupBaseComponent {
  renderer;
  cd;
  inputEl;
  initialized = false;
  timeoutResize;
  visibleElement = false;
  disclaimers = [];
  visibleDisclaimers = [];
  id = `po-lookup[${uuid()}]`;
  modalSubscription;
  isCalculateVisibleItems = true;
  get autocomplete() {
    return this.noAutocomplete ? "off" : "on";
  }
  constructor(renderer, poLookupFilterService, poLookupModalService, cd, injector) {
    super(poLookupFilterService, injector, poLookupModalService);
    this.renderer = renderer;
    this.cd = cd;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    if (this.autoFocus) {
      this.focus();
    }
    this.initialized = true;
  }
  ngDoCheck() {
    const inputWidth = this.inputEl?.nativeElement.offsetWidth;
    if (inputWidth && !this.visibleElement && this.initialized || inputWidth && this.isCalculateVisibleItems) {
      this.debounceResize();
      this.visibleElement = true;
    }
    this.cd.markForCheck();
  }
  ngOnDestroy() {
    if (this.modalSubscription) {
      this.modalSubscription.unsubscribe();
    }
  }
  ngOnInit() {
    super.ngOnInit();
    this.initializeListeners();
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoLookupComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoLookupComponent, { static: true }) lookup: PoLookupComponent;
   *
   * focusLookup() {
   *   this.lookup.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  openLookup() {
    if (this.isAllowedOpenModal()) {
      const { advancedFilters, service, columns, filterParams, hideColumnsManager, literals, infiniteScroll, multiple, fieldLabel, fieldValue, changeVisibleColumns, columnRestoreManager } = this;
      const selectedItems = this.checkSelectedItems();
      this.poLookupModalService.openModal({
        advancedFilters,
        service,
        columns,
        filterParams,
        hideColumnsManager,
        title: this.label,
        literals,
        infiniteScroll,
        multiple,
        selectedItems,
        fieldLabel,
        fieldValue,
        changeVisibleColumns,
        columnRestoreManager
      });
      if (!this.modalSubscription) {
        this.modalSubscription = this.poLookupModalService.selectValueEvent.subscribe((selectedOptions) => {
          if (selectedOptions.length > 1 || this.disclaimers.length) {
            this.setDisclaimers(selectedOptions);
            this.updateVisibleItems();
          }
          this.selectModel(selectedOptions);
        });
      }
    }
  }
  checkSelectedItems() {
    if (this.multiple) {
      if (!this.disclaimers.length && this.valueToModel?.length) {
        return [__spreadValues({ value: this.valueToModel[0], label: this.oldValue }, this.selectedOptions[0])];
      }
      return this.disclaimers;
    } else {
      return this.valueToModel;
    }
  }
  setDisclaimers(selectedOptions) {
    this.disclaimers = selectedOptions.map((selectedOption) => __spreadValues({
      value: selectedOption[this.fieldValue],
      label: selectedOption[this.fieldLabel]
    }, selectedOption));
    this.visibleDisclaimers = [...this.disclaimers];
    this.cd.markForCheck();
  }
  setViewValue(value, object) {
    if (this.inputEl && this.fieldFormat) {
      this.setInputValueWipoieldFormat(object);
    } else if (this.inputEl) {
      this.inputEl.nativeElement.value = this.valueToModel || this.valueToModel === 0 ? value : "";
    }
    this.cd.markForCheck();
  }
  getViewValue() {
    return this.inputEl.nativeElement.value;
  }
  searchEvent() {
    this.onTouched?.();
    const value = this.getViewValue();
    if (this.oldValue?.toString() !== value) {
      this.searchById(value);
    }
  }
  closeDisclaimer(value) {
    this.disclaimers = this.disclaimers.filter((disclaimer) => disclaimer.value !== value);
    this.valueToModel = this.valueToModel.filter((model) => model !== value);
    this.updateVisibleItems();
    this.callOnChange(this.valueToModel.length ? this.valueToModel : void 0);
  }
  updateVisibleItems() {
    if (this.disclaimers && this.disclaimers.length > 0) {
      this.visibleDisclaimers = [].concat(this.disclaimers);
    }
    this.debounceResize();
    if (!this.inputEl.nativeElement.offsetWidth) {
      this.isCalculateVisibleItems = true;
    }
  }
  debounceResize() {
    if (!this.autoHeight) {
      clearTimeout(this.timeoutResize);
      this.timeoutResize = setTimeout(() => {
        this.calculateVisibleItems();
      }, 200);
    }
  }
  getInputWidth() {
    return this.inputEl.nativeElement.offsetWidth - 40;
  }
  getDisclaimersWidth() {
    const disclaimers = this.inputEl.nativeElement.querySelectorAll("po-disclaimer");
    return Array.from(disclaimers).map((disclaimer) => disclaimer["offsetWidth"]);
  }
  calculateVisibleItems() {
    const disclaimersWidth = this.getDisclaimersWidth();
    const inputWidth = this.getInputWidth();
    const extraDisclaimerSize = 38;
    const disclaimersVisible = disclaimersWidth[0];
    const newDisclaimers = [];
    const disclaimers = this.disclaimers;
    if (inputWidth > 0) {
      let sum = 0;
      let i = 0;
      for (i = 0; i < disclaimers.length; i++) {
        sum += disclaimersWidth[i];
        newDisclaimers.push(disclaimers[i]);
        if (sum > inputWidth) {
          sum -= disclaimersWidth[i];
          this.isCalculateVisibleItems = false;
          break;
        }
      }
      if (disclaimersVisible || !disclaimers.length) {
        if (i === disclaimers.length) {
          this.isCalculateVisibleItems = false;
          return;
        }
        if (sum + extraDisclaimerSize > inputWidth) {
          newDisclaimers.splice(-2, 2);
          const label = "+" + (disclaimers.length + 1 - i).toString();
          newDisclaimers.push({ value: "", label });
        } else {
          newDisclaimers.splice(-1, 1);
          const label = "+" + (disclaimers.length - i).toString();
          newDisclaimers.push({ value: "", label });
        }
      }
    }
    this.visibleDisclaimers = [...newDisclaimers];
  }
  isAllowedOpenModal() {
    if (!this.service) {
      console.warn("No service informed");
    }
    return !!(this.service && !this.disabled);
  }
  formatFields(objectSelected, properties) {
    let formatedField;
    if (Array.isArray(properties)) {
      for (const property of properties) {
        if (objectSelected && objectSelected[property]) {
          if (!formatedField) {
            formatedField = objectSelected[property];
          } else {
            formatedField = formatedField + " - " + objectSelected[property];
          }
        }
      }
    }
    if (!formatedField) {
      formatedField = objectSelected[this.fieldValue];
    }
    return formatedField;
  }
  setInputValueWipoieldFormat(objectSelected) {
    const isEmpty = Object.keys(objectSelected).length === 0;
    let fieldFormated;
    if (Array.isArray(this.fieldFormat)) {
      fieldFormated = this.formatFields(objectSelected, this.fieldFormat);
    } else {
      fieldFormated = this.fieldFormat(objectSelected);
    }
    this.oldValue = isEmpty ? "" : fieldFormated;
    this.inputEl.nativeElement.value = isEmpty ? "" : fieldFormated;
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.updateVisibleItems();
    });
  }
  static ɵfac = function PoLookupComponent_Factory(t) {
    return new (t || _PoLookupComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoLookupFilterService), ɵɵdirectiveInject(PoLookupModalService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLookupComponent, selectors: [["po-lookup"]], viewQuery: function PoLookupComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$N, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    }
  }, features: [ɵɵProvidersFeature(providers$2), ɵɵInheritDefinitionFeature], decls: 5, vars: 10, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], ["class", "po-field-container-content", 4, "ngIf", "ngIfElse"], [3, "p-help", "p-disabled"], ["disclaimersTemplate", ""], [1, "po-field-container-content"], ["type", "text", 1, "po-input", 3, "id", "ngClass", "autocomplete", "disabled", "placeholder", "required", "blur"], ["inp", ""], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], ["tabindex", "-1", 1, "po-icon", "po-field-icon", "po-icon-search", "po-icon-input", 3, "click", "focus"], ["iconLookup", ""], [1, "po-icon-input", 3, "p-element-ref", "p-change-event"], [1, "po-input", "po-input-icon-right", "po-lookup-input", "po-icon-input", 3, "tabindex"], ["class", "po-lookup-input-placeholder", 4, "ngIf"], ["class", "po-lookup-input-disclaimer", 3, "p-label", "p-value", "p-hide-close", "po-clickable", "p-close-action", 4, "ngFor", "ngForOf"], [1, "po-lookup-input-placeholder"], [1, "po-lookup-input-disclaimer", 3, "p-label", "p-value", "p-hide-close", "p-close-action"]], template: function PoLookupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0);
      ɵɵtemplate(1, PoLookupComponent_div_1_Template, 7, 11, "div", 1);
      ɵɵelement(2, "po-field-container-bottom", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, PoLookupComponent_ng_template_3_Template, 8, 13, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(4);
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.disclaimers.length)("ngIfElse", _r2);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, dependencies: [NgClass, NgForOf, NgIf, PoCleanComponent, PoDisclaimerComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLookupComponent, [{
    type: Component,
    args: [{ selector: "po-lookup", changeDetection: ChangeDetectionStrategy.OnPush, providers: providers$2, template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content" *ngIf="!disclaimers.length; else disclaimersTemplate">
    <input
      #inp
      class="po-input"
      [id]="id"
      type="text"
      [ngClass]="clean && inp.value ? 'po-input-double-icon-right' : 'po-input-icon-right'"
      [autocomplete]="autocomplete"
      [disabled]="disabled"
      [placeholder]="disabled ? '' : placeholder"
      [required]="required"
      (blur)="searchEvent()"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled"
        [p-element-ref]="inputEl"
        (p-change-event)="cleanModel()"
      >
      </po-clean>

      <span
        #iconLookup
        class="po-icon po-field-icon po-icon-search po-icon-input"
        tabindex="-1"
        [class.po-field-icon]="!disabled"
        [class.po-field-icon-disabled]="disabled"
        (click)="openLookup()"
        (focus)="inp.focus()"
      >
      </span>
    </div>
  </div>
  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>
</po-field-container>

<ng-template #disclaimersTemplate>
  <div class="po-field-container-content">
    <div
      #inp
      [tabindex]="disabled ? -1 : 0"
      class="po-input po-input-icon-right po-lookup-input po-icon-input"
      [class.po-lookup-input-auto]="autoHeight"
      [class.po-lookup-input-static]="!autoHeight"
      [class.po-lookup-input-disabled]="disabled"
    >
      <span *ngIf="placeholder && !disclaimers?.length" class="po-lookup-input-placeholder">
        {{ placeholder }}
      </span>

      <po-disclaimer
        *ngFor="let disclaimer of visibleDisclaimers"
        class="po-lookup-input-disclaimer"
        [p-label]="disclaimer.label"
        [p-value]="disclaimer.value"
        [p-hide-close]="disclaimer.value === '' || disabled"
        [class.po-clickable]="disclaimer.value === '' && !disabled"
        (p-close-action)="closeDisclaimer(disclaimer.value)"
      >
      </po-disclaimer>
    </div>

    <div class="po-field-icon-container-right">
      <span
        #iconLookup
        class="po-icon po-field-icon po-icon-search po-icon-input"
        tabindex="-1"
        [class.po-field-icon]="!disabled"
        [class.po-field-icon-disabled]="disabled"
        (click)="openLookup()"
        (focus)="inp.focus()"
      >
      </span>
    </div>
  </div>
</ng-template>
` }]
  }], () => [{ type: Renderer2 }, { type: PoLookupFilterService }, { type: PoLookupModalService }, { type: ChangeDetectorRef }, { type: Injector }], { inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: false }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLookupComponent, { className: "PoLookupComponent", filePath: "lib/components/po-field/po-lookup/po-lookup.component.ts", lineNumber: 110 });
})();
var PoMultiselectOptionTemplateDirective = class _PoMultiselectOptionTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoMultiselectOptionTemplateDirective_Factory(t) {
    return new (t || _PoMultiselectOptionTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoMultiselectOptionTemplateDirective, selectors: [["", "p-multiselect-option-template", ""]] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectOptionTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-multiselect-option-template]"
    }]
  }], () => [{ type: TemplateRef }], null);
})();
var PoMultiselectFilterMode;
(function(PoMultiselectFilterMode2) {
  PoMultiselectFilterMode2[PoMultiselectFilterMode2["startsWith"] = 0] = "startsWith";
  PoMultiselectFilterMode2[PoMultiselectFilterMode2["contains"] = 1] = "contains";
  PoMultiselectFilterMode2[PoMultiselectFilterMode2["endsWith"] = 2] = "endsWith";
})(PoMultiselectFilterMode || (PoMultiselectFilterMode = {}));
var PO_MULTISELECT_DEBOUNCE_TIME_DEFAULT = 400;
var PO_MULTISELECT_FIELD_LABEL_DEFAULT = "label";
var PO_MULTISELECT_FIELD_VALUE_DEFAULT = "value";
var poMultiselectLiteralsDefault = {
  en: {
    noData: "No data found",
    placeholderSearch: "Search",
    selectAll: "Select all",
    selectItem: "Select items"
  },
  es: {
    noData: "Datos no encontrados",
    placeholderSearch: "Busca",
    selectAll: "Seleccionar todo",
    selectItem: "Seleccionar items"
  },
  pt: {
    noData: "Nenhum dado encontrado",
    placeholderSearch: "Buscar",
    selectAll: "Selecionar todos",
    selectItem: "Selecionar itens"
  },
  ru: {
    noData: "Данные не найдены",
    placeholderSearch: "искать",
    selectAll: "Выбрать все",
    selectItem: "Выбрать элементы"
  }
};
var PoMultiselectBaseComponent = class _PoMultiselectBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Label no componente. */
  label;
  /** Texto de apoio para o campo. */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /** Mensagem apresentada enquanto o campo estiver vazio. */
  placeholder = "";
  /**
   * @description
   *
   * Placeholder do campo de pesquisa.
   *
   * > Caso o mesmo não seja informado, o valor padrão será traduzido com base no idioma do navegador (pt, es e en).
   *
   * @default `Buscar`
   */
  placeholderSearch = "";
  /** Nome do componente. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Indica se o campo "Selecionar todos" será escondido.
   *
   * @default `false`
   */
  hideSelectAll;
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver alterações no ngModel.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Define que o dropdown do multiselect será incluido no body da página e não suspenso com a caixa de texto do componente.
   * Opção necessária para o caso de uso do componente em páginas que necessitam renderizar o multiselect fora do conteúdo principal.
   *
   * > Obs: O uso dessa propriedade pode acarretar na perda sequencial da tabulação da página
   *
   * @default `false`
   */
  appendBox = false;
  selectedOptions = [];
  visibleOptionsDropdown = [];
  visibleTags = [];
  isServerSearching = false;
  isFirstFilter = true;
  filterSubject = new Subject();
  service;
  defaultService;
  // eslint-disable-next-line
  onModelTouched = null;
  clickOutListener;
  resizeListener;
  getObjectsByValuesSubscription;
  _filterService;
  _debounceTime = 400;
  _disabled = false;
  _filterMode = PoMultiselectFilterMode.startsWith;
  _hideSearch = false;
  _literals;
  _options;
  _required = false;
  _sort = false;
  _autoHeight = false;
  _fieldLabel = PO_MULTISELECT_FIELD_LABEL_DEFAULT;
  _fieldValue = PO_MULTISELECT_FIELD_VALUE_DEFAULT;
  language;
  lastLengthModel;
  onModelChange;
  validatorChange;
  autoHeightInitialValue;
  /**
   * @optional
   *
   * @description
   * Nesta propriedade pode ser informada a URL do serviço em que será realizado o filtro para carregamento da lista de itens no componente.
   *
   *Também existe a possibilidade de informar um serviço implementando a interface `PoMultiselectFilter`.
   *
   *Caso utilizado uma URL, o serviço deve ser retornado no padrão [API PO UI](https://po-ui.io/guides/api) e utilizar as propriedades `p-field-label` e `p-field-value` para a construção da lista de itens.
   *
   *Quando utilizada uma URL de serviço, então será concatenada nesta URL o valor que deseja-se filtrar da seguinte forma:
   *
   *```
   * // caso filtrar por "Peter"
   *  https://localhost:8080/api/heroes?filter=Peter
   *```
   *
   *E caso iniciar o campo com valor, os itens serão buscados da seguinte forma:
   *
   *```
   * // caso o valor do campo for [1234, 5678];
   *  https://localhost:8080/api/heroes?value=1234,5678
   *
   * //O *value* é referente ao `fieldValue`.
   *```
   *
   */
  set filterService(value) {
    if (value) {
      this._filterService = value;
      this.autoHeight = this.autoHeightInitialValue !== void 0 ? this.autoHeightInitialValue : true;
      this.options = [];
    }
  }
  get filterService() {
    return this._filterService;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que a altura do componente será auto ajustável, possuindo uma altura minima porém a altura máxima será de acordo
   * com o número de itens selecionados e a extensão dos mesmos, mantendo-os sempre visíveis.
   *
   * > O valor padrão será `true` quando houver serviço (`p-filter-service`).
   *
   * @default `false`
   */
  set autoHeight(value) {
    this._autoHeight = value;
    this.autoHeightInitialValue = value;
  }
  get autoHeight() {
    return this._autoHeight;
  }
  /**
   * @optional
   *
   * @description
   * Esta propriedade define em quanto tempo (em milissegundos), aguarda para acionar o evento de filtro após cada pressionamento de tecla.
   *
   * > Será utilizada apenas quando houver serviço (`p-filter-service`) e somente será aceito valor maior do que *zero*.
   *
   * @default `400`
   */
  set debounceTime(value) {
    const parsedValue = parseInt(value, 10);
    this._debounceTime = !isNaN(parsedValue) && parsedValue > 0 ? parsedValue : PO_MULTISELECT_DEBOUNCE_TIME_DEFAULT;
  }
  get debounceTime() {
    return this._debounceTime;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-multiselect`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoMultiselectLiterals = {
   *    noData: 'Nenhum dado encontrado',
   *    placeholderSearch: 'Buscar',
   *    selectAll: 'Select all',
   *    selectItem: 'Select items'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoMultiselectLiterals = {
   *    noData: 'Sem dados'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
   *
   * ```
   * <po-multiselect
   *   [p-literals]="customLiterals">
   * </po-po-multiselect>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poMultiselectLiteralsDefault[poLocaleDefault]), poMultiselectLiteralsDefault[this.language]), value);
    } else {
      this._literals = poMultiselectLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poMultiselectLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  set required(required) {
    this._required = required === "" ? true : convertToBoolean(required);
    this.validateModel();
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = disabled === "" ? true : convertToBoolean(disabled);
    this.validateModel();
    this.updateVisibleItems();
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Esconde o campo de pesquisa existente dentro do dropdown do po-multiselect.
   *
   * @default `false`
   */
  set hideSearch(hideSearch) {
    this._hideSearch = hideSearch === "" ? true : convertToBoolean(hideSearch);
  }
  get hideSearch() {
    return this._hideSearch;
  }
  /**
   * @description
   *
   * Nesta propriedade deve ser definida uma lista de objetos que será exibida no multiselect.
   * Esta lista deve conter os valores e os labels que serão apresentados na tela.
   *
   * > Essa propriedade é imutável, ou seja, sempre que quiser atualizar a lista de opções disponíveis
   * atualize a referência do objeto:
   *
   * ```
   * // atualiza a referência do objeto garantindo a atualização do template
   * this.options = [...this.options, { value: 'x', label: 'Nova opção' }];
   *
   * // evite, pois não atualiza a referência do objeto podendo gerar atrasos na atualização do template
   * this.options.push({ value: 'x', label: 'Nova opção' });
   * ```
   * > A lista pode ser definida utilizando um array com o valor representando `value` e `label` das seguintes formas:
   *
   * ```
   * <po-multiselect name="multiselect" p-label="PO Multiselect" [p-options]="[{value: 1, label: 'One'}, {value: 2, label: 'two'}]"> </po-multiselect>
   * ```
   *
   * ```
   * <po-multiselect name="multiselect" p-label="PO Multiselect" [p-options]="[{name: 'Roger', age: 28}, {name: 'Anne', age: 35}]" p-field-label="name" p-field-value="age"> </po-multiselect>
   * ```
   *
   * - Aconselha-se utilizar valores distintos no `label` e `value` dos itens.
   */
  set options(options) {
    this._options = options;
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que a lista definida na propriedade p-options será ordenada pelo label antes de ser apresentada no
   * dropdown.
   *
   * @default `false`
   */
  set sort(sort) {
    this._sort = sort === "" ? true : convertToBoolean(sort);
    this.validAndSortOptions();
  }
  get sort() {
    return this._sort;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no campo de busca, quando habilitado.
   * Valores definidos no enum: PoMultiselectFilterMode
   *
   * @default `startsWith`
   */
  set filterMode(filterMode) {
    this._filterMode = filterMode in PoMultiselectFilterMode ? filterMode : PoMultiselectFilterMode.startsWith;
    switch (this._filterMode.toString()) {
      case "startsWith":
        this._filterMode = PoMultiselectFilterMode.startsWith;
        break;
      case "contains":
        this._filterMode = PoMultiselectFilterMode.contains;
        break;
      case "endsWith":
        this._filterMode = PoMultiselectFilterMode.endsWith;
        break;
    }
  }
  get filterMode() {
    return this._filterMode;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * `PoMultiSelectOption`.
   *
   * @default `label`
   */
  set fieldLabel(value) {
    this._fieldLabel = value ? value : PO_MULTISELECT_FIELD_LABEL_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldLabel = this._fieldLabel;
    }
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo valor de cada item da lista.
   *
   * Necessário quando informar o serviço como URL e o mesmo não estiver retornando uma lista de objetos no padrão da interface
   * `PoMultiSelectOption`.
   *
   * @default `value`
   */
  set fieldValue(value) {
    this._fieldValue = value ? value : PO_MULTISELECT_FIELD_VALUE_DEFAULT;
    if (isTypeof(this.filterService, "string") && this.service) {
      this.service.fieldValue = this._fieldValue;
    }
  }
  get fieldValue() {
    return this._fieldValue;
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  ngOnInit() {
    if (this.filterService) {
      this.setService(this.filterService);
    }
    this.filterSubject.pipe(debounceTime(this.debounceTime), distinctUntilChanged(), tap(() => this.isServerSearching = true), switchMap((search) => this.applyFilter(search)), tap(() => this.isServerSearching = false)).subscribe();
    this.setLabelsAndValuesOptions();
    this.validAndSortOptions();
    this.updateList(this.options);
  }
  setService(service) {
    if (isTypeof(service, "object")) {
      this.service = service;
    } else {
      this.service = this.defaultService;
      this.service.configProperties(service, this.fieldLabel, this.fieldValue);
    }
    this.isFirstFilter = true;
  }
  validAndSortOptions() {
    if (this.options && this.options.length) {
      removeUndefinedAndNullOptionsWithFieldValue(this.options, this.fieldValue);
      removeDuplicatedOptionsWithFieldValue(this.options, this.fieldValue);
      this.setUndefinedLabels(this.options);
      if (this.sort) {
        sortOptionsByProperty(this.options, this.fieldLabel);
      }
    }
  }
  setUndefinedLabels(options) {
    options.forEach((option) => {
      if (!option[this.fieldLabel]) {
        option[this.fieldLabel] = option[this.fieldValue];
      }
    });
  }
  updateList(options) {
    if (options) {
      this.visibleOptionsDropdown = options;
    }
  }
  callOnChange(selectedOptions) {
    if (this.onModelChange) {
      this.onModelChange(this.getValuesFromOptions(selectedOptions));
      this.eventChange(selectedOptions);
    }
  }
  eventChange(selectedOptions) {
    if (selectedOptions && this.lastLengthModel !== selectedOptions.length) {
      this.change.emit(selectedOptions);
    }
    this.lastLengthModel = selectedOptions ? selectedOptions.length : null;
  }
  getValuesFromOptions(selectedOptions) {
    return selectedOptions && selectedOptions.length ? selectedOptions.map((option) => option[this.fieldValue]) : [];
  }
  getLabelByValue(value) {
    const index = this.options.findIndex((option) => option[this.fieldValue] === value);
    return this.options[index].label;
  }
  searchByLabel(search, options, filterMode) {
    if (search && options && options.length) {
      const newOptions = [];
      options.forEach((option) => {
        if (option[this.fieldLabel] && this.compareMethod(search, option, filterMode)) {
          newOptions.push(option);
        }
      });
      this.visibleOptionsDropdown = newOptions;
    } else {
      this.visibleOptionsDropdown = [...options];
    }
  }
  compareMethod(search, option, filterMode) {
    switch (filterMode) {
      case PoMultiselectFilterMode.startsWith:
        return this.startsWith(search, option);
      case PoMultiselectFilterMode.contains:
        return this.contains(search, option);
      case PoMultiselectFilterMode.endsWith:
        return this.endsWith(search, option);
    }
  }
  startsWith(search, option) {
    return option[this.fieldLabel].toLowerCase().startsWith(search.toLowerCase());
  }
  contains(search, option) {
    return option[this.fieldLabel].toLowerCase().indexOf(search.toLowerCase()) > -1;
  }
  endsWith(search, option) {
    return option[this.fieldLabel].toLowerCase().endsWith(search.toLowerCase());
  }
  validate(c) {
    if (requiredFailed(this.required, this.disabled, c.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    return null;
  }
  updateSelectedOptions(newOptions, options = this.options) {
    this.selectedOptions = [];
    if (newOptions.length === 0) {
      this.lastLengthModel = void 0;
    }
    if (this.filterService) {
      this.selectedOptions = newOptions;
    } else {
      newOptions.forEach((newOption) => {
        options.forEach((option) => {
          if (option[this.fieldValue] === newOption[this.fieldValue]) {
            this.selectedOptions.push(option);
          }
        });
      });
    }
    this.updateVisibleItems();
  }
  writeValue(values) {
    values = values || [];
    if (this.service && values.length) {
      this.getObjectsByValuesSubscription = this.service.getObjectsByValues(values).subscribe((options) => {
        this.updateSelectedOptions(options);
        this.callOnChange(this.selectedOptions);
      });
    } else {
      this.updateSelectedOptions(values.map((value) => ({ [this.fieldValue]: value })));
      if (this.selectedOptions && this.selectedOptions.length < values.length) {
        this.callOnChange(this.selectedOptions);
      }
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  setLabelsAndValuesOptions() {
    if (this.fieldLabel && this.fieldValue && this.options) {
      this.options.map((option) => {
        option.label = option[this.fieldLabel];
        option.value = option[this.fieldValue];
      });
    }
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  static ɵfac = function PoMultiselectBaseComponent_Factory(t) {
    return new (t || _PoMultiselectBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoMultiselectBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"], optional: [InputFlags.None, "p-optional", "optional"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], placeholderSearch: [InputFlags.None, "p-placeholder-search", "placeholderSearch"], name: "name", hideSelectAll: [InputFlags.HasDecoratorInputTransform, "p-hide-select-all", "hideSelectAll", convertToBoolean], appendBox: [InputFlags.HasDecoratorInputTransform, "p-append-in-body", "appendBox", convertToBoolean], filterService: [InputFlags.None, "p-filter-service", "filterService"], autoHeight: [InputFlags.HasDecoratorInputTransform, "p-auto-height", "autoHeight", convertToBoolean], debounceTime: [InputFlags.None, "p-debounce-time", "debounceTime"], literals: [InputFlags.None, "p-literals", "literals"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], disabled: [InputFlags.None, "p-disabled", "disabled"], hideSearch: [InputFlags.None, "p-hide-search", "hideSearch"], options: [InputFlags.None, "p-options", "options"], sort: [InputFlags.None, "p-sort", "sort"], filterMode: [InputFlags.None, "p-filter-mode", "filterMode"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"] }, outputs: { change: "p-change" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], placeholderSearch: [{
    type: Input,
    args: ["p-placeholder-search"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], hideSelectAll: [{
    type: Input,
    args: [{ alias: "p-hide-select-all", transform: convertToBoolean }]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], appendBox: [{
    type: Input,
    args: [{ alias: "p-append-in-body", transform: convertToBoolean }]
  }], filterService: [{
    type: Input,
    args: ["p-filter-service"]
  }], autoHeight: [{
    type: Input,
    args: [{ alias: "p-auto-height", transform: convertToBoolean }]
  }], debounceTime: [{
    type: Input,
    args: ["p-debounce-time"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], hideSearch: [{
    type: Input,
    args: ["p-hide-search"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], sort: [{
    type: Input,
    args: ["p-sort"]
  }], filterMode: [{
    type: Input,
    args: ["p-filter-mode"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }] });
})();
var PoMultiselectFilterService = class _PoMultiselectFilterService {
  http;
  fieldLabel = "label";
  fieldValue = "value";
  _url;
  messages = [];
  get url() {
    return this._url;
  }
  constructor(http) {
    this.http = http;
  }
  getFilteredData({ value }) {
    const params = value ? { filter: value } : {};
    return this.http.get(this.url, {
      params
    }).pipe(map((response) => this.parseToArrayMultiselectOptions(response["items"])));
  }
  getObjectsByValues(value) {
    return this.http.get(`${this.url}?${this.fieldValue}=${value.toString()}`).pipe(map((response) => this.parseToArrayMultiselectOptions(response["items"])));
  }
  configProperties(url, fieldLabel, fieldValue) {
    this._url = url;
    this.fieldLabel = fieldLabel;
    this.fieldValue = fieldValue;
  }
  parseToArrayMultiselectOptions(items) {
    if (items && items.length > 0) {
      return items.map((item) => this.parseToMultiselectOption(item));
    }
    return [];
  }
  parseToMultiselectOption(item) {
    const label = item[this.fieldLabel];
    const value = item[this.fieldValue];
    return { [this.fieldLabel]: label, [this.fieldValue]: value };
  }
  static ɵfac = function PoMultiselectFilterService_Factory(t) {
    return new (t || _PoMultiselectFilterService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoMultiselectFilterService, factory: _PoMultiselectFilterService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectFilterService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var _c0$M = ["dropdownElement"];
var _c1$i = ["iconElement"];
var _c2$8 = ["inputElement"];
function PoMultiselectComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.placeholder ? ctx_r2.placeholder : ctx_r2.literals.selectItem, " ");
  }
}
function PoMultiselectComponent_po_tag_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-tag", 16);
    ɵɵlistener("p-close", function PoMultiselectComponent_po_tag_6_Template_po_tag_p_close_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r15);
      const tag_r12 = restoredCtx.$implicit;
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.closeTag(tag_r12[ctx_r14.fieldValue], $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tag_r12 = ctx.$implicit;
    const i_r13 = ctx.index;
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", tag_r12[ctx_r3.fieldValue] === "" && !ctx_r3.disabled);
    ɵɵproperty("p-value", tag_r12[ctx_r3.fieldLabel])("p-literals", i_r13 + 1 === ctx_r3.visibleTags.length && ctx_r3.hasMoreTag ? ctx_r3.literalsTag : void 0)("p-removable", true)("p-disabled", ctx_r3.disabled);
  }
}
function PoMultiselectComponent_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMultiselectComponent_ng_template_11_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMultiselectComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoMultiselectComponent_ng_template_11_ng_container_0_Template, 1, 0, "ng-container", 17);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r11 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", _r11);
  }
}
function PoMultiselectComponent_ng_template_13_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMultiselectComponent_ng_template_13_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoMultiselectComponent_ng_template_13_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 17);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r11 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", _r11);
  }
}
function PoMultiselectComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoMultiselectComponent_ng_template_13_ng_template_0_Template, 1, 1, "ng-template", 18);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r0 = ɵɵreference(2);
    ɵɵproperty("cdkConnectedOverlayOrigin", _r0)("cdkConnectedOverlayOpen", true);
  }
}
function PoMultiselectComponent_ng_template_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-multiselect-dropdown", 19, 20);
    ɵɵlistener("p-change", function PoMultiselectComponent_ng_template_16_Template_po_multiselect_dropdown_p_change_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r20 = ɵɵnextContext();
      return ɵɵresetView(ctx_r20.changeItems($event));
    })("p-change-search", function PoMultiselectComponent_ng_template_16_Template_po_multiselect_dropdown_p_change_search_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r22 = ɵɵnextContext();
      return ɵɵresetView(ctx_r22.changeSearch($event));
    })("p-close-dropdown", function PoMultiselectComponent_ng_template_16_Template_po_multiselect_dropdown_p_close_dropdown_0_listener() {
      ɵɵrestoreView(_r21);
      const ctx_r23 = ɵɵnextContext();
      return ɵɵresetView(ctx_r23.controlDropdownVisibility(false));
    })("keydown", function PoMultiselectComponent_ng_template_16_Template_po_multiselect_dropdown_keydown_0_listener($event) {
      ɵɵrestoreView(_r21);
      const ctx_r24 = ɵɵnextContext();
      return ɵɵresetView(ctx_r24.onKeyDownDropdown($event, 0));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext();
    ɵɵproperty("p-searching", ctx_r10.isServerSearching)("p-hide-search", ctx_r10.hideSearch)("p-hide-select-all", ctx_r10.hideSelectAll)("p-literals", ctx_r10.literals)("p-options", ctx_r10.options)("p-visible-options", ctx_r10.visibleOptionsDropdown)("p-selected-options", ctx_r10.selectedOptions)("p-placeholder-search", ctx_r10.placeholderSearch)("p-field-value", ctx_r10.fieldValue)("p-field-label", ctx_r10.fieldLabel)("p-multiselect-template", ctx_r10.multiselectOptionTemplate);
  }
}
var poMultiselectContainerOffset = 8;
var poMultiselectContainerPositionDefault = "bottom";
var poMultiselectInputPaddingRight = 52;
var poMultiselectSpaceBetweenTags = 8;
var literalsTagRemoveOthers = {
  pt: {
    remove: "Remover todos os itens selecionados"
  },
  ru: {
    remove: "Удалить все выбранные элементы"
  },
  es: {
    remove: "Eliminar todos los elementos seleccionados"
  },
  en: {
    remove: "Clear all selected items"
  }
};
var providers$1 = [
  PoMultiselectFilterService,
  PoControlPositionService,
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoMultiselectComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoMultiselectComponent),
    multi: true
  }
];
var PoMultiselectComponent = class _PoMultiselectComponent extends PoMultiselectBaseComponent {
  renderer;
  changeDetector;
  el;
  controlPosition;
  defaultService;
  multiselectOptionTemplate;
  dropdownElement;
  dropdown;
  iconElement;
  inputElement;
  literalsTag;
  dropdownIcon = "po-icon-arrow-down";
  dropdownOpen = false;
  initialized = false;
  hasMoreTag;
  timeoutResize;
  visibleElement = false;
  subscription = new Subscription();
  enterCloseTag = false;
  initCalculateItems = true;
  isCalculateVisibleItems = true;
  cacheOptions;
  focusOnTag = false;
  constructor(renderer, changeDetector, el, controlPosition, defaultService, languageService) {
    super(languageService);
    this.renderer = renderer;
    this.changeDetector = changeDetector;
    this.el = el;
    this.controlPosition = controlPosition;
    this.defaultService = defaultService;
    const language = languageService.getShortLanguage();
    this.literalsTag = __spreadValues(__spreadValues({}, literalsTagRemoveOthers[poLocaleDefault]), literalsTagRemoveOthers[language]);
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
    this.initialized = true;
  }
  ngOnChanges(changes) {
    if (this.filterService && (changes.filterService || changes.fieldValue || changes.fieldLabel)) {
      this.setService(this.filterService);
    }
  }
  ngDoCheck() {
    const inputWidth = this.inputElement.nativeElement.offsetWidth;
    if (inputWidth && !this.visibleElement && this.initialized || inputWidth && this.isCalculateVisibleItems) {
      this.debounceResize();
      this.visibleElement = true;
    }
  }
  ngOnDestroy() {
    this.removeListeners();
    this.getObjectsByValuesSubscription?.unsubscribe();
    this.filterSubject?.unsubscribe();
    this.subscription.unsubscribe();
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoMultiselectComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoMultiselectComponent, { static: true }) multiselect: PoMultiselectComponent;
   *
   * focusMultiselect() {
   *   this.multiselect.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputElement.nativeElement.focus();
    }
  }
  getInputWidth() {
    return this.el.nativeElement.querySelector(".po-multiselect-input").offsetWidth - poMultiselectInputPaddingRight;
  }
  getTagsWidth() {
    const tags = this.el.nativeElement.querySelectorAll("po-tag");
    return Array.from(tags).map((tag) => tag["offsetWidth"]);
  }
  calculateVisibleItems() {
    this.hasMoreTag = false;
    const tagsWidth = this.getTagsWidth();
    const inputWidth = this.getInputWidth();
    const extraTagSize = 63;
    const tagsVisible = tagsWidth[0];
    this.visibleTags = [];
    if (inputWidth > 0) {
      let sum = 0;
      let i = 0;
      for (i = 0; i < this.selectedOptions.length; i++) {
        sum += tagsWidth[i] + poMultiselectSpaceBetweenTags;
        this.visibleTags.push(this.selectedOptions[i]);
        if (sum > inputWidth) {
          sum -= tagsWidth[i];
          this.isCalculateVisibleItems = false;
          break;
        }
      }
      if (tagsVisible || !this.selectedOptions.length) {
        if (i === this.selectedOptions.length) {
          this.isCalculateVisibleItems = false;
          return;
        }
        this.hasMoreTag = true;
        if (sum + extraTagSize > inputWidth) {
          this.visibleTags.splice(-2, 2);
          const label = "+" + (this.selectedOptions.length + 1 - i).toString();
          this.visibleTags.push({ [this.fieldValue]: "", [this.fieldLabel]: label });
        } else {
          this.visibleTags.splice(-1, 1);
          const label = "+" + (this.selectedOptions.length - i).toString();
          this.visibleTags.push({ [this.fieldValue]: "", [this.fieldLabel]: label });
        }
      }
      if (this.initCalculateItems) {
        setTimeout(() => {
          this.handleKeyboardNavigationTag();
        }, 300);
      }
      this.initCalculateItems = false;
    }
    this.changeDetector.markForCheck();
  }
  changeItems(changedItems) {
    this.updateSelectedOptions(changedItems);
    this.callOnChange(this.selectedOptions);
    if (this.autoHeight && this.dropdownOpen) {
      this.changeDetector.detectChanges();
      this.adjustContainerPosition();
    }
    setTimeout(() => {
      this.handleKeyboardNavigationTag();
    }, 300);
  }
  updateVisibleItems() {
    if (this.selectedOptions) {
      this.visibleTags = [].concat(this.selectedOptions);
    }
    this.debounceResize();
    if (!this.inputElement.nativeElement.offsetWidth) {
      this.isCalculateVisibleItems = true;
    }
  }
  debounceResize() {
    if (!this.autoHeight) {
      clearTimeout(this.timeoutResize);
      this.timeoutResize = setTimeout(() => {
        this.calculateVisibleItems();
      }, 200);
    }
    this.changeDetector.markForCheck();
  }
  onBlur() {
    if (typeof this.inputElement.nativeElement.getAttribute("aria-label") === "string" && this.inputElement.nativeElement.getAttribute("aria-label").includes("Unselected")) {
      this.inputElement.nativeElement.setAttribute("aria-label", this.label ? this.label : "");
    }
    this.onModelTouched?.();
  }
  onKeyDown(event) {
    if (event.shiftKey && event.keyCode === PoKeyCodeEnum.tab && !this.focusOnTag) {
      this.controlDropdownVisibility(false);
    }
    this.focusOnTag = false;
    if (event.keyCode === PoKeyCodeEnum.tab) {
      return;
    }
    if (event.keyCode === PoKeyCodeEnum.esc) {
      event.preventDefault();
      this.controlDropdownVisibility(false);
      return;
    }
    if (event.keyCode === PoKeyCodeEnum.arrowDown && this.visibleTags.length > 0) {
      event.preventDefault();
      this.controlDropdownVisibility(true);
      this.dropdown?.listbox?.setFocus();
      return;
    }
    if (event.keyCode === PoKeyCodeEnum.enter && !this.enterCloseTag) {
      if (this.visibleTags.length === 0) {
        this.toggleDropdownVisibility();
        this.focus();
        return;
      } else {
        event.preventDefault();
        this.toggleDropdownVisibility();
        return;
      }
    }
    if (event.keyCode === PoKeyCodeEnum.space) {
      event.preventDefault();
      this.toggleDropdownVisibility();
    }
    this.enterCloseTag = false;
  }
  toggleDropdownVisibility() {
    if (this.disabled) {
      return;
    }
    if (this.filterService) {
      this.applyFilterInFirstClick();
    }
    this.controlDropdownVisibility(!this.dropdownOpen);
  }
  onKeyDownDropdown(event, index) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.controlDropdownVisibility(false);
      this.inputElement.nativeElement.focus();
    }
  }
  openDropdown(toOpen) {
    if (toOpen && !this.disabled) {
      this.controlDropdownVisibility(true);
    }
  }
  controlDropdownVisibility(toOpen) {
    toOpen ? this.open() : this.close();
  }
  scrollToSelectedOptions() {
    if (this.selectedOptions && this.selectedOptions.length) {
      const index = this.options.findIndex((option) => option[this.fieldValue] === this.selectedOptions[0][this.fieldValue]);
      this.dropdown.scrollTo(index);
    }
  }
  setVisibleOptionsDropdown(options) {
    this.visibleOptionsDropdown = options;
    this.changeDetector.markForCheck();
  }
  changeSearch(event) {
    if (event && event[this.fieldValue] !== void 0) {
      if (this.filterService) {
        this.filterSubject.next(event[this.fieldValue]);
      } else {
        this.searchByLabel(event[this.fieldValue], this.options, this.filterMode);
      }
    } else {
      this.setVisibleOptionsDropdown(this.options);
    }
    setTimeout(() => this.adjustContainerPosition());
  }
  closeTag(value, event) {
    let index;
    this.enterCloseTag = true;
    if (!value || typeof value === "string" && value.includes("+")) {
      index = null;
      const itemsNotInVisibleTags = this.selectedOptions.filter((option) => !this.visibleTags.includes(option));
      for (const option of this.visibleTags) {
        if (!this.selectedOptions.includes(option)) {
          this.selectedOptions.splice(this.visibleTags.length - 1, itemsNotInVisibleTags.length);
          this.updateVisibleItems();
          this.callOnChange(this.selectedOptions);
        }
      }
    } else {
      index = this.selectedOptions.findIndex((option) => option[this.fieldValue] === value);
      this.selectedOptions.splice(index, 1);
      this.updateVisibleItems();
      this.callOnChange(this.selectedOptions);
    }
    setTimeout(() => {
      this.focusOnNextTag(index, event);
    }, 300);
  }
  wasClickedOnToggle(event) {
    if (this.dropdownOpen && !this.inputElement.nativeElement.contains(event.target) && !this.iconElement.nativeElement.contains(event.target) && !this.dropdownElement.nativeElement.contains(event.target)) {
      this.controlDropdownVisibility(false);
    }
  }
  applyFilter(value = "") {
    const param = { property: this.fieldLabel, value };
    return this.service.getFilteredData(param).pipe(catchError((err) => {
      this.isServerSearching = false;
      return of([]);
    }), tap((options) => {
      this.setOptionsByApplyFilter(options);
    }));
  }
  applyFilterInFirstClick() {
    if (this.isFirstFilter) {
      this.isServerSearching = true;
      this.filterSubject.next(new String());
    } else {
      this.options = [...this.cacheOptions];
    }
  }
  setOptionsByApplyFilter(items) {
    if (this.isFirstFilter) {
      this.cacheOptions = [...items];
      this.isFirstFilter = false;
    }
    this.options = [...items];
    this.setVisibleOptionsDropdown(this.options);
  }
  adjustContainerPosition() {
    this.controlPosition.adjustPosition(poMultiselectContainerPositionDefault);
  }
  close() {
    this.dropdownIcon = "po-icon-arrow-down";
    this.dropdownOpen = false;
    this.dropdown.controlVisibility(false);
    this.setVisibleOptionsDropdown(this.options);
    this.removeListeners();
  }
  focusOnNextTag(indexClosed, clickOrEnter) {
    if (clickOrEnter === "enter") {
      const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
      indexClosed = indexClosed || indexClosed === 0 ? indexClosed : tagRemoveElements.length;
      if (tagRemoveElements.length === 0) {
        this.inputElement.nativeElement.focus();
        this.inputElement.nativeElement.setAttribute("aria-label", `Unselected items ${this.label}`);
        this.controlDropdownVisibility(true);
      }
      this.focusOnRemoveTag(tagRemoveElements, indexClosed);
    } else {
      indexClosed = 0;
    }
    this.handleKeyboardNavigationTag(indexClosed);
  }
  focusOnRemoveTag(tag, indexClosed) {
    if (tag.length === indexClosed) {
      tag[indexClosed - 1]?.focus();
    } else {
      tag[indexClosed]?.focus();
    }
  }
  handleKeyboardNavigationTag(initialIndex = 0) {
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    const tagRemoveElements = this.el.nativeElement.querySelectorAll(".po-tag-remove");
    this.initializeTagRemoveElements(tagRemoveElements, initialIndex);
  }
  setTabIndex(element, tabIndex) {
    element.setAttribute("tabindex", tabIndex);
  }
  handleArrowLeft(tagRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index - 1].focus();
      this.setTabIndex(tagRemoveElements[index - 1], 0);
    }
  }
  handleArrowRight(tagRemoveElements, index) {
    if (index < tagRemoveElements.length - 1) {
      this.setTabIndex(tagRemoveElements[index], -1);
      tagRemoveElements[index + 1].focus();
      this.setTabIndex(tagRemoveElements[index + 1], 0);
    }
  }
  handleKeyDown(event, tagRemoveElements, index) {
    const KEY_SPACE = "Space";
    const KEY_ARROW_LEFT = "ArrowLeft";
    const KEY_ARROW_RIGHT = "ArrowRight";
    this.focusOnTag = true;
    if (event.code === KEY_SPACE) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.key === KEY_ARROW_LEFT) {
      this.handleArrowLeft(tagRemoveElements, index);
    } else if (event.key === KEY_ARROW_RIGHT) {
      this.handleArrowRight(tagRemoveElements, index);
    }
  }
  initializeTagRemoveElements(tagRemoveElements, initialIndex) {
    tagRemoveElements.forEach((tagRemoveElement, index) => {
      if (index === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex], 0);
      } else if (tagRemoveElements.length === initialIndex) {
        this.setTabIndex(tagRemoveElements[initialIndex - 1], 0);
      } else {
        this.setTabIndex(tagRemoveElement, -1);
      }
      this.subscription.add(fromEvent(tagRemoveElement, "keydown").subscribe((event) => {
        this.handleKeyDown(event, tagRemoveElements, index);
      }));
    });
  }
  initializeListeners() {
    this.clickOutListener = this.renderer.listen("document", "click", (event) => {
      this.wasClickedOnToggle(event);
    });
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.updateVisibleItems();
      isMobile() ? this.adjustContainerPosition() : this.close();
    });
    window.addEventListener("scroll", this.onScroll, true);
  }
  onScroll = () => {
    this.adjustContainerPosition();
  };
  open() {
    this.dropdownIcon = "po-icon-arrow-up";
    this.dropdownOpen = true;
    this.dropdown.controlVisibility(true);
    this.setVisibleOptionsDropdown(this.options);
    this.initializeListeners();
    this.scrollToSelectedOptions();
    this.changeDetector.detectChanges();
    this.setPositionDropdown();
  }
  removeListeners() {
    if (this.clickOutListener) {
      this.clickOutListener();
    }
    if (this.resizeListener) {
      this.resizeListener();
    }
    window.removeEventListener("scroll", this.onScroll, true);
    this.changeDetector.markForCheck();
  }
  setPositionDropdown() {
    this.controlPosition.setElements(this.dropdown.container.nativeElement, poMultiselectContainerOffset, this.inputElement, ["top", "bottom"], true);
    this.adjustContainerPosition();
  }
  static ɵfac = function PoMultiselectComponent_Factory(t) {
    return new (t || _PoMultiselectComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoControlPositionService), ɵɵdirectiveInject(PoMultiselectFilterService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMultiselectComponent, selectors: [["po-multiselect"]], contentQueries: function PoMultiselectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoMultiselectOptionTemplateDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiselectOptionTemplate = _t.first);
    }
  }, viewQuery: function PoMultiselectComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$M, 5, ElementRef);
      ɵɵviewQuery(_c0$M, 5);
      ɵɵviewQuery(_c1$i, 7, ElementRef);
      ɵɵviewQuery(_c2$8, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdownElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdown = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iconElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    }
  }, features: [ɵɵProvidersFeature(providers$1), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 18, vars: 30, consts: [[3, "p-disabled", "p-label", "p-optional", "p-required", "p-show-required"], ["cdkOverlayOrigin", "", 1, "po-field-container-content"], ["trigger", "cdkOverlayOrigin"], [1, "po-input-icon-right", "po-multiselect-input", 3, "tabindex", "keydown", "click", "blur"], ["inputElement", ""], ["class", "po-multiselect-input-placeholder", "aria-hidden", "true", 4, "ngIf"], [3, "p-value", "p-literals", "p-removable", "po-clickable", "p-disabled", "p-close", 4, "ngFor", "ngForOf"], [1, "po-field-icon-container-right"], [3, "ngClass"], ["iconElement", ""], [4, "ngIf", "ngIfThen", "ngIfElse"], ["dropdownDefault", ""], ["dropdownCDK", ""], [3, "p-help", "p-disabled"], ["dropdownListbox", ""], ["aria-hidden", "true", 1, "po-multiselect-input-placeholder"], [3, "p-value", "p-literals", "p-removable", "p-disabled", "p-close"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", 3, "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen"], [3, "p-searching", "p-hide-search", "p-hide-select-all", "p-literals", "p-options", "p-visible-options", "p-selected-options", "p-placeholder-search", "p-field-value", "p-field-label", "p-multiselect-template", "p-change", "p-change-search", "p-close-dropdown", "keydown"], ["dropdownElement", ""]], template: function PoMultiselectComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1, 2)(3, "div", 3, 4);
      ɵɵlistener("keydown", function PoMultiselectComponent_Template_div_keydown_3_listener($event) {
        return ctx.onKeyDown($event);
      })("click", function PoMultiselectComponent_Template_div_click_3_listener() {
        return ctx.toggleDropdownVisibility();
      })("blur", function PoMultiselectComponent_Template_div_blur_3_listener() {
        return ctx.onBlur();
      });
      ɵɵtemplate(5, PoMultiselectComponent_span_5_Template, 2, 1, "span", 5)(6, PoMultiselectComponent_po_tag_6_Template, 1, 6, "po-tag", 6);
      ɵɵelementStart(7, "div", 7);
      ɵɵelement(8, "span", 8, 9);
      ɵɵelementEnd()()();
      ɵɵtemplate(10, PoMultiselectComponent_ng_container_10_Template, 1, 0, "ng-container", 10)(11, PoMultiselectComponent_ng_template_11_Template, 1, 1, "ng-template", null, 11, ɵɵtemplateRefExtractor)(13, PoMultiselectComponent_ng_template_13_Template, 1, 2, "ng-template", null, 12, ɵɵtemplateRefExtractor);
      ɵɵelement(15, "po-field-container-bottom", 13);
      ɵɵelementEnd();
      ɵɵtemplate(16, PoMultiselectComponent_ng_template_16_Template, 2, 11, "ng-template", null, 14, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r7 = ɵɵreference(12);
      const _r9 = ɵɵreference(14);
      ɵɵproperty("p-disabled", ctx.disabled)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance();
      ɵɵclassProp("po-multiselect-show", ctx.dropdownOpen);
      ɵɵadvance(2);
      ɵɵclassProp("po-multiselect-input-auto", ctx.autoHeight)("po-multiselect-input-static", !ctx.autoHeight)("po-multiselect-input-disabled", ctx.disabled)("po-multiselect-input-font", !ctx.disabled && !(ctx.visibleTags == null ? null : ctx.visibleTags.length));
      ɵɵproperty("tabindex", ctx.disabled ? -1 : 0);
      ɵɵattribute("disabled", ctx.disabled)("aria-label", ctx.label);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.disabled && !(ctx.visibleTags == null ? null : ctx.visibleTags.length));
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.visibleTags);
      ɵɵadvance(2);
      ɵɵclassMapInterpolate2("po-icon po-field-icon ", ctx.dropdownIcon, " ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
      ɵɵproperty("ngClass", ctx.disabled ? "po-field-icon-disabled" : "");
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.appendBox)("ngIfThen", _r9)("ngIfElse", _r7);
      ɵɵadvance(5);
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectComponent, [{
    type: Component,
    args: [{ selector: "po-multiselect", changeDetection: ChangeDetectionStrategy.OnPush, providers: providers$1, template: `<po-field-container
  [p-disabled]="disabled"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div
    cdkOverlayOrigin
    #trigger="cdkOverlayOrigin"
    class="po-field-container-content"
    [class.po-multiselect-show]="dropdownOpen"
  >
    <div
      #inputElement
      [tabindex]="disabled ? -1 : 0"
      [attr.disabled]="disabled"
      [attr.aria-label]="label"
      class="po-input-icon-right po-multiselect-input"
      [class.po-multiselect-input-auto]="autoHeight"
      [class.po-multiselect-input-static]="!autoHeight"
      [class.po-multiselect-input-disabled]="disabled"
      [class.po-multiselect-input-font]="!disabled && !visibleTags?.length"
      (keydown)="onKeyDown($event)"
      (click)="toggleDropdownVisibility()"
      (blur)="onBlur()"
    >
      <span *ngIf="!disabled && !visibleTags?.length" class="po-multiselect-input-placeholder" aria-hidden="true">
        {{ placeholder ? placeholder : literals.selectItem }}
      </span>

      <po-tag
        *ngFor="let tag of visibleTags; index as i"
        [p-value]="tag[fieldLabel]"
        [p-literals]="i + 1 === visibleTags.length && hasMoreTag ? literalsTag : undefined"
        [p-removable]="true"
        [class.po-clickable]="tag[fieldValue] === '' && !disabled"
        [p-disabled]="disabled"
        (p-close)="closeTag(tag[fieldValue], $event)"
      ></po-tag>

      <div class="po-field-icon-container-right">
        <span
          #iconElement
          class="po-icon po-field-icon {{ dropdownIcon }} {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
          [ngClass]="disabled ? 'po-field-icon-disabled' : ''"
        >
        </span>
      </div>
    </div>
  </div>

  <ng-container *ngIf="appendBox; then dropdownCDK; else dropdownDefault"> </ng-container>

  <ng-template #dropdownDefault>
    <ng-container *ngTemplateOutlet="dropdownListbox"> </ng-container>
  </ng-template>

  <ng-template #dropdownCDK>
    <ng-template cdkConnectedOverlay [cdkConnectedOverlayOrigin]="trigger" [cdkConnectedOverlayOpen]="true">
      <ng-container *ngTemplateOutlet="dropdownListbox"></ng-container>
    </ng-template>
  </ng-template>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>
</po-field-container>

<ng-template #dropdownListbox>
  <po-multiselect-dropdown
    #dropdownElement
    [p-searching]="isServerSearching"
    [p-hide-search]="hideSearch"
    [p-hide-select-all]="hideSelectAll"
    [p-literals]="literals"
    [p-options]="options"
    [p-visible-options]="visibleOptionsDropdown"
    [p-selected-options]="selectedOptions"
    [p-placeholder-search]="placeholderSearch"
    [p-field-value]="fieldValue"
    [p-field-label]="fieldLabel"
    [p-multiselect-template]="multiselectOptionTemplate"
    (p-change)="changeItems($event)"
    (p-change-search)="changeSearch($event)"
    (p-close-dropdown)="controlDropdownVisibility(false)"
    (keydown)="onKeyDownDropdown($event, 0)"
  >
  </po-multiselect-dropdown>
</ng-template>
` }]
  }], () => [{ type: Renderer2 }, { type: ChangeDetectorRef }, { type: ElementRef }, { type: PoControlPositionService }, { type: PoMultiselectFilterService }, { type: PoLanguageService }], { multiselectOptionTemplate: [{
    type: ContentChild,
    args: [PoMultiselectOptionTemplateDirective, { static: true }]
  }], dropdownElement: [{
    type: ViewChild,
    args: ["dropdownElement", { read: ElementRef }]
  }], dropdown: [{
    type: ViewChild,
    args: ["dropdownElement"]
  }], iconElement: [{
    type: ViewChild,
    args: ["iconElement", { read: ElementRef, static: true }]
  }], inputElement: [{
    type: ViewChild,
    args: ["inputElement", { read: ElementRef, static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMultiselectComponent, { className: "PoMultiselectComponent", filePath: "lib/components/po-field/po-multiselect/po-multiselect.component.ts", lineNumber: 118 });
})();
var PoNumberBaseComponent = class _PoNumberBaseComponent extends PoInputGeneric {
  type = "number";
  invalidInputValueOnBlur = false;
  /* istanbul ignore next */
  constructor(elementRef, cd) {
    super(elementRef, cd);
  }
  eventOnInput(e) {
    if (!this.mask) {
      let value = e.target.value;
      const valueMaxlength = this.validMaxLength(this.maxlength, value);
      this.invalidInputValueOnBlur = false;
      if (value !== valueMaxlength) {
        value = valueMaxlength;
        this.inputEl.nativeElement.value = value;
      }
      this.callOnChange(this.formatNumber(value));
    }
  }
  onBlur(event) {
    const target = event.target;
    this.invalidInputValueOnBlur = target.value === "" && !target.validity.valid;
    if (this.invalidInputValueOnBlur) {
      this.callOnChange("Valor Inválido");
    }
    this.eventOnBlur(event);
  }
  onKeyDown(event) {
    if (!this.isKeyAllowed(event)) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
  validMaxLength(maxlength, value) {
    if (maxlength && value.length > maxlength) {
      const substringValue = value.toString().substring(0, maxlength);
      if (substringValue && this.isEndWithDot(substringValue)) {
        return substringValue.toString().substring(0, maxlength - 1);
      }
      return substringValue;
    }
    return value;
  }
  writeValueModel(value) {
    if (this.inputEl) {
      if (value || value === 0) {
        if (this.mask) {
          this.inputEl.nativeElement.value = this.objMask.controlFormatting(String(value));
          if (this.objMask.formatModel) {
            this.onChangePropagate(this.objMask.valueToModel);
          }
        } else {
          this.inputEl.nativeElement.value = value;
        }
      } else {
        this.inputEl.nativeElement.value = "";
      }
    }
    this.changeModel.emit(value);
  }
  isEndWithDot(value) {
    return value && value.lastIndexOf(".") === value.length - 1;
  }
  formatNumber(value) {
    return value ? Number(value) : null;
  }
  isKeyAllowed(event) {
    return this.isShortcut(event) || this.isControlKeys(event) || !this.isInvalidKey(event.key);
  }
  isInvalidKey(key) {
    const validatesKey = new RegExp(/[a-zA-Z:;=_´`^~"'?!@#$%¨&*()><{}çÇ\[\]/\\|]+/);
    return validatesKey.test(key);
  }
  isShortcut(event) {
    const key = event.keyCode;
    const ctrl = event.ctrlKey || event.metaKey;
    const keyA = key === 65;
    const keyC = key === 67;
    const keyX = key === 88;
    const keyV = key === 86;
    return ctrl && keyC || ctrl && keyV || ctrl && keyA || ctrl && keyX;
  }
  isControlKeys(event) {
    const controlKeys = [
      "Backspace",
      "ArrowLeft",
      "ArrowRight",
      "ArrowUp",
      "ArrowDown",
      "Left",
      "Right",
      "Up",
      "Down",
      "Tab",
      "Delete",
      "Home",
      "End",
      "Enter"
    ];
    return controlKeys.indexOf(event.key) !== -1;
  }
  static ɵfac = function PoNumberBaseComponent_Factory(t) {
    return new (t || _PoNumberBaseComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoNumberBaseComponent, features: [ɵɵInheritDefinitionFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNumberBaseComponent, [{
    type: Directive
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], null);
})();
function PoNumberComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-field-icon-disabled", ctx_r0.disabled);
    ɵɵproperty("p-icon", ctx_r0.icon);
  }
}
function PoNumberComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoNumberComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-default-value", null)("p-element-ref", ctx_r2.inputEl);
  }
}
var PoNumberComponent = class _PoNumberComponent extends PoNumberBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Intervalo.
   *
   * @default 1
   */
  step = "1";
  /** Valor mínimo.
   *
   * > Quando o valor mínimo for um número com decimais aconselha-se utilizar junto da propriedade `p-step` também passando a ela um valor decimal.
   */
  min;
  set setMin(min) {
    this.min = !isNaN(min) ? min : void 0;
    this.validateModel();
  }
  /** Valor máximo.
   *
   * > Quando o valor máximo for um número com decimais aconselha-se utilizar junto da propriedade `p-step` também passando a ela um valor decimal.
   */
  max;
  set setMax(max) {
    this.max = !isNaN(max) ? max : void 0;
    this.validateModel();
  }
  id = `po-number[${uuid()}]`;
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  onWheel(event) {
    event.preventDefault();
  }
  extraValidation(abstractControl) {
    this.errorPattern = this.errorPattern !== "Valor Inválido" ? this.errorPattern : "";
    if (minFailed(this.min, abstractControl.value)) {
      return {
        min: {
          valid: false
        }
      };
    }
    if (maxFailed(this.max, abstractControl.value)) {
      return {
        max: {
          valid: false
        }
      };
    }
    if (this.invalidInputValueOnBlur) {
      this.errorPattern = this.errorPattern || "Valor Inválido";
      return {
        number: {
          valid: false
        }
      };
    }
    return null;
  }
  getErrorPatternMessage() {
    return this.errorPattern !== "" && this.containsInvalidClass() ? this.errorPattern : "";
  }
  containsInvalidClass() {
    return this.el.nativeElement.classList.contains("ng-invalid") && this.el.nativeElement.classList.contains("ng-dirty") && this.inputEl.nativeElement.value !== "" || this.invalidInputValueOnBlur;
  }
  static ɵfac = function PoNumberComponent_Factory(t) {
    return new (t || _PoNumberComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNumberComponent, selectors: [["po-number"]], hostBindings: function PoNumberComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("wheel", function PoNumberComponent_wheel_HostBindingHandler($event) {
        return ctx.onWheel($event);
      });
    }
  }, inputs: { step: [InputFlags.None, "p-step", "step"], setMin: [InputFlags.None, "p-min", "setMin"], setMax: [InputFlags.None, "p-max", "setMax"] }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoNumberComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoNumberComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 8, vars: 26, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], ["type", "number", 1, "po-input", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "tabindex", "blur", "focus", "input", "keydown"], ["inp", ""], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-default-value", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-field-icon-container-left"], [1, "po-field-icon", "po-icon-input", 3, "p-icon"], [1, "po-icon-input", 3, "p-default-value", "p-element-ref", "p-change-event"]], template: function PoNumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1);
      ɵɵtemplate(2, PoNumberComponent_div_2_Template, 2, 3, "div", 2);
      ɵɵelementStart(3, "input", 3, 4);
      ɵɵlistener("blur", function PoNumberComponent_Template_input_blur_3_listener($event) {
        return ctx.onBlur($event);
      })("focus", function PoNumberComponent_Template_input_focus_3_listener($event) {
        return ctx.eventOnFocus($event);
      })("input", function PoNumberComponent_Template_input_input_3_listener($event) {
        return ctx.eventOnInput($event);
      })("keydown", function PoNumberComponent_Template_input_keydown_3_listener($event) {
        return ctx.onKeyDown($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵtemplate(6, PoNumberComponent_po_clean_6_Template, 1, 2, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelement(7, "po-field-container-bottom", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("tabindex", ctx.disabled ? -1 : 0);
      ɵɵattribute("max", ctx.max)("min", ctx.min)("name", ctx.name)("step", ctx.step);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPatternMessage());
    }
  }, dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNumberComponent, [{
    type: Component,
    args: [{ selector: "po-number", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoNumberComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoNumberComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon class="po-field-icon po-icon-input" [class.po-field-icon-disabled]="disabled" [p-icon]="icon"></po-icon>
    </div>
    <input
      #inp
      class="po-input"
      type="number"
      [attr.max]="max"
      [attr.min]="min"
      [attr.name]="name"
      [attr.step]="step"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [tabindex]="disabled ? -1 : 0"
      (blur)="onBlur($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
      (keydown)="onKeyDown($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-default-value]="null"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled" [p-error-pattern]="getErrorPatternMessage()">
  </po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], { step: [{
    type: Input,
    args: ["p-step"]
  }], setMin: [{
    type: Input,
    args: ["p-min"]
  }], setMax: [{
    type: Input,
    args: ["p-max"]
  }], onWheel: [{
    type: HostListener,
    args: ["wheel", ["$event"]]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNumberComponent, { className: "PoNumberComponent", filePath: "lib/components/po-field/po-number/po-number.component.ts", lineNumber: 61 });
})();
function PoPasswordComponent_po_clean_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 9);
    ɵɵlistener("p-change-event", function PoPasswordComponent_po_clean_7_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-element-ref", ctx_r1.inputEl);
  }
}
function PoPasswordComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 10);
    ɵɵlistener("click", function PoPasswordComponent_span_8_Template_span_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.showPassword());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r2.visiblePassword ? "po-icon-eye" : "po-icon-eye-off po-field-icon-disabled");
  }
}
var PoPasswordComponent = class _PoPasswordComponent extends PoInputGeneric {
  id = `po-password[${uuid()}]`;
  type = "password";
  visiblePassword = false;
  _hidePasswordPeek = false;
  /**
   * @optional
   *
   * @description
   *
   * Permite esconder a função de espiar a senha digitada.
   *
   * @default `false`
   */
  set hidePasswordPeek(value) {
    this._hidePasswordPeek = convertToBoolean(value);
    if (value) {
      this.visiblePassword = false;
      this.type = "password";
    }
  }
  get hidePasswordPeek() {
    return this._hidePasswordPeek;
  }
  get autocomplete() {
    return this.noAutocomplete ? "new-password" : "on";
  }
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
  }
  extraValidation(c) {
    return null;
  }
  showPassword() {
    this.visiblePassword = !this.visiblePassword;
    this.type = this.type === "password" ? "text" : "password";
  }
  static ɵfac = function PoPasswordComponent_Factory(t) {
    return new (t || _PoPasswordComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPasswordComponent, selectors: [["po-password"]], inputs: { hidePasswordPeek: [InputFlags.None, "p-hide-password-peek", "hidePasswordPeek"] }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoPasswordComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoPasswordComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 10, vars: 28, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-field-icon-container-left"], [1, "po-input", "po-input-icon-left", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type", "blur", "click", "focus", "input"], ["inp", ""], [1, "po-field-icon-container-right"], ["class", "po-icon-input", 3, "p-element-ref", "p-change-event", 4, "ngIf"], ["class", "po-icon po-field-icon po-icon-input", 3, "ngClass", "click", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-icon-input", 3, "p-element-ref", "p-change-event"], [1, "po-icon", "po-field-icon", "po-icon-input", 3, "ngClass", "click"]], template: function PoPasswordComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "div", 2);
      ɵɵelement(3, "span");
      ɵɵelementEnd();
      ɵɵelementStart(4, "input", 3, 4);
      ɵɵlistener("blur", function PoPasswordComponent_Template_input_blur_4_listener($event) {
        return ctx.eventOnBlur($event);
      })("click", function PoPasswordComponent_Template_input_click_4_listener($event) {
        return ctx.eventOnClick($event);
      })("focus", function PoPasswordComponent_Template_input_focus_4_listener($event) {
        return ctx.eventOnFocus($event);
      })("input", function PoPasswordComponent_Template_input_input_4_listener($event) {
        return ctx.eventOnInput($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5);
      ɵɵtemplate(7, PoPasswordComponent_po_clean_7_Template, 1, 1, "po-clean", 6)(8, PoPasswordComponent_span_8_Template, 1, 1, "span", 7);
      ɵɵelementEnd()();
      ɵɵelement(9, "po-field-container-bottom", 8);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(5);
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(3);
      ɵɵclassMapInterpolate1("po-icon po-field-icon po-icon-lock ", ctx.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
      ɵɵclassProp("po-field-icon-disabled", ctx.disabled);
      ɵɵadvance();
      ɵɵclassProp("po-input-double-icon-right", ctx.clean && _r0.value && !ctx.hidePasswordPeek)("po-input-icon-right", ctx.clean || !ctx.hidePasswordPeek);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.disabled ? "password" : ctx.type);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hidePasswordPeek && !ctx.disabled);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern());
    }
  }, dependencies: [NgClass, NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPasswordComponent, [{
    type: Component,
    args: [{ selector: "po-password", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoPasswordComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoPasswordComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-field-icon-container-left">
      <span
        class="po-icon po-field-icon po-icon-lock {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
      >
      </span>
    </div>

    <input
      #inp
      class="po-input po-input-icon-left"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-double-icon-right]="clean && inp.value && !hidePasswordPeek"
      [class.po-input-icon-right]="clean || !hidePasswordPeek"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="disabled ? 'password' : type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="po-icon-input"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>

      <span
        *ngIf="!hidePasswordPeek && !disabled"
        class="po-icon po-field-icon po-icon-input"
        [ngClass]="visiblePassword ? 'po-icon-eye' : 'po-icon-eye-off po-field-icon-disabled'"
        (click)="showPassword()"
      >
      </span>
    </div>
  </div>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled" [p-error-pattern]="getErrorPattern()">
  </po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], { hidePasswordPeek: [{
    type: Input,
    args: ["p-hide-password-peek"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPasswordComponent, { className: "PoPasswordComponent", filePath: "lib/components/po-field/po-password/po-password.component.ts", lineNumber: 47 });
})();
var PoRichTextService = class _PoRichTextService {
  model = new Subject();
  emitModel(value) {
    this.model.next(value);
  }
  getModel() {
    return this.model.asObservable();
  }
  static ɵfac = function PoRichTextService_Factory(t) {
    return new (t || _PoRichTextService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoRichTextService, factory: _PoRichTextService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextService, [{
    type: Injectable
  }], null, null);
})();
var PoRichTextBaseComponent = class _PoRichTextBaseComponent {
  richTextService;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se o alinhamento de texto será desabilitado.
   *
   * @default `false`
   */
  disabledTextAlign = false;
  /**
   * @description
   *
   * Mensagem que será apresentada quando a propriedade required estiver habilitada e o campo for limpo após algo ser digitado.
   */
  errorMessage = "";
  /**
   * @optional
   *
   * @description
   *
   * Texto de apoio do campo.
   */
  help;
  /**
   * @optional
   *
   * @description
   *
   * Rótulo do campo.
   */
  label;
  /** Nome e identificador do campo. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao deixar o campo e que recebe como parâmetro o valor alterado.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao modificar valor do model e que recebe como parâmetro o valor alterado.
   */
  changeModel = new EventEmitter();
  invalid = false;
  onChangeModel = null;
  value;
  _height;
  _placeholder;
  _readonly;
  _required;
  validatorChange;
  // eslint-disable-next-line
  onTouched = null;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura da área de edição de texto.
   *
   * > Altura mínima do componente é `94` e a altura máxima é `262`.
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Mensagem que aparecerá enquanto o campo não estiver preenchido.
   *
   * @default ''
   */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente leitura.
   *
   * @default `false`
   */
  set readonly(value) {
    this._readonly = convertToBoolean(value);
  }
  get readonly() {
    return this._readonly;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(value) {
    this._required = convertToBoolean(value);
    this.validateModel(this.value);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  constructor(richTextService) {
    this.richTextService = richTextService;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangeModel = func;
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnTouched(func) {
    this.onTouched = func;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, false, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(value) {
    this.value = value;
    this.richTextService.emitModel(value);
  }
  // Executa a função onChange
  updateModel(value) {
    if (this.onChangeModel) {
      this.onChangeModel(value);
    }
  }
  validateModel(value) {
    if (this.validatorChange) {
      this.validatorChange(value);
    }
  }
  static ɵfac = function PoRichTextBaseComponent_Factory(t) {
    return new (t || _PoRichTextBaseComponent)(ɵɵdirectiveInject(PoRichTextService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoRichTextBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], disabledTextAlign: [InputFlags.HasDecoratorInputTransform, "p-disabled-text-align", "disabledTextAlign", convertToBoolean], errorMessage: [InputFlags.None, "p-error-message", "errorMessage"], help: [InputFlags.None, "p-help", "help"], label: [InputFlags.None, "p-label", "label"], name: "name", optional: [InputFlags.None, "p-optional", "optional"], height: [InputFlags.None, "p-height", "height"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], readonly: [InputFlags.None, "p-readonly", "readonly"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"] }, outputs: { change: "p-change", changeModel: "p-change-model" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextBaseComponent, [{
    type: Directive
  }], () => [{ type: PoRichTextService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], disabledTextAlign: [{
    type: Input,
    args: [{ alias: "p-disabled-text-align", transform: convertToBoolean }]
  }], errorMessage: [{
    type: Input,
    args: ["p-error-message"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], changeModel: [{
    type: Output,
    args: ["p-change-model"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], readonly: [{
    type: Input,
    args: ["p-readonly"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }] });
})();
var _c0$L = ["bodyElement"];
var poRichTextBodyCommands = [
  "bold",
  "italic",
  "underline",
  "justifyleft",
  "justifycenter",
  "justifyright",
  "justifyfull",
  "insertUnorderedList",
  "Createlink"
];
var PoRichTextBodyComponent = class _PoRichTextBodyComponent {
  richTextService;
  bodyElement;
  height;
  label;
  modelValue;
  placeholder;
  readonly;
  change = new EventEmitter();
  commands = new EventEmitter();
  selectedLink = new EventEmitter();
  shortcutCommand = new EventEmitter();
  value = new EventEmitter();
  blur = new EventEmitter();
  isLinkEditing;
  linkElement;
  timeoutChange;
  valueBeforeChange;
  modelSubscription;
  constructor(richTextService) {
    this.richTextService = richTextService;
  }
  ngOnInit() {
    this.bodyElement.nativeElement.designMode = "on";
    this.modelSubscription = this.richTextService.getModel().subscribe((modelValue) => {
      this.modelValue = modelValue;
      this.bodyElement.nativeElement.innerHTML = "";
      this.updateValueWithModelValue();
      this.addClickListenerOnAnchorElements();
    });
  }
  ngOnDestroy() {
    this.modelSubscription?.unsubscribe();
  }
  executeCommand(command) {
    this.bodyElement.nativeElement.focus();
    if (typeof command === "object") {
      if (command.command === "InsertHTML") {
        const { command: linkCommand, value: { urlLink }, value: { urlLinkText } } = command;
        this.handleCommandLink(linkCommand, urlLink, urlLinkText);
      } else {
        document.execCommand(command.command, false, command.value);
      }
    } else {
      document.execCommand(command, false, null);
    }
    this.updateModel();
    this.value.emit(this.modelValue);
  }
  linkEditing(event) {
    this.isLinkEditing = !!event;
  }
  onBlur() {
    this.blur.emit();
    if (this.modelValue !== this.valueBeforeChange) {
      clearTimeout(this.timeoutChange);
      this.timeoutChange = setTimeout(() => {
        this.change.emit(this.modelValue);
      }, 200);
    }
  }
  focus() {
    this.bodyElement.nativeElement.focus();
  }
  onClick() {
    this.emitSelectionCommands();
  }
  onFocus() {
    this.valueBeforeChange = this.modelValue;
  }
  onKeyDown(event) {
    const keyK = event.keyCode === PoKeyCodeEnum.keyK;
    const isLinkShortcut = keyK && event.ctrlKey || keyK && event.metaKey;
    if (isLinkShortcut) {
      event.preventDefault();
      this.shortcutCommand.emit();
    }
    this.toggleCursorOnLink(event, "add");
  }
  onKeyUp(event) {
    this.toggleCursorOnLink(event, "remove");
    this.removeBrElement();
    this.updateModel();
    this.emitSelectionCommands();
  }
  onPaste() {
    this.update();
    setTimeout(() => this.addClickListenerOnAnchorElements());
  }
  update() {
    setTimeout(() => this.updateModel());
    setTimeout(() => {
      this.removeBrElement();
      this.updateModel();
      this.emitSelectionCommands();
    });
  }
  addClickListenerOnAnchorElements() {
    this.bodyElement.nativeElement.querySelectorAll("a").forEach((element) => {
      element.addEventListener("click", this.onAnchorClick);
    });
  }
  emitSelectionCommands() {
    const commands = poRichTextBodyCommands.filter((command) => document.queryCommandState(command));
    const rgbColor = document.queryCommandValue("ForeColor");
    let hexColor;
    if (!isIE()) {
      hexColor = this.rgbToHex(rgbColor);
    }
    if (this.isCursorPositionedInALink()) {
      commands.push("Createlink");
    }
    this.selectedLink.emit(this.linkElement);
    this.commands.emit({ commands, hexColor });
  }
  getTextSelection() {
    const textSelection = document.getSelection();
    if (!textSelection) {
      return;
    }
    const focusNode = textSelection.focusNode ? textSelection.focusNode.parentElement : void 0;
    const anchorNode = textSelection.anchorNode ? textSelection.anchorNode.parentNode : void 0;
    const node = focusNode || anchorNode;
    let tagName;
    if (node) {
      tagName = node["tagName"] || node["nodeName"];
      return {
        node,
        tagName
      };
    }
  }
  handleCommandLink(linkCommand, urlLink, urlLinkText) {
    if (isIE()) {
      this.insertHtmlLinkElement(urlLink, urlLinkText);
    } else {
      const linkValue = isFirefox() && !this.isLinkEditing ? `&nbsp;${this.makeLinkTag(urlLink, urlLinkText)}&nbsp;` : this.makeLinkTag(urlLink, urlLinkText);
      document.execCommand(linkCommand, false, linkValue);
    }
    this.addClickListenerOnAnchorElements();
  }
  // tratamento específico para IE pois não suporta o comando 'insertHTML'.
  insertHtmlLinkElement(urlLink, urlLinkText) {
    const selection = document.getSelection();
    const selectionRange = selection.getRangeAt(0);
    const elementLink = document.createElement("a");
    const elementlinkText = document.createTextNode(urlLinkText);
    elementLink.appendChild(elementlinkText);
    elementLink.href = urlLink;
    elementLink.setAttribute("target", "_blank");
    elementLink.classList.add("po-rich-text-link");
    selectionRange.deleteContents();
    selectionRange.insertNode(elementLink);
  }
  isCursorPositionedInALink() {
    const textSelection = this.getTextSelection();
    this.linkElement = void 0;
    let isLink = false;
    if (textSelection && textSelection.node && textSelection.tagName === "A") {
      this.linkElement = textSelection.node;
      isLink = true;
    } else if ((isFirefox() || isIEOrEdge()) && this.verifyCursorPositionInFirefoxIEEdge()) {
      isLink = true;
    } else {
      isLink = textSelection ? this.isParentNodeAnchor(textSelection) : false;
    }
    return isLink;
  }
  isParentNodeAnchor(textSelection) {
    let element = textSelection.node;
    let isLink = false;
    while (element && (element.tagName !== null || element.nodeName !== null)) {
      if (element.tagName === "A" || element.nodeName === "A") {
        this.linkElement = element;
        isLink = true;
        return isLink;
      }
      element = element.parentElement || element.parentNode;
    }
    this.linkElement = void 0;
    return isLink;
  }
  makeLinkTag(urlLink, urlLinkText) {
    return `<a class="po-rich-text-link" href="${urlLink}" target="_blank">${urlLinkText || urlLink}</a>`;
  }
  onAnchorClick = (event) => {
    const { target, ctrlKey, metaKey } = event;
    let url;
    let elementLink;
    if (ctrlKey || metaKey) {
      if (event.path) {
        event.path.forEach((element) => {
          if (element.nodeName === "A") {
            url = element.href;
            elementLink = element;
          }
        });
      } else {
        url = target.attributes.href.value;
        elementLink = target;
      }
      openExternalLink(url);
      elementLink.classList.remove("po-clickable");
    }
  };
  // Tratamento necessário para eliminar a tag <br> criada no firefox quando o body for limpo.
  removeBrElement() {
    const bodyElement = this.bodyElement.nativeElement;
    if (!bodyElement.innerText.trim() && bodyElement.childNodes.length === 1 && bodyElement.querySelector("br")) {
      bodyElement.querySelector("br").remove();
    }
  }
  rgbToHex(rgb) {
    const sep = rgb.indexOf(",") > -1 ? "," : " ";
    rgb = rgb.substr(4).split(")")[0].split(sep);
    let r = (+rgb[0]).toString(16);
    let g = (+rgb[1]).toString(16);
    let b = (+rgb[2]).toString(16);
    if (r.length === 1) {
      r = "0" + r;
    }
    if (g.length === 1) {
      g = "0" + g;
    }
    if (b.length === 1) {
      b = "0" + b;
    }
    return "#" + r + g + b;
  }
  toggleCursorOnLink(event, action) {
    const selection = document.getSelection();
    const element = selection.focusNode ? selection.focusNode.parentNode : void 0;
    const isCtrl = event.key === "Control";
    const isCommand = event.key === "Meta";
    const isOnCtrlLink = this.isCursorPositionedInALink() && (isCtrl || isCommand);
    if (element) {
      if (isOnCtrlLink) {
        element["classList"][action]("po-clickable");
      } else {
        const isClickable = element["classList"] && element["classList"].contains("po-clickable");
        if (isClickable) {
          element["classList"].remove("po-clickable");
        }
      }
      this.updateModel();
    }
  }
  updateModel() {
    this.modelValue = this.bodyElement.nativeElement.innerHTML;
    this.value.emit(this.modelValue);
  }
  updateValueWithModelValue() {
    if (this.modelValue) {
      this.bodyElement.nativeElement.insertAdjacentHTML("afterbegin", this.modelValue);
    }
  }
  verifyCursorPositionInFirefoxIEEdge() {
    const textSelection = document.getSelection();
    const nodeLink = textSelection.focusNode;
    let isLink = false;
    if (nodeLink && nodeLink.nodeName === "A") {
      this.linkElement = nodeLink;
      isLink = true;
    } else {
      const range = textSelection.getRangeAt(0);
      const fragmentDocument = range.cloneContents();
      const element = fragmentDocument.childNodes[0] || fragmentDocument.firstElementChild;
      this.linkElement = element && element.nodeName === "A" ? element : void 0;
      isLink = !!this.linkElement;
    }
    return isLink;
  }
  static ɵfac = function PoRichTextBodyComponent_Factory(t) {
    return new (t || _PoRichTextBodyComponent)(ɵɵdirectiveInject(PoRichTextService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRichTextBodyComponent, selectors: [["po-rich-text-body"]], viewQuery: function PoRichTextBodyComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$L, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.bodyElement = _t.first);
    }
  }, inputs: { height: [InputFlags.None, "p-height", "height"], label: [InputFlags.None, "p-label", "label"], modelValue: [InputFlags.None, "p-model-value", "modelValue"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], readonly: [InputFlags.None, "p-readonly", "readonly"] }, outputs: { change: "p-change", commands: "p-commands", selectedLink: "p-selected-link", shortcutCommand: "p-shortcut-command", value: "p-value", blur: "p-blur" }, decls: 2, vars: 5, consts: [["tabindex", "0", 1, "po-rich-text-body", 3, "blur", "click", "cut", "focus", "keydown", "keyup", "paste"], ["bodyElement", ""]], template: function PoRichTextBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("blur", function PoRichTextBodyComponent_Template_div_blur_0_listener() {
        return ctx.onBlur();
      })("click", function PoRichTextBodyComponent_Template_div_click_0_listener() {
        return ctx.onClick();
      })("cut", function PoRichTextBodyComponent_Template_div_cut_0_listener() {
        return ctx.update();
      })("focus", function PoRichTextBodyComponent_Template_div_focus_0_listener() {
        return ctx.onFocus();
      })("keydown", function PoRichTextBodyComponent_Template_div_keydown_0_listener($event) {
        return ctx.onKeyDown($event);
      })("keyup", function PoRichTextBodyComponent_Template_div_keyup_0_listener($event) {
        return ctx.onKeyUp($event);
      })("paste", function PoRichTextBodyComponent_Template_div_paste_0_listener() {
        return ctx.onPaste();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.height, "px");
      ɵɵattribute("aria-label", ctx.label)("contenteditable", !ctx.readonly)("data-placeholder", ctx.placeholder);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextBodyComponent, [{
    type: Component,
    args: [{ selector: "po-rich-text-body", template: '<div\n  #bodyElement\n  class="po-rich-text-body"\n  tabindex="0"\n  [attr.aria-label]="label"\n  [attr.contenteditable]="!readonly"\n  [attr.data-placeholder]="placeholder"\n  [style.height.px]="height"\n  (blur)="onBlur()"\n  (click)="onClick()"\n  (cut)="update()"\n  (focus)="onFocus()"\n  (keydown)="onKeyDown($event)"\n  (keyup)="onKeyUp($event)"\n  (paste)="onPaste()"\n></div>\n' }]
  }], () => [{ type: PoRichTextService }], { bodyElement: [{
    type: ViewChild,
    args: ["bodyElement", { static: true }]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], modelValue: [{
    type: Input,
    args: ["p-model-value"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], readonly: [{
    type: Input,
    args: ["p-readonly"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], commands: [{
    type: Output,
    args: ["p-commands"]
  }], selectedLink: [{
    type: Output,
    args: ["p-selected-link"]
  }], shortcutCommand: [{
    type: Output,
    args: ["p-shortcut-command"]
  }], value: [{
    type: Output,
    args: ["p-value"]
  }], blur: [{
    type: Output,
    args: ["p-blur"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextBodyComponent, { className: "PoRichTextBodyComponent", filePath: "lib/components/po-field/po-rich-text/po-rich-text-body/po-rich-text-body.component.ts", lineNumber: 25 });
})();
var poRichTextLiteralsDefault = {
  en: {
    bold: "Bold",
    italic: "Italic",
    underline: "Underline",
    left: "Left",
    center: "Center",
    right: "Right",
    justify: "Justify",
    textColor: "Text color",
    unorderedList: "Bulleted list",
    insertLink: "Insert link",
    linkTextLabel: "Text with link",
    linkUrlTextHelper: "Paste in the text box below the copied browser link",
    linkUrlTextPlaceholder: "Enter the link address that will be attached to the text.",
    cancel: "Cancel",
    editLink: "Edit link",
    insert: "Insert",
    insertImage: "Insert image",
    urlImage: "URL image"
  },
  es: {
    bold: "Negrita",
    italic: "Cursiva",
    underline: "Subrayado",
    left: "Izquierda",
    center: "Centro",
    right: "Derecha",
    justify: "Justificado",
    textColor: "Color del texto",
    unorderedList: "Lista con viñetas",
    insertLink: "Insertar el link",
    linkTextLabel: "Texto con enlace",
    linkUrlTextHelper: "Pegue en el cuadro de texto debajo del enlace del navegador copiado",
    linkUrlTextPlaceholder: "Ingrese la dirección del enlace que se adjuntará al texto.",
    cancel: "Cancelar",
    editLink: "Editar enlace",
    insert: "Insertar",
    insertImage: "Insertar imagen",
    urlImage: "Imagen URL"
  },
  pt: {
    bold: "Negrito",
    italic: "Itálico",
    underline: "Sublinhado",
    left: "Esquerda",
    center: "Centro",
    right: "Direita",
    justify: "Justificado",
    textColor: "Cor do texto",
    unorderedList: "Lista com marcadores",
    insertLink: "Inserir link",
    linkTextLabel: "Texto com link",
    linkUrlTextHelper: "Cole na caixa de texto abaixo o link copiado do navegador",
    linkUrlTextPlaceholder: "Insira o endereço do link que será anexado ao texto",
    cancel: "Cancelar",
    editLink: "Editar link",
    insert: "Inserir",
    insertImage: "Inserir imagem",
    urlImage: "Imagem em URL"
  },
  ru: {
    bold: "Жирный",
    italic: "Италик",
    underline: "Подчеркивание",
    left: "Влево",
    center: "Центр",
    right: "Вправо",
    justify: "Растянуть",
    textColor: "Цвет текста",
    unorderedList: "Список",
    insertLink: "Вставьте ссылку",
    linkTextLabel: "Текст со ссылкой",
    linkUrlTextHelper: "Вставьте в текстовое поле ниже скопированную ссылку",
    linkUrlTextPlaceholder: "Вставьте ссылку для привязки к тексту",
    cancel: "Отмена",
    editLink: "Редактировать ссылку",
    insert: "Вставить",
    insertImage: "Вставить изображение",
    urlImage: "Ссылка на изображение"
  }
};
var PoUploadStatus;
(function(PoUploadStatus2) {
  PoUploadStatus2[PoUploadStatus2["Uploaded"] = 0] = "Uploaded";
  PoUploadStatus2[PoUploadStatus2["Uploading"] = 1] = "Uploading";
  PoUploadStatus2[PoUploadStatus2["Error"] = 2] = "Error";
  PoUploadStatus2[PoUploadStatus2["None"] = 3] = "None";
})(PoUploadStatus || (PoUploadStatus = {}));
var PoUploadFile = class {
  // Nome do arquivo.
  name;
  // Arquivo bruto.
  rawFile;
  // Status de envio do arquivo.
  status;
  // Identificador do arquivo.
  uid;
  // Extensão do arquivo.
  extension;
  // Tamanho do arquivo em bytes;
  size;
  // propriedade para auxiliar a exibição do texto no componente progress
  displayName;
  // porcentagem utilizada para repassar ao componente progress
  percent;
  constructor(file) {
    if (file) {
      this.name = file.name;
      this.displayName = `${file.name} - ${this.getFileSize(file.size)}`;
      this.extension = this.getExtension(file.name);
      this.size = file.size;
      this.rawFile = file;
      this.uid = this.generateUUID();
      this.status = PoUploadStatus.None;
    }
  }
  getExtension(value) {
    if (value) {
      const extension = value.substr(value.lastIndexOf("."));
      return extension.toLowerCase();
    }
    return "";
  }
  generateUUID() {
    function s4() {
      return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
    }
    return s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
  }
  // Retorna o tamanho do arquivo em KBytes.
  getFileSize(size) {
    let kbSize = 0;
    if (size) {
      kbSize = Math.ceil(size / 1024);
    }
    return `${kbSize} KB`;
  }
};
var PoUploadBaseService = class _PoUploadBaseService {
  http;
  formField = "files";
  requests = [];
  constructor(http) {
    this.http = http;
  }
  /**
   * Método responsável por enviar os arquivos ao servidor, conforme o parâmetro URL.
   *
   * @param url URL da requisição a ser efetuada.
   * @param files Arquivos a serem enviados.
   * @param tOnUpload Função a ser executada quando o arquivo for enviado ao servidor.
   * @param uploadCallback Função que será executada enquanto os arquivos estiverem sendo enviados.
   * @param successCallback Função a ser executada quando a requisição for efetuada com sucesso.
   * @param errorCallback Função a ser executada quando a requisição foi efetuada com sucesso.
   */
  upload(url, files, headers, tOnUpload, uploadCallback, successCallback, errorCallback) {
    const filesLength = files.length;
    const uploadEvent = {
      data: {},
      file: null,
      url,
      headers
    };
    for (let i = 0; i < filesLength; i++) {
      const formData = new FormData();
      const file = files[i];
      const fileName = file.rawFile.name;
      formData.append(this.formField, file.rawFile, fileName);
      if (tOnUpload) {
        uploadEvent["file"] = file;
        tOnUpload.emit(uploadEvent);
        formData.append("data", JSON.stringify(uploadEvent.data));
        url = uploadEvent.url;
        headers = uploadEvent.headers;
      }
      this.sendFile(url, file, headers, formData, uploadCallback, successCallback, errorCallback);
    }
  }
  sendFile(url, file, headers, formData, uploadCallback, successCallback, errorCallback) {
    let request = new Subscription();
    request = this.getRequest(url, headers, formData).subscribe((event) => {
      if (event.type === HttpEventType.UploadProgress) {
        this.addRequest(file, request);
        const percentDone = Math.round(100 * event.loaded / event.total);
        uploadCallback(file, percentDone);
      } else if (event instanceof HttpResponse) {
        successCallback(file, event);
      }
    }, (err) => {
      errorCallback(file, err);
    });
  }
  getRequest(url, headers, formData) {
    const httpHeaders = new HttpHeaders(headers);
    const req = new HttpRequest("POST", url, formData, {
      reportProgress: true,
      headers: httpHeaders
    });
    return this.http.request(req);
  }
  stopRequestByFile(file, callback) {
    const requestObj = this.requests.find((req) => req.file.uid === file.uid);
    if (requestObj) {
      const request = requestObj.request;
      request.unsubscribe();
      this.removeRequest(requestObj);
      callback();
    }
  }
  removeRequest(requestObj) {
    const index = this.requests.indexOf(requestObj);
    this.requests.splice(index, 1);
  }
  addRequest(file, request) {
    const hasRequest = this.requests.some((req) => req.file.uid === file.uid);
    if (!hasRequest) {
      this.requests.push({ file, request });
    }
  }
  static ɵfac = function PoUploadBaseService_Factory(t) {
    return new (t || _PoUploadBaseService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoUploadBaseService, factory: _PoUploadBaseService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadBaseService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var PoUploadService = class _PoUploadService extends PoUploadBaseService {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoUploadService_BaseFactory;
    return function PoUploadService_Factory(t) {
      return (ɵPoUploadService_BaseFactory || (ɵPoUploadService_BaseFactory = ɵɵgetInheritedFactory(_PoUploadService)))(t || _PoUploadService);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({ token: _PoUploadService, factory: _PoUploadService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadService, [{
    type: Injectable
  }], null, null);
})();
var poUploadLiteralsDefault = {
  en: {
    files: "files",
    folders: "folders",
    selectFile: "Select file",
    selectFiles: "Select files",
    selectFolder: "Select folder",
    startSending: "Start sending",
    dragFilesHere: "Drag files here",
    dragFoldersHere: "Drag folders here",
    selectFilesOnComputer: "or select files on your computer",
    selectFolderOnComputer: "or select folder on your computer",
    dropFilesHere: "Drop files here",
    dropFoldersHere: "Drop folders here",
    invalidDropArea: "{0} were not dropped in the correct area",
    invalidFileType: "Failed to load {0} file(s) as it is not the allowed file type.",
    invalidAmount: "Failed to load {0} file(s), as it exceeds the limit amount of files.",
    invalidFormat: "Failed to load {0} file(s), as it does not match the format(s): {1}.",
    invalidSize: "Failed to load {0} files(s), as it is not the allowed size: from {1} to {2}.",
    numberOfFilesAllowed: "{0} file(s) allowed",
    allowedFormats: "Accepted file formats: {0}.",
    allowedFileSizeRange: "Size limit per file: from {0} to {1}",
    maxFileSizeAllowed: "Size limit per file: {0} maximum",
    minFileSizeAllowed: "Size limit per file: {0} minimum",
    errorOccurred: "An error has occurred",
    sentWithSuccess: "Sent with success"
  },
  es: {
    files: "archivos",
    folders: "carpetas",
    selectFile: "Seleccionar archivo",
    selectFiles: "Seleccionar archivos",
    selectFolder: "Seleccionar carpeta",
    startSending: "Iniciar carga",
    dragFilesHere: "Arrastra los archivos aquí",
    dragFoldersHere: "Arrastra las carpetas aquí",
    selectFilesOnComputer: "o selecciona los archivos en tu computadora",
    selectFolderOnComputer: "o selecciona la carpeta en tu computadora",
    dropFilesHere: "Deja los archivos aquí",
    dropFoldersHere: "Deja las carpetas aquí",
    invalidDropArea: "Los {0} no se insertaron en la ubicación correcta",
    invalidFileType: "Error al cargar {0} archivo (s) ya que no es el tipo de archivo permitido",
    invalidAmount: "Error al cargar {0} archivo (s) ya que excede la cantidad limite de archivos.",
    invalidFormat: "Error al cargar {0} archivo (s) ya que no coincide con el formato (s): {1}.",
    invalidSize: "Error al cargar {0} archivo (s) ya que no cumple con el tamaño permitido: desde {1} hasta {2}.",
    numberOfFilesAllowed: "{0} archivo(s) permitido(s)",
    allowedFormats: "Formatos aceptados: {0}.",
    allowedFileSizeRange: "Limite de tamaño de archivo: desde {0} hasta {1}",
    maxFileSizeAllowed: "Limite de tamaño de archivo: hasta {0}",
    minFileSizeAllowed: "Limite de tamaño de archivo: minimo {0}",
    errorOccurred: "Ocurrio un error",
    sentWithSuccess: "Enviado con éxito"
  },
  pt: {
    files: "arquivos",
    folders: "diretórios",
    selectFile: "Selecionar arquivo",
    selectFiles: "Selecionar arquivos",
    selectFolder: "Selecionar pasta",
    startSending: "Iniciar envio",
    dragFilesHere: "Arraste os arquivos aqui",
    dragFoldersHere: "Arraste as pastas aqui",
    selectFilesOnComputer: "ou selecione os arquivos no computador",
    selectFolderOnComputer: "ou selecione a pasta no computador",
    dropFilesHere: "Solte os arquivos aqui",
    dropFoldersHere: "Solte as pastas aqui",
    invalidDropArea: "Os {0} não foram inseridos no local correto",
    invalidFileType: "Falha ao carregar {0} arquivo (s), pois não é o tipo de arquivo permitido",
    invalidAmount: "Falha ao carregar {0} arquivo(s), pois excede(m) a quantidade limite de arquivos.",
    invalidFormat: "Falha ao carregar {0} arquivo(s), pois não corresponde(m) ao(s) formato(s): {1}.",
    invalidSize: "Falha ao carregar {0} arquivo(s), pois não atende ao tamanho permitido: {1} até {2}.",
    numberOfFilesAllowed: "Quantidade máxima: {0} arquivo(s)",
    allowedFormats: "Formatos adotados: {0}.",
    allowedFileSizeRange: "Limite de tamanho por arquivo: de {0} até {1}",
    maxFileSizeAllowed: "Limite de tamanho por arquivo: até {0}",
    minFileSizeAllowed: "Limite de tamanho por arquivo: no mínimo {0}",
    errorOccurred: "Ocorreu um erro",
    sentWithSuccess: "Enviado com sucesso"
  },
  ru: {
    files: "файлы",
    folders: "папки с файлами",
    selectFile: "Выберите файл",
    selectFiles: "Выберите файлы",
    selectFolder: "Выберите папку с файлами",
    startSending: "Начать загрузку",
    dragFilesHere: "Перетащите файлы сюда",
    dragFoldersHere: "Перетащите сюда папки",
    selectFilesOnComputer: "или выберите файлы на компьютере",
    selectFolderOnComputer: "или выберите папку на вашем компьютере",
    dropFilesHere: "Оставьте файлы здесь",
    dropFoldersHere: "Перетащите сюда папки",
    invalidDropArea: "{0} не были вставлены в правильном месте.",
    invalidFileType: "Не удалось загрузить файлы {0}, так как это неверный тип файла",
    invalidAmount: "Não foi possível carregar os arquivos {0} porque eles excederam o limite de arquivos.",
    invalidFormat: "Не удалось загрузить файлы {0}, так как они не соответствуют формату (ам): {1}.",
    invalidSize: "Не удалось загрузить файлы {0}, поскольку они не соответствуют разрешенному размеру: от {1} до {2}.",
    numberOfFilesAllowed: "Максимальное количество: {0} файлов",
    allowedFormats: "Форматы приняты: {0}.",
    allowedFileSizeRange: "Ограничение размера файла: от {0} до {1}",
    maxFileSizeAllowed: "Ограничение размера файла: до {0}",
    minFileSizeAllowed: "Ограничение размера файла: не менее {0}",
    errorOccurred: "Произошла ошибка.",
    sentWithSuccess: "Успешно отправлено"
  }
};
var poUploadFormFieldDefault = "files";
var poUploadMaxFileSize = 31457280;
var poUploadMinFileSize = 0;
var PoUploadBaseComponent = class _PoUploadBaseComponent {
  uploadService;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /**
   * @optional
   *
   * @description
   *
   * Define em *pixels* a altura da área onde podem ser arrastados os arquivos. A altura mínima aceita é `160px`.
   *
   * > Esta propriedade funciona somente se a propriedade `p-drag-drop` estiver habilitada.
   *
   * @default `320`
   */
  dragDropHeight;
  /** Rótulo do campo. */
  label;
  /** Texto de apoio para o campo. */
  help;
  /** URL que deve ser feita a requisição com os arquivos selecionados. */
  url;
  /** Define o valor do atributo `name` do componente. */
  name = "file";
  /**
   * @optional
   *
   * @description
   *
   * Define se o envio do arquivo será automático ao selecionar o mesmo.
   *
   * > Esta propriedade funciona somente se a propriedade `p-url` tiver um valor atribuído.
   *
   * @default `false`
   */
  autoUpload = false;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   *  - O campo conter `p-required`;
   *  - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /** Objeto que contém os cabeçalhos que será enviado na requisição dos arquivos. */
  headers;
  /**
   * @optional
   *
   * @description
   *
   * Define se a propriedade `p-url` é obrigatória.
   *
   * Caso a propriedade seja definida como `false`:
   * - o botão de "Selecionar arquivo" ficará habilitado mesmo sem a propriedade `p-url` definida.
   * - o botão "Iniciar envio" ficará oculto até que a propriedade `p-url` seja definida.
   *
   * > Se utilizada com a propriedade `p-auto-upload` definida como `true` será necessário definir a propriedade `p-url`.
   *
   * @default `true`
   */
  requiredUrl = true;
  /**
   * @optional
   *
   * @description
   *
   * Função que será executada no momento de realizar o envio do arquivo,
   * onde será possível adicionar informações ao parâmetro que será enviado na requisição.
   * É passado por parâmetro um objeto com o arquivo e a propriedade data nesta propriedade pode ser informado algum dado,
   * que será enviado em conjunto com o arquivo na requisição, por exemplo:
   *
   * ```
   *   event.data = {id: 'id do usuário'};
   * ```
   */
  onUpload = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento será disparado quando ocorrer algum erro no envio do arquivo.
   * > Por parâmetro será passado o objeto do retorno que é do tipo `HttpErrorResponse`.
   */
  onError = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento será disparado quando o envio do arquivo for realizado com sucesso.
   * > Por parâmetro será passado o objeto do retorno que é do tipo `HttpResponse`.
   */
  onSuccess = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da *tag* `form`.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-upload ... [ngModel]="UploadModel" (ngModelChange)="uploadModel = $event"> </po-upload>
   * ```
   *
   */
  ngModelChange = new EventEmitter();
  allowedExtensions;
  currentFiles;
  canHandleDirectory;
  onModelChange;
  extensionNotAllowed = 0;
  quantityNotAllowed = 0;
  sizeNotAllowed = 0;
  onModelTouched = null;
  _directory;
  _disabled;
  _dragDrop = false;
  _fileRestrictions;
  _formField;
  _hideRestrictionsInfo;
  _hideSelectButton;
  _hideSendButton;
  _isMultiple;
  _literals;
  _required;
  language;
  validatorChange;
  /**
   * @optional
   *
   * @description
   *
   * Permite a seleção de diretórios contendo um ou mais arquivos para envio.
   *
   * > A habilitação desta propriedade se restringe apenas à seleção de diretórios.
   *
   * > Definição não suportada pelo browser **Internet Explorer**, todavia será possível a seleção de arquivos padrão.
   *
   * @default `false`
   */
  set directory(value) {
    this._directory = convertToBoolean(value);
    this.canHandleDirectory = this._directory && !isIE() && !isMobile();
    this.setDirectoryAttribute(this.canHandleDirectory);
  }
  get directory() {
    return this._directory;
  }
  /**
   * @optional
   *
   * @description
   *
   * Exibe a área onde é possível arrastar e selecionar os arquivos. Quando estiver definida, omite o botão para seleção de arquivos
   * automaticamente.
   *
   * > Recomendamos utilizar apenas um `po-upload` com esta funcionalidade por tela.
   *
   * @default `false`
   */
  set dragDrop(value) {
    this._dragDrop = convertToBoolean(value);
  }
  get dragDrop() {
    return this._dragDrop;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta visualmente as informações de restrições para o upload.
   *
   * @default `false`
   */
  set hideRestrictionsInfo(value) {
    this._hideRestrictionsInfo = convertToBoolean(value);
  }
  get hideRestrictionsInfo() {
    return this._hideRestrictionsInfo;
  }
  /**
   * @optional
   *
   * @description
   *
   * Omite o botão de seleção de arquivos.
   *
   * > Caso o valor definido seja `true`, caberá ao desenvolvedor a responsabilidade
   * pela chamada do método `selectFiles()` para seleção de arquivos.
   *
   * @default `false`
   */
  set hideSelectButton(value) {
    this._hideSelectButton = convertToBoolean(value);
  }
  get hideSelectButton() {
    return this._hideSelectButton;
  }
  /**
   * @optional
   *
   * @description
   *
   * Omite o botão de envio de arquivos.
   *
   * > Caso o valor definido seja `true`, caberá ao desenvolvedor a responsabilidade
   * pela chamada do método `sendFiles()` para envio do(s) arquivo(s) selecionado(s).
   *
   * @default `false`
   */
  set hideSendButton(value) {
    this._hideSendButton = convertToBoolean(value);
  }
  get hideSendButton() {
    return this._hideSendButton;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-upload`.
   *
   * Existem duas maneiras de customizar o componente:
   *
   * - passando um objeto implementando a interface `PoUploadLiterals` com todas as literais disponíveis;
   * - passando apenas as literais que deseja customizar:
   * ```
   *  const customLiterals: PoUploadLiterals = {
   *    folders: 'Pastas',
   *    selectFile: 'Buscar arquivo',
   *    startSending: 'Enviar'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente:
   *
   * ```
   * <po-upload
   *   [p-literals]="customLiterals">
   * </po-upload>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do *browser* (pt, en, es, ru).
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poUploadLiteralsDefault[poLocaleDefault]), poUploadLiteralsDefault[this.language]), value);
    } else {
      this._literals = poUploadLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poUploadLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto que segue a definição da interface `PoUploadFileRestrictions`,
   * que possibilita definir tamanho máximo/mínimo e extensão dos arquivos permitidos.
   */
  set fileRestrictions(restrictions) {
    this._fileRestrictions = this.initRestrictions(restrictions);
    this.setAllowedExtensions(restrictions);
  }
  get fileRestrictions() {
    return this._fileRestrictions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Nome do campo de formulário que será enviado para o serviço informado na propriedade `p-url`.
   *
   * @default `files`
   */
  set formField(value) {
    this._formField = value && typeof value === "string" ? value : poUploadFormFieldDefault;
    this.getUploadService().formField = this.formField;
  }
  get formField() {
    return this._formField;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.validateModel(this.currentFiles);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se pode selecionar mais de um arquivo.
   *
   * > Se utilizada a `p-directory`, habilita-se automaticamente esta propriedade.
   */
  set isMultiple(value) {
    this._isMultiple = convertToBoolean(value);
  }
  get isMultiple() {
    return this.canHandleDirectory ? true : this._isMultiple;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel(this.currentFiles);
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  constructor(uploadService, languageService) {
    this.uploadService = uploadService;
    this.language = languageService.getShortLanguage();
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  registerOnValidatorChange(fn) {
    this.validatorChange = fn;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
  }
  writeValue(model) {
    if (model) {
      if (!isEquals(this.currentFiles, model)) {
        this.currentFiles = this.parseFiles(model);
      }
    } else {
      this.currentFiles = void 0;
    }
  }
  isExceededFileLimit(currentFilesLength) {
    return this.isMultiple && this.fileRestrictions && this.fileRestrictions.maxFiles > 0 && this.fileRestrictions.maxFiles <= currentFilesLength;
  }
  // Faz o parse dos arquivos selecionados para arquivos do formato PoUploadFile e atualiza os arquivos correntes.
  parseFiles(files) {
    let poUploadFiles = this.currentFiles || [];
    const filesLength = files.length;
    for (let i = 0; i < filesLength; i++) {
      if (this.isExceededFileLimit(poUploadFiles.length)) {
        this.quantityNotAllowed = filesLength - this.fileRestrictions.maxFiles;
        break;
      }
      const file = new PoUploadFile(files[i]);
      if (this.checkRestrictions(file)) {
        poUploadFiles = this.insertFileInFiles(file, poUploadFiles);
      }
    }
    this.sendFeedback();
    return poUploadFiles;
  }
  validateModel(model) {
    if (this.validatorChange) {
      this.validatorChange(model);
    }
  }
  // Verifica se o arquivo está de acordo com as restrições.
  checkRestrictions(file) {
    const restrictions = this.fileRestrictions;
    if (restrictions) {
      const allowedExtensions = restrictions.allowedExtensions;
      const minFileSize = restrictions.minFileSize;
      const maxFileSize = restrictions.maxFileSize;
      const isAccept = allowedExtensions ? this.isAllowedExtension(file.extension, allowedExtensions) : true;
      const isAcceptSize = file.size >= minFileSize && file.size <= maxFileSize;
      if (!isAcceptSize) {
        this.sizeNotAllowed = this.sizeNotAllowed + 1;
      }
      return isAccept && isAcceptSize;
    }
    return true;
  }
  existsFileSameName(file, files) {
    return files.some((currentFile) => file.name === currentFile.name);
  }
  getUploadService() {
    return this.uploadService;
  }
  insertFileInFiles(newFile, files) {
    if (this.existsFileSameName(newFile, files)) {
      return this.updateExistsFileInFiles(newFile, files);
    }
    if (this.isMultiple) {
      files.push(newFile);
    } else {
      files.splice(0, files.length, newFile);
    }
    return files;
  }
  isAllowedExtension(extension, allowedExtensions = []) {
    const isAllowed = allowedExtensions.some((ext) => ext.toLowerCase() === extension);
    if (!isAllowed) {
      this.extensionNotAllowed = this.extensionNotAllowed + 1;
    }
    return isAllowed;
  }
  setAllowedExtensions(restrictions = {}) {
    const _allowedExtensions = restrictions.allowedExtensions || [];
    this.allowedExtensions = _allowedExtensions.join(",");
  }
  initRestrictions(restrictions) {
    if (!restrictions) {
      return;
    }
    const minFileSize = restrictions.minFileSize || poUploadMinFileSize;
    const maxFileSize = restrictions.maxFileSize || poUploadMaxFileSize;
    return __spreadProps(__spreadValues({}, restrictions), {
      maxFileSize,
      minFileSize
    });
  }
  updateExistsFileInFiles(newFile, files) {
    const fileIndex = files.findIndex((currentFile) => newFile.name === currentFile.name && currentFile.status !== PoUploadStatus.Uploaded);
    if (fileIndex !== -1) {
      files.splice(fileIndex, 1, newFile);
    }
    return files;
  }
  static ɵfac = function PoUploadBaseComponent_Factory(t) {
    return new (t || _PoUploadBaseComponent)(ɵɵdirectiveInject(PoUploadService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoUploadBaseComponent, hostVars: 1, hostBindings: function PoUploadBaseComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("p-required-url", ctx.requiredUrl);
    }
  }, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], dragDropHeight: [InputFlags.None, "p-drag-drop-height", "dragDropHeight"], label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"], url: [InputFlags.None, "p-url", "url"], name: "name", autoUpload: [InputFlags.None, "p-auto-upload", "autoUpload"], optional: [InputFlags.None, "p-optional", "optional"], headers: [InputFlags.None, "p-headers", "headers"], requiredUrl: [InputFlags.HasDecoratorInputTransform, "p-required-url", "requiredUrl", convertToBoolean], directory: [InputFlags.None, "p-directory", "directory"], dragDrop: [InputFlags.None, "p-drag-drop", "dragDrop"], hideRestrictionsInfo: [InputFlags.None, "p-hide-restrictions-info", "hideRestrictionsInfo"], hideSelectButton: [InputFlags.None, "p-hide-select-button", "hideSelectButton"], hideSendButton: [InputFlags.None, "p-hide-send-button", "hideSendButton"], literals: [InputFlags.None, "p-literals", "literals"], fileRestrictions: [InputFlags.None, "p-restrictions", "fileRestrictions"], formField: [InputFlags.None, "p-form-field", "formField"], disabled: [InputFlags.None, "p-disabled", "disabled"], isMultiple: [InputFlags.None, "p-multiple", "isMultiple"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"] }, outputs: { onUpload: "p-upload", onError: "p-error", onSuccess: "p-success", ngModelChange: "ngModelChange" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadBaseComponent, [{
    type: Directive
  }], () => [{ type: PoUploadService }, { type: PoLanguageService }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], dragDropHeight: [{
    type: Input,
    args: ["p-drag-drop-height"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], url: [{
    type: Input,
    args: ["p-url"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], autoUpload: [{
    type: Input,
    args: ["p-auto-upload"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], headers: [{
    type: Input,
    args: ["p-headers"]
  }], requiredUrl: [{
    type: HostBinding,
    args: ["attr.p-required-url"]
  }, {
    type: Input,
    args: [{ alias: "p-required-url", transform: convertToBoolean }]
  }], onUpload: [{
    type: Output,
    args: ["p-upload"]
  }], onError: [{
    type: Output,
    args: ["p-error"]
  }], onSuccess: [{
    type: Output,
    args: ["p-success"]
  }], ngModelChange: [{
    type: Output,
    args: ["ngModelChange"]
  }], directory: [{
    type: Input,
    args: ["p-directory"]
  }], dragDrop: [{
    type: Input,
    args: ["p-drag-drop"]
  }], hideRestrictionsInfo: [{
    type: Input,
    args: ["p-hide-restrictions-info"]
  }], hideSelectButton: [{
    type: Input,
    args: ["p-hide-select-button"]
  }], hideSendButton: [{
    type: Input,
    args: ["p-hide-send-button"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], fileRestrictions: [{
    type: Input,
    args: ["p-restrictions"]
  }], formField: [{
    type: Input,
    args: ["p-form-field"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], isMultiple: [{
    type: Input,
    args: ["p-multiple"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }] });
})();
var _c0$K = ["selectFilesLink"];
function PoUploadDragDropAreaComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoUploadDragDropAreaComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 5);
    ɵɵelementStart(1, "div", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.directoryCompatible ? ctx_r1.literals == null ? null : ctx_r1.literals.dropFoldersHere : ctx_r1.literals == null ? null : ctx_r1.literals.dropFilesHere, " ");
  }
}
var _c1$h = (a0) => ({ "po-clickable": a0 });
function PoUploadDragDropAreaComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelement(0, "span", 7);
    ɵɵelementStart(1, "div", 8);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 9, 10);
    ɵɵlistener("click", function PoUploadDragDropAreaComponent_ng_template_5_Template_button_click_3_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.selectFiles.emit());
    });
    ɵɵtext(5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r3.directoryCompatible ? ctx_r3.literals == null ? null : ctx_r3.literals.dragFoldersHere : ctx_r3.literals == null ? null : ctx_r3.literals.dragFilesHere, " ");
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r3.disabled)("ngClass", ɵɵpureFunction1(4, _c1$h, !ctx_r3.disabled));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r3.directoryCompatible ? ctx_r3.literals == null ? null : ctx_r3.literals.selectFolderOnComputer : ctx_r3.literals == null ? null : ctx_r3.literals.selectFilesOnComputer, " ");
  }
}
var _c2$7 = (a0) => ({ "po-upload-drag-drop-area-disabled": a0 });
var PoUploadDragDropAreaComponent = class _PoUploadDragDropAreaComponent {
  elementRef;
  directoryCompatible;
  disabled;
  height;
  literals;
  overlay;
  selectFiles = new EventEmitter();
  selectFilesLinkElement;
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  focus() {
    this.selectFilesLinkElement.nativeElement.focus();
  }
  static ɵfac = function PoUploadDragDropAreaComponent_Factory(t) {
    return new (t || _PoUploadDragDropAreaComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoUploadDragDropAreaComponent, selectors: [["po-upload-drag-drop-area"]], viewQuery: function PoUploadDragDropAreaComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$K, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectFilesLinkElement = _t.first);
    }
  }, inputs: { directoryCompatible: [InputFlags.None, "p-directory-compatible", "directoryCompatible"], disabled: [InputFlags.None, "p-disabled", "disabled"], height: [InputFlags.None, "p-height", "height"], literals: [InputFlags.None, "p-literals", "literals"], overlay: [InputFlags.None, "p-overlay", "overlay"] }, outputs: { selectFiles: "p-select-files" }, decls: 7, vars: 8, consts: [[1, "po-upload-drag-drop-area", 3, "ngClass"], [1, "po-upload-drag-drop-area-container"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["overlayTemplate", ""], ["defaultTemplate", ""], [1, "po-upload-drag-drop-area-overlay-icon", "po-icon", "po-icon-upload-cloud"], [1, "po-upload-drag-drop-area-overlay-label"], [1, "po-upload-drag-drop-area-icon", "po-icon", "po-icon-upload-cloud"], [1, "po-upload-drag-drop-area-label"], [1, "po-upload-drag-drop-area-select-files", 3, "disabled", "ngClass", "click"], ["selectFilesLink", ""]], template: function PoUploadDragDropAreaComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, PoUploadDragDropAreaComponent_ng_container_2_Template, 1, 0, "ng-container", 2);
      ɵɵelementEnd()();
      ɵɵtemplate(3, PoUploadDragDropAreaComponent_ng_template_3_Template, 3, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor)(5, PoUploadDragDropAreaComponent_ng_template_5_Template, 6, 6, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(4);
      const _r4 = ɵɵreference(6);
      ɵɵstyleProp("height", ctx.height, "px");
      ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c2$7, ctx.disabled));
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.overlay && !ctx.disabled)("ngIfThen", _r2)("ngIfElse", _r4);
    }
  }, dependencies: [NgClass, NgIf], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropAreaComponent, [{
    type: Component,
    args: [{ selector: "po-upload-drag-drop-area", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div
  class="po-upload-drag-drop-area"
  [ngClass]="{ 'po-upload-drag-drop-area-disabled': disabled }"
  [style.height.px]="height"
>
  <div class="po-upload-drag-drop-area-container">
    <ng-container *ngIf="overlay && !disabled; then overlayTemplate; else defaultTemplate"> </ng-container>
  </div>
</div>

<ng-template #overlayTemplate>
  <span class="po-upload-drag-drop-area-overlay-icon po-icon po-icon-upload-cloud"></span>

  <div class="po-upload-drag-drop-area-overlay-label">
    {{ directoryCompatible ? literals?.dropFoldersHere : literals?.dropFilesHere }}
  </div>
</ng-template>

<ng-template #defaultTemplate>
  <span class="po-upload-drag-drop-area-icon po-icon po-icon-upload-cloud"></span>

  <div class="po-upload-drag-drop-area-label">
    {{ directoryCompatible ? literals?.dragFoldersHere : literals?.dragFilesHere }}
  </div>

  <button
    #selectFilesLink
    class="po-upload-drag-drop-area-select-files"
    [disabled]="disabled"
    [ngClass]="{ 'po-clickable': !disabled }"
    (click)="selectFiles.emit()"
  >
    {{ directoryCompatible ? literals?.selectFolderOnComputer : literals?.selectFilesOnComputer }}
  </button>
</ng-template>
` }]
  }], () => [{ type: ElementRef }], { directoryCompatible: [{
    type: Input,
    args: ["p-directory-compatible"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], overlay: [{
    type: Input,
    args: ["p-overlay"]
  }], selectFiles: [{
    type: Output,
    args: ["p-select-files"]
  }], selectFilesLinkElement: [{
    type: ViewChild,
    args: ["selectFilesLink"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadDragDropAreaComponent, { className: "PoUploadDragDropAreaComponent", filePath: "lib/components/po-field/po-upload/po-upload-drag-drop/po-upload-drag-drop-area/po-upload-drag-drop-area.component.ts", lineNumber: 10 });
})();
var PoUploadDragDropDirective = class _PoUploadDragDropDirective {
  i18nPipe;
  notification;
  areaElement;
  directoryCompatible;
  disabled;
  literals;
  dragLeave = new EventEmitter();
  dragOver = new EventEmitter();
  fileChange = new EventEmitter();
  timeout;
  files;
  invalidFileType;
  constructor(i18nPipe, notification) {
    this.i18nPipe = i18nPipe;
    this.notification = notification;
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    this.timeout = setTimeout(() => this.dragLeave.emit(), 30);
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this.timeout);
    if (!this.disabled) {
      this.dragOver.emit();
    }
  }
  onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    this.getFilesFromDataTransferItems(event);
    this.dragLeave.emit();
  }
  getFilesFromDataTransferItems(event) {
    if (!this.disabled) {
      this.invalidFileType = 0;
      if (this.directoryCompatible) {
        this.getOnlyDirectories(event.dataTransfer.items).then(() => {
          this.sendFiles(event, this.files);
        });
      } else {
        const files = this.getOnlyFiles(event.dataTransfer);
        this.sendFiles(event, files);
      }
    }
  }
  // analisa as entradas recursivamente
  getFilesFromEntry(entry) {
    return __async(this, null, function* () {
      if (entry.isFile) {
        const file = yield this.readFile(entry);
        return [file];
      } else if (entry.isDirectory) {
        return yield this.readDirectory(entry);
      }
    });
  }
  getOnlyDirectories(dataTransferItems) {
    return __async(this, null, function* () {
      const entries = [];
      for (const item of dataTransferItems) {
        entries.push(item.webkitGetAsEntry());
      }
      this.files = [];
      for (const entry of entries) {
        if (entry.isFile) {
          this.invalidFileType++;
        } else {
          const newFiles = yield this.getFilesFromEntry(entry);
          this.files = this.files.concat(newFiles);
        }
      }
    });
  }
  // return only files. If it is a directory, invalidFileType counts.
  getOnlyFiles(dataTransfer) {
    const fileList = Array.from(dataTransfer.files);
    const entriesFiles = Array.from(dataTransfer.items).map((item) => item.webkitGetAsEntry());
    return fileList.reduce((newFiles, file) => {
      const entryFile = entriesFiles.find((entry) => entry.name === file.name);
      if (entryFile.isFile) {
        return newFiles.concat(file);
      } else {
        this.invalidFileType++;
      }
      return newFiles;
    }, []);
  }
  readFile(entry) {
    return new Promise((resolve) => {
      entry.file((file) => {
        resolve(file);
      });
    });
  }
  readDirectory(entry) {
    return __async(this, null, function* () {
      const dirReader = entry.createReader();
      let files = [];
      const newFiles = yield this.readDirectoryEntries(dirReader);
      files = files.concat(newFiles);
      return files;
    });
  }
  readDirectoryEntries(dirReader) {
    return new Promise((resolve) => {
      dirReader.readEntries((entries) => __async(this, null, function* () {
        let files = [];
        for (const entry of entries) {
          const itemFiles = yield this.getFilesFromEntry(entry);
          files = files.concat(itemFiles);
        }
        resolve(files);
      }));
    });
  }
  sendFeedback(invalidFiles) {
    if (invalidFiles) {
      this.setPipeArguments("invalidFileType", invalidFiles);
    }
  }
  sendFiles(event, files) {
    if (this.areaElement.contains(event.target)) {
      if (files.length > 0) {
        this.fileChange.emit(files);
      }
      this.sendFeedback(this.invalidFileType);
    } else {
      const invalidDropAreaArg = this.directoryCompatible ? this.literals.folders : this.literals.files;
      this.setPipeArguments("invalidDropArea", invalidDropAreaArg);
    }
  }
  // método responsável por setar os argumentos do i18nPipe.
  setPipeArguments(literalAttributes, args) {
    const pipeArguments = this.i18nPipe.transform(this.literals[literalAttributes], args);
    this.notification.information(pipeArguments);
  }
  static ɵfac = function PoUploadDragDropDirective_Factory(t) {
    return new (t || _PoUploadDragDropDirective)(ɵɵdirectiveInject(PoI18nPipe), ɵɵdirectiveInject(PoNotificationService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoUploadDragDropDirective, selectors: [["", "p-upload-drag-drop", ""]], hostBindings: function PoUploadDragDropDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("dragleave", function PoUploadDragDropDirective_dragleave_HostBindingHandler($event) {
        return ctx.onDragLeave($event);
      }, false, ɵɵresolveDocument)("dragover", function PoUploadDragDropDirective_dragover_HostBindingHandler($event) {
        return ctx.onDragOver($event);
      }, false, ɵɵresolveDocument)("drop", function PoUploadDragDropDirective_drop_HostBindingHandler($event) {
        return ctx.onDrop($event);
      }, false, ɵɵresolveDocument);
    }
  }, inputs: { areaElement: [InputFlags.None, "p-area-element", "areaElement"], directoryCompatible: [InputFlags.None, "p-directory-compatible", "directoryCompatible"], disabled: [InputFlags.None, "p-disabled", "disabled"], literals: [InputFlags.None, "p-literals", "literals"] }, outputs: { dragLeave: "p-drag-leave", dragOver: "p-drag-over", fileChange: "p-file-change" }, features: [ɵɵProvidersFeature([PoI18nPipe])] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropDirective, [{
    type: Directive,
    args: [{
      selector: "[p-upload-drag-drop]",
      providers: [PoI18nPipe]
    }]
  }], () => [{ type: PoI18nPipe }, { type: PoNotificationService }], { areaElement: [{
    type: Input,
    args: ["p-area-element"]
  }], directoryCompatible: [{
    type: Input,
    args: ["p-directory-compatible"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], dragLeave: [{
    type: Output,
    args: ["p-drag-leave"]
  }], dragOver: [{
    type: Output,
    args: ["p-drag-over"]
  }], fileChange: [{
    type: Output,
    args: ["p-file-change"]
  }], onDragLeave: [{
    type: HostListener,
    args: ["document:dragleave", ["$event"]]
  }], onDragOver: [{
    type: HostListener,
    args: ["document:dragover", ["$event"]]
  }], onDrop: [{
    type: HostListener,
    args: ["document:drop", ["$event"]]
  }] });
})();
var _c0$J = ["DragDropAreaFixed"];
var PoUploadDragDropAreaOverlayComponent = class _PoUploadDragDropAreaOverlayComponent {
  renderer;
  DragDropAreaFixed;
  directoryCompatible;
  disabled;
  literals;
  target;
  areaElement = new EventEmitter();
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (this.target) {
      this.setPosition(this.target);
    }
    this.areaElement.emit(this.DragDropAreaFixed.nativeElement);
  }
  setPosition(targetElement) {
    const boundingClientRect = targetElement.nativeElement.getBoundingClientRect();
    const clientRectKeys = ["bottom", "left", "height", "right", "top", "width"];
    clientRectKeys.forEach((clientRectKey) => {
      const clientRectValue = boundingClientRect[clientRectKey];
      this.renderer.setStyle(this.DragDropAreaFixed.nativeElement, clientRectKey, `${clientRectValue}px`);
    });
  }
  static ɵfac = function PoUploadDragDropAreaOverlayComponent_Factory(t) {
    return new (t || _PoUploadDragDropAreaOverlayComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoUploadDragDropAreaOverlayComponent, selectors: [["po-upload-drag-drop-area-overlay"]], viewQuery: function PoUploadDragDropAreaOverlayComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$J, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.DragDropAreaFixed = _t.first);
    }
  }, inputs: { directoryCompatible: [InputFlags.None, "p-directory-compatible", "directoryCompatible"], disabled: [InputFlags.None, "p-disabled", "disabled"], literals: [InputFlags.None, "p-literals", "literals"], target: [InputFlags.None, "p-target", "target"] }, outputs: { areaElement: "p-area-element" }, decls: 3, vars: 4, consts: [[1, "po-overlay-fixed"], [1, "po-upload-drag-drop-area-overlay", 3, "p-directory-compatible", "p-disabled", "p-literals", "p-overlay"], ["DragDropAreaFixed", ""]], template: function PoUploadDragDropAreaOverlayComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵelement(1, "po-upload-drag-drop-area", 1, 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("p-directory-compatible", ctx.directoryCompatible)("p-disabled", ctx.disabled)("p-literals", ctx.literals)("p-overlay", true);
    }
  }, dependencies: [PoUploadDragDropAreaComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropAreaOverlayComponent, [{
    type: Component,
    args: [{ selector: "po-upload-drag-drop-area-overlay", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-overlay-fixed">\n  <po-upload-drag-drop-area\n    #DragDropAreaFixed\n    class="po-upload-drag-drop-area-overlay"\n    [p-directory-compatible]="directoryCompatible"\n    [p-disabled]="disabled"\n    [p-literals]="literals"\n    [p-overlay]="true"\n  >\n  </po-upload-drag-drop-area>\n</div>\n' }]
  }], () => [{ type: Renderer2 }], { DragDropAreaFixed: [{
    type: ViewChild,
    args: ["DragDropAreaFixed", { read: ElementRef, static: true }]
  }], directoryCompatible: [{
    type: Input,
    args: ["p-directory-compatible"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], target: [{
    type: Input,
    args: ["p-target"]
  }], areaElement: [{
    type: Output,
    args: ["p-area-element"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadDragDropAreaOverlayComponent, { className: "PoUploadDragDropAreaOverlayComponent", filePath: "lib/components/po-field/po-upload/po-upload-drag-drop/po-upload-drag-drop-area-overlay/po-upload-drag-drop-area-overlay.component.ts", lineNumber: 20 });
})();
var _c0$I = ["dragDropOverlay"];
function PoUploadDragDropComponent_po_upload_drag_drop_area_overlay_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-upload-drag-drop-area-overlay", 2, 3);
    ɵɵlistener("p-area-element", function PoUploadDragDropComponent_po_upload_drag_drop_area_overlay_0_Template_po_upload_drag_drop_area_overlay_p_area_element_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onAreaElement($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-directory-compatible", ctx_r0.directoryCompatible)("p-disabled", ctx_r0.disabled)("p-literals", ctx_r0.literals)("p-target", ctx_r0.dragDropAreaComponent.elementRef);
  }
}
var PoUploadDragDropHeightDefault = 320;
var PoUploadDragDropHeightMin = 160;
var PoUploadDragDropComponent = class _PoUploadDragDropComponent {
  changeDetector;
  dragDropOverlayElement;
  dragDropAreaComponent;
  directoryCompatible;
  disabled;
  literals;
  fileChange = new EventEmitter();
  selectFiles = new EventEmitter();
  areaElement;
  isDragOver = false;
  _dragDropHeight = PoUploadDragDropHeightDefault;
  set dragDropHeight(value) {
    const dragDropHeight = convertToInt(value, PoUploadDragDropHeightDefault);
    this._dragDropHeight = dragDropHeight < PoUploadDragDropHeightMin ? PoUploadDragDropHeightMin : dragDropHeight;
  }
  get dragDropHeight() {
    return this._dragDropHeight;
  }
  constructor(changeDetector) {
    this.changeDetector = changeDetector;
  }
  focus() {
    this.dragDropAreaComponent.focus();
  }
  onAreaElement(element) {
    this.areaElement = element;
    this.changeDetector.detectChanges();
  }
  onDragLeave() {
    this.isDragOver = false;
  }
  onDragOver() {
    this.isDragOver = true;
  }
  onFileChange(files) {
    this.isDragOver = false;
    this.fileChange.emit(files);
  }
  static ɵfac = function PoUploadDragDropComponent_Factory(t) {
    return new (t || _PoUploadDragDropComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoUploadDragDropComponent, selectors: [["po-upload-drag-drop"]], viewQuery: function PoUploadDragDropComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$I, 5, ElementRef);
      ɵɵviewQuery(PoUploadDragDropAreaComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragDropOverlayElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragDropAreaComponent = _t.first);
    }
  }, inputs: { directoryCompatible: [InputFlags.None, "p-directory-compatible", "directoryCompatible"], disabled: [InputFlags.None, "p-disabled", "disabled"], literals: [InputFlags.None, "p-literals", "literals"], dragDropHeight: [InputFlags.None, "p-drag-drop-height", "dragDropHeight"] }, outputs: { fileChange: "p-file-change", selectFiles: "p-select-files" }, decls: 2, vars: 7, consts: [[3, "p-directory-compatible", "p-disabled", "p-literals", "p-target", "p-area-element", 4, "ngIf"], ["p-upload-drag-drop", "", 3, "p-area-element", "p-directory-compatible", "p-disabled", "p-height", "p-literals", "p-overlay", "p-drag-leave", "p-drag-over", "p-file-change", "p-select-files"], [3, "p-directory-compatible", "p-disabled", "p-literals", "p-target", "p-area-element"], ["dragDropOverlay", ""]], template: function PoUploadDragDropComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoUploadDragDropComponent_po_upload_drag_drop_area_overlay_0_Template, 2, 4, "po-upload-drag-drop-area-overlay", 0);
      ɵɵelementStart(1, "po-upload-drag-drop-area", 1);
      ɵɵlistener("p-drag-leave", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_drag_leave_1_listener() {
        return ctx.onDragLeave();
      })("p-drag-over", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_drag_over_1_listener() {
        return ctx.onDragOver();
      })("p-file-change", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_file_change_1_listener($event) {
        return ctx.onFileChange($event);
      })("p-select-files", function PoUploadDragDropComponent_Template_po_upload_drag_drop_area_p_select_files_1_listener() {
        return ctx.selectFiles.emit();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isDragOver);
      ɵɵadvance();
      ɵɵproperty("p-area-element", ctx.areaElement)("p-directory-compatible", ctx.directoryCompatible)("p-disabled", ctx.disabled)("p-height", ctx.dragDropHeight)("p-literals", ctx.literals)("p-overlay", false);
    }
  }, dependencies: [NgIf, PoUploadDragDropDirective, PoUploadDragDropAreaOverlayComponent, PoUploadDragDropAreaComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadDragDropComponent, [{
    type: Component,
    args: [{ selector: "po-upload-drag-drop", changeDetection: ChangeDetectionStrategy.OnPush, template: '<po-upload-drag-drop-area-overlay\n  #dragDropOverlay\n  *ngIf="isDragOver"\n  [p-directory-compatible]="directoryCompatible"\n  [p-disabled]="disabled"\n  [p-literals]="literals"\n  [p-target]="dragDropAreaComponent.elementRef"\n  (p-area-element)="onAreaElement($event)"\n>\n</po-upload-drag-drop-area-overlay>\n\n<po-upload-drag-drop-area\n  p-upload-drag-drop\n  [p-area-element]="areaElement"\n  [p-directory-compatible]="directoryCompatible"\n  [p-disabled]="disabled"\n  [p-height]="dragDropHeight"\n  [p-literals]="literals"\n  [p-overlay]="false"\n  (p-drag-leave)="onDragLeave()"\n  (p-drag-over)="onDragOver()"\n  (p-file-change)="onFileChange($event)"\n  (p-select-files)="selectFiles.emit()"\n>\n</po-upload-drag-drop-area>\n' }]
  }], () => [{ type: ChangeDetectorRef }], { dragDropOverlayElement: [{
    type: ViewChild,
    args: ["dragDropOverlay", { read: ElementRef }]
  }], dragDropAreaComponent: [{
    type: ViewChild,
    args: [PoUploadDragDropAreaComponent, { static: true }]
  }], directoryCompatible: [{
    type: Input,
    args: ["p-directory-compatible"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], fileChange: [{
    type: Output,
    args: ["p-file-change"]
  }], selectFiles: [{
    type: Output,
    args: ["p-select-files"]
  }], dragDropHeight: [{
    type: Input,
    args: ["p-drag-drop-height"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadDragDropComponent, { className: "PoUploadDragDropComponent", filePath: "lib/components/po-field/po-upload/po-upload-drag-drop/po-upload-drag-drop.component.ts", lineNumber: 25 });
})();
function PoUploadFileRestrictionsComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 1);
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r0.literals == null ? null : ctx_r0.literals.numberOfFilesAllowed, ctx_r0.maxFiles), "\n");
  }
}
function PoUploadFileRestrictionsComponent_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 1);
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r1.literals == null ? null : ctx_r1.literals.allowedFormats, ctx_r1.allowedExtensions), "\n");
  }
}
var _c0$H = (a0, a1) => [a0, a1];
function PoUploadFileRestrictionsComponent_p_2_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r3.literals == null ? null : ctx_r3.literals.allowedFileSizeRange, ɵɵpureFunction2(4, _c0$H, ctx_r3.minFileSize, ctx_r3.maxFileSize)), " ");
  }
}
function PoUploadFileRestrictionsComponent_p_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r4.literals == null ? null : ctx_r4.literals.minFileSizeAllowed, ctx_r4.minFileSize), " ");
  }
}
function PoUploadFileRestrictionsComponent_p_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵpipe(2, "poI18n");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 1, ctx_r5.literals == null ? null : ctx_r5.literals.maxFileSizeAllowed, ctx_r5.maxFileSize), " ");
  }
}
function PoUploadFileRestrictionsComponent_p_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 1)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, PoUploadFileRestrictionsComponent_p_2_span_3_Template, 3, 7, "span", 2)(4, PoUploadFileRestrictionsComponent_p_2_span_4_Template, 3, 4, "span", 2)(5, PoUploadFileRestrictionsComponent_p_2_span_5_Template, 3, 4, "span", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.literals == null ? null : ctx_r2.literals.allowedSizes);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.minFileSize && ctx_r2.maxFileSize);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.minFileSize && !ctx_r2.maxFileSize);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.maxFileSize && !ctx_r2.minFileSize);
  }
}
var PoUploadFileRestrictionsComponent = class _PoUploadFileRestrictionsComponent {
  changeDetector;
  maxFiles;
  literals;
  _allowedExtensions;
  _maxFileSize;
  _minFileSize;
  language;
  set allowedExtensions(value) {
    this._allowedExtensions = this.formatAllowedExtensions(value);
  }
  get allowedExtensions() {
    return this._allowedExtensions;
  }
  set maxFileSize(value) {
    this._maxFileSize = formatBytes(value);
  }
  get maxFileSize() {
    return this._maxFileSize;
  }
  set minFileSize(value) {
    this._minFileSize = formatBytes(value);
  }
  get minFileSize() {
    return this._minFileSize;
  }
  constructor(changeDetector, languageService) {
    this.changeDetector = changeDetector;
    this.language = languageService.getShortLanguage();
  }
  ngOnInit() {
    this.setLiterals();
  }
  formatAllowedExtensions(allowedExtensions) {
    const conjunction = { "pt": "e", "en": "and", "es": "y", "ru": "и" };
    return allowedExtensions ? allowedExtensions.join(", ").toUpperCase().replace(/,(?=[^,]*$)/, ` ${conjunction[this.language]}`) : void 0;
  }
  setLiterals() {
    this.literals = __spreadValues(__spreadValues({}, poUploadLiteralsDefault[poLocaleDefault]), poUploadLiteralsDefault[this.language]);
    this.changeDetector.detectChanges();
  }
  static ɵfac = function PoUploadFileRestrictionsComponent_Factory(t) {
    return new (t || _PoUploadFileRestrictionsComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoUploadFileRestrictionsComponent, selectors: [["po-upload-file-restrictions"]], inputs: { maxFiles: [InputFlags.None, "p-max-files", "maxFiles"], allowedExtensions: [InputFlags.None, "p-allowed-extensions", "allowedExtensions"], maxFileSize: [InputFlags.None, "p-max-file-size", "maxFileSize"], minFileSize: [InputFlags.None, "p-min-file-size", "minFileSize"] }, decls: 3, vars: 3, consts: [["class", "po-font-text-small", 4, "ngIf"], [1, "po-font-text-small"], [4, "ngIf"]], template: function PoUploadFileRestrictionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoUploadFileRestrictionsComponent_p_0_Template, 3, 4, "p", 0)(1, PoUploadFileRestrictionsComponent_p_1_Template, 3, 4, "p", 0)(2, PoUploadFileRestrictionsComponent_p_2_Template, 6, 4, "p", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.maxFiles > 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.allowedExtensions);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.minFileSize || ctx.maxFileSize);
    }
  }, dependencies: [NgIf, PoI18nPipe], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadFileRestrictionsComponent, [{
    type: Component,
    args: [{ selector: "po-upload-file-restrictions", changeDetection: ChangeDetectionStrategy.OnPush, template: '<p class="po-font-text-small" *ngIf="maxFiles > 1">\n  {{ literals?.numberOfFilesAllowed | poI18n: maxFiles }}\n</p>\n\n<p class="po-font-text-small" *ngIf="allowedExtensions">\n  {{ literals?.allowedFormats | poI18n: allowedExtensions }}\n</p>\n\n<p class="po-font-text-small" *ngIf="minFileSize || maxFileSize">\n  <span>{{ literals?.allowedSizes }}</span>\n\n  <span *ngIf="minFileSize && maxFileSize">\n    {{ literals?.allowedFileSizeRange | poI18n: [minFileSize, maxFileSize] }}\n  </span>\n\n  <span *ngIf="minFileSize && !maxFileSize">\n    {{ literals?.minFileSizeAllowed | poI18n: minFileSize }}\n  </span>\n\n  <span *ngIf="maxFileSize && !minFileSize">\n    {{ literals?.maxFileSizeAllowed | poI18n: maxFileSize }}\n  </span>\n</p>\n' }]
  }], () => [{ type: ChangeDetectorRef }, { type: PoLanguageService }], { maxFiles: [{
    type: Input,
    args: ["p-max-files"]
  }], allowedExtensions: [{
    type: Input,
    args: ["p-allowed-extensions"]
  }], maxFileSize: [{
    type: Input,
    args: ["p-max-file-size"]
  }], minFileSize: [{
    type: Input,
    args: ["p-min-file-size"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadFileRestrictionsComponent, { className: "PoUploadFileRestrictionsComponent", filePath: "lib/components/po-field/po-upload/po-upload-file-restrictions/po-upload-file-restrictions.component.ts", lineNumber: 14 });
})();
var _c0$G = ["inputFile"];
var _c1$g = ["uploadButton"];
function PoUploadComponent_po_upload_drag_drop_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-upload-drag-drop", 11);
    ɵɵlistener("p-file-change", function PoUploadComponent_po_upload_drag_drop_5_Template_po_upload_drag_drop_p_file_change_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.onFileChangeDragDrop($event));
    })("p-select-files", function PoUploadComponent_po_upload_drag_drop_5_Template_po_upload_drag_drop_p_select_files_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.selectFiles());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-directory-compatible", ctx_r1.canHandleDirectory)("p-disabled", ctx_r1.isDisabled)("p-drag-drop-height", ctx_r1.dragDropHeight)("p-literals", ctx_r1.literals);
  }
}
function PoUploadComponent_po_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 12, 13);
    ɵɵlistener("p-click", function PoUploadComponent_po_button_6_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.selectFiles());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r2.isDisabled)("p-label", ctx_r2.selectFileButtonLabel);
  }
}
var _c2$6 = (a0) => ({ "po-upload-file-restrictions-drag-drop": a0 });
function PoUploadComponent_po_upload_file_restrictions_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-upload-file-restrictions", 14);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(5, _c2$6, ctx_r3.displayDragDrop))("p-allowed-extensions", ctx_r3.fileRestrictions == null ? null : ctx_r3.fileRestrictions.allowedExtensions)("p-max-files", ctx_r3.maxFiles)("p-max-file-size", ctx_r3.fileRestrictions == null ? null : ctx_r3.fileRestrictions.maxFileSize)("p-min-file-size", ctx_r3.fileRestrictions == null ? null : ctx_r3.fileRestrictions.minFileSize);
  }
}
function PoUploadComponent_div_8_po_progress_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-progress", 19);
    ɵɵlistener("p-cancel", function PoUploadComponent_div_8_po_progress_3_Template_po_progress_p_cancel_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r15);
      const file_r13 = restoredCtx.$implicit;
      const ctx_r14 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r14.cancel(file_r13));
    })("p-retry", function PoUploadComponent_div_8_po_progress_3_Template_po_progress_p_retry_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r15);
      const file_r13 = restoredCtx.$implicit;
      const ctx_r16 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r16.uploadFiles([file_r13]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r13 = ctx.$implicit;
    const ctx_r12 = ɵɵnextContext(2);
    ɵɵproperty("p-info", ctx_r12.infoByUploadStatus[file_r13.status] == null ? null : ctx_r12.infoByUploadStatus[file_r13.status].text(file_r13.percent))("p-info-icon", ctx_r12.infoByUploadStatus[file_r13.status] == null ? null : ctx_r12.infoByUploadStatus[file_r13.status].icon)("p-status", ctx_r12.progressStatusByFileStatus[file_r13.status])("p-text", file_r13.displayName)("p-value", file_r13.percent);
  }
}
var _c3$3 = (a0) => ({ "po-upload-progress-container-area po-pt-2 po-pl-1": a0 });
function PoUploadComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15)(1, "po-container", 16)(2, "div", 17);
    ɵɵtemplate(3, PoUploadComponent_div_8_po_progress_3_Template, 1, 5, "po-progress", 18);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-height", ctx_r4.hasMoreThanFourItems ? 280 : "auto")("p-no-border", !ctx_r4.hasMoreThanFourItems)("p-no-padding", !ctx_r4.hasMoreThanFourItems);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c3$3, ctx_r4.hasMoreThanFourItems));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r4.currentFiles)("ngForTrackBy", ctx_r4.trackByFn);
  }
}
function PoUploadComponent_po_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 20);
    ɵɵlistener("p-click", function PoUploadComponent_po_button_9_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r17 = ɵɵnextContext();
      return ɵɵresetView(ctx_r17.uploadFiles(ctx_r17.currentFiles));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("po-mt-3", ctx_r5.hasMoreThanFourItems);
    ɵɵproperty("p-disabled", ctx_r5.hasAnyFileUploading(ctx_r5.currentFiles))("p-label", ctx_r5.literals.startSending);
  }
}
var PoUploadComponent = class _PoUploadComponent extends PoUploadBaseComponent {
  renderer;
  i18nPipe;
  notification;
  cd;
  inputFile;
  poUploadDragDropComponent;
  uploadButton;
  id = `po-upload[${uuid()}]`;
  infoByUploadStatus = {
    [PoUploadStatus.Uploaded]: {
      text: () => this.literals.sentWithSuccess,
      icon: "po-icon-ok"
    },
    [PoUploadStatus.Error]: {
      text: () => this.literals.errorOccurred
    },
    [PoUploadStatus.Uploading]: {
      text: (percent) => percent + "%"
    }
  };
  progressStatusByFileStatus = {
    [PoUploadStatus.Uploaded]: PoProgressStatus.Success,
    [PoUploadStatus.Error]: PoProgressStatus.Error
  };
  calledByCleanInputValue = false;
  constructor(uploadService, renderer, i18nPipe, notification, cd, languageService) {
    super(uploadService, languageService);
    this.renderer = renderer;
    this.i18nPipe = i18nPipe;
    this.notification = notification;
    this.cd = cd;
  }
  get displayDragDrop() {
    return this.dragDrop && !isMobile();
  }
  get displaySendButton() {
    const currentFiles = this.currentFiles || [];
    return !this.hideSendButton && !this.autoUpload && currentFiles.length > 0 && this.hasFileNotUploaded && this.requiredUrl;
  }
  get selectFileButtonLabel() {
    if (this.canHandleDirectory) {
      return this.literals.selectFolder;
    } else if (this.isMultiple) {
      return this.literals.selectFiles;
    } else {
      return this.literals.selectFile;
    }
  }
  get hasMoreThanFourItems() {
    return this.currentFiles && this.currentFiles.length > 4;
  }
  get hasMultipleFiles() {
    return this.currentFiles && this.currentFiles.length > 1;
  }
  get hasFileNotUploaded() {
    if (Array.isArray(this.currentFiles)) {
      return this.currentFiles.some((file) => file.status !== PoUploadStatus.Uploaded);
    }
    return false;
  }
  get isDisabled() {
    const currentFiles = this.currentFiles || [];
    return this.requiredUrl ? !!(this.hasAnyFileUploading(currentFiles) || !this.url || this.disabled || this.isExceededFileLimit(currentFiles.length)) : !!(this.hasAnyFileUploading(currentFiles) || this.autoUpload || this.disabled || this.isExceededFileLimit(currentFiles.length));
  }
  get maxFiles() {
    return this.isMultiple && this.fileRestrictions && this.fileRestrictions.maxFiles;
  }
  cancel(file) {
    if (file.status === PoUploadStatus.Uploading) {
      return this.stopUpload(file);
    }
    this.removeFile(file);
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  /** Método responsável por **limpar** o(s) arquivo(s) selecionado(s). */
  clear() {
    this.currentFiles = void 0;
    this.updateModel([]);
    this.cleanInputValue();
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoUploadComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoUploadComponent, { static: true }) upload: PoUploadComponent;
   *
   * focusUpload() {
   *   this.upload.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      if (this.uploadButton) {
        this.uploadButton.focus();
        return;
      }
      if (this.displayDragDrop) {
        this.poUploadDragDropComponent.focus();
      }
    }
  }
  // Verifica se existe algum arquivo sendo enviado ao serviço.
  hasAnyFileUploading(files) {
    if (files && files.length) {
      return files.some((file) => file.status === PoUploadStatus.Uploading);
    }
    return false;
  }
  // retorna se o status do arquivo é diferente de enviado
  isAllowCancelEvent(status) {
    return status !== PoUploadStatus.Uploaded;
  }
  // Função disparada ao selecionar algum arquivo.
  onFileChange(event) {
    if (this.calledByCleanInputValue) {
      this.calledByCleanInputValue = false;
      return event.preventDefault();
    }
    const files = event.target.files;
    this.updateFiles(files);
    this.cleanInputValue();
  }
  onFileChangeDragDrop(files) {
    this.updateFiles(files);
  }
  // Remove o arquivo passado por parâmetro da lista dos arquivos correntes.
  removeFile(file) {
    const index = this.currentFiles.indexOf(file);
    this.currentFiles.splice(index, 1);
    this.updateModel([...this.currentFiles]);
  }
  /** Método responsável por **abrir** a janela para seleção de arquivo(s). */
  selectFiles() {
    this.onModelTouched?.();
    this.calledByCleanInputValue = false;
    this.inputFile.nativeElement.click();
  }
  sendFeedback() {
    if (this.sizeNotAllowed > 0) {
      const minFileSize = formatBytes(this.fileRestrictions.minFileSize);
      const maxFileSize = formatBytes(this.fileRestrictions.maxFileSize);
      const args = [this.sizeNotAllowed, minFileSize || "0", maxFileSize];
      this.setPipeArguments("invalidSize", args);
      this.sizeNotAllowed = 0;
    }
    if (this.extensionNotAllowed > 0) {
      const allowedExtensionsFormatted = this.fileRestrictions.allowedExtensions.join(", ").toUpperCase();
      const args = [this.extensionNotAllowed, allowedExtensionsFormatted];
      this.setPipeArguments("invalidFormat", args);
      this.extensionNotAllowed = 0;
    }
    if (this.quantityNotAllowed > 0) {
      const args = [this.quantityNotAllowed];
      this.setPipeArguments("invalidAmount", args);
      this.quantityNotAllowed = 0;
    }
  }
  /** Método responsável por **enviar** o(s) arquivo(s) selecionado(s). */
  sendFiles() {
    if (this.currentFiles && this.currentFiles.length) {
      this.uploadFiles(this.currentFiles);
    }
  }
  setDirectoryAttribute(canHandleDirectory) {
    if (canHandleDirectory) {
      this.renderer.setAttribute(this.inputFile.nativeElement, "webkitdirectory", "true");
    } else {
      this.renderer.removeAttribute(this.inputFile.nativeElement, "webkitdirectory");
    }
  }
  // Caso o componente estiver no modo AutoUpload, o arquivo também será removido da lista.
  stopUpload(file) {
    this.uploadService.stopRequestByFile(file, () => {
      if (this.autoUpload) {
        this.removeFile(file);
      } else {
        this.stopUploadHandler(file);
      }
      this.cd.markForCheck();
    });
  }
  trackByFn(index, file) {
    return file.uid;
  }
  // Envia os arquivos passados por parâmetro, exceto os que já foram enviados ao serviço.
  uploadFiles(files) {
    const filesFiltered = files.filter((file) => file.status !== PoUploadStatus.Uploaded);
    this.uploadService.upload(this.url, filesFiltered, this.headers, this.onUpload, (file, percent) => {
      this.uploadingHandler(file, percent);
    }, (file, eventResponse) => {
      this.responseHandler(file, PoUploadStatus.Uploaded);
      this.onSuccess.emit(eventResponse);
    }, (file, eventError) => {
      this.responseHandler(file, PoUploadStatus.Error);
      this.onError.emit(eventError);
    });
  }
  cleanInputValue() {
    this.calledByCleanInputValue = true;
    this.inputFile.nativeElement.value = "";
    this.cd.detectChanges();
  }
  // função disparada na resposta do sucesso ou error
  responseHandler(file, status) {
    file.status = status;
    file.percent = 100;
    this.cd.markForCheck();
  }
  // método responsável por setar os argumentos do i18nPipe de acordo com a restrição.
  setPipeArguments(literalAttributes, literalArguments) {
    const pipeArguments = this.i18nPipe.transform(this.literals[literalAttributes], literalArguments);
    this.notification.information(pipeArguments);
  }
  // Função disparada ao parar um envio de arquivo.
  stopUploadHandler(file) {
    file.status = PoUploadStatus.None;
    file.percent = 0;
    this.cd.markForCheck();
  }
  updateFiles(files) {
    this.currentFiles = this.parseFiles(files);
    this.updateModel([...this.currentFiles]);
    if (this.autoUpload) {
      this.uploadFiles(this.currentFiles);
    }
  }
  // Atualiza o ngModel para os arquivos passados por parâmetro.
  updateModel(files) {
    const modelFiles = this.mapCleanUploadFiles(files);
    this.onModelChange ? this.onModelChange(modelFiles) : this.ngModelChange.emit(modelFiles);
  }
  // Função disparada enquanto o arquivo está sendo enviado ao serviço.
  uploadingHandler(file, percent) {
    file.status = PoUploadStatus.Uploading;
    file.percent = percent;
    this.cd.markForCheck();
  }
  // retorna os objetos do array sem as propriedades: percent e displayName
  mapCleanUploadFiles(files) {
    const mapedByUploadFile = (progressFile) => {
      const _a = progressFile, { percent, displayName } = _a, uploadFile = __objRest(_a, ["percent", "displayName"]);
      return uploadFile;
    };
    return files.map(mapedByUploadFile);
  }
  static ɵfac = function PoUploadComponent_Factory(t) {
    return new (t || _PoUploadComponent)(ɵɵdirectiveInject(PoUploadService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(PoI18nPipe), ɵɵdirectiveInject(PoNotificationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoUploadComponent, selectors: [["po-upload"]], viewQuery: function PoUploadComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$G, 7, ElementRef);
      ɵɵviewQuery(PoUploadDragDropComponent, 5);
      ɵɵviewQuery(_c1$g, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputFile = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poUploadDragDropComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.uploadButton = _t.first);
    }
  }, features: [ɵɵProvidersFeature([
    PoI18nPipe,
    PoUploadService,
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoUploadComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoUploadComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 11, vars: 19, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-upload"], ["type", "file", 1, "po-upload-input", 3, "accept", "id", "disabled", "multiple", "required", "change"], ["inputFile", ""], [3, "p-directory-compatible", "p-disabled", "p-drag-drop-height", "p-literals", "p-file-change", "p-select-files", 4, "ngIf"], ["class", "po-upload-button", "for", "file", 3, "p-disabled", "p-label", "p-click", 4, "ngIf"], ["class", "po-upload-file-restrictions", 3, "ngClass", "p-allowed-extensions", "p-max-files", "p-max-file-size", "p-min-file-size", 4, "ngIf"], ["class", "po-upload-progress-container", 4, "ngIf"], ["class", "po-upload-send-button", "p-kind", "primary", 3, "po-mt-3", "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-help", "p-disabled"], [3, "p-directory-compatible", "p-disabled", "p-drag-drop-height", "p-literals", "p-file-change", "p-select-files"], ["for", "file", 1, "po-upload-button", 3, "p-disabled", "p-label", "p-click"], ["uploadButton", ""], [1, "po-upload-file-restrictions", 3, "ngClass", "p-allowed-extensions", "p-max-files", "p-max-file-size", "p-min-file-size"], [1, "po-upload-progress-container"], [3, "p-height", "p-no-border", "p-no-padding"], [3, "ngClass"], [3, "p-info", "p-info-icon", "p-status", "p-text", "p-value", "p-cancel", "p-retry", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-info", "p-info-icon", "p-status", "p-text", "p-value", "p-cancel", "p-retry"], ["p-kind", "primary", 1, "po-upload-send-button", 3, "p-disabled", "p-label", "p-click"]], template: function PoUploadComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "div", 2)(3, "input", 3, 4);
      ɵɵlistener("change", function PoUploadComponent_Template_input_change_3_listener($event) {
        return ctx.onFileChange($event);
      });
      ɵɵelementEnd();
      ɵɵtemplate(5, PoUploadComponent_po_upload_drag_drop_5_Template, 1, 4, "po-upload-drag-drop", 5)(6, PoUploadComponent_po_button_6_Template, 2, 2, "po-button", 6)(7, PoUploadComponent_po_upload_file_restrictions_7_Template, 1, 7, "po-upload-file-restrictions", 7)(8, PoUploadComponent_div_8_Template, 4, 8, "div", 8)(9, PoUploadComponent_po_button_9_Template, 1, 4, "po-button", 9);
      ɵɵelementEnd()();
      ɵɵelement(10, "po-field-container-bottom", 10);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.isDisabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(3);
      ɵɵproperty("accept", ctx.allowedExtensions)("id", ctx.id)("disabled", ctx.isDisabled)("multiple", ctx.isMultiple)("required", ctx.required);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.displayDragDrop);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hideSelectButton && !ctx.displayDragDrop);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fileRestrictions && !ctx.hideRestrictionsInfo);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.currentFiles && ctx.currentFiles.length);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.displaySendButton);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, dependencies: [NgClass, NgForOf, NgIf, PoButtonComponent, PoContainerComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoProgressComponent, PoUploadDragDropComponent, PoUploadFileRestrictionsComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUploadComponent, [{
    type: Component,
    args: [{ selector: "po-upload", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      PoI18nPipe,
      PoUploadService,
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoUploadComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoUploadComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="isDisabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div class="po-upload">
      <input
        #inputFile
        class="po-upload-input"
        type="file"
        [accept]="allowedExtensions"
        [attr.name]="name"
        [id]="id"
        [disabled]="isDisabled"
        [multiple]="isMultiple"
        [required]="required"
        (change)="onFileChange($event)"
      />

      <po-upload-drag-drop
        *ngIf="displayDragDrop"
        [p-directory-compatible]="canHandleDirectory"
        [p-disabled]="isDisabled"
        [p-drag-drop-height]="dragDropHeight"
        [p-literals]="literals"
        (p-file-change)="onFileChangeDragDrop($event)"
        (p-select-files)="selectFiles()"
      >
      </po-upload-drag-drop>

      <po-button
        *ngIf="!hideSelectButton && !displayDragDrop"
        #uploadButton
        class="po-upload-button"
        for="file"
        [p-disabled]="isDisabled"
        [p-label]="selectFileButtonLabel"
        (p-click)="selectFiles()"
      >
      </po-button>

      <po-upload-file-restrictions
        *ngIf="fileRestrictions && !hideRestrictionsInfo"
        class="po-upload-file-restrictions"
        [ngClass]="{ 'po-upload-file-restrictions-drag-drop': displayDragDrop }"
        [p-allowed-extensions]="fileRestrictions?.allowedExtensions"
        [p-max-files]="maxFiles"
        [p-max-file-size]="fileRestrictions?.maxFileSize"
        [p-min-file-size]="fileRestrictions?.minFileSize"
      >
      </po-upload-file-restrictions>

      <div *ngIf="currentFiles && currentFiles.length" class="po-upload-progress-container">
        <po-container
          [p-height]="hasMoreThanFourItems ? 280 : 'auto'"
          [p-no-border]="!hasMoreThanFourItems"
          [p-no-padding]="!hasMoreThanFourItems"
        >
          <div [ngClass]="{ 'po-upload-progress-container-area po-pt-2 po-pl-1': hasMoreThanFourItems }">
            <po-progress
              *ngFor="let file of currentFiles; trackBy: trackByFn"
              [p-info]="infoByUploadStatus[file.status]?.text(file.percent)"
              [p-info-icon]="infoByUploadStatus[file.status]?.icon"
              [p-status]="progressStatusByFileStatus[file.status]"
              [p-text]="file.displayName"
              [p-value]="file.percent"
              (p-cancel)="cancel(file)"
              (p-retry)="uploadFiles([file])"
            >
            </po-progress>
          </div>
        </po-container>
      </div>

      <po-button
        *ngIf="displaySendButton"
        class="po-upload-send-button"
        [class.po-mt-3]="hasMoreThanFourItems"
        p-kind="primary"
        [p-disabled]="hasAnyFileUploading(currentFiles)"
        [p-label]="literals.startSending"
        (p-click)="uploadFiles(currentFiles)"
      ></po-button>
    </div>
  </div>
  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: PoUploadService }, { type: Renderer2 }, { type: PoI18nPipe }, { type: PoNotificationService }, { type: ChangeDetectorRef }, { type: PoLanguageService }], { inputFile: [{
    type: ViewChild,
    args: ["inputFile", { read: ElementRef, static: true }]
  }], poUploadDragDropComponent: [{
    type: ViewChild,
    args: [PoUploadDragDropComponent]
  }], uploadButton: [{
    type: ViewChild,
    args: ["uploadButton"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUploadComponent, { className: "PoUploadComponent", filePath: "lib/components/po-field/po-upload/po-upload.component.ts", lineNumber: 70 });
})();
function PoUrlComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵelement(1, "po-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-field-icon ", ctx_r0.disabled ? "po-icon-input-disabled" : "po-icon-input", "");
    ɵɵclassProp("po-field-icon-disabled", ctx_r0.disabled);
    ɵɵproperty("p-icon", ctx_r0.icon);
  }
}
function PoUrlComponent_po_clean_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-clean", 10);
    ɵɵlistener("p-change-event", function PoUrlComponent_po_clean_6_Template_po_clean_p_change_event_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.clear($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2.disabled ? "po-icon-input-disabled" : "po-icon-input");
    ɵɵproperty("p-element-ref", ctx_r2.inputEl);
  }
}
var PoUrlComponent = class _PoUrlComponent extends PoInputGeneric {
  id = `po-url[${uuid()}]`;
  icon = "po-icon-world";
  type = "url";
  pattern = "^((https|http):\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-A-Za-z\\d%_.~+]*)*(\\?[;&A-Za-z\\d%_.~+=-]*)?(\\#[-A-Za-z\\d_]*)?$";
  mask = "";
  listener = this.validateClassesForPattern.bind(this);
  /* istanbul ignore next */
  constructor(el, cd) {
    super(el, cd);
    this.maxlength = 254;
  }
  ngAfterViewInit() {
    setTimeout(() => {
      if (!this.onChangePropagate) {
        this.inputEl.nativeElement.addEventListener("keyup", this.listener);
      }
    });
    super.ngAfterViewInit();
  }
  ngOnDestroy() {
    if (!this.onChangePropagate) {
      this.inputEl.nativeElement.removeEventListener("keyup", this.listener);
    }
  }
  extraValidation(c) {
    return null;
  }
  static ɵfac = function PoUrlComponent_Factory(t) {
    return new (t || _PoUrlComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoUrlComponent, selectors: [["po-url"]], features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoUrlComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoUrlComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 8, vars: 23, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], ["class", "po-field-icon-container-left", 4, "ngIf"], [1, "po-input", 3, "autocomplete", "disabled", "id", "placeholder", "readonly", "required", "type", "blur", "click", "focus", "input"], ["inp", ""], [1, "po-field-icon-container-right"], [3, "class", "p-element-ref", "p-change-event", 4, "ngIf"], [3, "p-help", "p-disabled", "p-error-pattern"], [1, "po-field-icon-container-left"], [3, "p-icon"], [3, "p-element-ref", "p-change-event"]], template: function PoUrlComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1);
      ɵɵtemplate(2, PoUrlComponent_div_2_Template, 2, 6, "div", 2);
      ɵɵelementStart(3, "input", 3, 4);
      ɵɵlistener("blur", function PoUrlComponent_Template_input_blur_3_listener($event) {
        return ctx.eventOnBlur($event);
      })("click", function PoUrlComponent_Template_input_click_3_listener($event) {
        return ctx.eventOnClick($event);
      })("focus", function PoUrlComponent_Template_input_focus_3_listener($event) {
        return ctx.eventOnFocus($event);
      })("input", function PoUrlComponent_Template_input_input_3_listener($event) {
        return ctx.eventOnInput($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵtemplate(6, PoUrlComponent_po_clean_6_Template, 1, 4, "po-clean", 6);
      ɵɵelementEnd()();
      ɵɵelement(7, "po-field-container-bottom", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.icon);
      ɵɵadvance();
      ɵɵclassProp("po-input-icon-left", ctx.icon)("po-input-icon-right", ctx.clean);
      ɵɵproperty("autocomplete", ctx.autocomplete)("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("type", ctx.type);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.clean && !ctx.disabled && !ctx.readonly);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled)("p-error-pattern", ctx.getErrorPattern());
    }
  }, dependencies: [NgIf, PoCleanComponent, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoIconComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoUrlComponent, [{
    type: Component,
    args: [{ selector: "po-url", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoUrlComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoUrlComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <div *ngIf="icon" class="po-field-icon-container-left">
      <po-icon
        class="po-field-icon {{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        [class.po-field-icon-disabled]="disabled"
        [p-icon]="icon"
      ></po-icon>
    </div>

    <input
      #inp
      class="po-input"
      [attr.name]="name"
      [autocomplete]="autocomplete"
      [class.po-input-icon-left]="icon"
      [class.po-input-icon-right]="clean"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [type]="type"
      (blur)="eventOnBlur($event)"
      (click)="eventOnClick($event)"
      (focus)="eventOnFocus($event)"
      (input)="eventOnInput($event)"
    />

    <div class="po-field-icon-container-right">
      <po-clean
        class="{{ disabled ? 'po-icon-input-disabled' : 'po-icon-input' }}"
        *ngIf="clean && !disabled && !readonly"
        [p-element-ref]="inputEl"
        (p-change-event)="clear($event)"
      >
      </po-clean>
    </div>
  </div>

  <po-field-container-bottom
    [p-help]="help"
    [p-disabled]="disabled"
    [p-error-pattern]="getErrorPattern()"
  ></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoUrlComponent, { className: "PoUrlComponent", filePath: "lib/components/po-field/po-url/po-url.component.ts", lineNumber: 57 });
})();
var _c0$F = ["modal"];
var _c1$f = ["modalImageForm"];
var _c2$5 = ["upload"];
var uploadRestrictions = [".apng", ".bmp", ".gif", ".ico", ".jpeg", ".jpg", ".png", ".svg"];
var PoRichTextImageModalComponent = class _PoRichTextImageModalComponent {
  languageService;
  modal;
  modalImageForm;
  upload;
  command = new EventEmitter();
  savedCursorPosition;
  selection = document.getSelection();
  uploadModel;
  uploadRestrictions = {
    allowedExtensions: uploadRestrictions
  };
  urlImage;
  literals;
  modalCancelAction;
  modalConfirmAction;
  get isUploadValid() {
    return !!(this.uploadModel && this.uploadModel.length);
  }
  get isUrlValid() {
    return !!this.urlImage && this.modalImageForm && this.modalImageForm.valid;
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues({}, poRichTextLiteralsDefault[this.languageService.getShortLanguage()]);
    this.modalCancelAction = {
      label: this.literals.cancel,
      action: () => {
        this.modal.close();
        this.command.emit();
        this.retrieveCursorPosition();
        this.cleanUpFields();
      }
    };
    this.modalConfirmAction = {
      label: this.literals.insert,
      disabled: false,
      action: () => this.insertElementRef()
    };
  }
  openModal() {
    this.saveCursorPosition();
    this.modal.open();
  }
  cleanUpFields() {
    this.urlImage = void 0;
    this.uploadModel = void 0;
  }
  convertToBase64() {
    return __async(this, null, function* () {
      if (this.isUploadValid) {
        const uploadImage = this.uploadModel[0].rawFile;
        return yield convertImageToBase64(uploadImage);
      }
    });
  }
  emitCommand(value) {
    let command;
    if (value) {
      command = "insertImage";
      this.command.emit({ command, value });
    }
  }
  insertElementRef() {
    return __async(this, null, function* () {
      let uploadImage;
      if (!this.urlImage) {
        uploadImage = yield this.convertToBase64();
      }
      this.retrieveCursorPosition();
      this.modal.close();
      if (this.isUrlValid || this.isUploadValid) {
        this.emitCommand(this.urlImage || uploadImage);
      }
      this.cleanUpFields();
    });
  }
  retrieveCursorPosition() {
    this.selection.collapse(this.savedCursorPosition[0], this.savedCursorPosition[1]);
  }
  saveCursorPosition() {
    this.savedCursorPosition = [this.selection.focusNode, this.selection.focusOffset];
  }
  static ɵfac = function PoRichTextImageModalComponent_Factory(t) {
    return new (t || _PoRichTextImageModalComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRichTextImageModalComponent, selectors: [["po-rich-text-image-modal"]], viewQuery: function PoRichTextImageModalComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$F, 7);
      ɵɵviewQuery(_c1$f, 5);
      ɵɵviewQuery(_c2$5, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalImageForm = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.upload = _t.first);
    }
  }, outputs: { command: "p-command" }, decls: 9, vars: 10, consts: [["p-hide-close", "", 3, "p-primary-action", "p-secondary-action", "p-title"], ["modal", ""], ["modalImageForm", "ngForm"], [1, "po-row"], ["name", "upload", "p-drag-drop-height", "160", "p-hide-restrictions-info", "", "p-hide-send-button", "", "p-url", "x", 1, "po-md-12", 3, "ngModel", "p-drag-drop", "p-disabled", "p-restrictions", "ngModelChange"], ["upload", ""], ["name", "url", 1, "po-md-12", "po-mt-3", 3, "ngModel", "p-label", "p-disabled", "ngModelChange"]], template: function PoRichTextImageModalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-modal", 0, 1)(2, "form", null, 2)(4, "div", 3)(5, "po-upload", 4, 5);
      ɵɵtwoWayListener("ngModelChange", function PoRichTextImageModalComponent_Template_po_upload_ngModelChange_5_listener($event) {
        ɵɵtwoWayBindingSet(ctx.uploadModel, $event) || (ctx.uploadModel = $event);
        return $event;
      });
      ɵɵelementEnd()();
      ɵɵelementStart(7, "div", 3)(8, "po-url", 6);
      ɵɵtwoWayListener("ngModelChange", function PoRichTextImageModalComponent_Template_po_url_ngModelChange_8_listener($event) {
        ɵɵtwoWayBindingSet(ctx.urlImage, $event) || (ctx.urlImage = $event);
        return $event;
      });
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(1);
      ɵɵproperty("p-primary-action", ctx.modalConfirmAction)("p-secondary-action", ctx.modalCancelAction)("p-title", ctx.literals.insertImage);
      ɵɵadvance(5);
      ɵɵtwoWayProperty("ngModel", ctx.uploadModel);
      ɵɵproperty("p-drag-drop", !_r0.isHidden)("p-disabled", ctx.isUrlValid)("p-restrictions", ctx.uploadRestrictions);
      ɵɵadvance(3);
      ɵɵtwoWayProperty("ngModel", ctx.urlImage);
      ɵɵproperty("p-label", ctx.literals.urlImage)("p-disabled", ctx.isUploadValid);
    }
  }, dependencies: [ɵNgNoValidate, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, PoModalComponent, PoUploadComponent, PoUrlComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextImageModalComponent, [{
    type: Component,
    args: [{ selector: "po-rich-text-image-modal", template: '<po-modal\n  #modal\n  p-hide-close\n  [p-primary-action]="modalConfirmAction"\n  [p-secondary-action]="modalCancelAction"\n  [p-title]="literals.insertImage"\n>\n  <form #modalImageForm="ngForm">\n    <div class="po-row">\n      <!-- po-upload desabilita o drag drop caso não tenha valor atribuido para a propriedade p-url -->\n      <po-upload\n        #upload\n        class="po-md-12"\n        name="upload"\n        [(ngModel)]="uploadModel"\n        p-drag-drop-height="160"\n        p-hide-restrictions-info\n        p-hide-send-button\n        p-url="x"\n        [p-drag-drop]="!modal.isHidden"\n        [p-disabled]="isUrlValid"\n        [p-restrictions]="uploadRestrictions"\n      >\n      </po-upload>\n    </div>\n\n    <div class="po-row">\n      <po-url\n        class="po-md-12 po-mt-3"\n        name="url"\n        [(ngModel)]="urlImage"\n        [p-label]="literals.urlImage"\n        [p-disabled]="isUploadValid"\n      >\n      </po-url>\n    </div>\n  </form>\n</po-modal>\n' }]
  }], () => [{ type: PoLanguageService }], { modal: [{
    type: ViewChild,
    args: ["modal", { static: true }]
  }], modalImageForm: [{
    type: ViewChild,
    args: ["modalImageForm"]
  }], upload: [{
    type: ViewChild,
    args: ["upload", { static: true }]
  }], command: [{
    type: Output,
    args: ["p-command"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextImageModalComponent, { className: "PoRichTextImageModalComponent", filePath: "lib/components/po-field/po-rich-text/po-rich-text-image-modal/po-rich-text-image-modal.component.ts", lineNumber: 18 });
})();
var _c0$E = ["modal"];
var _c1$e = ["modalLinkForm"];
var PoRichTextLinkModalComponent = class _PoRichTextLinkModalComponent {
  languageService;
  modal;
  modalLinkForm;
  command = new EventEmitter();
  linkEditing = new EventEmitter();
  savedCursorPosition;
  selection = document.getSelection();
  urlLink;
  urlLinkText;
  literals;
  modalCancelAction;
  modalConfirmAction;
  isLinkEditing;
  isSelectedLink;
  linkElement;
  savedSelection;
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues({}, poRichTextLiteralsDefault[this.languageService?.getShortLanguage()]);
  }
  ngOnInit() {
    this.setModalCancelAction();
    this.setModalConfirmAction();
  }
  linkConfirmAction() {
    return this.isLinkEditing ? this.literals.editLink : this.literals.insertLink;
  }
  formModelValidate() {
    return this.modalConfirmAction.disabled = this.modalLinkForm?.invalid;
  }
  openModal(selectedLinkElement) {
    this.saveCursorPosition();
    this.prepareModalForLink(selectedLinkElement);
    this.modalConfirmAction.label = this.linkConfirmAction();
    this.modal.open();
  }
  selectedLink(linkElement) {
    this.isSelectedLink = !!linkElement;
    this.linkElement = linkElement;
  }
  checkIfIsEmpty(urlLink, urlLinkText) {
    return urlLinkText === void 0 || urlLinkText.trim() === "" ? urlLink : urlLinkText;
  }
  cleanUpFields() {
    this.urlLink = void 0;
    this.urlLinkText = void 0;
    this.isLinkEditing = false;
    this.isSelectedLink = false;
    this.linkElement = void 0;
  }
  formReset(control) {
    control.markAsPristine();
    control.markAsUntouched();
    control.updateValueAndValidity();
  }
  prepareModalForLink(selectedLinkElement) {
    this.saveSelectionText();
    if (this.modalLinkForm) {
      this.formReset(this.modalLinkForm.control);
    }
    setTimeout(() => {
      this.formModelValidate();
    });
    this.selectedLink(selectedLinkElement);
    if (this.isSelectedLink) {
      this.isLinkEditing = true;
      this.setLinkEditableForModal();
    }
    this.linkEditing.emit(this.isLinkEditing);
  }
  restoreSelection() {
    if (this.savedSelection) {
      if (this.selection) {
        this.selection.removeAllRanges();
        this.selection.addRange(this.savedSelection);
      }
      return true;
    } else {
      return false;
    }
  }
  retrieveCursorPosition() {
    this.selection.collapse(this.savedCursorPosition[0], this.savedCursorPosition[1]);
  }
  saveCursorPosition() {
    this.savedCursorPosition = [this.selection.focusNode, this.selection.focusOffset];
  }
  saveSelectionText() {
    if (this.selection.anchorNode !== null) {
      this.savedSelection = this.selection.getRangeAt(0);
      this.urlLinkText = this.selection.toString();
    } else {
      return null;
    }
  }
  setLinkEditableForModal() {
    this.urlLinkText = this.linkElement.innerText;
    this.urlLink = this.linkElement.getAttribute("href");
  }
  setModalCancelAction() {
    this.modalCancelAction = {
      label: this.literals.cancel,
      action: () => {
        this.modal.close();
        this.command.emit();
        this.retrieveCursorPosition();
        this.cleanUpFields();
      }
    };
  }
  setModalConfirmAction() {
    this.modalConfirmAction = {
      label: this.linkConfirmAction(),
      disabled: true,
      action: () => this.isLinkEditing ? this.toEditLink() : this.toInsertLink(this.urlLink, this.urlLinkText)
    };
  }
  toEditLink() {
    if (isIE()) {
      this.linkElement.parentNode.removeChild(this.linkElement);
    } else {
      this.linkElement.remove();
    }
    this.toInsertLink(this.urlLink, this.urlLinkText);
  }
  toInsertLink(urlLink, urlLinkText) {
    this.modal.close();
    this.restoreSelection();
    const urlLinkTextValue = this.checkIfIsEmpty(urlLink, urlLinkText);
    const urlAsExternalLink = isExternalLink(urlLink) ? urlLink : `http://${urlLink}`;
    const command = "InsertHTML";
    const value = { urlLink: urlAsExternalLink, urlLinkText: urlLinkTextValue };
    this.command.emit({ command, value });
    this.cleanUpFields();
  }
  static ɵfac = function PoRichTextLinkModalComponent_Factory(t) {
    return new (t || _PoRichTextLinkModalComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRichTextLinkModalComponent, selectors: [["po-rich-text-link-modal"]], viewQuery: function PoRichTextLinkModalComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$E, 7);
      ɵɵviewQuery(_c1$e, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modalLinkForm = _t.first);
    }
  }, outputs: { command: "p-command", linkEditing: "p-link-editing" }, decls: 7, vars: 9, consts: [["p-hide-close", "", 3, "p-primary-action", "p-secondary-action", "p-title"], ["modal", ""], ["modalLinkForm", "ngForm"], [1, "po-row"], ["name", "urlLinkText", "p-optional", "", 1, "po-md-12", "po-mb-2", 3, "ngModel", "p-label", "p-placeholder", "ngModelChange"], ["name", "urlLink", "p-label", "Link", "p-required", "", 1, "po-md-12", 3, "ngModel", "p-help", "p-placeholder", "ngModelChange", "p-change-model"]], template: function PoRichTextLinkModalComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-modal", 0, 1)(2, "form", null, 2)(4, "div", 3)(5, "po-input", 4);
      ɵɵtwoWayListener("ngModelChange", function PoRichTextLinkModalComponent_Template_po_input_ngModelChange_5_listener($event) {
        ɵɵtwoWayBindingSet(ctx.urlLinkText, $event) || (ctx.urlLinkText = $event);
        return $event;
      });
      ɵɵelementEnd();
      ɵɵelementStart(6, "po-url", 5);
      ɵɵtwoWayListener("ngModelChange", function PoRichTextLinkModalComponent_Template_po_url_ngModelChange_6_listener($event) {
        ɵɵtwoWayBindingSet(ctx.urlLink, $event) || (ctx.urlLink = $event);
        return $event;
      });
      ɵɵlistener("p-change-model", function PoRichTextLinkModalComponent_Template_po_url_p_change_model_6_listener() {
        return ctx.formModelValidate();
      });
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵproperty("p-primary-action", ctx.modalConfirmAction)("p-secondary-action", ctx.modalCancelAction)("p-title", ctx.linkConfirmAction());
      ɵɵadvance(5);
      ɵɵtwoWayProperty("ngModel", ctx.urlLinkText);
      ɵɵproperty("p-label", ctx.literals.linkTextLabel)("p-placeholder", ctx.literals.linkTextLabel);
      ɵɵadvance();
      ɵɵtwoWayProperty("ngModel", ctx.urlLink);
      ɵɵproperty("p-help", ctx.literals.linkUrlTextHelper)("p-placeholder", ctx.literals.linkUrlTextPlaceholder);
    }
  }, dependencies: [ɵNgNoValidate, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, PoModalComponent, PoInputComponent, PoUrlComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextLinkModalComponent, [{
    type: Component,
    args: [{ selector: "po-rich-text-link-modal", template: '<po-modal\n  #modal\n  p-hide-close\n  [p-primary-action]="modalConfirmAction"\n  [p-secondary-action]="modalCancelAction"\n  [p-title]="linkConfirmAction()"\n>\n  <form #modalLinkForm="ngForm">\n    <div class="po-row">\n      <po-input\n        class="po-md-12 po-mb-2"\n        name="urlLinkText"\n        [(ngModel)]="urlLinkText"\n        p-optional\n        [p-label]="literals.linkTextLabel"\n        [p-placeholder]="literals.linkTextLabel"\n      >\n      </po-input>\n\n      <po-url\n        class="po-md-12"\n        name="urlLink"\n        [(ngModel)]="urlLink"\n        p-label="Link"\n        p-required\n        [p-help]="literals.linkUrlTextHelper"\n        [p-placeholder]="literals.linkUrlTextPlaceholder"\n        (p-change-model)="formModelValidate()"\n      >\n      </po-url>\n    </div>\n  </form>\n</po-modal>\n' }]
  }], () => [{ type: PoLanguageService }], { modal: [{
    type: ViewChild,
    args: ["modal", { static: true }]
  }], modalLinkForm: [{
    type: ViewChild,
    args: ["modalLinkForm"]
  }], command: [{
    type: Output,
    args: ["p-command"]
  }], linkEditing: [{
    type: Output,
    args: ["p-link-editing"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextLinkModalComponent, { className: "PoRichTextLinkModalComponent", filePath: "lib/components/po-field/po-rich-text/po-rich-text-link-modal/po-rich-text-link-modal.component.ts", lineNumber: 14 });
})();
var _c0$D = ["colorPickerInput"];
var _c1$d = ["toolbarElement"];
function PoRichTextToolbarComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 15)(1, "div", 16)(2, "button", 17)(3, "input", 18, 19);
    ɵɵlistener("change", function PoRichTextToolbarComponent_div_4_Template_input_change_3_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.changeTextColor($event.target.value));
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.readonly)("p-tooltip", ctx_r1.literals.textColor);
    ɵɵattribute("aria-label", ctx_r1.literals.textColor);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.readonly);
    ɵɵattribute("aria-label", ctx_r1.literals.textColor);
  }
}
function PoRichTextToolbarComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵelement(1, "po-button-group", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-buttons", ctx_r2.alignButtons);
  }
}
var poRichTextDefaultColor = "#000000";
var PoRichTextToolbarComponent = class _PoRichTextToolbarComponent {
  languageService;
  colorPickerInput;
  toolbarElement;
  richTextImageModal;
  richTextLinkModal;
  command = new EventEmitter();
  modal = new EventEmitter();
  linkEditing = new EventEmitter();
  literals;
  alignButtons;
  formatButtons;
  listButtons;
  linkButtons;
  mediaButtons;
  _disabledTextAlign;
  _readonly;
  selectedLinkElement;
  set disabledTextAlign(value) {
    this._disabledTextAlign = value;
  }
  get disabledTextAlign() {
    return this._disabledTextAlign;
  }
  set readonly(value) {
    this._readonly = value;
    this.toggleDisableButtons(this._readonly);
  }
  get readonly() {
    return this._readonly;
  }
  get isInternetExplorer() {
    return isIE();
  }
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues({}, poRichTextLiteralsDefault[this.languageService?.getShortLanguage()]);
    this.alignButtons = [
      {
        command: "justifyleft",
        icon: "po-icon-align-left",
        tooltip: this.literals.left,
        action: this.emitAlignCommand.bind(this, "justifyleft"),
        selected: true
      },
      {
        command: "justifycenter",
        icon: "po-icon-align-center",
        tooltip: this.literals.center,
        action: this.emitAlignCommand.bind(this, "justifycenter")
      },
      {
        command: "justifyright",
        icon: "po-icon-align-right",
        tooltip: this.literals.right,
        action: this.emitAlignCommand.bind(this, "justifyright")
      },
      {
        command: "justifyfull",
        icon: "po-icon-align-justify",
        tooltip: this.literals.justify,
        action: this.emitAlignCommand.bind(this, "justifyfull")
      }
    ];
    this.formatButtons = [
      {
        command: "bold",
        icon: "po-icon-text-bold",
        tooltip: this.literals.bold,
        action: this.emitCommand.bind(this, "bold")
      },
      {
        command: "italic",
        icon: "po-icon-text-italic",
        tooltip: this.literals.italic,
        action: this.emitCommand.bind(this, "italic")
      },
      {
        command: "underline",
        icon: "po-icon-text-underline",
        tooltip: this.literals.underline,
        action: this.emitCommand.bind(this, "underline")
      }
    ];
    this.listButtons = [
      {
        command: "insertUnorderedList",
        icon: "po-icon-list",
        tooltip: this.literals.unorderedList,
        action: this.emitCommand.bind(this, "insertUnorderedList")
      }
    ];
    this.mediaButtons = [
      {
        tooltip: this.literals.insertImage,
        icon: "po-icon-picture",
        action: () => this.richTextImageModal.openModal()
      }
    ];
    this.linkButtons = [
      {
        command: "Createlink",
        icon: "po-icon-link",
        tooltip: `${this.literals.insertLink} (Ctrl + K)`,
        action: () => this.richTextLinkModal.openModal(this.selectedLinkElement)
      }
    ];
  }
  ngAfterViewInit() {
    this.removeButtonFocus();
    this.setColorInColorPicker(poRichTextDefaultColor);
  }
  changeTextColor(value) {
    const command = "foreColor";
    this.command.emit({ command, value });
  }
  emitLinkEditing(isLinkEdit) {
    this.linkEditing.emit(isLinkEdit);
  }
  selectedLink(selectedLinkElement) {
    this.selectedLinkElement = selectedLinkElement;
  }
  setButtonsStates(obj) {
    if (!this.readonly) {
      this.alignButtons.forEach((button) => button.selected = obj.commands.includes(button.command));
      this.formatButtons.forEach((button) => button.selected = obj.commands.includes(button.command));
      this.listButtons[0].selected = obj.commands.includes(this.listButtons[0].command);
      this.linkButtons[0].selected = obj.commands.includes(this.linkButtons[0].command);
      this.setColorInColorPicker(obj.hexColor);
    }
  }
  shortcutTrigger() {
    this.richTextLinkModal.openModal(this.selectedLinkElement);
  }
  emitCommand(command) {
    this.command.emit(command);
  }
  emitAlignCommand(command) {
    const index = this.alignButtons.findIndex((btn) => btn.command === command);
    if (!this.alignButtons[index].selected) {
      this.alignButtons[index].selected = false;
    }
    this.command.emit(command);
  }
  removeButtonFocus() {
    const buttons = this.toolbarElement.nativeElement.querySelectorAll("button");
    buttons.forEach((button) => button.setAttribute("tabindex", "-1"));
  }
  setColorInColorPicker(color) {
    this.colorPickerInput.nativeElement.value = color;
  }
  toggleDisableButtons(state2) {
    this.alignButtons.forEach((button) => button.disabled = state2);
    this.formatButtons.forEach((button) => button.disabled = state2);
    this.listButtons[0].disabled = state2;
    this.linkButtons[0].disabled = state2;
    this.mediaButtons[0].disabled = state2;
  }
  static ɵfac = function PoRichTextToolbarComponent_Factory(t) {
    return new (t || _PoRichTextToolbarComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRichTextToolbarComponent, selectors: [["po-rich-text-toolbar"]], viewQuery: function PoRichTextToolbarComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$D, 5, ElementRef);
      ɵɵviewQuery(_c1$d, 7);
      ɵɵviewQuery(PoRichTextImageModalComponent, 7);
      ɵɵviewQuery(PoRichTextLinkModalComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.colorPickerInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.richTextImageModal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.richTextLinkModal = _t.first);
    }
  }, inputs: { disabledTextAlign: [InputFlags.None, "p-disabled-text-align", "disabledTextAlign"], readonly: [InputFlags.None, "p-readonly", "readonly"] }, outputs: { command: "p-command", modal: "p-modal", linkEditing: "p-link-editing" }, decls: 16, vars: 6, consts: [[1, "po-rich-text-toolbar"], ["toolbarElement", ""], ["data-rich-text-toolbar", "format", 1, "po-rich-text-toolbar-button-align"], ["p-toggle", "multiple", 3, "p-buttons"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "color", 4, "ngIf"], ["class", "po-rich-text-toolbar-button-align", "data-rich-text-toolbar", "align", 4, "ngIf"], ["data-rich-text-toolbar", "list", 1, "po-rich-text-toolbar-button-align"], ["p-toggle", "single", 3, "p-buttons"], ["data-rich-text-toolbar", "link", 1, "po-rich-text-toolbar-button-align"], [3, "p-buttons"], ["data-rich-text-toolbar", "media", 1, "po-rich-text-toolbar-button-align"], [3, "p-command"], ["richTextImageModal", ""], [3, "p-command", "p-link-editing"], ["richTextLinkModal", ""], ["data-rich-text-toolbar", "color", 1, "po-rich-text-toolbar-button-align"], [1, "po-rich-text-toolbar-color-picker-container"], ["type", "button", 1, "po-button", "po-button-default", "po-rich-text-toolbar-color-picker-button", 3, "disabled", "p-tooltip"], ["type", "color", 1, "po-rich-text-toolbar-color-picker-input", 3, "disabled", "change"], ["colorPickerInput", ""], ["data-rich-text-toolbar", "align", 1, "po-rich-text-toolbar-button-align"]], template: function PoRichTextToolbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1)(2, "div", 2);
      ɵɵelement(3, "po-button-group", 3);
      ɵɵelementEnd();
      ɵɵtemplate(4, PoRichTextToolbarComponent_div_4_Template, 5, 5, "div", 4)(5, PoRichTextToolbarComponent_div_5_Template, 2, 1, "div", 5);
      ɵɵelementStart(6, "div", 6);
      ɵɵelement(7, "po-button-group", 7);
      ɵɵelementEnd();
      ɵɵelementStart(8, "div", 8);
      ɵɵelement(9, "po-button-group", 9);
      ɵɵelementEnd();
      ɵɵelementStart(10, "div", 10);
      ɵɵelement(11, "po-button-group", 9);
      ɵɵelementEnd()();
      ɵɵelementStart(12, "po-rich-text-image-modal", 11, 12);
      ɵɵlistener("p-command", function PoRichTextToolbarComponent_Template_po_rich_text_image_modal_p_command_12_listener($event) {
        return ctx.emitCommand($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(14, "po-rich-text-link-modal", 13, 14);
      ɵɵlistener("p-command", function PoRichTextToolbarComponent_Template_po_rich_text_link_modal_p_command_14_listener($event) {
        return ctx.emitCommand($event);
      })("p-link-editing", function PoRichTextToolbarComponent_Template_po_rich_text_link_modal_p_link_editing_14_listener($event) {
        return ctx.emitLinkEditing($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("p-buttons", ctx.formatButtons);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isInternetExplorer);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.disabledTextAlign);
      ɵɵadvance(2);
      ɵɵproperty("p-buttons", ctx.listButtons);
      ɵɵadvance(2);
      ɵɵproperty("p-buttons", ctx.linkButtons);
      ɵɵadvance(2);
      ɵɵproperty("p-buttons", ctx.mediaButtons);
    }
  }, dependencies: [NgIf, PoButtonGroupComponent, PoTooltipDirective, PoRichTextImageModalComponent, PoRichTextLinkModalComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextToolbarComponent, [{
    type: Component,
    args: [{ selector: "po-rich-text-toolbar", template: '<div class="po-rich-text-toolbar" #toolbarElement>\n  <div class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="format">\n    <po-button-group p-toggle="multiple" [p-buttons]="formatButtons"> </po-button-group>\n  </div>\n\n  <div *ngIf="!isInternetExplorer" class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="color">\n    <div class="po-rich-text-toolbar-color-picker-container">\n      <button\n        type="button"\n        class="po-button po-button-default po-rich-text-toolbar-color-picker-button"\n        [disabled]="readonly"\n        [p-tooltip]="literals.textColor"\n        [attr.aria-label]="literals.textColor"\n      >\n        <input\n          #colorPickerInput\n          class="po-rich-text-toolbar-color-picker-input"\n          type="color"\n          [disabled]="readonly"\n          (change)="changeTextColor($event.target.value)"\n          [attr.aria-label]="literals.textColor"\n        />\n      </button>\n    </div>\n  </div>\n\n  <div *ngIf="!disabledTextAlign" class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="align">\n    <po-button-group p-toggle="single" [p-buttons]="alignButtons"> </po-button-group>\n  </div>\n\n  <div class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="list">\n    <po-button-group p-toggle="single" [p-buttons]="listButtons"> </po-button-group>\n  </div>\n\n  <div class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="link">\n    <po-button-group [p-buttons]="linkButtons"> </po-button-group>\n  </div>\n\n  <div class="po-rich-text-toolbar-button-align" data-rich-text-toolbar="media">\n    <po-button-group [p-buttons]="mediaButtons"> </po-button-group>\n  </div>\n</div>\n\n<po-rich-text-image-modal #richTextImageModal (p-command)="emitCommand($event)"> </po-rich-text-image-modal>\n\n<po-rich-text-link-modal\n  #richTextLinkModal\n  (p-command)="emitCommand($event)"\n  (p-link-editing)="emitLinkEditing($event)"\n>\n</po-rich-text-link-modal>\n' }]
  }], () => [{ type: PoLanguageService }], { colorPickerInput: [{
    type: ViewChild,
    args: ["colorPickerInput", { read: ElementRef }]
  }], toolbarElement: [{
    type: ViewChild,
    args: ["toolbarElement", { static: true }]
  }], richTextImageModal: [{
    type: ViewChild,
    args: [PoRichTextImageModalComponent, { static: true }]
  }], richTextLinkModal: [{
    type: ViewChild,
    args: [PoRichTextLinkModalComponent, { static: true }]
  }], command: [{
    type: Output,
    args: ["p-command"]
  }], modal: [{
    type: Output,
    args: ["p-modal"]
  }], linkEditing: [{
    type: Output,
    args: ["p-link-editing"]
  }], disabledTextAlign: [{
    type: Input,
    args: ["p-disabled-text-align"]
  }], readonly: [{
    type: Input,
    args: ["p-readonly"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextToolbarComponent, { className: "PoRichTextToolbarComponent", filePath: "lib/components/po-field/po-rich-text/po-rich-text-toolbar/po-rich-text-toolbar.component.ts", lineNumber: 18 });
})();
var providers = [
  {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoRichTextComponent),
    multi: true
  },
  {
    provide: NG_VALIDATORS,
    // eslint-disable-next-line
    useExisting: forwardRef(() => PoRichTextComponent),
    multi: true
  },
  {
    provide: PoRichTextService
  }
];
var PoRichTextComponent = class _PoRichTextComponent extends PoRichTextBaseComponent {
  element;
  bodyElement;
  listener = this.validateClassesForRequired.bind(this);
  modelLastUpdate;
  get errorMsg() {
    return this.errorMessage !== "" && !this.value && this.required && this.invalid ? this.errorMessage : "";
  }
  constructor(element, richTextService) {
    super(richTextService);
    this.element = element;
  }
  ngAfterViewInit() {
    this.addKeyListeners();
    this.verifyAutoFocus();
  }
  ngOnDestroy() {
    if (!this.onChangeModel) {
      this.element.nativeElement.removeEventListener("keyup", this.listener);
      this.element.nativeElement.removeEventListener("keydown", this.listener);
      this.element.nativeElement.removeEventListener("cut", this.listener);
      this.element.nativeElement.removeEventListener("paste", this.listener);
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoRichTextComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoRichTextComponent, { static: true }) richText: PoRichTextComponent;
   *
   * focusRichText() {
   *   this.richText.focus();
   * }
   * ```
   */
  focus() {
    this.bodyElement.focus();
  }
  onBlur() {
    this.onTouched?.();
  }
  onChangeValue(value) {
    this.change.emit(value);
  }
  updateValue(value) {
    this.value = value;
    this.invalid = !value;
    this.controlChangeModelEmitter(this.value);
    this.updateModel(this.value);
  }
  addKeyListeners() {
    if (!this.onChangeModel) {
      this.element.nativeElement.addEventListener("keyup", this.listener);
      this.element.nativeElement.addEventListener("keydown", this.listener);
      this.element.nativeElement.addEventListener("cut", this.listener);
      this.element.nativeElement.addEventListener("paste", this.listener);
    }
  }
  controlChangeModelEmitter(value) {
    if (this.modelLastUpdate !== value) {
      this.changeModel.emit(value);
      this.modelLastUpdate = value;
    }
  }
  verifyAutoFocus() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  validateClassesForRequired() {
    setTimeout(() => {
      const value = this.value;
      const element = this.element.nativeElement;
      if (!value && this.required) {
        element.classList.add("ng-invalid");
        element.classList.add("ng-dirty");
      } else {
        element.classList.remove("ng-invalid");
      }
    });
  }
  static ɵfac = function PoRichTextComponent_Factory(t) {
    return new (t || _PoRichTextComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoRichTextService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoRichTextComponent, selectors: [["po-rich-text"]], viewQuery: function PoRichTextComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoRichTextBodyComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.bodyElement = _t.first);
    }
  }, features: [ɵɵProvidersFeature(providers), ɵɵInheritDefinitionFeature], decls: 7, vars: 13, consts: [[3, "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [3, "p-height", "p-label", "p-model-value", "p-placeholder", "p-readonly", "p-change", "p-commands", "p-selected-link", "p-shortcut-command", "p-value", "p-blur"], ["richTextBody", ""], [3, "p-readonly", "p-disabled-text-align", "p-link-editing", "p-command"], ["richTextToolbar", ""], [3, "p-help", "p-error-pattern"]], template: function PoRichTextComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r2 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "po-rich-text-body", 2, 3);
      ɵɵlistener("p-change", function PoRichTextComponent_Template_po_rich_text_body_p_change_2_listener($event) {
        return ctx.onChangeValue($event);
      })("p-commands", function PoRichTextComponent_Template_po_rich_text_body_p_commands_2_listener($event) {
        ɵɵrestoreView(_r2);
        const _r1 = ɵɵreference(5);
        return ɵɵresetView(_r1.setButtonsStates($event));
      })("p-selected-link", function PoRichTextComponent_Template_po_rich_text_body_p_selected_link_2_listener($event) {
        ɵɵrestoreView(_r2);
        const _r1 = ɵɵreference(5);
        return ɵɵresetView(_r1.selectedLink($event));
      })("p-shortcut-command", function PoRichTextComponent_Template_po_rich_text_body_p_shortcut_command_2_listener() {
        ɵɵrestoreView(_r2);
        const _r1 = ɵɵreference(5);
        return ɵɵresetView(_r1.shortcutTrigger());
      })("p-value", function PoRichTextComponent_Template_po_rich_text_body_p_value_2_listener($event) {
        return ctx.updateValue($event);
      })("p-blur", function PoRichTextComponent_Template_po_rich_text_body_p_blur_2_listener() {
        return ctx.onBlur();
      });
      ɵɵelementEnd();
      ɵɵelementStart(4, "po-rich-text-toolbar", 4, 5);
      ɵɵlistener("p-link-editing", function PoRichTextComponent_Template_po_rich_text_toolbar_p_link_editing_4_listener($event) {
        ɵɵrestoreView(_r2);
        const _r0 = ɵɵreference(3);
        return ɵɵresetView(_r0.linkEditing($event));
      })("p-command", function PoRichTextComponent_Template_po_rich_text_toolbar_p_command_4_listener($event) {
        ɵɵrestoreView(_r2);
        const _r0 = ɵɵreference(3);
        return ɵɵresetView(_r0.executeCommand($event));
      });
      ɵɵelementEnd()();
      ɵɵelement(6, "po-field-container-bottom", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("p-height", ctx.height)("p-label", ctx.label)("p-model-value", ctx.value)("p-placeholder", ctx.placeholder)("p-readonly", ctx.readonly);
      ɵɵadvance(2);
      ɵɵproperty("p-readonly", ctx.readonly)("p-disabled-text-align", ctx.disabledTextAlign);
      ɵɵadvance(2);
      ɵɵproperty("p-help", ctx.help)("p-error-pattern", ctx.errorMsg);
    }
  }, dependencies: [PoFieldContainerBottomComponent, PoFieldContainerComponent, PoRichTextBodyComponent, PoRichTextToolbarComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoRichTextComponent, [{
    type: Component,
    args: [{ selector: "po-rich-text", providers, changeDetection: ChangeDetectionStrategy.OnPush, template: '<po-field-container [p-label]="label" [p-optional]="optional" [p-required]="required" [p-show-required]="showRequired">\n  <div class="po-field-container-content">\n    <po-rich-text-body\n      #richTextBody\n      [p-height]="height"\n      [p-label]="label"\n      [p-model-value]="value"\n      [p-placeholder]="placeholder"\n      [p-readonly]="readonly"\n      (p-change)="onChangeValue($event)"\n      (p-commands)="richTextToolbar.setButtonsStates($event)"\n      (p-selected-link)="richTextToolbar.selectedLink($event)"\n      (p-shortcut-command)="richTextToolbar.shortcutTrigger()"\n      (p-value)="updateValue($event)"\n      (p-blur)="onBlur()"\n    >\n    </po-rich-text-body>\n\n    <po-rich-text-toolbar\n      #richTextToolbar\n      [p-readonly]="readonly"\n      [p-disabled-text-align]="disabledTextAlign"\n      (p-link-editing)="richTextBody.linkEditing($event)"\n      (p-command)="richTextBody.executeCommand($event)"\n    >\n    </po-rich-text-toolbar>\n  </div>\n\n  <po-field-container-bottom [p-help]="help" [p-error-pattern]="errorMsg"></po-field-container-bottom>\n</po-field-container>\n' }]
  }], () => [{ type: ElementRef }, { type: PoRichTextService }], { bodyElement: [{
    type: ViewChild,
    args: [PoRichTextBodyComponent, { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoRichTextComponent, { className: "PoRichTextComponent", filePath: "lib/components/po-field/po-rich-text/po-rich-text.component.ts", lineNumber: 63 });
})();
var PoFieldValidateModel = class _PoFieldValidateModel extends PoFieldModel {
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional = false;
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   *
   * @default `false`
   */
  required = false;
  /**
   *  Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  onValidatorChange;
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    return this.extraValidation(abstractControl);
  }
  registerOnValidatorChange(fn) {
    this.onValidatorChange = fn;
  }
  validateModel() {
    if (this.onValidatorChange) {
      this.onValidatorChange();
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoFieldValidateModel_BaseFactory;
    return function PoFieldValidateModel_Factory(t) {
      return (ɵPoFieldValidateModel_BaseFactory || (ɵPoFieldValidateModel_BaseFactory = ɵɵgetInheritedFactory(_PoFieldValidateModel)))(t || _PoFieldValidateModel);
    };
  })();
  static ɵdir = ɵɵdefineDirective({ type: _PoFieldValidateModel, inputs: { optional: [InputFlags.HasDecoratorInputTransform, "p-optional", "optional", convertToBoolean], required: [InputFlags.HasDecoratorInputTransform, "p-required", "required", convertToBoolean], showRequired: [InputFlags.None, "p-show-required", "showRequired"] }, features: [ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldValidateModel, [{
    type: Directive
  }], null, { optional: [{
    type: Input,
    args: [{ alias: "p-optional", transform: convertToBoolean }]
  }], required: [{
    type: Input,
    args: [{ alias: "p-required", transform: convertToBoolean }]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }] });
})();
var _c0$C = ["select"];
function PoSelectComponent_ng_container_4_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    let tmp_3_0;
    ɵɵproperty("disabled", !!ctx_r5.placeholder)("hidden", !(ctx_r5.selectedValue == null ? null : ctx_r5.selectedValue.toString()) && !ctx_r5.placeholder)("selected", !(ctx_r5.selectedValue == null ? null : ctx_r5.selectedValue.toString()))("value", (tmp_3_0 = ctx_r5.placeholder) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : "");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r5.placeholder, " ");
  }
}
function PoSelectComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_4_option_1_Template, 2, 5, "option", 6);
    ɵɵelementStart(2, "option", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r1.selectedValue == null ? null : ctx_r1.selectedValue.toString()) || !!ctx_r1.placeholder);
    ɵɵadvance();
    ɵɵproperty("hidden", true);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.displayValue);
  }
}
function PoSelectComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "option");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.displayValue || ctx_r2.placeholder);
  }
}
function PoSelectComponent_ng_container_6_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r7 = ctx.$implicit;
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("disabled", ctx_r6.readonly)("value", item_r7 == null ? null : item_r7[ctx_r6.fieldValue]);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r7 == null ? null : item_r7[ctx_r6.fieldLabel], " ");
  }
}
function PoSelectComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_6_option_1_Template, 2, 3, "option", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.optionWithoutGroup);
  }
}
function PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_option_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const subItem_r12 = ctx.$implicit;
    const ctx_r11 = ɵɵnextContext(4);
    ɵɵproperty("value", subItem_r12 == null ? null : subItem_r12[ctx_r11.fieldValue])("disabled", ctx_r11.readonly);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", subItem_r12 == null ? null : subItem_r12[ctx_r11.fieldLabel], " ");
  }
}
function PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "optgroup", 13);
    ɵɵtemplate(1, PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_option_1_Template, 2, 3, "option", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r9 = ɵɵnextContext().$implicit;
    const ctx_r10 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate("label", item_r9 == null ? null : item_r9.label);
    ɵɵproperty("disabled", ctx_r10.readonly);
    ɵɵadvance();
    ɵɵproperty("ngForOf", item_r9.options);
  }
}
function PoSelectComponent_ng_container_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_7_ng_container_1_optgroup_1_Template, 2, 3, "optgroup", 12);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", (item_r9 == null ? null : item_r9.options.length) > 0);
  }
}
function PoSelectComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoSelectComponent_ng_container_7_ng_container_1_Template, 2, 1, "ng-container", 11);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r4.listGroupOptions);
  }
}
var PO_SELECT_FIELD_LABEL_DEFAULT = "label";
var PO_SELECT_FIELD_VALUE_DEFAULT = "value";
var PoSelectComponent = class _PoSelectComponent extends PoFieldValidateModel {
  changeDetector;
  renderer;
  selectElement;
  /**
   * @optional
   *
   * @description
   *
   * Função para atualizar o ngModel do componente, necessário quando não for utilizado dentro da tag form.
   *
   * Na versão 12.2.0 do Angular a verificação `strictTemplates` vem true como default. Portanto, para utilizar
   * two-way binding no componente deve se utilizar da seguinte forma:
   *
   * ```
   * <po-select ... [ngModel]="selectModel" (ngModelChange)="selectModel = $event"> </po-select>
   * ```
   */
  ngModelChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente para leitura.
   *
   * @default `false`
   */
  readonly = false;
  /** Mensagem que aparecerá enquanto nenhuma opção estiver selecionada. */
  placeholder;
  displayValue;
  id = `po-select[${uuid()}]`;
  modelValue;
  selectedValue;
  optionsDefault = [];
  listGroupOptions = [];
  optionWithoutGroup = [];
  isSafari = isSafari();
  onModelTouched;
  _fieldLabel = PO_SELECT_FIELD_LABEL_DEFAULT;
  _fieldValue = PO_SELECT_FIELD_VALUE_DEFAULT;
  _options;
  /**
   * Nesta propriedade deve ser definido uma coleção de objetos que implementam a interface `PoSelectOption`,
   * ou uma coleção de objetos dentro de grupos diferentes, que seriam da interface `PoSelectOptionGroup`.
   *
   * Caso esta lista estiver vazia, o model será `undefined`.
   *
   * > Essa propriedade é imutável, ou seja, sempre que quiser atualizar a lista de opções disponíveis
   * atualize a referência do objeto:
   *
   * ```
   * // atualiza a referência do objeto garantindo a atualização do template
   * this.options = [...this.options, { value: 'x', label: 'Nova opção' }];
   *
   * // evite, pois não atualiza a referência do objeto podendo gerar atrasos na atualização do template
   * this.options.push({ value: 'x', label: 'Nova opção' });
   * ```
   *
   * > Para coleção de objetos dentro de grupos distintos será exibido a label e opções somente se a propriedade `options` possua valores.
   *  Sendo assim, a estrutura seguiria dessa forma:
   *
   * ```
   * this.options = [{
   *  label: 'Opções',
   *  options: [
   *    { value: 1, label: 'opção 1' },
   *    { value: 2, label: 'opção 2' }
   *  ],
   * }];
   * ```
   *
   * É possível a utilização de opções agrupadas e desagrupadas em conjunto, porém será feita a ordenação de exibir as opções
   * desagrupadas acima.
   *
   */
  set options(options) {
    this.listGroupOptions = [];
    this.optionWithoutGroup = [];
    if (this.fieldLabel && this.fieldValue && options) {
      options.map((option) => {
        if (this.isItemGroup(option)) {
          option.options.map((opt) => {
            opt.label = opt[this.fieldLabel];
            opt.value = opt[this.fieldValue];
          });
        } else {
          option.label = option[this.fieldLabel];
          option.value = option[this.fieldValue];
        }
      });
    }
    if (options) {
      this.optionsDefault = [...options];
      this.separateOptions();
      this.optionsDefault = [];
      this.optionsDefault = [...this.optionWithoutGroup, ...this.transformInArray(this.listGroupOptions)];
      this.onUpdateOptions();
      this._options = [...this.optionsDefault];
    }
  }
  get options() {
    return this._options;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   *
   * @default `label`
   */
  set fieldLabel(value) {
    this._fieldLabel = value || PO_SELECT_FIELD_LABEL_DEFAULT;
    if (this.options && this.options.length > 0) {
      this.options = [...this.options];
    }
  }
  get fieldLabel() {
    return this._fieldLabel;
  }
  /**
   * @optional
   *
   * @description
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente
   * (`p-options`), esta propriedade será responsável pelo valor de cada item da lista.
   *
   * @default `value`
   */
  set fieldValue(value) {
    this._fieldValue = value || PO_SELECT_FIELD_VALUE_DEFAULT;
    if (this.options && this.options.length > 0) {
      this.options = [...this.options];
    }
  }
  get fieldValue() {
    return this._fieldValue;
  }
  /* istanbul ignore next */
  constructor(changeDetector, renderer) {
    super();
    this.changeDetector = changeDetector;
    this.renderer = renderer;
  }
  ngOnChanges(changes) {
    if (changes.options?.currentValue) {
      this.options = changes.options.currentValue;
    }
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoSelectComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoSelectComponent, { static: true }) select: PoSelectComponent;
   *
   * focusSelect() {
   *   this.select.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.selectElement.nativeElement.focus();
    }
  }
  onBlur() {
    this.onModelTouched?.();
  }
  // Altera o valor ao selecionar um item.
  onSelectChange(value) {
    this.onModelTouched?.();
    if (value && this.options && this.options.length) {
      const optionFound = this.findOptionValue(value);
      if (optionFound) {
        this.updateValues(optionFound);
      }
    }
  }
  onUpdateOptions() {
    if (this.modelValue) {
      this.onSelectChange(this.modelValue);
    }
  }
  // Atualiza valores
  updateValues(option) {
    if (this.selectedValue !== option[this.fieldValue]) {
      this.selectedValue = option[this.fieldValue];
      this.selectElement.nativeElement.value = option[this.fieldValue];
      this.updateModel(option[this.fieldValue]);
      this.displayValue = option[this.fieldLabel];
      this.emitChange(option[this.fieldValue]);
    }
  }
  // Recebe as alterações do model
  onWriteValue(value) {
    const optionFound = this.findOptionValue(value);
    if (optionFound) {
      this.selectElement.nativeElement.value = optionFound.value;
      this.selectedValue = optionFound[this.fieldValue];
      this.displayValue = optionFound[this.fieldLabel];
    } else if (validValue(this.selectedValue)) {
      this.selectElement.nativeElement.value = void 0;
      this.updateModel(void 0);
      this.selectedValue = void 0;
      this.displayValue = void 0;
    }
    this.modelValue = value;
    this.changeDetector.detectChanges();
  }
  extraValidation(c) {
    return null;
  }
  isItemGroup(item) {
    if (item.options) {
      return Array.isArray(item.options) ? true : false;
    }
    return false;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  isEqual(value, inputValue) {
    if ((value || value === 0) && inputValue) {
      return value.toString() === inputValue.toString();
    }
    if (value === null && inputValue !== null || value === void 0 && inputValue !== void 0) {
      value = `${value}`;
    }
    return value === inputValue;
  }
  findOptionValue(value) {
    if (this.options) {
      return this.options.find((option) => this.isEqual(option.value, value));
    }
  }
  transformInArray(objectWithArray) {
    return objectWithArray.reduce((options, items) => {
      if (items.options) {
        return options.concat(items.options);
      }
      return [];
    }, []);
  }
  separateOptions() {
    this.optionsDefault.forEach((option) => {
      if (this.isItemGroup(option)) {
        this.validateOptions(option.options);
        this.listGroupOptions.push(option);
      } else {
        this.optionWithoutGroup.push(option);
      }
    });
    if (this.optionWithoutGroup.length > 0) {
      this.validateOptions(this.optionWithoutGroup);
    }
  }
  validateOptions(options) {
    removeDuplicatedOptions(options);
    removeUndefinedAndNullOptions(options);
  }
  static ɵfac = function PoSelectComponent_Factory(t) {
    return new (t || _PoSelectComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSelectComponent, selectors: [["po-select"]], viewQuery: function PoSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$C, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectElement = _t.first);
    }
  }, inputs: { readonly: [InputFlags.HasDecoratorInputTransform, "p-readonly", "readonly", convertToBoolean], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], options: [InputFlags.None, "p-options", "options"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"] }, outputs: { ngModelChange: "ngModelChange" }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoSelectComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoSelectComponent),
      multi: true
    }
  ]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 9, vars: 18, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-select", 3, "disabled", "id", "required", "change"], ["select", ""], [4, "ngIf"], [3, "p-help", "p-disabled"], [3, "disabled", "hidden", "selected", "value", 4, "ngIf"], [3, "hidden"], [3, "disabled", "hidden", "selected", "value"], [3, "disabled", "value", 4, "ngFor", "ngForOf"], [3, "disabled", "value"], [4, "ngFor", "ngForOf"], [3, "label", "disabled", 4, "ngIf"], [3, "label", "disabled"], [3, "value", "disabled", 4, "ngFor", "ngForOf"], [3, "value", "disabled"]], template: function PoSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "select", 2, 3);
      ɵɵlistener("change", function PoSelectComponent_Template_select_change_2_listener($event) {
        return ctx.onSelectChange($event.target.value);
      });
      ɵɵtemplate(4, PoSelectComponent_ng_container_4_Template, 4, 3, "ng-container", 4)(5, PoSelectComponent_ng_container_5_Template, 3, 1, "ng-container", 4)(6, PoSelectComponent_ng_container_6_Template, 2, 1, "ng-container", 4)(7, PoSelectComponent_ng_container_7_Template, 2, 1, "ng-container", 4);
      ɵɵelementEnd()();
      ɵɵelement(8, "po-field-container-bottom", 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵclassProp("po-select-placeholder", !(ctx.selectedValue == null ? null : ctx.selectedValue.toString()) && !!ctx.placeholder);
      ɵɵproperty("disabled", ctx.disabled)("id", ctx.id)("required", ctx.required);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.isSafari);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isSafari);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.optionWithoutGroup.length > 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.listGroupOptions.length > 0);
      ɵɵadvance();
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, dependencies: [NgForOf, NgIf, NgSelectOption, ɵNgSelectMultipleOption, PoFieldContainerBottomComponent, PoFieldContainerComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSelectComponent, [{
    type: Component,
    args: [{ selector: "po-select", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoSelectComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoSelectComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <select
      #select
      class="po-select"
      [attr.name]="name"
      [class.po-select-placeholder]="!selectedValue?.toString() && !!placeholder"
      [disabled]="disabled"
      [id]="id"
      [required]="required"
      (change)="onSelectChange($event.target.value)"
    >
      <ng-container *ngIf="!isSafari">
        <option
          *ngIf="!selectedValue?.toString() || !!placeholder"
          [disabled]="!!placeholder"
          [hidden]="!selectedValue?.toString() && !placeholder"
          [selected]="!selectedValue?.toString()"
          [value]="placeholder ?? ''"
        >
          {{ placeholder }}
        </option>
        <option [hidden]="true">{{ displayValue }}</option>
      </ng-container>

      <ng-container *ngIf="isSafari">
        <option>{{ displayValue || placeholder }}</option>
      </ng-container>

      <ng-container *ngIf="optionWithoutGroup.length > 0">
        <option *ngFor="let item of optionWithoutGroup" [disabled]="readonly" [value]="item?.[this.fieldValue]">
          {{ item?.[this.fieldLabel] }}
        </option>
      </ng-container>
      <ng-container *ngIf="listGroupOptions.length > 0">
        <ng-container *ngFor="let item of listGroupOptions">
          <optgroup *ngIf="item?.options.length > 0" label="{{ item?.label }}" [disabled]="readonly">
            <option *ngFor="let subItem of item.options" [value]="subItem?.[this.fieldValue]" [disabled]="readonly">
              {{ subItem?.[this.fieldLabel] }}
            </option>
          </optgroup>
        </ng-container>
      </ng-container>
    </select>
  </div>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: Renderer2 }], { selectElement: [{
    type: ViewChild,
    args: ["select", { read: ElementRef, static: true }]
  }], ngModelChange: [{
    type: Output,
    args: ["ngModelChange"]
  }], readonly: [{
    type: Input,
    args: [{ alias: "p-readonly", transform: convertToBoolean }]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSelectComponent, { className: "PoSelectComponent", filePath: "lib/components/po-field/po-select/po-select.component.ts", lineNumber: 92 });
})();
var PoTextareaBaseComponent = class _PoTextareaBaseComponent {
  cd;
  /**
   * @optional
   *
   * @description
   *
   * Aplica foco no elemento ao ser iniciado.
   *
   * > Caso mais de um elemento seja configurado com essa propriedade, apenas o último elemento declarado com ela terá o foco.
   *
   * @default `false`
   */
  autoFocus = false;
  /** Label do campo. */
  label;
  /** Texto de apoio do campo. */
  help;
  /** Nome e Id do componente. */
  name;
  /**
   * @optional
   *
   * @description
   *
   * Define se a indicação de campo opcional será exibida.
   *
   * > Não será exibida a indicação se:
   * - O campo conter `p-required`;
   * - Não possuir `p-help` e/ou `p-label`.
   *
   * @default `false`
   */
  optional;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao sair do campo.
   */
  blur = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao entrar do campo.
   */
  enter = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor e deixar o campo.
   */
  change = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do model.
   */
  changeModel = new EventEmitter();
  _disabled = false;
  _maxlength;
  _minlength;
  _placeholder = "";
  _readonly = false;
  _required = false;
  _rows = 3;
  modelLastUpdate;
  onChangePropagate = null;
  validatorChange;
  // eslint-disable-next-line
  onTouched = null;
  /** Placeholder, mensagem que aparecerá enquanto o campo não estiver preenchido. */
  set placeholder(value) {
    this._placeholder = value || "";
  }
  get placeholder() {
    return this._placeholder;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será desabilitado.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o campo será somente leitura.
   *
   * @default `false`
   */
  set readonly(readonly) {
    this._readonly = convertToBoolean(readonly);
  }
  get readonly() {
    return this._readonly;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define que o campo será obrigatório.
   * > Esta propriedade é desconsiderada quando o input está desabilitado `(p-disabled)`.
   *
   * @default `false`
   */
  set required(required) {
    this._required = convertToBoolean(required);
    this.validateModel();
  }
  get required() {
    return this._required;
  }
  /**
   * Define se a indicação de campo obrigatório será exibida.
   *
   * > Não será exibida a indicação se:
   * - Não possuir `p-help` e/ou `p-label`.
   */
  showRequired = false;
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade mínima de caracteres que o campo aceita.
   */
  set minlength(minlength) {
    this._minlength = convertToInt(minlength);
    this.validateModel();
  }
  get minlength() {
    return this._minlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade máxima de caracteres que o campo aceita.
   */
  set maxlength(maxlength) {
    this._maxlength = convertToInt(maxlength);
    this.validateModel();
  }
  get maxlength() {
    return this._maxlength;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica a quantidade de linhas que serão exibidas.
   *
   * @default `3`
   */
  set rows(value) {
    this._rows = isNaN(parseInt(value, 10)) || value < 3 ? 3 : parseInt(value, 10);
  }
  get rows() {
    return this._rows;
  }
  constructor(cd) {
    this.cd = cd;
  }
  callOnChange(value) {
    if (this.onChangePropagate) {
      this.onChangePropagate(value);
    }
    this.controlChangeModelEmitter(value);
  }
  controlChangeModelEmitter(value) {
    if (this.modelLastUpdate !== value) {
      this.changeModel.emit(value);
      this.modelLastUpdate = value;
    }
  }
  // Função implementada do ControlValueAccessor
  // Usada para interceptar os estados de habilitado via forms api
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  // Funções `registerOnChange`, `registerOnTouched` e `registerOnValidatorChange` implementadas referentes ao ControlValueAccessor
  // usadas para interceptar as mudanças e não atualizar automaticamente o Model
  registerOnChange(func) {
    this.onChangePropagate = func;
  }
  registerOnTouched(func) {
    this.onTouched = func;
  }
  registerOnValidatorChange(func) {
    this.validatorChange = func;
  }
  validate(abstractControl) {
    if (requiredFailed(this.required, this.disabled, abstractControl.value)) {
      return {
        required: {
          valid: false
        }
      };
    }
    if (minlengpoailed(this.minlength, abstractControl.value)) {
      return {
        minlength: {
          valid: false
        }
      };
    }
    if (maxlengpoailed(this.maxlength, abstractControl.value)) {
      return {
        maxlength: {
          valid: false
        }
      };
    }
  }
  // Função implementada do ControlValueAccessor
  writeValue(value) {
    this.writeValueModel(value);
    this.cd.markForCheck();
  }
  validateModel() {
    if (this.validatorChange) {
      this.validatorChange();
    }
  }
  static ɵfac = function PoTextareaBaseComponent_Factory(t) {
    return new (t || _PoTextareaBaseComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTextareaBaseComponent, inputs: { autoFocus: [InputFlags.HasDecoratorInputTransform, "p-auto-focus", "autoFocus", convertToBoolean], label: [InputFlags.None, "p-label", "label"], help: [InputFlags.None, "p-help", "help"], name: "name", optional: [InputFlags.None, "p-optional", "optional"], placeholder: [InputFlags.None, "p-placeholder", "placeholder"], disabled: [InputFlags.None, "p-disabled", "disabled"], readonly: [InputFlags.None, "p-readonly", "readonly"], required: [InputFlags.None, "p-required", "required"], showRequired: [InputFlags.None, "p-show-required", "showRequired"], minlength: [InputFlags.None, "p-minlength", "minlength"], maxlength: [InputFlags.None, "p-maxlength", "maxlength"], rows: [InputFlags.None, "p-rows", "rows"] }, outputs: { blur: "p-blur", enter: "p-enter", change: "p-change", changeModel: "p-change-model" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTextareaBaseComponent, [{
    type: Directive
  }], () => [{ type: ChangeDetectorRef }], { autoFocus: [{
    type: Input,
    args: [{ alias: "p-auto-focus", transform: convertToBoolean }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], name: [{
    type: Input,
    args: ["name"]
  }], optional: [{
    type: Input,
    args: ["p-optional"]
  }], blur: [{
    type: Output,
    args: ["p-blur"]
  }], enter: [{
    type: Output,
    args: ["p-enter"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], changeModel: [{
    type: Output,
    args: ["p-change-model"]
  }], placeholder: [{
    type: Input,
    args: ["p-placeholder"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], readonly: [{
    type: Input,
    args: ["p-readonly"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], showRequired: [{
    type: Input,
    args: ["p-show-required"]
  }], minlength: [{
    type: Input,
    args: ["p-minlength"]
  }], maxlength: [{
    type: Input,
    args: ["p-maxlength"]
  }], rows: [{
    type: Input,
    args: ["p-rows"]
  }] });
})();
var _c0$B = ["inp"];
var PoTextareaComponent = class _PoTextareaComponent extends PoTextareaBaseComponent {
  inputEl;
  id = `po-textarea[${uuid()}]`;
  valueBeforeChange;
  fireChange = false;
  constructor(cd) {
    super(cd);
  }
  /**
   * Função que atribui foco ao componente.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoTextareaComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild(PoTextareaComponent, { static: true }) textarea: PoTextareaComponent;
   *
   * focusTextarea() {
   *   this.textarea.focus();
   * }
   * ```
   */
  focus() {
    if (!this.disabled) {
      this.inputEl.nativeElement.focus();
    }
  }
  ngAfterViewInit() {
    if (this.autoFocus) {
      this.focus();
    }
  }
  writeValueModel(value) {
    if (this.inputEl) {
      if (!value) {
        this.inputEl.nativeElement.value = "";
      } else {
        this.inputEl.nativeElement.value = value;
      }
    }
    if (value) {
      this.change.emit(value);
    }
  }
  validMaxLength(maxlength, value) {
    return maxlength && value.length > maxlength ? value.toString().substring(0, maxlength) : value;
  }
  eventOnInput(event) {
    const value = this.validMaxLength(this.maxlength, event.target.value);
    this.callOnChange(value);
    this.inputEl.nativeElement.value = value;
  }
  eventOnFocus() {
    this.valueBeforeChange = this.inputEl.nativeElement.value;
    this.enter.emit();
  }
  eventOnBlur() {
    this.onTouched?.();
    this.blur.emit();
    this.controlChangeEmitter();
  }
  controlChangeEmitter() {
    const elementValue = this.inputEl.nativeElement.value;
    if (elementValue !== this.valueBeforeChange) {
      this.change.emit(elementValue);
    }
  }
  static ɵfac = function PoTextareaComponent_Factory(t) {
    return new (t || _PoTextareaComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTextareaComponent, selectors: [["po-textarea"]], viewQuery: function PoTextareaComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$B, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputEl = _t.first);
    }
  }, features: [ɵɵProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _PoTextareaComponent),
      multi: true
    },
    {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _PoTextareaComponent),
      multi: true
    }
  ]), ɵɵInheritDefinitionFeature], decls: 5, vars: 15, consts: [[3, "p-disabled", "p-id", "p-label", "p-optional", "p-required", "p-show-required"], [1, "po-field-container-content"], [1, "po-textarea", 3, "disabled", "id", "placeholder", "readonly", "required", "rows", "blur", "focus", "input"], ["inp", ""], [3, "p-help", "p-disabled"]], template: function PoTextareaComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-field-container", 0)(1, "div", 1)(2, "textarea", 2, 3);
      ɵɵlistener("blur", function PoTextareaComponent_Template_textarea_blur_2_listener() {
        return ctx.eventOnBlur();
      })("focus", function PoTextareaComponent_Template_textarea_focus_2_listener() {
        return ctx.eventOnFocus();
      })("input", function PoTextareaComponent_Template_textarea_input_2_listener($event) {
        return ctx.eventOnInput($event);
      });
      ɵɵelementEnd()();
      ɵɵelement(4, "po-field-container-bottom", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disabled)("p-id", ctx.id)("p-label", ctx.label)("p-optional", ctx.optional)("p-required", ctx.required)("p-show-required", ctx.showRequired);
      ɵɵadvance(2);
      ɵɵproperty("disabled", ctx.disabled)("id", ctx.id)("placeholder", ctx.disabled ? "" : ctx.placeholder)("readonly", ctx.readonly)("required", ctx.required)("rows", ctx.rows);
      ɵɵattribute("name", ctx.name);
      ɵɵadvance(2);
      ɵɵproperty("p-help", ctx.help)("p-disabled", ctx.disabled);
    }
  }, dependencies: [PoFieldContainerBottomComponent, PoFieldContainerComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTextareaComponent, [{
    type: Component,
    args: [{ selector: "po-textarea", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => PoTextareaComponent),
        multi: true
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => PoTextareaComponent),
        multi: true
      }
    ], template: `<po-field-container
  [p-disabled]="disabled"
  [p-id]="id"
  [p-label]="label"
  [p-optional]="optional"
  [p-required]="required"
  [p-show-required]="showRequired"
>
  <div class="po-field-container-content">
    <textarea
      #inp
      class="po-textarea"
      (blur)="eventOnBlur()"
      (focus)="eventOnFocus()"
      (input)="eventOnInput($event)"
      [attr.name]="name"
      [disabled]="disabled"
      [id]="id"
      [placeholder]="disabled ? '' : placeholder"
      [readonly]="readonly"
      [required]="required"
      [rows]="rows"
    ></textarea>
  </div>

  <po-field-container-bottom [p-help]="help" [p-disabled]="disabled"></po-field-container-bottom>
</po-field-container>
` }]
  }], () => [{ type: ChangeDetectorRef }], { inputEl: [{
    type: ViewChild,
    args: ["inp", { read: ElementRef, static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTextareaComponent, { className: "PoTextareaComponent", filePath: "lib/components/po-field/po-textarea/po-textarea.component.ts", lineNumber: 59 });
})();
var poSearchLiteralsDefault = {
  en: {
    search: "Search",
    clean: "Clean"
  },
  es: {
    search: "Buscar",
    clean: "limpiar"
  },
  pt: {
    search: "Pesquisar",
    clean: "Apagar"
  },
  ru: {
    search: "Поиск",
    clean: "чистый"
  }
};
var PoSearchBaseComponent = class _PoSearchBaseComponent {
  _literals;
  _ariaLabel;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Desabilita o po-search e não permite que o usuário interaja com o mesmo.
   *
   * @default `false`
   */
  disabled;
  /**
   * @optional
   *
   * @description
   *
   * Lista de itens que serão utilizados para pesquisa
   */
  items = [];
  /**
   * @optional
   *
   * @description
   *
   * Define um aria-label para o po-search.
   *
   * > Devido o componente não possuir uma label assim como outros campos de texto, o `aria-label` é utilizado para acessibilidade.
   */
  set ariaLabel(value) {
    this._ariaLabel = value;
    if (value !== this.literals.search) {
      this._ariaLabel = `${this._ariaLabel} ${this.literals.search}`;
    }
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  /**
   * @description
   *
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente (p-items), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   */
  filterKeys = [];
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informado o nome da propriedade do objeto que será utilizado para a conversão dos itens apresentados na lista do componente (p-items), esta propriedade será responsável pelo texto de apresentação de cada item da lista.
   */
  icon;
  /**
   * @optional
   *
   * @description
   *
   * Determina a forma de realizar a pesquisa no componente
   *
   * Valores aceitos:
   * - `action`: Realiza a busca a cada caractere digitado.
   * - `trigger`: Realiza a busca ao pressionar `enter` ou clicar no ícone de busca.
   *
   * @default `action`
   */
  type = "action";
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-search`.
   *
   * Para utilizar basta passar a literal que deseja customizar:
   *
   * ```
   *  const customLiterals: PoSearchLiterals = {
   *    search: 'Pesquisar',
   *    clean: 'Limpar',
   *  };
   * ```
   *
   * E para carregar a literal customizada, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-search
   *   [p-literals]="customLiterals">
   * </po-search>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poSearchLiteralsDefault[poLocaleDefault]), poSearchLiteralsDefault[this.language]), value);
    } else {
      this._literals = poSearchLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poSearchLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o modo de pesquisa utilizado no campo de busca, quando habilitado. Valores definidos no enum: PoSearchFilterMode
   *
   * @default `startsWith`
   */
  filterType = PoSearchFilterMode.startsWith;
  /**
   * @optional
   *
   * @description
   *
   * Evento disparado ao alterar valor do model.
   */
  changeModel = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver alterações no input.
   */
  filteredItemsChange = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Pode ser informada uma função que será disparada quando houver alterações nos filtros.
   */
  filter = new EventEmitter();
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoSearchBaseComponent_Factory(t) {
    return new (t || _PoSearchBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoSearchBaseComponent, inputs: { disabled: [InputFlags.HasDecoratorInputTransform, "p-disabled", "disabled", convertToBoolean], items: [InputFlags.None, "p-items", "items"], ariaLabel: [InputFlags.None, "p-aria-label", "ariaLabel"], filterKeys: [InputFlags.None, "p-filter-keys", "filterKeys"], icon: [InputFlags.None, "p-icon", "icon"], type: [InputFlags.None, "p-search-type", "type"], literals: [InputFlags.None, "p-literals", "literals"], filterType: [InputFlags.None, "p-filter-type", "filterType"] }, outputs: { changeModel: "p-change-model", filteredItemsChange: "p-filtered-items-change", filter: "p-filter" }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { disabled: [{
    type: Input,
    args: [{ alias: "p-disabled", transform: convertToBoolean }]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], ariaLabel: [{
    type: Input,
    args: ["p-aria-label"]
  }], filterKeys: [{
    type: Input,
    args: ["p-filter-keys"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], type: [{
    type: Input,
    args: ["p-search-type"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], filterType: [{
    type: Input,
    args: ["p-filter-type"]
  }], changeModel: [{
    type: Output,
    args: ["p-change-model"]
  }], filteredItemsChange: [{
    type: Output,
    args: ["p-filtered-items-change"]
  }], filter: [{
    type: Output,
    args: ["p-filter"]
  }] });
})();
var _c0$A = ["poSearchInput"];
function PoSearchComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "po-icon", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-icon", ctx_r0.icon ? ctx_r0.icon : "po-icon-search");
  }
}
function PoSearchComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 9);
    ɵɵlistener("click", function PoSearchComponent_button_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.clearSearch());
    })("keydown.enter", function PoSearchComponent_button_5_Template_button_keydown_enter_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.clearSearch());
    });
    ɵɵelement(1, "po-icon", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ctx_r2.literals.clean);
  }
}
function PoSearchComponent_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function PoSearchComponent_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      const _r1 = ɵɵreference(3);
      return ɵɵresetView(ctx_r7.onSearchChange(_r1.value, true));
    })("keydown.enter", function PoSearchComponent_button_6_Template_button_keydown_enter_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r9 = ɵɵnextContext();
      const _r1 = ɵɵreference(3);
      return ɵɵresetView(ctx_r9.onSearchChange(_r1.value, true));
    });
    ɵɵelement(1, "po-icon", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ctx_r3.literals.search)("disabled", ctx_r3.disabled);
    ɵɵadvance();
    ɵɵproperty("p-icon", ctx_r3.icon ? ctx_r3.icon : "po-icon-search");
  }
}
var PoSearchComponent = class _PoSearchComponent extends PoSearchBaseComponent {
  languageService;
  renderer;
  poSearchInput;
  filteredItems = [];
  constructor(languageService, renderer) {
    super(languageService);
    this.languageService = languageService;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.filteredItems = this.items;
  }
  clearSearch() {
    this.poSearchInput.nativeElement.value = "";
    this.onSearchChange("", true);
    this.filteredItemsChange.emit(this.items);
    this.poSearchInput.nativeElement.focus();
  }
  onSearchChange(searchText, activated) {
    if (activated) {
      searchText = searchText.toLowerCase();
      if (this.items && this.items.length > 0) {
        this.filteredItems = this.items.filter((item) => this.filterKeys.some((key) => {
          let value = item[key];
          if (typeof value !== "string") {
            value = value != null ? value.toString() : null;
          }
          value = value != null ? value.toLowerCase() : null;
          if (this.filterType === PoSearchFilterMode.startsWith) {
            return value != null && value.startsWith(searchText);
          } else if (this.filterType === PoSearchFilterMode.contains) {
            return value != null && value.includes(searchText);
          } else if (this.filterType === PoSearchFilterMode.endsWith) {
            return value != null && value.endsWith(searchText);
          }
          return false;
        }));
        this.filteredItemsChange.emit(this.filteredItems);
      } else {
        this.filteredItems = [];
        this.filteredItemsChange.emit(this.filteredItems);
      }
      this.changeModel.emit(searchText);
    }
  }
  static ɵfac = function PoSearchComponent_Factory(t) {
    return new (t || _PoSearchComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSearchComponent, selectors: [["po-search"]], viewQuery: function PoSearchComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$A, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poSearchInput = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 7, vars: 12, consts: [[1, "po-search"], ["class", "po-search-icon", 4, "ngIf"], ["type", "text", 1, "po-search-input", 3, "ariaLabel", "disabled", "placeholder", "input", "keyup.enter"], ["poSearchInput", ""], [1, "po-search-buttons"], ["class", "po-search-button po-search-button-clean", "type", "button", 3, "ariaLabel", "click", "keydown.enter", 4, "ngIf"], ["class", "po-search-button po-search-button-trigger", "type", "button", 3, "ariaLabel", "disabled", "click", "keydown.enter", 4, "ngIf"], [1, "po-search-icon"], [3, "p-icon"], ["type", "button", 1, "po-search-button", "po-search-button-clean", 3, "ariaLabel", "click", "keydown.enter"], ["p-icon", "po-icon-clear-content"], ["type", "button", 1, "po-search-button", "po-search-button-trigger", 3, "ariaLabel", "disabled", "click", "keydown.enter"]], template: function PoSearchComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoSearchComponent_div_1_Template, 2, 1, "div", 1);
      ɵɵelementStart(2, "input", 2, 3);
      ɵɵlistener("input", function PoSearchComponent_Template_input_input_2_listener($event) {
        return ctx.onSearchChange($event.target.value, ctx.type === "action" ? true : false);
      })("keyup.enter", function PoSearchComponent_Template_input_keyup_enter_2_listener($event) {
        return ctx.onSearchChange($event.target.value, ctx.type === "trigger" ? true : false);
      });
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 4);
      ɵɵtemplate(5, PoSearchComponent_button_5_Template, 2, 1, "button", 5)(6, PoSearchComponent_button_6_Template, 2, 3, "button", 6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      const _r1 = ɵɵreference(3);
      ɵɵclassProp("po-search-disabled", ctx.disabled);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "action");
      ɵɵadvance();
      ɵɵclassProp("po-search-input-clean", !!_r1.value && !ctx.disabled)("po-search-input-trigger", ctx.type === "trigger");
      ɵɵproperty("ariaLabel", ctx.ariaLabel)("disabled", ctx.disabled)("placeholder", ctx.literals.search);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !!_r1.value && !ctx.disabled);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "trigger");
    }
  }, dependencies: [NgIf, PoIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchComponent, [{
    type: Component,
    args: [{ selector: "po-search", template: `<div class="po-search" [class.po-search-disabled]="disabled">
  <div *ngIf="type === 'action'" class="po-search-icon">
    <po-icon [p-icon]="icon ? icon : 'po-icon-search'"></po-icon>
  </div>

  <input
    #poSearchInput
    class="po-search-input"
    type="text"
    [ariaLabel]="ariaLabel"
    [class.po-search-input-clean]="!!poSearchInput.value && !disabled"
    [class.po-search-input-trigger]="type === 'trigger'"
    [disabled]="disabled"
    [placeholder]="literals.search"
    (input)="onSearchChange($event.target.value, type === 'action' ? true : false)"
    (keyup.enter)="onSearchChange($event.target.value, type === 'trigger' ? true : false)"
  />

  <div class="po-search-buttons">
    <button
      *ngIf="!!poSearchInput.value && !disabled"
      class="po-search-button po-search-button-clean"
      type="button"
      [ariaLabel]="literals.clean"
      (click)="clearSearch()"
      (keydown.enter)="clearSearch()"
    >
      <po-icon p-icon="po-icon-clear-content"></po-icon>
    </button>

    <button
      *ngIf="type === 'trigger'"
      class="po-search-button po-search-button-trigger"
      type="button"
      [ariaLabel]="literals.search"
      (click)="onSearchChange(poSearchInput.value, true)"
      (keydown.enter)="onSearchChange(poSearchInput.value, true)"
      [disabled]="disabled"
    >
      <po-icon [p-icon]="icon ? icon : 'po-icon-search'"> </po-icon>
    </button>
  </div>
</div>
` }]
  }], () => [{ type: PoLanguageService }, { type: Renderer2 }], { poSearchInput: [{
    type: ViewChild,
    args: ["poSearchInput", { read: ElementRef, static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSearchComponent, { className: "PoSearchComponent", filePath: "lib/components/po-search/po-search.component.ts", lineNumber: 33 });
})();
var PoSearchModule = class _PoSearchModule {
  static ɵfac = function PoSearchModule_Factory(t) {
    return new (t || _PoSearchModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoSearchModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoCleanModule, PoIconModule, PoLoadingModule, PoAccordionModule, FormsModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSearchModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoCleanModule, PoIconModule, PoLoadingModule, PoAccordionModule, FormsModule],
      declarations: [PoSearchComponent],
      exports: [PoSearchComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoSearchModule, { declarations: [PoSearchComponent], imports: [CommonModule, PoCleanModule, PoIconModule, PoLoadingModule, PoAccordionModule, FormsModule], exports: [PoSearchComponent] });
})();
var PoTableModule = class _PoTableModule {
  static ɵfac = function PoTableModule_Factory(t) {
    return new (t || _PoTableModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoTableModule });
  static ɵinj = ɵɵdefineInjector({ providers: [DecimalPipe], imports: [
    CommonModule,
    FormsModule,
    ScrollingModule,
    DragDropModule,
    RouterModule,
    PoButtonModule,
    PoCheckboxGroupModule,
    PoContainerModule,
    PoLoadingModule,
    PoModalModule,
    PoPopoverModule,
    PoPopupModule,
    PoTagModule,
    PoTimeModule,
    PoTooltipModule,
    PoIconModule,
    PoCheckboxModule,
    PoRadioModule,
    PoLinkModule,
    PoPageSlideModule,
    PoSwitchModule,
    PoSearchModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTableModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        FormsModule,
        ScrollingModule,
        DragDropModule,
        RouterModule,
        PoButtonModule,
        PoCheckboxGroupModule,
        PoContainerModule,
        PoLoadingModule,
        PoModalModule,
        PoPopoverModule,
        PoPopupModule,
        PoTagModule,
        PoTimeModule,
        PoTooltipModule,
        PoIconModule,
        PoCheckboxModule,
        PoRadioModule,
        PoLinkModule,
        PoPageSlideModule,
        PoSwitchModule,
        PoSearchModule
      ],
      declarations: [
        PoTableComponent,
        PoTableColumnIconComponent,
        PoTableColumnLabelComponent,
        PoTableColumnLinkComponent,
        PoTableColumnManagerComponent,
        PoTableListManagerComponent,
        PoTableDetailComponent,
        PoTableIconComponent,
        PoTableRowTemplateDirective,
        PoTableShowSubtitleComponent,
        PoTableSubtitleCircleComponent,
        PoTableSubtitleFooterComponent,
        PoTableCellTemplateDirective,
        PoTableColumnTemplateDirective,
        PoTableColumnFrozenDirective
      ],
      exports: [
        PoTableComponent,
        PoTableRowTemplateDirective,
        PoTableCellTemplateDirective,
        PoTableColumnTemplateDirective
      ],
      providers: [DecimalPipe]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTableModule, { declarations: [
    PoTableComponent,
    PoTableColumnIconComponent,
    PoTableColumnLabelComponent,
    PoTableColumnLinkComponent,
    PoTableColumnManagerComponent,
    PoTableListManagerComponent,
    PoTableDetailComponent,
    PoTableIconComponent,
    PoTableRowTemplateDirective,
    PoTableShowSubtitleComponent,
    PoTableSubtitleCircleComponent,
    PoTableSubtitleFooterComponent,
    PoTableCellTemplateDirective,
    PoTableColumnTemplateDirective,
    PoTableColumnFrozenDirective
  ], imports: [
    CommonModule,
    FormsModule,
    ScrollingModule,
    DragDropModule,
    RouterModule,
    PoButtonModule,
    PoCheckboxGroupModule,
    PoContainerModule,
    PoLoadingModule,
    PoModalModule,
    PoPopoverModule,
    PoPopupModule,
    PoTagModule,
    PoTimeModule,
    PoTooltipModule,
    PoIconModule,
    PoCheckboxModule,
    PoRadioModule,
    PoLinkModule,
    PoPageSlideModule,
    PoSwitchModule,
    PoSearchModule
  ], exports: [
    PoTableComponent,
    PoTableRowTemplateDirective,
    PoTableCellTemplateDirective,
    PoTableColumnTemplateDirective
  ] });
})();
ɵɵsetComponentScope(PoTableComponent, [
  NgClass,
  NgForOf,
  NgIf,
  NgTemplateOutlet,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgPlural,
  NgPluralCase,
  CdkFixedSizeVirtualScroll,
  CdkVirtualForOf,
  CdkVirtualScrollViewport,
  CdkDropList,
  CdkDrag,
  CdkDragHandle,
  PoButtonComponent,
  PoContainerComponent,
  PoLoadingOverlayComponent,
  PoModalComponent,
  PoPopupComponent,
  PoTooltipDirective,
  PoIconComponent,
  PoCheckboxComponent,
  PoRadioComponent,
  PoSearchComponent,
  PoTableColumnIconComponent,
  PoTableColumnLabelComponent,
  PoTableColumnLinkComponent,
  PoTableColumnManagerComponent,
  PoTableDetailComponent,
  PoTableSubtitleCircleComponent,
  PoTableSubtitleFooterComponent,
  PoTableColumnFrozenDirective
], [LowerCasePipe, TitleCasePipe, CurrencyPipe, DatePipe, PoTimePipe]);
var _c0$z = ["container"];
var _c1$c = ["divElement"];
var _c2$4 = ["listbox"];
var PoMultiselectDropdownComponent = class _PoMultiselectDropdownComponent {
  cd;
  /** Propriedade que indica se deve exibir o loading. */
  isServerSearching = false;
  /** Propriedade que indica se o campo de pesquisa deverá ser escondido. */
  hideSearch = false;
  /** Propriedade que que recebe as literais definidas no componente `po-multiselect`. */
  literals;
  /** Placeholder do campo de pesquisa. */
  placeholderSearch;
  /** Propriedade que recebe a lista de opções selecionadas. */
  selectedOptions = [];
  /** Propriedade que recebe a lista com todas as opções. */
  options = [];
  /** Propriedade que recebe a lista de opções que deverão ser criadas no dropdown. */
  visibleOptions = [];
  /** Propriedade que indica se o campo "Selecionar todos" deverá ser escondido. */
  hideSelectAll = false;
  fieldValue;
  fieldLabel;
  multiselectTemplate;
  /** Evento disparado a cada tecla digitada na pesquisa. */
  changeSearch = new EventEmitter();
  /** Evento disparado a cada alteração na lista das opções selecionadas. */
  change = new EventEmitter();
  /**
   * Evento disparado quando for detectada uma ação que necessite fechar o dropdown.
   * Por exemplo, no caso de ser teclado TAB dentro do dropdown, então é disparado este evento
   * para notificar o componente principal que deve fechar o dropdown.
   */
  closeDropdown = new EventEmitter();
  container;
  divElement;
  listbox;
  scrollTop = 0;
  show = false;
  constructor(cd) {
    this.cd = cd;
  }
  get hasOptions() {
    return !!this.options?.length;
  }
  scrollTo(index) {
    this.scrollTop = index <= 2 ? 0 : index * 44 - 88;
    this.cd.markForCheck();
  }
  isSelectedItem(option) {
    return this.selectedOptions.some((selectedItem) => selectedItem[this.fieldValue] === option[this.fieldValue]);
  }
  clickItem(check, options) {
    if (options) {
      this.updateSelectedValues(check, options);
    } else {
      const { selected, option } = check;
      this.updateSelectedValues(selected, option);
    }
  }
  onClickSelectAll() {
    const selectedValues = this.selectedOptions.map(({ [this.fieldValue]: value }) => value);
    if (this.everyVisibleOptionsSelected(selectedValues)) {
      this.selectedOptions = [];
    } else {
      this.selectedOptions = this.uniqueSelectedOptions(selectedValues);
    }
    this.change.emit(this.selectedOptions);
  }
  updateSelectedValues(checked, option) {
    if (checked) {
      this.selectedOptions.push(option);
    } else {
      this.selectedOptions = this.selectedOptions.filter((selectedOption) => selectedOption[this.fieldValue] !== option[this.fieldValue]);
    }
    this.change.emit(this.selectedOptions);
  }
  everyVisibleOptionsSelected(selectedValues) {
    return this.visibleOptions.every((visibleOption) => selectedValues.includes(visibleOption[this.fieldValue]));
  }
  someVisibleOptionsSelected(selectedValues) {
    return this.visibleOptions.some((visibleOption) => selectedValues.includes(visibleOption[this.fieldValue]));
  }
  getStateSelectAll() {
    const selectedValues = this.selectedOptions.map(({ [this.fieldValue]: value }) => value);
    if (this.everyVisibleOptionsSelected(selectedValues)) {
      return true;
    } else if (this.someVisibleOptionsSelected(selectedValues)) {
      return null;
    } else {
      return false;
    }
  }
  callChangeSearch(event) {
    this.changeSearch.emit(event);
  }
  controlVisibility(toOpen) {
    this.show = toOpen;
    setTimeout(() => {
      if (toOpen && this.listbox?.searchElement && !this.hideSearch) {
        this.listbox.searchElement.setFocus();
        this.listbox.searchElement.clean();
      }
    });
    this.cd.markForCheck();
  }
  uniqueSelectedOptions(selectedValues) {
    const newSelectedOptions = [...this.selectedOptions];
    for (const visibleOption of this.visibleOptions) {
      if (!selectedValues.includes(visibleOption[this.fieldValue])) {
        newSelectedOptions.push(visibleOption);
      }
    }
    return newSelectedOptions;
  }
  static ɵfac = function PoMultiselectDropdownComponent_Factory(t) {
    return new (t || _PoMultiselectDropdownComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMultiselectDropdownComponent, selectors: [["po-multiselect-dropdown"]], viewQuery: function PoMultiselectDropdownComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$z, 7, ElementRef);
      ɵɵviewQuery(_c1$c, 7, ElementRef);
      ɵɵviewQuery(_c2$4, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.divElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listbox = _t.first);
    }
  }, inputs: { isServerSearching: [InputFlags.None, "p-searching", "isServerSearching"], hideSearch: [InputFlags.None, "p-hide-search", "hideSearch"], literals: [InputFlags.None, "p-literals", "literals"], placeholderSearch: [InputFlags.None, "p-placeholder-search", "placeholderSearch"], selectedOptions: [InputFlags.None, "p-selected-options", "selectedOptions"], options: [InputFlags.None, "p-options", "options"], visibleOptions: [InputFlags.None, "p-visible-options", "visibleOptions"], hideSelectAll: [InputFlags.None, "p-hide-select-all", "hideSelectAll"], fieldValue: [InputFlags.None, "p-field-value", "fieldValue"], fieldLabel: [InputFlags.None, "p-field-label", "fieldLabel"], multiselectTemplate: [InputFlags.None, "p-multiselect-template", "multiselectTemplate"] }, outputs: { changeSearch: "p-change-search", change: "p-change", closeDropdown: "p-close-dropdown" }, decls: 7, vars: 15, consts: [[1, "po-multiselect-container", 3, "hidden"], ["container", ""], [3, "scrollTop"], ["divElement", ""], ["p-type", "check", 3, "p-items", "p-selected-options", "p-checkboxAllValue", "p-field-value", "p-field-value-search", "p-field-label", "p-literal-search", "p-literals", "p-is-searching", "p-hide-search", "p-hide-select-all", "p-template", "p-placeholder-search", "p-change", "p-change-all", "p-change-search", "p-close"], ["listbox", ""]], template: function PoMultiselectDropdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1)(2, "div", 2, 3);
      ɵɵelementContainerStart(4);
      ɵɵelementStart(5, "po-listbox", 4, 5);
      ɵɵlistener("p-change", function PoMultiselectDropdownComponent_Template_po_listbox_p_change_5_listener($event) {
        return ctx.clickItem($event);
      })("p-change-all", function PoMultiselectDropdownComponent_Template_po_listbox_p_change_all_5_listener() {
        return ctx.onClickSelectAll();
      })("p-change-search", function PoMultiselectDropdownComponent_Template_po_listbox_p_change_search_5_listener($event) {
        return ctx.callChangeSearch($event);
      })("p-close", function PoMultiselectDropdownComponent_Template_po_listbox_p_close_5_listener() {
        return ctx.closeDropdown.emit();
      });
      ɵɵelementEnd();
      ɵɵelementContainerEnd();
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("hidden", !ctx.show);
      ɵɵadvance(2);
      ɵɵproperty("scrollTop", ctx.scrollTop);
      ɵɵadvance(3);
      ɵɵproperty("p-items", ctx.visibleOptions)("p-selected-options", ctx.selectedOptions)("p-checkboxAllValue", ctx.getStateSelectAll())("p-field-value", ctx.fieldValue)("p-field-value-search", ctx.fieldValue)("p-field-label", ctx.fieldLabel)("p-literal-search", ctx.literals)("p-literals", ctx.literals)("p-is-searching", ctx.isServerSearching)("p-hide-search", ctx.hideSearch)("p-hide-select-all", ctx.hideSelectAll)("p-template", ctx.multiselectTemplate)("p-placeholder-search", ctx.placeholderSearch);
    }
  }, dependencies: [PoListBoxComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMultiselectDropdownComponent, [{
    type: Component,
    args: [{ selector: "po-multiselect-dropdown", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div #container class="po-multiselect-container" [hidden]="!show">\n  <div [scrollTop]="scrollTop" #divElement>\n    <ng-container>\n      <po-listbox\n        #listbox\n        p-type="check"\n        [p-items]="visibleOptions"\n        [p-selected-options]="selectedOptions"\n        [p-checkboxAllValue]="getStateSelectAll()"\n        [p-field-value]="fieldValue"\n        [p-field-value-search]="fieldValue"\n        [p-field-label]="fieldLabel"\n        [p-literal-search]="literals"\n        [p-literals]="literals"\n        [p-is-searching]="isServerSearching"\n        [p-hide-search]="hideSearch"\n        [p-hide-select-all]="hideSelectAll"\n        [p-template]="multiselectTemplate"\n        [p-placeholder-search]="placeholderSearch"\n        (p-change)="clickItem($event)"\n        (p-change-all)="onClickSelectAll()"\n        (p-change-search)="callChangeSearch($event)"\n        (p-close)="closeDropdown.emit()"\n      >\n      </po-listbox>\n    </ng-container>\n  </div>\n</div>\n' }]
  }], () => [{ type: ChangeDetectorRef }], { isServerSearching: [{
    type: Input,
    args: ["p-searching"]
  }], hideSearch: [{
    type: Input,
    args: ["p-hide-search"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], placeholderSearch: [{
    type: Input,
    args: ["p-placeholder-search"]
  }], selectedOptions: [{
    type: Input,
    args: ["p-selected-options"]
  }], options: [{
    type: Input,
    args: ["p-options"]
  }], visibleOptions: [{
    type: Input,
    args: ["p-visible-options"]
  }], hideSelectAll: [{
    type: Input,
    args: ["p-hide-select-all"]
  }], fieldValue: [{
    type: Input,
    args: ["p-field-value"]
  }], fieldLabel: [{
    type: Input,
    args: ["p-field-label"]
  }], multiselectTemplate: [{
    type: Input,
    args: ["p-multiselect-template"]
  }], changeSearch: [{
    type: Output,
    args: ["p-change-search"]
  }], change: [{
    type: Output,
    args: ["p-change"]
  }], closeDropdown: [{
    type: Output,
    args: ["p-close-dropdown"]
  }], container: [{
    type: ViewChild,
    args: ["container", { read: ElementRef, static: true }]
  }], divElement: [{
    type: ViewChild,
    args: ["divElement", { read: ElementRef, static: true }]
  }], listbox: [{
    type: ViewChild,
    args: ["listbox"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMultiselectDropdownComponent, { className: "PoMultiselectDropdownComponent", filePath: "lib/components/po-field/po-multiselect/po-multiselect-dropdown/po-multiselect-dropdown.component.ts", lineNumber: 29 });
})();
var PoFieldModule = class _PoFieldModule {
  static ɵfac = function PoFieldModule_Factory(t) {
    return new (t || _PoFieldModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoFieldModule });
  static ɵinj = ɵɵdefineInjector({ imports: [
    CommonModule,
    FormsModule,
    FormsModule.withConfig({
      callSetDisabledState: "whenDisabledForLegacyCode"
    }),
    OverlayModule,
    PoButtonGroupModule,
    PoButtonModule,
    PoCleanModule,
    PoCalendarModule,
    PoCheckboxGroupModule,
    PoRadioGroupModule,
    PoContainerModule,
    PoDatepickerModule,
    PoDisclaimerGroupModule,
    PoDisclaimerModule,
    PoFieldContainerModule,
    PoLoadingModule,
    PoModalModule,
    PoProgressModule,
    PoServicesModule,
    PoTableModule,
    PoTooltipModule,
    PoIconModule,
    PoCheckboxModule,
    PoRadioModule,
    PoLabelModule,
    PoListBoxModule,
    PoSwitchModule,
    PoTagModule,
    PoCheckboxGroupModule,
    PoRadioGroupModule,
    PoCleanModule,
    PoDatepickerModule,
    PoFieldContainerModule,
    PoCheckboxModule,
    PoRadioModule,
    PoLabelModule,
    PoSwitchModule,
    PoTagModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoFieldModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        FormsModule,
        FormsModule.withConfig({
          callSetDisabledState: "whenDisabledForLegacyCode"
        }),
        OverlayModule,
        PoButtonGroupModule,
        PoButtonModule,
        PoCleanModule,
        PoCalendarModule,
        PoCheckboxGroupModule,
        PoRadioGroupModule,
        PoContainerModule,
        PoDatepickerModule,
        PoDisclaimerGroupModule,
        PoDisclaimerModule,
        PoFieldContainerModule,
        PoLoadingModule,
        PoModalModule,
        PoProgressModule,
        PoServicesModule,
        PoTableModule,
        PoTooltipModule,
        PoIconModule,
        PoCheckboxModule,
        PoRadioModule,
        PoLabelModule,
        PoListBoxModule,
        PoSwitchModule,
        PoTagModule
      ],
      exports: [
        PoCheckboxGroupModule,
        PoRadioGroupModule,
        PoCleanModule,
        PoDatepickerModule,
        PoComboComponent,
        PoComboOptionTemplateDirective,
        PoMultiselectOptionTemplateDirective,
        PoDecimalComponent,
        PoDatepickerRangeComponent,
        PoEmailComponent,
        PoFieldContainerModule,
        PoInputComponent,
        PoLoginComponent,
        PoLookupComponent,
        PoLookupModalComponent,
        PoMultiselectComponent,
        PoNumberComponent,
        PoPasswordComponent,
        PoRichTextComponent,
        PoSelectComponent,
        PoTextareaComponent,
        PoUploadComponent,
        PoUrlComponent,
        PoCheckboxModule,
        PoRadioModule,
        PoLabelModule,
        PoSwitchModule,
        PoTagModule
      ],
      declarations: [
        PoComboComponent,
        PoComboOptionTemplateDirective,
        PoMultiselectOptionTemplateDirective,
        PoDecimalComponent,
        PoDatepickerRangeComponent,
        PoEmailComponent,
        PoInputComponent,
        PoLoginComponent,
        PoLookupComponent,
        PoLookupModalComponent,
        PoMultiselectComponent,
        PoMultiselectDropdownComponent,
        PoNumberComponent,
        PoPasswordComponent,
        PoRichTextBodyComponent,
        PoRichTextComponent,
        PoRichTextImageModalComponent,
        PoRichTextLinkModalComponent,
        PoRichTextToolbarComponent,
        PoSelectComponent,
        PoTextareaComponent,
        PoUploadComponent,
        PoUploadDragDropComponent,
        PoUploadDragDropDirective,
        PoUploadDragDropAreaOverlayComponent,
        PoUploadDragDropAreaComponent,
        PoUploadFileRestrictionsComponent,
        PoUrlComponent
      ],
      providers: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoFieldModule, { declarations: [
    PoComboComponent,
    PoComboOptionTemplateDirective,
    PoMultiselectOptionTemplateDirective,
    PoDecimalComponent,
    PoDatepickerRangeComponent,
    PoEmailComponent,
    PoInputComponent,
    PoLoginComponent,
    PoLookupComponent,
    PoLookupModalComponent,
    PoMultiselectComponent,
    PoMultiselectDropdownComponent,
    PoNumberComponent,
    PoPasswordComponent,
    PoRichTextBodyComponent,
    PoRichTextComponent,
    PoRichTextImageModalComponent,
    PoRichTextLinkModalComponent,
    PoRichTextToolbarComponent,
    PoSelectComponent,
    PoTextareaComponent,
    PoUploadComponent,
    PoUploadDragDropComponent,
    PoUploadDragDropDirective,
    PoUploadDragDropAreaOverlayComponent,
    PoUploadDragDropAreaComponent,
    PoUploadFileRestrictionsComponent,
    PoUrlComponent
  ], imports: [
    CommonModule,
    FormsModule,
    FormsModule,
    OverlayModule,
    PoButtonGroupModule,
    PoButtonModule,
    PoCleanModule,
    PoCalendarModule,
    PoCheckboxGroupModule,
    PoRadioGroupModule,
    PoContainerModule,
    PoDatepickerModule,
    PoDisclaimerGroupModule,
    PoDisclaimerModule,
    PoFieldContainerModule,
    PoLoadingModule,
    PoModalModule,
    PoProgressModule,
    PoServicesModule,
    PoTableModule,
    PoTooltipModule,
    PoIconModule,
    PoCheckboxModule,
    PoRadioModule,
    PoLabelModule,
    PoListBoxModule,
    PoSwitchModule,
    PoTagModule
  ], exports: [
    PoCheckboxGroupModule,
    PoRadioGroupModule,
    PoCleanModule,
    PoDatepickerModule,
    PoComboComponent,
    PoComboOptionTemplateDirective,
    PoMultiselectOptionTemplateDirective,
    PoDecimalComponent,
    PoDatepickerRangeComponent,
    PoEmailComponent,
    PoFieldContainerModule,
    PoInputComponent,
    PoLoginComponent,
    PoLookupComponent,
    PoLookupModalComponent,
    PoMultiselectComponent,
    PoNumberComponent,
    PoPasswordComponent,
    PoRichTextComponent,
    PoSelectComponent,
    PoTextareaComponent,
    PoUploadComponent,
    PoUrlComponent,
    PoCheckboxModule,
    PoRadioModule,
    PoLabelModule,
    PoSwitchModule,
    PoTagModule
  ] });
})();
ɵɵsetComponentScope(PoLookupModalComponent, function() {
  return [NgIf, DefaultValueAccessor, NgControlStatus, NgModel, PoDisclaimerGroupComponent, PoFieldContainerComponent, PoModalComponent, PoTableComponent];
}, []);
ɵɵsetComponentScope(PoMultiselectComponent, function() {
  return [NgClass, NgForOf, NgIf, NgTemplateOutlet, CdkConnectedOverlay, CdkOverlayOrigin, PoFieldContainerBottomComponent, PoFieldContainerComponent, PoTagComponent, PoMultiselectDropdownComponent];
}, []);
var PoInfoOrientation;
(function(PoInfoOrientation2) {
  PoInfoOrientation2["Horizontal"] = "horizontal";
  PoInfoOrientation2["Vertical"] = "vertical";
})(PoInfoOrientation || (PoInfoOrientation = {}));
var poInfoOrientationDefault = PoInfoOrientation.Vertical;
var PoInfoBaseComponent = class _PoInfoBaseComponent {
  /** Valor do rótulo a ser exibido. */
  label;
  /**
   * Ao informar uma URL, o conteúdo será exibido na forma de um *link* e ao ser clicado será redirecionado para a URL informada.
   *
   * > Caso informar `http://` será aberto uma nova aba.
   * Caso informar um caminho relativo, exemplo: `/customers`, será aberto na aba atual.
   *
   */
  url;
  /** Valor do conteúdo a ser exibido. */
  value;
  poInfoOrientation = PoInfoOrientation;
  _labelSize;
  _orientation = poInfoOrientationDefault;
  /**
   * @optional
   *
   * @description
   *
   * Quantidade de [colunas](/guides/grid-system) usadas para a exibição da `p-label` quando o componente for
   * utilizado na orientação horizontal.
   *
   * Valores válidos:
   *  - `[1 .. 11]`
   *
   * > A propriedade `p-value` recebe o número de colunas restantes, por exemplo, se definido 3 colunas a mesma assume 9 colunas.
   */
  set labelSize(value) {
    if (isNaN(parseInt(value, 10))) {
      this._labelSize = void 0;
    } else {
      value = parseInt(value, 10);
      this._labelSize = value < 1 || value > 11 ? void 0 : value;
    }
  }
  get labelSize() {
    return this._labelSize;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o layout de exibição.
   *
   * > Quando definido na horizontal, pode-se utilizar a propriedade `p-label-size` para um maior controle das informações exibidas.
   *
   * @default `vertical`
   */
  set orientation(value) {
    this._orientation = Object.values(PoInfoOrientation).includes(value) ? value : poInfoOrientationDefault;
  }
  get orientation() {
    return this._orientation;
  }
  static ɵfac = function PoInfoBaseComponent_Factory(t) {
    return new (t || _PoInfoBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoInfoBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], url: [InputFlags.None, "p-url", "url"], value: [InputFlags.None, "p-value", "value"], labelSize: [InputFlags.None, "p-label-size", "labelSize"], orientation: [InputFlags.None, "p-orientation", "orientation"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInfoBaseComponent, [{
    type: Directive
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], url: [{
    type: Input,
    args: ["p-url"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], labelSize: [{
    type: Input,
    args: ["p-label-size"]
  }], orientation: [{
    type: Input,
    args: ["p-orientation"]
  }] });
})();
function PoInfoComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoInfoComponent_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoInfoComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoInfoComponent_ng_template_6_ng_container_0_Template, 1, 0, "ng-container", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const _r6 = ɵɵreference(11);
    const _r8 = ɵɵreference(13);
    ɵɵproperty("ngIf", ctx_r1.isExternalLink)("ngIfThen", _r6)("ngIfElse", _r8);
  }
}
function PoInfoComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.value);
  }
}
function PoInfoComponent_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("href", ctx_r5.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r5.value);
  }
}
function PoInfoComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext();
    ɵɵproperty("routerLink", ctx_r7.url);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r7.value);
  }
}
var PoInfoComponent = class _PoInfoComponent extends PoInfoBaseComponent {
  get isExternalLink() {
    return isExternalLink(this.url);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoInfoComponent_BaseFactory;
    return function PoInfoComponent_Factory(t) {
      return (ɵPoInfoComponent_BaseFactory || (ɵPoInfoComponent_BaseFactory = ɵɵgetInheritedFactory(_PoInfoComponent)))(t || _PoInfoComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoInfoComponent, selectors: [["po-info"]], features: [ɵɵInheritDefinitionFeature], decls: 14, vars: 16, consts: [[1, "po-info"], [1, "po-info-container-title", 3, "ngClass"], [1, "po-info-label"], [3, "ngClass"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["infoLink", ""], ["infoValue", ""], ["externalLink", ""], ["internalLink", ""], [1, "po-info-value"], ["target", "_blank", 1, "po-info-value", "po-info-link", 3, "href"], [1, "po-info-value", "po-info-link", 3, "routerLink"]], template: function PoInfoComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd()();
      ɵɵelementStart(4, "div", 3);
      ɵɵtemplate(5, PoInfoComponent_ng_container_5_Template, 1, 0, "ng-container", 4);
      ɵɵelementEnd()();
      ɵɵtemplate(6, PoInfoComponent_ng_template_6_Template, 1, 3, "ng-template", null, 5, ɵɵtemplateRefExtractor)(8, PoInfoComponent_ng_template_8_Template, 2, 1, "ng-template", null, 6, ɵɵtemplateRefExtractor)(10, PoInfoComponent_ng_template_10_Template, 2, 2, "ng-template", null, 7, ɵɵtemplateRefExtractor)(12, PoInfoComponent_ng_template_12_Template, 2, 2, "ng-template", null, 8, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(7);
      const _r4 = ɵɵreference(9);
      ɵɵclassProp("po-row", ctx.orientation === ctx.poInfoOrientation.Horizontal && ctx.labelSize);
      ɵɵadvance();
      ɵɵclassProp("po-info-label-horizontal", ctx.orientation === ctx.poInfoOrientation.Horizontal)("po-text-nowrap", ctx.orientation === ctx.poInfoOrientation.Horizontal && !ctx.labelSize);
      ɵɵproperty("ngClass", ctx.labelSize && ctx.orientation === ctx.poInfoOrientation.Horizontal ? "po-sm-" + ctx.labelSize : "");
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.orientation === ctx.poInfoOrientation.Horizontal ? ctx.label + ":" : ctx.label, " ");
      ɵɵadvance();
      ɵɵclassProp("po-info-container-content", ctx.orientation !== ctx.poInfoOrientation.Horizontal)("po-info-value-horizontal", ctx.orientation === ctx.poInfoOrientation.Horizontal);
      ɵɵproperty("ngClass", ctx.labelSize && ctx.orientation === ctx.poInfoOrientation.Horizontal ? "po-sm-" + (12 - ctx.labelSize) : "");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.url)("ngIfThen", _r2)("ngIfElse", _r4);
    }
  }, dependencies: [NgClass, NgIf, RouterLink], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInfoComponent, [{
    type: Component,
    args: [{ selector: "po-info", changeDetection: ChangeDetectionStrategy.OnPush, template: `<div class="po-info" [class.po-row]="orientation === poInfoOrientation.Horizontal && labelSize">
  <div
    class="po-info-container-title"
    [ngClass]="labelSize && orientation === poInfoOrientation.Horizontal ? 'po-sm-' + labelSize : ''"
    [class.po-info-label-horizontal]="orientation === poInfoOrientation.Horizontal"
    [class.po-text-nowrap]="orientation === poInfoOrientation.Horizontal && !labelSize"
  >
    <span class="po-info-label">
      {{ orientation === poInfoOrientation.Horizontal ? label + ':' : label }}
    </span>
  </div>

  <div
    [ngClass]="labelSize && orientation === poInfoOrientation.Horizontal ? 'po-sm-' + (12 - labelSize) : ''"
    [class.po-info-container-content]="orientation !== poInfoOrientation.Horizontal"
    [class.po-info-value-horizontal]="orientation === poInfoOrientation.Horizontal"
  >
    <ng-container *ngIf="url; then infoLink; else infoValue"></ng-container>
  </div>
</div>

<ng-template #infoLink>
  <ng-container *ngIf="isExternalLink; then externalLink; else internalLink"> </ng-container>
</ng-template>

<ng-template #infoValue>
  <span class="po-info-value">{{ value }}</span>
</ng-template>

<ng-template #externalLink>
  <a class="po-info-value po-info-link" [href]="url" target="_blank">{{ value }}</a>
</ng-template>

<ng-template #internalLink>
  <a class="po-info-value po-info-link" [routerLink]="url">{{ value }}</a>
</ng-template>
` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoInfoComponent, { className: "PoInfoComponent", filePath: "lib/components/po-info/po-info.component.ts", lineNumber: 32 });
})();
var PoInfoModule = class _PoInfoModule {
  static ɵfac = function PoInfoModule_Factory(t) {
    return new (t || _PoInfoModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoInfoModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInfoModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: [PoInfoComponent],
      exports: [PoInfoComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoInfoModule, { declarations: [PoInfoComponent], imports: [CommonModule, RouterModule], exports: [PoInfoComponent] });
})();
function getGridColumnsClasses(gridColumns, offsetColumns, grid, offset, pull) {
  const systemGrid = {
    gridSm: grid?.smGrid || gridColumns || 12,
    gridMd: grid?.mdGrid || gridColumns || 6,
    gridLg: grid?.lgGrid || gridColumns || 4,
    gridXl: grid?.xlGrid || gridColumns || 3,
    offsetSm: offset?.smOffset || offsetColumns || 0,
    offsetMd: offset?.mdOffset || offsetColumns || 0,
    offsetLg: offset?.lgOffset || offsetColumns || 0,
    offsetXl: offset?.xlOffset || offsetColumns || 0,
    pullSm: pull?.smPull || 0,
    pullMd: pull?.mdPull || 0,
    pullLg: pull?.lgPull || 0,
    pullXl: pull?.xlPull || 0
  };
  return `po-sm-${systemGrid.gridSm} po-offset-sm-${systemGrid.offsetSm} po-pull-sm-${systemGrid.pullSm} po-md-${systemGrid.gridMd} po-offset-md-${systemGrid.offsetMd} po-pull-md-${systemGrid.pullMd} po-lg-${systemGrid.gridLg} po-offset-lg-${systemGrid.offsetLg} po-pull-lg-${systemGrid.pullLg} po-xl-${systemGrid.gridXl} po-offset-xl-${systemGrid.offsetXl} po-pull-xl-${systemGrid.pullXl}`;
}
function isVisibleField(field) {
  const containsVisible = "visible" in field;
  return containsVisible ? field.visible : true;
}
var PoDynamicFieldType;
(function(PoDynamicFieldType2) {
  PoDynamicFieldType2["Boolean"] = "boolean";
  PoDynamicFieldType2["Currency"] = "currency";
  PoDynamicFieldType2["Decimal"] = "decimal";
  PoDynamicFieldType2["Date"] = "date";
  PoDynamicFieldType2["DateTime"] = "datetime";
  PoDynamicFieldType2["Time"] = "time";
  PoDynamicFieldType2["Number"] = "number";
  PoDynamicFieldType2["String"] = "string";
  PoDynamicFieldType2["Upload"] = "upload";
})(PoDynamicFieldType || (PoDynamicFieldType = {}));
var PoDynamicFormFieldsBaseComponent = class _PoDynamicFormFieldsBaseComponent {
  titleCasePipe;
  autoFocus;
  disabledForm;
  validate;
  formValidate = new EventEmitter();
  fieldsChange = new EventEmitter();
  // Evento disparado se existir optionsService em visibleField. Necessário resgatar referência do objeto selecionado para quando se tratar de recebimento de opções via serviço.
  objectValue = new EventEmitter();
  validateOnInput;
  visibleFields = [];
  _fields;
  _validateFields;
  _value = {};
  // array de objetos que implementam a interface PoDynamicFormField, que serão exibidos no componente.
  set fields(value) {
    this._fields = Array.isArray(value) ? [...value] : [];
  }
  get fields() {
    return this._fields;
  }
  // valor que será utilizado para iniciar valor no componente.
  set value(value) {
    this._value = value && isTypeof(value, "object") ? value : {};
  }
  get value() {
    return this._value;
  }
  set validateFields(value) {
    this._validateFields = Array.isArray(value) ? [...value] : [];
  }
  get validateFields() {
    return this._validateFields;
  }
  constructor(titleCasePipe) {
    this.titleCasePipe = titleCasePipe;
  }
  compareTo(value, compareTo) {
    return value === compareTo;
  }
  // retorna um array com os objetos configurados e visíveis.
  getVisibleFields() {
    const visibleFields = [];
    this.fields.forEach((field) => {
      if (this.existsProperty(visibleFields, field.property)) {
        this.printError(`"po-dynamic-form" property "${field.property}" está duplicado. Interface: PoDynamicFormField.`);
        return;
      }
      if (!field["property"]) {
        this.printError('"po-dynamic-form" É obrigatório ser especificado um property.');
        return;
      }
      if (isVisibleField(field)) {
        visibleFields.push(this.createField(field));
      }
    });
    return sortFields(visibleFields);
  }
  // converte um array em string para um array de objetos que contem label e value.
  convertOptions(options) {
    const everyOptionString = options.every((option) => typeof option === "string");
    if (everyOptionString) {
      return options.map((value) => ({ label: value, value }));
    }
    return options;
  }
  // cria um novo objeto com as classes de grid system, com control (tipo do componente) e label default.
  createField(field) {
    const control = this.getComponentControl(field);
    const options = !!field.options ? this.convertOptions(field.options) : void 0;
    const focus = this.hasFocus(field);
    const type = field && field.type ? field.type.toLocaleLowerCase() : "string";
    const componentClass = getGridColumnsClasses(field.gridColumns, field.offsetColumns, {
      smGrid: field.gridSmColumns,
      mdGrid: field.gridMdColumns,
      lgGrid: field.gridLgColumns,
      xlGrid: field.gridXlColumns
    }, {
      smOffset: field.offsetSmColumns,
      mdOffset: field.offsetMdColumns,
      lgOffset: field.offsetLgColumns,
      xlOffset: field.offsetXlColumns
    }, {
      smPull: field.gridSmPull,
      mdPull: field.gridMdPull,
      lgPull: field.gridLgPull,
      xlPull: field.gridXlPull
    });
    return __spreadProps(__spreadValues({
      label: this.titleCasePipe.transform(field.property),
      maskFormatModel: this.compareTo(type, PoDynamicFieldType.Time)
    }, field), {
      componentClass,
      control,
      focus,
      options
    });
  }
  existsProperty(fields, property) {
    return fields.some((field) => field.property === property);
  }
  // recupera o componente de acordo com algumas regras do field.
  getComponentControl(field = {}) {
    const type = field && field.type ? field.type.toLocaleLowerCase() : "string";
    const { forceBooleanComponentType } = field;
    const forceOptionComponent = this.verifyForceOptionComponent(field);
    if (forceBooleanComponentType) {
      return forceBooleanComponentType;
    }
    if (forceOptionComponent) {
      const { forceOptionsComponentType } = field;
      return forceOptionsComponentType;
    }
    if (this.isNumberType(field, type)) {
      return "number";
    } else if (this.isCurrencyType(field, type) || type === PoDynamicFieldType.Decimal) {
      return "decimal";
    } else if (this.isSelect(field)) {
      return "select";
    } else if (this.isRadioGroup(field)) {
      return "radioGroup";
    } else if (this.isCheckboxGroup(field)) {
      return "checkboxGroup";
    } else if (this.isMultiselect(field)) {
      return "multiselect";
    } else if (this.compareTo(type, PoDynamicFieldType.Boolean)) {
      return "switch";
    } else if (this.compareTo(type, PoDynamicFieldType.Date) || this.compareTo(type, PoDynamicFieldType.DateTime)) {
      return field.range ? "datepickerrange" : "datepicker";
    } else if (this.compareTo(type, PoDynamicFieldType.Time)) {
      field.mask = field.mask || "99:99";
      return "input";
    } else if (this.isCombo(field)) {
      return "combo";
    } else if (this.isLookup(field)) {
      return "lookup";
    } else if (this.isTextarea(field)) {
      return "textarea";
    } else if (this.isPassword(field)) {
      return "password";
    } else if (this.isUpload(field)) {
      return "upload";
    }
    return "input";
  }
  hasFocus(field) {
    return !!this.autoFocus && this.autoFocus === field.property;
  }
  isCheckboxGroup(field) {
    const { optionsService, optionsMulti, options } = field;
    return !optionsService && optionsMulti && !!options && options.length <= 3;
  }
  isCombo(field) {
    const { optionsService } = field;
    return !!optionsService && (isTypeof(optionsService, "string") || this.isComboFilter(optionsService));
  }
  isCurrencyType(field, type) {
    const { mask, pattern } = field;
    return this.compareTo(type, PoDynamicFieldType.Currency) && !mask && !pattern;
  }
  isLookupFilter(object) {
    return object && object.getObjectByValue !== void 0;
  }
  isComboFilter(object) {
    return object && object.getFilteredData !== void 0;
  }
  isLookup(field) {
    const { searchService } = field;
    return !!searchService && (isTypeof(searchService, "string") || this.isLookupFilter(searchService));
  }
  isMultiselect(field) {
    const { optionsService, optionsMulti, options } = field;
    return optionsMulti && (!!optionsService || !!options && options.length > 3);
  }
  isNumberType(field, type) {
    const { mask, pattern } = field;
    return this.compareTo(type, PoDynamicFieldType.Number) && !mask && !pattern;
  }
  isPassword(field) {
    const { secret } = field;
    return secret;
  }
  isRadioGroup(field) {
    const { optionsMulti, options } = field;
    return !optionsMulti && !!options && options.length <= 3;
  }
  isUpload(field) {
    const { url, type } = field;
    return url && type === "upload";
  }
  verifyForceOptionComponent(field) {
    const { optionsMulti, optionsService, forceOptionsComponentType } = field;
    if (forceOptionsComponentType && !optionsMulti && !optionsService) {
      return true;
    }
    return false;
  }
  isSelect(field) {
    const { optionsMulti, options } = field;
    return !optionsMulti && !!options && options.length > 3;
  }
  isTextarea(field) {
    const { rows } = field;
    return rows && rows >= 3;
  }
  printError(error) {
    console.error(error);
  }
  static ɵfac = function PoDynamicFormFieldsBaseComponent_Factory(t) {
    return new (t || _PoDynamicFormFieldsBaseComponent)(ɵɵdirectiveInject(TitleCasePipe));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDynamicFormFieldsBaseComponent, inputs: { autoFocus: [InputFlags.None, "p-auto-focus", "autoFocus"], disabledForm: [InputFlags.None, "p-disabled-form", "disabledForm"], validate: [InputFlags.None, "p-validate", "validate"], validateOnInput: [InputFlags.None, "p-validate-on-input", "validateOnInput"], fields: [InputFlags.None, "p-fields", "fields"], value: [InputFlags.None, "p-value", "value"], validateFields: [InputFlags.None, "p-validate-fields", "validateFields"] }, outputs: { formValidate: "p-form-validate", fieldsChange: "p-fieldsChange", objectValue: "p-object-value" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormFieldsBaseComponent, [{
    type: Directive
  }], () => [{ type: TitleCasePipe }], { autoFocus: [{
    type: Input,
    args: ["p-auto-focus"]
  }], disabledForm: [{
    type: Input,
    args: ["p-disabled-form"]
  }], validate: [{
    type: Input,
    args: ["p-validate"]
  }], formValidate: [{
    type: Output,
    args: ["p-form-validate"]
  }], fieldsChange: [{
    type: Output,
    args: ["p-fieldsChange"]
  }], objectValue: [{
    type: Output,
    args: ["p-object-value"]
  }], validateOnInput: [{
    type: Input,
    args: ["p-validate-on-input"]
  }], fields: [{
    type: Input,
    args: ["p-fields"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], validateFields: [{
    type: Input,
    args: ["p-validate-fields"]
  }] });
})();
var _c0$y = ["component"];
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_divider_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-divider", 19);
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("p-label", field_r2.divider);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-datepicker", 20, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_2_Template_po_datepicker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r23);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r22 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r22.value[field_r2.property], $event) || (ctx_r22.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_2_Template_po_datepicker_p_change_0_listener() {
      ɵɵrestoreView(_r23);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r25 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r25.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r4.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-disabled", ctx_r4.isDisabled(field_r2))("p-error-pattern", field_r2.errorMessage)("p-auto-focus", field_r2.focus)("p-format", field_r2.format)("p-help", field_r2.help)("p-iso-format", field_r2.isoFormat)("p-label", field_r2.label)("p-locale", field_r2.locale)("p-max-date", field_r2.maxValue)("p-min-date", field_r2.minValue)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-readonly", field_r2.readonly)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-placeholder", field_r2.placeholder);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_range_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-datepicker-range", 22, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_range_3_Template_po_datepicker_range_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r30);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r29 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r29.value[field_r2.property], $event) || (ctx_r29.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_range_3_Template_po_datepicker_range_p_change_0_listener() {
      ɵɵrestoreView(_r30);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r32 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r32.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r5.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-disabled", ctx_r5.isDisabled(field_r2))("p-auto-focus", field_r2.focus)("p-help", field_r2.help)("p-label", field_r2.label)("p-literals", field_r2.literals)("p-max-date", field_r2.maxValue)("p-min-date", field_r2.minValue)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-readonly", field_r2.readonly)("p-required", field_r2.required)("p-show-required", field_r2.showRequired);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_input_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-input", 23, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_input_4_Template_po_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r37);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r36 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r36.value[field_r2.property], $event) || (ctx_r36.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_input_4_Template_po_input_p_change_0_listener() {
      ɵɵrestoreView(_r37);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r39 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r39.onChangeField(field_r2));
    })("p-change-model", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_input_4_Template_po_input_p_change_model_0_listener() {
      ɵɵrestoreView(_r37);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r41 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r41.onChangeFieldModel(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r6.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-disabled", ctx_r6.isDisabled(field_r2))("p-error-pattern", field_r2.errorMessage)("p-auto-focus", field_r2.focus)("p-help", field_r2.help)("p-label", field_r2.label)("p-mask-format-model", field_r2.maskFormatModel)("p-mask", field_r2.mask)("p-maxlength", field_r2.maxLength)("p-minlength", field_r2.minLength)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-pattern", field_r2.pattern)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-icon", field_r2.icon)("p-placeholder", field_r2.placeholder)("p-readonly", field_r2.readonly);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_number_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r46 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-number", 24, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_number_5_Template_po_number_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r46);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r45 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r45.value[field_r2.property], $event) || (ctx_r45.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_number_5_Template_po_number_p_change_0_listener() {
      ɵɵrestoreView(_r46);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r48 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r48.onChangeField(field_r2));
    })("p-change-model", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_number_5_Template_po_number_p_change_model_0_listener() {
      ɵɵrestoreView(_r46);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r50 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r50.onChangeFieldModel(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r7.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-disabled", ctx_r7.isDisabled(field_r2))("p-error-pattern", field_r2.errorMessage)("p-auto-focus", field_r2.focus)("p-help", field_r2.help)("p-label", field_r2.label)("p-min", field_r2.minValue)("p-max", field_r2.maxValue)("p-maxlength", field_r2.maxLength)("p-minlength", field_r2.minLength)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-step", field_r2.step)("p-readonly", field_r2.readonly)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-icon", field_r2.icon)("p-placeholder", field_r2.placeholder);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_decimal_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r55 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-decimal", 25, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_decimal_6_Template_po_decimal_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r55);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r54 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r54.value[field_r2.property], $event) || (ctx_r54.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_decimal_6_Template_po_decimal_p_change_0_listener() {
      ɵɵrestoreView(_r55);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r57 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r57.onChangeField(field_r2));
    })("p-change-model", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_decimal_6_Template_po_decimal_p_change_model_0_listener() {
      ɵɵrestoreView(_r55);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r59 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r59.onChangeFieldModel(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r8.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-error-pattern", field_r2.errorMessage)("p-disabled", ctx_r8.isDisabled(field_r2))("p-decimals-length", field_r2.decimalsLength)("p-thousand-maxlength", field_r2.thousandMaxlength)("p-icon", field_r2.icon)("p-auto-focus", field_r2.focus)("p-help", field_r2.help)("p-label", field_r2.label)("p-locale", field_r2.locale)("p-min", field_r2.minValue)("p-max", field_r2.maxValue)("p-maxlength", field_r2.maxLength)("p-minlength", field_r2.minLength)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-readonly", field_r2.readonly)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-placeholder", field_r2.placeholder);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_select_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r64 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-select", 26, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_select_7_Template_po_select_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r64);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r63 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r63.value[field_r2.property], $event) || (ctx_r63.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_select_7_Template_po_select_p_change_0_listener() {
      ɵɵrestoreView(_r64);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r66 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r66.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r9 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r9.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-field-label", field_r2.fieldLabel)("p-field-value", field_r2.fieldValue)("p-disabled", ctx_r9.isDisabled(field_r2))("p-help", field_r2.help)("p-label", field_r2.label)("p-optional", field_r2.optional)("p-options", field_r2.options)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-placeholder", field_r2.placeholder)("p-readonly", field_r2.readonly);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_radio_group_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r71 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-radio-group", 27, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_radio_group_8_Template_po_radio_group_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r71);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r70 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r70.value[field_r2.property], $event) || (ctx_r70.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_radio_group_8_Template_po_radio_group_p_change_0_listener() {
      ɵɵrestoreView(_r71);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r73 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r73.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r10 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r10.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-columns", field_r2.columns || 3)("p-auto-focus", field_r2.focus)("p-disabled", ctx_r10.isDisabled(field_r2))("p-help", field_r2.help)("p-label", field_r2.label)("p-optional", field_r2.optional)("p-options", field_r2.options)("p-required", field_r2.required)("p-show-required", field_r2.showRequired);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_switch_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r78 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-switch", 28, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_switch_9_Template_po_switch_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r78);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r77 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r77.value[field_r2.property], $event) || (ctx_r77.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_switch_9_Template_po_switch_p_change_0_listener() {
      ɵɵrestoreView(_r78);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r80 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r80.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r11 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r11.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-disabled", ctx_r11.isDisabled(field_r2))("p-format-model", field_r2.formatModel)("p-help", field_r2.help)("p-label", field_r2.label)("p-label-off", field_r2.booleanFalse)("p-label-on", field_r2.booleanTrue)("p-label-position", field_r2.labelPosition);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r85 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 29, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_10_Template_po_checkbox_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r85);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r84 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r84.value[field_r2.property], $event) || (ctx_r84.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_10_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r85);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r87 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r87.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r12 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r12.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-auto-focus", field_r2.focus)("p-disabled", ctx_r12.isDisabled(field_r2))("p-label", field_r2.label)("p-size", field_r2.size);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_combo_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r92 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-combo", 30, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_combo_11_Template_po_combo_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r92);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r91 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r91.value[field_r2.property], $event) || (ctx_r91.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_combo_11_Template_po_combo_p_change_0_listener($event) {
      ɵɵrestoreView(_r92);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r94 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r94.onChangeField(field_r2, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r13 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r13.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-auto-focus", field_r2.focus)("p-clean", field_r2.clean)("p-disabled", ctx_r13.isDisabled(field_r2))("p-field-label", field_r2.fieldLabel)("p-field-value", field_r2.fieldValue)("p-filter-params", field_r2.params)("p-filter-service", field_r2.optionsService)("p-help", field_r2.help)("p-infinite-scroll", field_r2.infiniteScroll)("p-infinite-scroll-distance", field_r2.infiniteScrollDistance || 100)("p-label", field_r2.label)("p-literals", field_r2.literals)("p-options", field_r2.options)("p-optional", field_r2.optional)("p-sort", field_r2.sort)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-icon", field_r2.icon)("p-placeholder", field_r2.placeholder)("p-filter-minlength", field_r2.filterMinlength)("p-filter-mode", field_r2.filterMode)("p-disabled-init-filter", field_r2.disabledInitFilter)("p-disabled-tab-filter", field_r2.disabledTabFilter)("p-debounce-time", field_r2.debounceTime)("p-change-on-enter", field_r2.changeOnEnter);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_lookup_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r99 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-lookup", 31, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_lookup_12_Template_po_lookup_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r99);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r98 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r98.value[field_r2.property], $event) || (ctx_r98.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_lookup_12_Template_po_lookup_p_change_0_listener() {
      ɵɵrestoreView(_r99);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r101 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r101.onChangeField(field_r2));
    })("p-change-visible-columns", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_lookup_12_Template_po_lookup_p_change_visible_columns_0_listener($event) {
      ɵɵrestoreView(_r99);
      const field_r2 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r2.changeVisibleColumns == null ? null : field_r2.changeVisibleColumns($event));
    })("p-restore-column-manager", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_lookup_12_Template_po_lookup_p_restore_column_manager_0_listener($event) {
      ɵɵrestoreView(_r99);
      const field_r2 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r2.columnRestoreManager == null ? null : field_r2.columnRestoreManager($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r14 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r14.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-columns", field_r2.columns)("p-disabled", ctx_r14.isDisabled(field_r2))("p-field-label", field_r2.fieldLabel || "label")("p-field-value", field_r2.fieldValue || "value")("p-filter-params", field_r2.params)("p-filter-service", field_r2.searchService)("p-auto-focus", field_r2.focus)("p-auto-height", field_r2.autoHeight)("p-help", field_r2.help)("p-field-format", field_r2.format)("p-infinite-scroll", field_r2.infiniteScroll)("p-label", field_r2.label)("p-literals", field_r2.literals)("p-multiple", field_r2.multiple)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-placeholder", field_r2.placeholder)("p-advanced-filters", field_r2.advancedFilters);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_group_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r110 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox-group", 27, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_group_13_Template_po_checkbox_group_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r110);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r109 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r109.value[field_r2.property], $event) || (ctx_r109.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_group_13_Template_po_checkbox_group_p_change_0_listener() {
      ɵɵrestoreView(_r110);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r112 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r112.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r15 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r15.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-columns", field_r2.columns || 3)("p-auto-focus", field_r2.focus)("p-disabled", ctx_r15.isDisabled(field_r2))("p-help", field_r2.help)("p-label", field_r2.label)("p-optional", field_r2.optional)("p-options", field_r2.options)("p-required", field_r2.required)("p-show-required", field_r2.showRequired);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_multiselect_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r117 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-multiselect", 32, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_multiselect_14_Template_po_multiselect_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r117);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r116 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r116.value[field_r2.property], $event) || (ctx_r116.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_multiselect_14_Template_po_multiselect_p_change_0_listener() {
      ɵɵrestoreView(_r117);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r119 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r119.onChangeField(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r16 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r16.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-disabled", ctx_r16.isDisabled(field_r2))("p-auto-focus", field_r2.focus)("p-auto-height", field_r2.autoHeight)("p-help", field_r2.help)("p-label", field_r2.label)("p-literals", field_r2.literals)("p-optional", field_r2.optional)("p-options", field_r2.options)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-placeholder", field_r2.placeholder)("p-field-label", field_r2.fieldLabel)("p-field-value", field_r2.fieldValue)("p-filter-service", field_r2.optionsService)("p-filter-mode", field_r2.filterMode)("p-debounce-time", field_r2.debounceTime)("p-sort", field_r2.sort)("p-placeholder-search", field_r2.placeholderSearch)("p-hide-search", field_r2.hideSearch)("p-hide-select-all", field_r2.hideSelectAll);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_textarea_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r124 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-textarea", 33, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_textarea_15_Template_po_textarea_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r124);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r123 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r123.value[field_r2.property], $event) || (ctx_r123.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_textarea_15_Template_po_textarea_p_change_0_listener() {
      ɵɵrestoreView(_r124);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r126 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r126.onChangeField(field_r2));
    })("p-change-model", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_textarea_15_Template_po_textarea_p_change_model_0_listener() {
      ɵɵrestoreView(_r124);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r128 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r128.onChangeFieldModel(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r17 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r17.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-disabled", ctx_r17.isDisabled(field_r2))("p-auto-focus", field_r2.focus)("p-help", field_r2.help)("p-label", field_r2.label)("p-maxlength", field_r2.maxLength)("p-minlength", field_r2.minLength)("p-optional", field_r2.optional)("p-readonly", field_r2.readonly)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-rows", field_r2.rows)("p-placeholder", field_r2.placeholder);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_password_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r133 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-password", 34, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_password_16_Template_po_password_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r133);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r132 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r132.value[field_r2.property], $event) || (ctx_r132.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_password_16_Template_po_password_p_change_0_listener() {
      ɵɵrestoreView(_r133);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r135 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r135.onChangeField(field_r2));
    })("p-change-model", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_password_16_Template_po_password_p_change_model_0_listener() {
      ɵɵrestoreView(_r133);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r137 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r137.onChangeFieldModel(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r18 = ɵɵnextContext(2);
    ɵɵproperty("name", field_r2.property);
    ɵɵtwoWayProperty("ngModel", ctx_r18.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-clean", field_r2.clean)("p-disabled", ctx_r18.isDisabled(field_r2))("p-error-pattern", field_r2.errorMessage)("p-auto-focus", field_r2.focus)("p-help", field_r2.help)("p-hide-password-peek", field_r2.hidePasswordPeek)("p-icon", field_r2.icon)("p-label", field_r2.label)("p-maxlength", field_r2.maxLength)("p-minlength", field_r2.minLength)("p-no-autocomplete", field_r2.noAutocomplete)("p-optional", field_r2.optional)("p-pattern", field_r2.pattern)("p-readonly", field_r2.readonly)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-placeholder", field_r2.placeholder);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r142 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-upload", 35, 21);
    ɵɵtwoWayListener("ngModelChange", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template_po_upload_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r142);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r141 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r141.value[field_r2.property], $event) || (ctx_r141.value[field_r2.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-error", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template_po_upload_p_error_0_listener($event) {
      ɵɵrestoreView(_r142);
      const field_r2 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r2.onError($event));
    })("p-success", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template_po_upload_p_success_0_listener($event) {
      ɵɵrestoreView(_r142);
      const field_r2 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r2.onSuccess($event));
    })("p-upload", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template_po_upload_p_upload_0_listener($event) {
      ɵɵrestoreView(_r142);
      const field_r2 = ɵɵnextContext().$implicit;
      return ɵɵresetView(field_r2.onUpload($event));
    })("p-change", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template_po_upload_p_change_0_listener() {
      ɵɵrestoreView(_r142);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r150 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r150.onChangeField(field_r2));
    })("p-change-model", function PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template_po_upload_p_change_model_0_listener() {
      ɵɵrestoreView(_r142);
      const field_r2 = ɵɵnextContext().$implicit;
      const ctx_r152 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r152.onChangeFieldModel(field_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const field_r2 = ɵɵnextContext().$implicit;
    const ctx_r19 = ɵɵnextContext(2);
    ɵɵtwoWayProperty("ngModel", ctx_r19.value[field_r2.property]);
    ɵɵproperty("ngClass", field_r2.componentClass)("p-auto-upload", field_r2.autoUpload)("p-directory", field_r2.directory)("p-disabled", ctx_r19.isDisabled(field_r2))("p-drag-drop", field_r2.dragDrop)("p-drag-drop-height", field_r2.dragDropHeight)("p-restrictions", field_r2.restrictions)("p-form-field", field_r2.formField)("p-headers", field_r2.headers)("p-help", field_r2.help)("p-hide-restrictions-info", field_r2.hideRestrictionsInfo)("p-hide-select-button", field_r2.hideSelectButton)("p-hide-send-button", field_r2.hideSendButton)("p-multiple", field_r2.multiple)("p-label", field_r2.label)("p-literals", field_r2.literals)("name", field_r2.property)("p-optional", field_r2.optional)("p-required", field_r2.required)("p-show-required", field_r2.showRequired)("p-url", field_r2.url);
  }
}
function PoDynamicFormFieldsComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_divider_1_Template, 1, 1, "po-divider", 3)(2, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_2_Template, 2, 20, "po-datepicker", 4)(3, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_datepicker_range_3_Template, 2, 16, "po-datepicker-range", 5)(4, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_input_4_Template, 2, 21, "po-input", 6)(5, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_number_5_Template, 2, 21, "po-number", 7)(6, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_decimal_6_Template, 2, 23, "po-decimal", 8)(7, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_select_7_Template, 2, 14, "po-select", 9)(8, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_radio_group_8_Template, 2, 12, "po-radio-group", 10)(9, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_switch_9_Template, 2, 10, "po-switch", 11)(10, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_10_Template, 2, 7, "po-checkbox", 12)(11, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_combo_11_Template, 2, 28, "po-combo", 13)(12, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_lookup_12_Template, 2, 24, "po-lookup", 14)(13, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_checkbox_group_13_Template, 2, 12, "po-checkbox-group", 10)(14, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_multiselect_14_Template, 2, 23, "po-multiselect", 15)(15, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_textarea_15_Template, 2, 15, "po-textarea", 16)(16, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_password_16_Template, 2, 20, "po-password", 17)(17, PoDynamicFormFieldsComponent_div_0_ng_container_1_po_upload_17_Template, 2, 22, "po-upload", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const field_r2 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", field_r2 == null ? null : field_r2.divider == null ? null : field_r2.divider.trim());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "datepicker"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "datepickerrange"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "input"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "number"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "decimal"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "select"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "radioGroup"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "switch"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "checkbox"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "combo"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "lookup"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "checkboxGroup"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "multiselect"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "textarea"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "password"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.compareTo(field_r2.control, "upload"));
  }
}
function PoDynamicFormFieldsComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtemplate(1, PoDynamicFormFieldsComponent_div_0_ng_container_1_Template, 18, 17, "ng-container", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.visibleFields)("ngForTrackBy", ctx_r0.trackBy);
  }
}
var PoDynamicFormFieldsComponent = class _PoDynamicFormFieldsComponent extends PoDynamicFormFieldsBaseComponent {
  validationService;
  changes;
  form;
  components;
  previousValue = {};
  constructor(titleCasePipe, validationService, changes, form) {
    super(titleCasePipe);
    this.validationService = validationService;
    this.changes = changes;
    this.form = form;
  }
  ngOnChanges(changes) {
    if (changes.fields) {
      this.visibleFields = this.getVisibleFields();
    }
  }
  focus(property) {
    const foundComponent = this.components.find((component) => component.name === property);
    if (foundComponent) {
      foundComponent.focus();
    }
  }
  isDisabled(field) {
    return field.disabled || this.disabledForm;
  }
  onChangeField(visibleField, objectValue) {
    return __async(this, null, function* () {
      const { property } = visibleField;
      const isBooleanType = visibleField.type === "boolean";
      const isChangedValueField = this.previousValue[property] !== this.value[property];
      if (visibleField.optionsService) {
        this.objectValue.emit(objectValue);
      }
      if ((this.form.touched || isBooleanType) && isChangedValueField) {
        const { changedField, changedFieldIndex } = this.getField(property);
        if (changedField.validate) {
          yield this.validateField(changedField, changedFieldIndex, visibleField);
        }
        this.triggerValidationOnForm(changedFieldIndex);
      }
      this.updatePreviousValue();
    });
  }
  //emite o valor a cada caractere digitado no input
  onChangeFieldModel(visibleField) {
    if (this.validateOnInput) {
      const { property } = visibleField;
      const { changedFieldIndex } = this.getField(property);
      this.triggerValidationOnForm(changedFieldIndex);
    }
  }
  updatePreviousValue() {
    this.previousValue = JSON.parse(JSON.stringify(this.value));
  }
  trackBy(index) {
    return index;
  }
  applyFieldValidation(index, validatedField) {
    const field = this.fields[index];
    this.fields[index] = __spreadValues(__spreadValues({}, field), validatedField.field);
    this.updateFields();
    if (validatedField.hasOwnProperty("value")) {
      this.value[field.property] = validatedField.value;
    }
    this.changes.detectChanges();
    if (validatedField.focus) {
      this.focus(field.property);
    }
  }
  getField(property) {
    const changedFieldIndex = this.fields.findIndex((field) => field.property === property);
    const changedField = this.fields[changedFieldIndex];
    return { changedField, changedFieldIndex };
  }
  triggerValidationOnForm(changedFieldIndex) {
    const isValidatableField = this.validateFields?.length ? this.validateFieldsChecker(this.validateFields, this.fields[changedFieldIndex].property) : true;
    const hasValidationForm = this.validate && isValidatableField && this.formValidate.observers.length;
    if (hasValidationForm) {
      const updatedField = this.fields[changedFieldIndex];
      this.formValidate.emit(updatedField);
    }
  }
  updateFields() {
    this.fieldsChange.emit(this.fields);
    this.visibleFields = this.getVisibleFields();
  }
  validateFieldsChecker(validateFields, propertyField) {
    return validateFields.some((validateFieldItem) => validateFieldItem === propertyField);
  }
  validateField(field, fieldIndex, visibleField) {
    return __async(this, null, function* () {
      const value = this.value[field.property];
      const previousDisabled = visibleField.disabled;
      visibleField.disabled = true;
      this.changes.detectChanges();
      try {
        const validatedField = yield this.validationService.sendFieldChange(field, value).toPromise();
        this.applyFieldValidation(fieldIndex, validatedField);
      } catch {
        visibleField.disabled = previousDisabled;
      }
    });
  }
  static ɵfac = function PoDynamicFormFieldsComponent_Factory(t) {
    return new (t || _PoDynamicFormFieldsComponent)(ɵɵdirectiveInject(TitleCasePipe), ɵɵdirectiveInject(PoDynamicFormValidationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgForm));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDynamicFormFieldsComponent, selectors: [["po-dynamic-form-fields"]], viewQuery: function PoDynamicFormFieldsComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$y, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.components = _t);
    }
  }, features: [ɵɵProvidersFeature([PoDynamicFormValidationService], [{ provide: ControlContainer, useExisting: NgForm }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "po-row", 4, "ngIf"], [1, "po-row"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-sm-12", 3, "p-label", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-format", "p-help", "p-iso-format", "p-label", "p-locale", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-show-required", "p-placeholder", "ngModelChange", "p-change", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-literals", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-show-required", "ngModelChange", "p-change", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-help", "p-label", "p-mask-format-model", "p-mask", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-required", "p-show-required", "p-icon", "p-placeholder", "p-readonly", "ngModelChange", "p-change", "p-change-model", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-help", "p-label", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-step", "p-readonly", "p-required", "p-show-required", "p-icon", "p-placeholder", "ngModelChange", "p-change", "p-change-model", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-clean", "p-error-pattern", "p-disabled", "p-decimals-length", "p-thousand-maxlength", "p-icon", "p-auto-focus", "p-help", "p-label", "p-locale", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-show-required", "p-placeholder", "ngModelChange", "p-change", "p-change-model", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-field-label", "p-field-value", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-show-required", "p-placeholder", "p-readonly", "ngModelChange", "p-change", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-columns", "p-auto-focus", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-show-required", "ngModelChange", "p-change", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-disabled", "p-format-model", "p-help", "p-label", "p-label-off", "p-label-on", "p-label-position", "ngModelChange", "p-change", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-auto-focus", "p-disabled", "p-label", "p-size", "ngModelChange", "p-change", 4, "ngIf"], ["p-emit-object-value", "", 3, "name", "ngModel", "ngClass", "p-auto-focus", "p-clean", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-help", "p-infinite-scroll", "p-infinite-scroll-distance", "p-label", "p-literals", "p-options", "p-optional", "p-sort", "p-required", "p-show-required", "p-icon", "p-placeholder", "p-filter-minlength", "p-filter-mode", "p-disabled-init-filter", "p-disabled-tab-filter", "p-debounce-time", "p-change-on-enter", "ngModelChange", "p-change", 4, "ngIf"], ["p-field-label", "label", "p-field-value", "value", 3, "name", "ngModel", "ngClass", "p-clean", "p-columns", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-auto-focus", "p-auto-height", "p-help", "p-field-format", "p-infinite-scroll", "p-label", "p-literals", "p-multiple", "p-no-autocomplete", "p-optional", "p-required", "p-show-required", "p-placeholder", "p-advanced-filters", "ngModelChange", "p-change", "p-change-visible-columns", "p-restore-column-manager", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-disabled", "p-auto-focus", "p-auto-height", "p-help", "p-label", "p-literals", "p-optional", "p-options", "p-required", "p-show-required", "p-placeholder", "p-field-label", "p-field-value", "p-filter-service", "p-filter-mode", "p-debounce-time", "p-sort", "p-placeholder-search", "p-hide-search", "p-hide-select-all", "ngModelChange", "p-change", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-maxlength", "p-minlength", "p-optional", "p-readonly", "p-required", "p-show-required", "p-rows", "p-placeholder", "ngModelChange", "p-change", "p-change-model", 4, "ngIf"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-help", "p-hide-password-peek", "p-icon", "p-label", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-readonly", "p-required", "p-show-required", "p-placeholder", "ngModelChange", "p-change", "p-change-model", 4, "ngIf"], [3, "ngModel", "ngClass", "p-auto-upload", "p-directory", "p-disabled", "p-drag-drop", "p-drag-drop-height", "p-restrictions", "p-form-field", "p-headers", "p-help", "p-hide-restrictions-info", "p-hide-select-button", "p-hide-send-button", "p-multiple", "p-label", "p-literals", "name", "p-optional", "p-required", "p-show-required", "p-url", "ngModelChange", "p-error", "p-success", "p-upload", "p-change", "p-change-model", 4, "ngIf"], [1, "po-sm-12", 3, "p-label"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-format", "p-help", "p-iso-format", "p-label", "p-locale", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-show-required", "p-placeholder", "ngModelChange", "p-change"], ["component", ""], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-literals", "p-max-date", "p-min-date", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-show-required", "ngModelChange", "p-change"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-help", "p-label", "p-mask-format-model", "p-mask", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-required", "p-show-required", "p-icon", "p-placeholder", "p-readonly", "ngModelChange", "p-change", "p-change-model"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-help", "p-label", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-step", "p-readonly", "p-required", "p-show-required", "p-icon", "p-placeholder", "ngModelChange", "p-change", "p-change-model"], [3, "name", "ngModel", "ngClass", "p-clean", "p-error-pattern", "p-disabled", "p-decimals-length", "p-thousand-maxlength", "p-icon", "p-auto-focus", "p-help", "p-label", "p-locale", "p-min", "p-max", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-readonly", "p-required", "p-show-required", "p-placeholder", "ngModelChange", "p-change", "p-change-model"], [3, "name", "ngModel", "ngClass", "p-field-label", "p-field-value", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-show-required", "p-placeholder", "p-readonly", "ngModelChange", "p-change"], [3, "name", "ngModel", "ngClass", "p-columns", "p-auto-focus", "p-disabled", "p-help", "p-label", "p-optional", "p-options", "p-required", "p-show-required", "ngModelChange", "p-change"], [3, "name", "ngModel", "ngClass", "p-disabled", "p-format-model", "p-help", "p-label", "p-label-off", "p-label-on", "p-label-position", "ngModelChange", "p-change"], [3, "name", "ngModel", "ngClass", "p-auto-focus", "p-disabled", "p-label", "p-size", "ngModelChange", "p-change"], ["p-emit-object-value", "", 3, "name", "ngModel", "ngClass", "p-auto-focus", "p-clean", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-help", "p-infinite-scroll", "p-infinite-scroll-distance", "p-label", "p-literals", "p-options", "p-optional", "p-sort", "p-required", "p-show-required", "p-icon", "p-placeholder", "p-filter-minlength", "p-filter-mode", "p-disabled-init-filter", "p-disabled-tab-filter", "p-debounce-time", "p-change-on-enter", "ngModelChange", "p-change"], ["p-field-label", "label", "p-field-value", "value", 3, "name", "ngModel", "ngClass", "p-clean", "p-columns", "p-disabled", "p-field-label", "p-field-value", "p-filter-params", "p-filter-service", "p-auto-focus", "p-auto-height", "p-help", "p-field-format", "p-infinite-scroll", "p-label", "p-literals", "p-multiple", "p-no-autocomplete", "p-optional", "p-required", "p-show-required", "p-placeholder", "p-advanced-filters", "ngModelChange", "p-change", "p-change-visible-columns", "p-restore-column-manager"], [3, "name", "ngModel", "ngClass", "p-disabled", "p-auto-focus", "p-auto-height", "p-help", "p-label", "p-literals", "p-optional", "p-options", "p-required", "p-show-required", "p-placeholder", "p-field-label", "p-field-value", "p-filter-service", "p-filter-mode", "p-debounce-time", "p-sort", "p-placeholder-search", "p-hide-search", "p-hide-select-all", "ngModelChange", "p-change"], [3, "name", "ngModel", "ngClass", "p-disabled", "p-auto-focus", "p-help", "p-label", "p-maxlength", "p-minlength", "p-optional", "p-readonly", "p-required", "p-show-required", "p-rows", "p-placeholder", "ngModelChange", "p-change", "p-change-model"], [3, "name", "ngModel", "ngClass", "p-clean", "p-disabled", "p-error-pattern", "p-auto-focus", "p-help", "p-hide-password-peek", "p-icon", "p-label", "p-maxlength", "p-minlength", "p-no-autocomplete", "p-optional", "p-pattern", "p-readonly", "p-required", "p-show-required", "p-placeholder", "ngModelChange", "p-change", "p-change-model"], [3, "ngModel", "ngClass", "p-auto-upload", "p-directory", "p-disabled", "p-drag-drop", "p-drag-drop-height", "p-restrictions", "p-form-field", "p-headers", "p-help", "p-hide-restrictions-info", "p-hide-select-button", "p-hide-send-button", "p-multiple", "p-label", "p-literals", "name", "p-optional", "p-required", "p-show-required", "p-url", "ngModelChange", "p-error", "p-success", "p-upload", "p-change", "p-change-model"]], template: function PoDynamicFormFieldsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoDynamicFormFieldsComponent_div_0_Template, 2, 2, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.visibleFields && ctx.visibleFields.length > 0);
    }
  }, dependencies: [NgClass, NgForOf, NgIf, NgControlStatus, NgModel, PoDividerComponent, PoCheckboxGroupComponent, PoRadioGroupComponent, PoDatepickerComponent, PoComboComponent, PoDecimalComponent, PoDatepickerRangeComponent, PoInputComponent, PoLookupComponent, PoMultiselectComponent, PoNumberComponent, PoPasswordComponent, PoSelectComponent, PoTextareaComponent, PoUploadComponent, PoCheckboxComponent, PoSwitchComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicFormFieldsComponent, [{
    type: Component,
    args: [{ selector: "po-dynamic-form-fields", viewProviders: [{ provide: ControlContainer, useExisting: NgForm }], providers: [PoDynamicFormValidationService], template: `<div class="po-row" *ngIf="visibleFields && visibleFields.length > 0">
  <ng-container *ngFor="let field of visibleFields; trackBy: trackBy">
    <po-divider *ngIf="field?.divider?.trim()" class="po-sm-12" [p-label]="field.divider"> </po-divider>

    <po-datepicker
      #component
      *ngIf="compareTo(field.control, 'datepicker')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-auto-focus]="field.focus"
      [p-format]="field.format"
      [p-help]="field.help"
      [p-iso-format]="field.isoFormat"
      [p-label]="field.label"
      [p-locale]="field.locale"
      [p-max-date]="field.maxValue"
      [p-min-date]="field.minValue"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
    >
    </po-datepicker>

    <po-datepicker-range
      #component
      *ngIf="compareTo(field.control, 'datepickerrange')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-max-date]="field.maxValue"
      [p-min-date]="field.minValue"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
    >
    </po-datepicker-range>

    <po-input
      #component
      *ngIf="compareTo(field.control, 'input')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-mask-format-model]="field.maskFormatModel"
      [p-mask]="field.mask"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-pattern]="field.pattern"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      [p-icon]="field.icon"
      [p-placeholder]="field.placeholder"
      [p-readonly]="field.readonly"
    >
    </po-input>

    <po-number
      #component
      *ngIf="compareTo(field.control, 'number')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-min]="field.minValue"
      [p-max]="field.maxValue"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-step]="field.step"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      [p-icon]="field.icon"
      [p-placeholder]="field.placeholder"
    >
    </po-number>

    <po-decimal
      #component
      *ngIf="compareTo(field.control, 'decimal')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-error-pattern]="field.errorMessage"
      [p-disabled]="isDisabled(field)"
      [p-decimals-length]="field.decimalsLength"
      [p-thousand-maxlength]="field.thousandMaxlength"
      [p-icon]="field.icon"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-locale]="field.locale"
      [p-min]="field.minValue"
      [p-max]="field.maxValue"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      [p-placeholder]="field.placeholder"
    >
    </po-decimal>

    <po-select
      #component
      *ngIf="compareTo(field.control, 'select')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-field-label]="field.fieldLabel"
      [p-field-value]="field.fieldValue"
      [p-disabled]="isDisabled(field)"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
      [p-readonly]="field.readonly"
    >
    </po-select>

    <po-radio-group
      #component
      *ngIf="compareTo(field.control, 'radioGroup')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-columns]="field.columns || 3"
      [p-auto-focus]="field.focus"
      [p-disabled]="isDisabled(field)"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
    >
    </po-radio-group>

    <po-switch
      #component
      *ngIf="compareTo(field.control, 'switch')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-disabled]="isDisabled(field)"
      [p-format-model]="field.formatModel"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-label-off]="field.booleanFalse"
      [p-label-on]="field.booleanTrue"
      [p-label-position]="field.labelPosition"
      (p-change)="onChangeField(field)"
    >
    </po-switch>

    <po-checkbox
      #component
      *ngIf="compareTo(field.control, 'checkbox')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-auto-focus]="field.focus"
      [p-disabled]="isDisabled(field)"
      [p-label]="field.label"
      [p-size]="field.size"
      (p-change)="onChangeField(field)"
    >
    </po-checkbox>

    <po-combo
      #component
      *ngIf="compareTo(field.control, 'combo')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      p-emit-object-value
      [p-auto-focus]="field.focus"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-field-label]="field.fieldLabel"
      [p-field-value]="field.fieldValue"
      [p-filter-params]="field.params"
      [p-filter-service]="field.optionsService"
      [p-help]="field.help"
      [p-infinite-scroll]="field.infiniteScroll"
      [p-infinite-scroll-distance]="field.infiniteScrollDistance || 100"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-options]="field.options"
      [p-optional]="field.optional"
      [p-sort]="field.sort"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field, $event)"
      [p-icon]="field.icon"
      [p-placeholder]="field.placeholder"
      [p-filter-minlength]="field.filterMinlength"
      [p-filter-mode]="field.filterMode"
      [p-disabled-init-filter]="field.disabledInitFilter"
      [p-disabled-tab-filter]="field.disabledTabFilter"
      [p-debounce-time]="field.debounceTime"
      [p-change-on-enter]="field.changeOnEnter"
    >
    </po-combo>

    <po-lookup
      #component
      *ngIf="compareTo(field.control, 'lookup')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      p-field-label="label"
      p-field-value="value"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-columns]="field.columns"
      [p-disabled]="isDisabled(field)"
      [p-field-label]="field.fieldLabel || 'label'"
      [p-field-value]="field.fieldValue || 'value'"
      [p-filter-params]="field.params"
      [p-filter-service]="field.searchService"
      [p-auto-focus]="field.focus"
      [p-auto-height]="field.autoHeight"
      [p-help]="field.help"
      [p-field-format]="field.format"
      [p-infinite-scroll]="field.infiniteScroll"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-multiple]="field.multiple"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
      [p-advanced-filters]="field.advancedFilters"
      (p-change-visible-columns)="field.changeVisibleColumns?.($event)"
      (p-restore-column-manager)="field.columnRestoreManager?.($event)"
    >
    </po-lookup>

    <po-checkbox-group
      #component
      *ngIf="compareTo(field.control, 'checkboxGroup')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-columns]="field.columns || 3"
      [p-auto-focus]="field.focus"
      [p-disabled]="isDisabled(field)"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
    >
    </po-checkbox-group>

    <po-multiselect
      #component
      *ngIf="compareTo(field.control, 'multiselect')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-disabled]="isDisabled(field)"
      [p-auto-focus]="field.focus"
      [p-auto-height]="field.autoHeight"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [p-optional]="field.optional"
      [p-options]="field.options"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      [p-placeholder]="field.placeholder"
      [p-field-label]="field.fieldLabel"
      [p-field-value]="field.fieldValue"
      [p-filter-service]="field.optionsService"
      [p-filter-mode]="field.filterMode"
      [p-debounce-time]="field.debounceTime"
      [p-sort]="field.sort"
      [p-placeholder-search]="field.placeholderSearch"
      [p-hide-search]="field.hideSearch"
      [p-hide-select-all]="field.hideSelectAll"
    >
    </po-multiselect>

    <po-textarea
      #component
      *ngIf="compareTo(field.control, 'textarea')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-disabled]="isDisabled(field)"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-label]="field.label"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-optional]="field.optional"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      [p-rows]="field.rows"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      [p-placeholder]="field.placeholder"
    >
    </po-textarea>

    <po-password
      #component
      *ngIf="compareTo(field.control, 'password')"
      [name]="field.property"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-clean]="field.clean"
      [p-disabled]="isDisabled(field)"
      [p-error-pattern]="field.errorMessage"
      [p-auto-focus]="field.focus"
      [p-help]="field.help"
      [p-hide-password-peek]="field.hidePasswordPeek"
      [p-icon]="field.icon"
      [p-label]="field.label"
      [p-maxlength]="field.maxLength"
      [p-minlength]="field.minLength"
      [p-no-autocomplete]="field.noAutocomplete"
      [p-optional]="field.optional"
      [p-pattern]="field.pattern"
      [p-readonly]="field.readonly"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      [p-placeholder]="field.placeholder"
    >
    </po-password>

    <po-upload
      #component
      *ngIf="compareTo(field.control, 'upload')"
      [(ngModel)]="value[field.property]"
      [ngClass]="field.componentClass"
      [p-auto-upload]="field.autoUpload"
      [p-directory]="field.directory"
      [p-disabled]="isDisabled(field)"
      [p-drag-drop]="field.dragDrop"
      [p-drag-drop-height]="field.dragDropHeight"
      [p-restrictions]="field.restrictions"
      [p-form-field]="field.formField"
      [p-headers]="field.headers"
      [p-help]="field.help"
      [p-hide-restrictions-info]="field.hideRestrictionsInfo"
      [p-hide-select-button]="field.hideSelectButton"
      [p-hide-send-button]="field.hideSendButton"
      [p-multiple]="field.multiple"
      [p-label]="field.label"
      [p-literals]="field.literals"
      [name]="field.property"
      (p-error)="field.onError($event)"
      (p-success)="field.onSuccess($event)"
      (p-upload)="field.onUpload($event)"
      [p-optional]="field.optional"
      [p-required]="field.required"
      [p-show-required]="field.showRequired"
      (p-change)="onChangeField(field)"
      (p-change-model)="onChangeFieldModel(field)"
      [p-url]="field.url"
    >
    </po-upload>
  </ng-container>
</div>
` }]
  }], () => [{ type: TitleCasePipe }, { type: PoDynamicFormValidationService }, { type: ChangeDetectorRef }, { type: NgForm }], { components: [{
    type: ViewChildren,
    args: ["component"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicFormFieldsComponent, { className: "PoDynamicFormFieldsComponent", filePath: "lib/components/po-dynamic/po-dynamic-form/po-dynamic-form-fields/po-dynamic-form-fields.component.ts", lineNumber: 23 });
})();
var PoDynamicViewService = class _PoDynamicViewService {
  httpClient;
  headers = new HttpHeaders({
    "X-PO-No-Message": "true"
  });
  url;
  constructor(httpClient) {
    this.httpClient = httpClient;
  }
  getObjectByValue(value, filterParams) {
    const validatedFilterParams = this.validateParams(filterParams);
    const encodedValue = encodeURIComponent(value);
    const newURL = `${this.url}/${encodedValue}`;
    return this.httpClient.get(newURL, { headers: this.headers, params: validatedFilterParams }).pipe(map((response) => "items" in response ? response.items : response));
  }
  onLoad(url, value) {
    return this.httpClient.post(url, value).toPromise();
  }
  setConfig(url) {
    this.url = url;
  }
  validateParams(params) {
    return isTypeof(params, "object") && !Array.isArray(params) ? params : void 0;
  }
  static ɵfac = function PoDynamicViewService_Factory(t) {
    return new (t || _PoDynamicViewService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoDynamicViewService, factory: _PoDynamicViewService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicViewService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var PoDynamicViewBaseComponent = class _PoDynamicViewBaseComponent {
  currencyPipe;
  datePipe;
  decimalPipe;
  timePipe;
  titleCasePipe;
  dynamicViewService;
  comboFilterService;
  multiselectFilterService;
  /**
   * @optional
   *
   * @description
   *
   * Possibilita executar uma função quando o componente é inicializado.
   *
   * A propriedade aceita os seguintes tipos:
   * - **String**: Endpoint usado pelo componente para requisição via `POST`.
   * - **Function**: Método que será executado na inicialização do componente.
   *
   * Para os dois tipos de utilização da propriedade espera-se o seguinte retorno:
   *
   * ```
   * {
   *   value: {
   *     cnpj: '**************', // altera valor do campo
   *     updated: (new Date()).toString() // atribui valor ao campo novo
   *   },
   *   fields: [
   *     { property: 'cnpj', tag: true, inverse: true }, // atribui novas propriedades ao field
   *     { property: 'updated', tag: true } // inclui campo novo
   *   ]
   * }
   * ```
   * > **value**: any = atribui novo valor do model.
   *
   * > **fields**: `Array<PoDynamicViewField>` = Lista de campos que deseja alterar as propriedades,
   * caso enviar um campo a mais será criado um novo campo.
   *
   * - Para esconder/remover campos precisa informar no field a propriedade `visible = false`.
   *
   */
  load;
  visibleFields = [];
  service;
  _fields = [];
  _showAllValue = false;
  _value = {};
  /**
   * @optional
   *
   * @description
   *
   * Lista de objetos que implementam a interface `PoDynamicView`.
   *
   * > Ex: `[ { property: 'age' } ]`
   *
   * Regras de tipagem e formatação dos valores exibidos:
   *
   * - Caso o *type* informado seja *currency* e não seja informado o *format* o mesmo recebe "'BRL', 'symbol', '1.2-2'"
   * como formato padrão.
   * - Caso o *type* informado seja *date* e não seja informado o *format* o mesmo recebe 'dd/MM/yyyy' como formato padrão.
   * - Caso o *type* informado seja *dateTime* e não seja informado o *format* o mesmo recebe 'dd/MM/yyyy HH:mm:ss' como formato padrão.
   * - Caso o *type* informado seja *number* e não seja informado o *format* o mesmo não será formatado.
   * - Caso o *type* informado seja *time* e não seja informado o *format* o mesmo recebe 'HH:mm:ss.ffffff' como formato padrão.
   *
   * > As propriedades informadas serão exibidas mesmo não contendo valor de referência no objeto da propriedade `p-value`.
   *
   * @default `[]`
   */
  set fields(fields) {
    this._fields = Array.isArray(fields) ? [...fields] : [];
  }
  get fields() {
    return this._fields;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica se exibirá todas as informações contidas dentro do objeto informado na propriedade `p-value`.
   *
   * @default `false`
   */
  set showAllValue(value) {
    this._showAllValue = convertToBoolean(value);
  }
  get showAllValue() {
    return this._showAllValue;
  }
  /**
   * @description
   *
   * Objeto que será utilizado para exibir as informações dinâmicas, o valor será recuperado através do atributo *property*
   * dos objetos contidos na propridade `p-fields`.
   *
   * > Ex: `{ age: '35' }`
   */
  set value(value) {
    this._value = value && isTypeof(value, "object") ? value : {};
  }
  get value() {
    return this._value;
  }
  constructor(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe, dynamicViewService, comboFilterService, multiselectFilterService) {
    this.currencyPipe = currencyPipe;
    this.datePipe = datePipe;
    this.decimalPipe = decimalPipe;
    this.timePipe = timePipe;
    this.titleCasePipe = titleCasePipe;
    this.dynamicViewService = dynamicViewService;
    this.comboFilterService = comboFilterService;
    this.multiselectFilterService = multiselectFilterService;
  }
  /**
   * Verifica se já existe algum outro campo com a order da posição dele no array,
   * se houver ele adiciona +1 até achar uma proxima posição
   */
  getOrdertoField(field, index) {
    const position = index + 1;
    return this.fields.findIndex((e) => e.order === position) > -1 ? this.getOrdertoField(field, position) : position;
  }
  getConfiguredFields(useSearchService = true) {
    const newFields = [];
    this.fields.forEach((field, index) => {
      field.order = field.order || this.getOrdertoField(field, index);
      if (!isVisibleField(field)) {
        return;
      }
      if (!field.searchService && !field.optionsService) {
        newFields.push(this.createField(field));
        return;
      }
      const hasValue = this.value[field.property]?.length || !Array.isArray(this.value[field.property]) && this.value[field.property] && useSearchService;
      if (hasValue) {
        const tempField = this.returnValues(__spreadValues({}, field), "");
        newFields.push(this.createField(tempField));
        if (field.searchService) {
          if (typeof field.searchService === "object") {
            this.service = field.searchService;
          } else if (typeof field.searchService === "string") {
            this.service = this.dynamicViewService;
            this.service.setConfig(field.searchService);
          }
        } else if (field.optionsService) {
          if (field.optionsMulti) {
            if (typeof field.optionsService === "object") {
              this.service = field.optionsService;
            } else {
              this.service = this.multiselectFilterService;
              this.service.configProperties(field.optionsService, field.fieldLabel, field.fieldValue);
            }
          } else {
            if (typeof field.optionsService === "object") {
              this.service = field.optionsService;
            } else {
              this.service = this.comboFilterService;
              this.service.configProperties(field.optionsService, field.fieldLabel, field.fieldValue);
            }
          }
        }
        const indexUpdated = field.order;
        this.createFieldWithService(field, newFields, indexUpdated);
      }
    });
    return sortFields(newFields);
  }
  // retorna fields ligado ao value mais os atributos do value que não possuiam fields.
  getMergedFields() {
    const mergedFields = [...this.getConfiguredFields()];
    this.getValueFields().forEach((valueField) => {
      const fieldIndex = mergedFields.findIndex((field) => field.property === valueField.property);
      const property = valueField.property;
      if (fieldIndex === -1) {
        mergedFields.push(this.createField({ property }));
      }
    });
    return mergedFields;
  }
  // retorna o objeto value como fields.
  getValueFields() {
    return Object.keys(this.value).map((property) => this.createField({ property }));
  }
  createField(field) {
    const property = field.property;
    let value;
    if (field.isArrayOrObject && this.value[property]) {
      value = this.transformArrayValue(this.value[property], field);
    } else if (field.fieldLabel) {
      value = this.transformFieldLabel(property, field);
    }
    if (!value) {
      value = this.transformValue(field.type, this.value[property], field.format);
    }
    return this.returnValues(field, value);
  }
  createFieldWithService(field, newFields, index) {
    const property = field.property;
    this.searchById(this.value[property], field).subscribe((response) => {
      const value = response;
      const allValues = this.returnValues(field, value);
      newFields.splice(index - 1, 1, allValues);
      sortFields(newFields);
    });
  }
  returnValues(field, value) {
    const property = field.property;
    const classesGridColumns = getGridColumnsClasses(field.gridColumns, field.offsetColumns, {
      smGrid: field.gridSmColumns,
      mdGrid: field.gridMdColumns,
      lgGrid: field.gridLgColumns,
      xlGrid: field.gridXlColumns
    }, {
      smOffset: field.offsetSmColumns,
      mdOffset: field.offsetMdColumns,
      lgOffset: field.offsetLgColumns,
      xlOffset: field.offsetXlColumns
    }, {
      smPull: field.gridSmPull,
      mdPull: field.gridMdPull,
      lgPull: field.gridLgPull,
      xlPull: field.gridXlPull
    });
    return __spreadValues({
      property,
      value,
      label: this.titleCasePipe.transform(property),
      cssClass: classesGridColumns
    }, field);
  }
  searchById(value, field) {
    if (typeof value === "string") {
      value = value.trim();
    }
    if (value !== "") {
      if (field.optionsMulti) {
        return this.service.getObjectsByValues(value, field.params).pipe(map((res) => this.transformArrayValue(res, field))).pipe(catchError(() => of(null)));
      } else {
        return this.service.getObjectByValue(value, field.params).pipe(map((res) => this.transformArrayValue(res, field))).pipe(catchError(() => of(null)));
      }
    } else {
      return of(null);
    }
  }
  transformArrayValue(valueProperty, field) {
    const valueArray = Array.isArray(valueProperty) ? valueProperty : [valueProperty];
    let labels;
    if (Array.isArray(field.format)) {
      labels = valueArray.map((objectData) => this.formatField(objectData, field.format));
    } else {
      const arrayWithLabel = valueArray.map((item) => ({
        value: item[field.fieldValue] || item.value,
        label: item[field.fieldLabel] || item.label
      }));
      labels = arrayWithLabel.map((optionValue) => {
        if (optionValue.label) {
          const labelTranformed = this.transformValue(field.type, optionValue.label, field.format);
          if (field.concatLabelValue && optionValue.value) {
            return `${labelTranformed} - ${optionValue.value}`;
          } else {
            return labelTranformed;
          }
        }
      });
    }
    if (labels[0] !== void 0 && labels.join()) {
      return labels.join(", ");
    } else {
      valueProperty = "";
      return void 0;
    }
  }
  transformFieldLabel(property, field) {
    if (field.concatLabelValue && field.fieldLabel && field.fieldValue && !field.isArrayOrObject) {
      const transformedValue = this.transformValue(field.type, this.value[field.fieldLabel], field.format);
      return `${transformedValue} - ${this.value[field.fieldValue]}`;
    }
    if (field.fieldLabel && !field.concatLabelValue && !field.isArrayOrObject) {
      this.value[property] = this.value[field.fieldLabel];
    }
    return void 0;
  }
  transformValue(type, value, format) {
    let transformedValue = value;
    switch (type) {
      case "currency":
        transformedValue = this.currencyPipe.transform(value, format || "BRL", "symbol", "1.2-2");
        break;
      case "date":
        transformedValue = this.datePipe.transform(value, format || "dd/MM/yyyy");
        break;
      case "dateTime":
        transformedValue = this.datePipe.transform(value, format || "dd/MM/yyyy HH:mm:ss");
        break;
      case "number":
        transformedValue = this.decimalPipe.transform(value, format);
        break;
      case "time":
        transformedValue = this.timePipe.transform(value, format || "HH:mm:ss.ffffff");
        break;
    }
    return transformedValue;
  }
  formatField(objectSelected, properties) {
    let formattedField;
    if (Array.isArray(properties)) {
      for (const property of properties) {
        if (objectSelected && objectSelected[property]) {
          if (!formattedField) {
            formattedField = objectSelected[property];
          } else {
            formattedField += " - " + objectSelected[property];
          }
        }
      }
    }
    return formattedField;
  }
  static ɵfac = function PoDynamicViewBaseComponent_Factory(t) {
    return new (t || _PoDynamicViewBaseComponent)(ɵɵdirectiveInject(CurrencyPipe), ɵɵdirectiveInject(DatePipe), ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(PoTimePipe), ɵɵdirectiveInject(TitleCasePipe), ɵɵdirectiveInject(PoDynamicViewService), ɵɵdirectiveInject(PoComboFilterService), ɵɵdirectiveInject(PoMultiselectFilterService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoDynamicViewBaseComponent, inputs: { load: [InputFlags.None, "p-load", "load"], fields: [InputFlags.None, "p-fields", "fields"], showAllValue: [InputFlags.None, "p-show-all-value", "showAllValue"], value: [InputFlags.None, "p-value", "value"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicViewBaseComponent, [{
    type: Directive
  }], () => [{ type: CurrencyPipe }, { type: DatePipe }, { type: DecimalPipe }, { type: PoTimePipe }, { type: TitleCasePipe }, { type: PoDynamicViewService }, { type: PoComboFilterService }, { type: PoMultiselectFilterService }], { load: [{
    type: Input,
    args: ["p-load"]
  }], fields: [{
    type: Input,
    args: ["p-fields"]
  }], showAllValue: [{
    type: Input,
    args: ["p-show-all-value"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
var PoImageBaseComponent = class _PoImageBaseComponent {
  isBase64 = false;
  _source;
  /**
   * @optional
   *
   * @description
   *
   * Define a altura da imagem em *pixels*. Caso não seja definida,
   * atribui o tamanho da imagem
   */
  height;
  /**
   * @optional
   *
   * @description
   *
   * Defini o texto alternativo descrevendo a imagem.
   */
  alternate;
  /**
   * @optional
   *
   * @description
   *
   * Fonte da imagem que pode ser um caminho local (`./assets/images/logo-black-small.png`)
   * ou um servidor externo (`https://po-ui.io/assets/images/logo-black-small.png`).
   */
  set source(value) {
    if (isValidImageBase64(value)) {
      this.isBase64 = true;
    }
    this._source = value;
  }
  get source() {
    return this._source;
  }
  /**
   * @optional
   *
   * @description
   *
   * Defini a prioridade de carregamento da imagem.
   * > Para as imagens com carregamento prioritátio ativo é necessário incluir
   * > uma tag link no head do arquivo index.html da sua aplicação.
   *
   * ```
   * <link rel="preconnect" href="<url_base_da_imagem>">
   * ```
   *
   * @default `false`
   */
  priority = false;
  /**
   * @optional
   *
   * @description
   *
   * Defini o carregamento que pode ser dos tipo:
   *
   * — lazy
   * — eager
   * — auto
   *
   * > Não é permitido definir esta propriedade em conjunto com a propriedade `p-priority`.
   */
  loading;
  static ɵfac = function PoImageBaseComponent_Factory(t) {
    return new (t || _PoImageBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoImageBaseComponent, inputs: { height: [InputFlags.None, "p-height", "height"], alternate: [InputFlags.None, "p-alt", "alternate"], source: [InputFlags.None, "p-src", "source"], priority: [InputFlags.None, "p-priority", "priority"], loading: [InputFlags.None, "p-loading", "loading"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoImageBaseComponent, [{
    type: Directive
  }], null, { height: [{
    type: Input,
    args: ["p-height"]
  }], alternate: [{
    type: Input,
    args: ["p-alt"]
  }], source: [{
    type: Input,
    args: ["p-src"]
  }], priority: [{
    type: Input,
    args: ["p-priority"]
  }], loading: [{
    type: Input,
    args: ["p-loading"]
  }] });
})();
function PoImageComponent_po_container_0_img_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 4);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("priority", ctx_r3.priority)("loading", ctx_r3.loading)("fill", true)("ngSrc", ctx_r3.source);
    ɵɵattribute("alt", ctx_r3.alternate);
  }
}
function PoImageComponent_po_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 2);
    ɵɵtemplate(1, PoImageComponent_po_container_0_img_1_Template, 1, 5, "img", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const _r2 = ɵɵreference(2);
    ɵɵproperty("p-height", ctx_r0.height);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.isBase64)("ngIfElse", _r2);
  }
}
function PoImageComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("loading", ctx_r1.loading)("src", ctx_r1.source, ɵɵsanitizeUrl);
    ɵɵattribute("alt", ctx_r1.alternate);
  }
}
var PoImageComponent = class _PoImageComponent extends PoImageBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoImageComponent_BaseFactory;
    return function PoImageComponent_Factory(t) {
      return (ɵPoImageComponent_BaseFactory || (ɵPoImageComponent_BaseFactory = ɵɵgetInheritedFactory(_PoImageComponent)))(t || _PoImageComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoImageComponent, selectors: [["po-image"]], features: [ɵɵInheritDefinitionFeature], decls: 3, vars: 1, consts: [["class", "po-container-image", 3, "p-height", 4, "ngIf"], ["imageBase64", ""], [1, "po-container-image", 3, "p-height"], ["class", "po-image", 3, "priority", "loading", "fill", "ngSrc", 4, "ngIf", "ngIfElse"], [1, "po-image", 3, "priority", "loading", "fill", "ngSrc"], [1, "po-image", 3, "loading", "src"]], template: function PoImageComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoImageComponent_po_container_0_Template, 2, 3, "po-container", 0)(1, PoImageComponent_ng_template_1_Template, 1, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.source);
    }
  }, dependencies: [NgIf, PoContainerComponent, NgOptimizedImage], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoImageComponent, [{
    type: Component,
    args: [{ selector: "po-image", template: '<po-container class="po-container-image" *ngIf="source" [p-height]="height">\n  <img\n    *ngIf="!isBase64; else imageBase64"\n    class="po-image"\n    [attr.alt]="alternate"\n    [priority]="priority"\n    [loading]="loading"\n    [fill]="true"\n    [ngSrc]="source"\n  />\n</po-container>\n\n<ng-template #imageBase64>\n  <img class="po-image" [attr.alt]="alternate" [loading]="loading" [src]="source" />\n</ng-template>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoImageComponent, { className: "PoImageComponent", filePath: "lib/components/po-image/po-image.component.ts", lineNumber: 30 });
})();
function PoDynamicViewComponent_div_0_ng_template_1_po_divider_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-divider", 8);
  }
  if (rf & 2) {
    const field_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("p-label", field_r8.divider);
  }
}
function PoDynamicViewComponent_div_0_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c0$x = (a0) => ({ $implicit: a0 });
function PoDynamicViewComponent_div_0_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoDynamicViewComponent_div_0_ng_template_1_po_divider_0_Template, 1, 1, "po-divider", 6)(1, PoDynamicViewComponent_div_0_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 7);
  }
  if (rf & 2) {
    const field_r8 = ctx.$implicit;
    ɵɵnextContext(2);
    const _r2 = ɵɵreference(2);
    const _r4 = ɵɵreference(4);
    const _r6 = ɵɵreference(6);
    ɵɵproperty("ngIf", field_r8 == null ? null : field_r8.divider == null ? null : field_r8.divider.trim());
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", !field_r8.tag && !field_r8.image ? _r2 : !field_r8.image ? _r4 : _r6)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c0$x, field_r8));
  }
}
function PoDynamicViewComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, PoDynamicViewComponent_div_0_ng_template_1_Template, 2, 5, "ng-template", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.visibleFields);
  }
}
function PoDynamicViewComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-info", 9);
  }
  if (rf & 2) {
    const field_r12 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", field_r12.cssClass)("p-label", field_r12.label)("p-value", ctx_r1.setFieldValue(field_r12));
  }
}
function PoDynamicViewComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tag", 10);
  }
  if (rf & 2) {
    const field_r13 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngClass", field_r13.cssClass)("p-color", field_r13.color)("p-icon", field_r13.icon)("p-inverse", field_r13.inverse)("p-label", field_r13.label)("p-value", ctx_r3.setFieldValue(field_r13));
  }
}
function PoDynamicViewComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-image", 11);
  }
  if (rf & 2) {
    const field_r14 = ctx.$implicit;
    ɵɵproperty("p-alt", field_r14.alt)("p-height", field_r14.height)("p-src", field_r14.value);
  }
}
var PoDynamicViewComponent = class _PoDynamicViewComponent extends PoDynamicViewBaseComponent {
  initChanges;
  constructor(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe, dynamicViewService, comboFilterService, multiselectFilterService) {
    super(currencyPipe, datePipe, decimalPipe, timePipe, titleCasePipe, dynamicViewService, comboFilterService, multiselectFilterService);
  }
  ngOnChanges(changes) {
    if (this.load && !this.initChanges) {
      this.initChanges = false;
    } else {
      this.initChanges = true;
    }
    if ((changes.fields || changes.value || changes.showAllValue) && this.initChanges) {
      this.visibleFields = this.getVisibleFields();
    }
  }
  ngOnInit() {
    if (this.load) {
      this.updateValuesAndFieldsOnLoad();
    }
  }
  setFieldValue(field) {
    if (field.options) {
      const selectedOption = field.options.find((option) => option.value === field.value);
      return selectedOption ? selectedOption.label : field.value;
    } else if (field.type === "boolean" && "booleanTrue" in field && "booleanFalse" in field) {
      return field.value ? field.booleanTrue : field.booleanFalse;
    } else {
      return field.value;
    }
  }
  getValuesAndFieldsFromLoad() {
    return __async(this, null, function* () {
      let valueAndFieldsFromLoad;
      if (typeof this.load === "string") {
        valueAndFieldsFromLoad = yield this.dynamicViewService.onLoad(this.load, this.value);
      } else if (typeof this.load === "function") {
        valueAndFieldsFromLoad = this.load();
      }
      return valueAndFieldsFromLoad || {};
    });
  }
  getVisibleFields() {
    if (this.showAllValue) {
      return this.getMergedFields();
    }
    return this.value && this.fields.length ? this.getConfiguredFields() : this.getValueFields();
  }
  setFieldOnLoad(fieldOnLoad) {
    const index = this.fields.findIndex((field) => field.property === fieldOnLoad.property);
    if (index >= 0) {
      this.fields[index] = __spreadValues(__spreadValues({}, this.fields[index]), fieldOnLoad);
    } else {
      this.fields.push(__spreadValues({}, fieldOnLoad));
    }
  }
  setFieldsOnLoad(fields) {
    if (fields) {
      fields.forEach((fieldOnLoad) => {
        this.setFieldOnLoad(fieldOnLoad);
      });
    }
  }
  setValueOnLoad(newValue) {
    Object.assign(this.value, newValue);
  }
  updateValuesAndFieldsOnLoad() {
    return __async(this, null, function* () {
      const { value, fields } = yield this.getValuesAndFieldsFromLoad();
      this.setValueOnLoad(value);
      this.setFieldsOnLoad(fields);
      this.visibleFields = this.getVisibleFields();
      this.initChanges = true;
    });
  }
  static ɵfac = function PoDynamicViewComponent_Factory(t) {
    return new (t || _PoDynamicViewComponent)(ɵɵdirectiveInject(CurrencyPipe), ɵɵdirectiveInject(DatePipe), ɵɵdirectiveInject(DecimalPipe), ɵɵdirectiveInject(PoTimePipe), ɵɵdirectiveInject(TitleCasePipe), ɵɵdirectiveInject(PoDynamicViewService), ɵɵdirectiveInject(PoComboFilterService), ɵɵdirectiveInject(PoMultiselectFilterService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoDynamicViewComponent, selectors: [["po-dynamic-view"]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 7, vars: 1, consts: [["class", "po-dynamic-view po-row", 4, "ngIf"], ["poInfo", ""], ["poTag", ""], ["poImage", ""], [1, "po-dynamic-view", "po-row"], ["ngFor", "", 3, "ngForOf"], ["class", "po-sm-12", 3, "p-label", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-sm-12", 3, "p-label"], [3, "ngClass", "p-label", "p-value"], [3, "ngClass", "p-color", "p-icon", "p-inverse", "p-label", "p-value"], [3, "p-alt", "p-height", "p-src"]], template: function PoDynamicViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoDynamicViewComponent_div_0_Template, 2, 1, "div", 0)(1, PoDynamicViewComponent_ng_template_1_Template, 1, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, PoDynamicViewComponent_ng_template_3_Template, 1, 6, "ng-template", null, 2, ɵɵtemplateRefExtractor)(5, PoDynamicViewComponent_ng_template_5_Template, 1, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.visibleFields.length);
    }
  }, dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, PoDividerComponent, PoInfoComponent, PoTagComponent, PoImageComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicViewComponent, [{
    type: Component,
    args: [{ selector: "po-dynamic-view", template: '<div class="po-dynamic-view po-row" *ngIf="visibleFields.length">\n  <ng-template ngFor let-field [ngForOf]="visibleFields">\n    <po-divider *ngIf="field?.divider?.trim()" class="po-sm-12" [p-label]="field.divider"> </po-divider>\n\n    <ng-container\n      *ngTemplateOutlet="\n        !field.tag && !field.image ? poInfo : !field.image ? poTag : poImage;\n        context: { $implicit: field }\n      "\n    >\n    </ng-container>\n  </ng-template>\n</div>\n\n<ng-template #poInfo let-field>\n  <po-info [ngClass]="field.cssClass" [p-label]="field.label" [p-value]="setFieldValue(field)"> </po-info>\n</ng-template>\n\n<ng-template #poTag let-field>\n  <po-tag\n    [ngClass]="field.cssClass"\n    [p-color]="field.color"\n    [p-icon]="field.icon"\n    [p-inverse]="field.inverse"\n    [p-label]="field.label"\n    [p-value]="setFieldValue(field)"\n  >\n  </po-tag>\n</ng-template>\n\n<ng-template #poImage let-field>\n  <po-image [p-alt]="field.alt" [p-height]="field.height" [p-src]="field.value"> </po-image>\n</ng-template>\n' }]
  }], () => [{ type: CurrencyPipe }, { type: DatePipe }, { type: DecimalPipe }, { type: PoTimePipe }, { type: TitleCasePipe }, { type: PoDynamicViewService }, { type: PoComboFilterService }, { type: PoMultiselectFilterService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoDynamicViewComponent, { className: "PoDynamicViewComponent", filePath: "lib/components/po-dynamic/po-dynamic-view/po-dynamic-view.component.ts", lineNumber: 37 });
})();
var PoImageModule = class _PoImageModule {
  static ɵfac = function PoImageModule_Factory(t) {
    return new (t || _PoImageModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoImageModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoContainerModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoImageModule, [{
    type: NgModule,
    args: [{
      declarations: [PoImageComponent],
      imports: [CommonModule, PoContainerModule, NgOptimizedImage],
      exports: [PoImageComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoImageModule, { declarations: [PoImageComponent], imports: [CommonModule, PoContainerModule, NgOptimizedImage], exports: [PoImageComponent] });
})();
var PoDynamicModule = class _PoDynamicModule {
  static ɵfac = function PoDynamicModule_Factory(t) {
    return new (t || _PoDynamicModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDynamicModule });
  static ɵinj = ɵɵdefineInjector({ providers: [
    CurrencyPipe,
    DatePipe,
    DecimalPipe,
    PoTimePipe,
    TitleCasePipe,
    PoDynamicFormLoadService,
    PoDynamicFormValidationService,
    PoDynamicViewService,
    PoComboFilterService,
    PoMultiselectFilterService
  ], imports: [
    CommonModule,
    FormsModule,
    PoDividerModule,
    PoInfoModule,
    PoFieldModule,
    PoTagModule,
    PoTimeModule,
    PoImageModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDynamicModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        FormsModule,
        PoDividerModule,
        PoInfoModule,
        PoFieldModule,
        PoTagModule,
        PoTimeModule,
        PoImageModule
      ],
      declarations: [PoDynamicFormComponent, PoDynamicFormFieldsComponent, PoDynamicViewComponent],
      exports: [PoDynamicFormComponent, PoDynamicViewComponent],
      providers: [
        CurrencyPipe,
        DatePipe,
        DecimalPipe,
        PoTimePipe,
        TitleCasePipe,
        PoDynamicFormLoadService,
        PoDynamicFormValidationService,
        PoDynamicViewService,
        PoComboFilterService,
        PoMultiselectFilterService
      ]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDynamicModule, { declarations: [PoDynamicFormComponent, PoDynamicFormFieldsComponent, PoDynamicViewComponent], imports: [
    CommonModule,
    FormsModule,
    PoDividerModule,
    PoInfoModule,
    PoFieldModule,
    PoTagModule,
    PoTimeModule,
    PoImageModule
  ], exports: [PoDynamicFormComponent, PoDynamicViewComponent] });
})();
ɵɵsetComponentScope(PoDynamicFormComponent, [NgIf, ɵNgNoValidate, NgControlStatusGroup, NgForm, PoDynamicFormFieldsComponent], []);
var PoGaugePadding = 24;
var poGaugeMinHeight = 300;
var PoGaugeThickness = 16;
var PoGaugePointerEnd = 4;
var poGaugeTotalValueDefault = 100;
var PoGaugeBaseComponent = class _PoGaugeBaseComponent {
  colorService;
  _description;
  _height = poGaugeMinHeight;
  _ranges = [];
  _title;
  _value;
  /**
   * @optional
   *
   * @description
   *
   * Define o texto que será exibido no gauge.
   * Há dois posicionamentos para ele:
   * - Se houver definição para `p-ranges`, o descritivo será exibido no topo do container, ficando acima do gauge;
   * - Na ausência de `p-ranges`, será incorporado dentro do arco do gauge, e abaixo de `p-value`.
   *
   * Para ambos os casos, se o conteúdo ultrapassar a área designada, serão geradas automaticamente reticências.
   * No entanto, será possível visualizar a mensagem através de um tooltip no passar do mouse sobre o texto.
   *
   * > Para uma melhor experiência do usuário, é recomendado um descritivo breve e com poucas palavras.
   * Desta forma evita-se o *overflow* do texto.
   */
  set description(value) {
    this._description = value;
    this.svgContainerSize();
  }
  get description() {
    return this._description;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do gauge.
   *
   * O valor mínimo aceito é 300px.
   *
   * @default `300px`
   */
  set height(value) {
    this._height = this.setGaugeHeight(value);
    this.svgContainerSize();
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Definição para o alcance de cores. Ao adicionar pelo menos um item na lista,
   * incorpora-se o ponteiro que assinala o valor passado em `p-value`.
   * Se o valor de `p-value` for inferior ao mínimo valor definido em `PoGaugeRanges.from`, o domínio mínimo do gauge será `p-value`.
   * A mesma regra prevalece para valores máximos.
   */
  set ranges(value) {
    this._ranges = Array.isArray(value) ? this.verifyColors(value) : [];
    this.svgContainerSize();
  }
  get ranges() {
    return this._ranges;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o título do gauge.
   */
  set title(value) {
    this._title = value;
    this.svgContainerSize();
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor referente ao valor da série. Seu comportamento segue a seguintes regras:
   *
   * - Sem `p-ranges`: Os valores passados para `p-value` e `p-description` serão centralizados no interior do arco.
   * A base do valor será percentual tendo como base os alcances entre zero e 100%. Se passado um valor superior a 100,
   * A colorização do gauge será completa e o valor passado será exibido no interior do arco.
   * - Com `p-ranges`: A descrição será exibida acima do gauge e haverá um ponteiro marcando o valor passado em `p-value`.
   * Considerando que o alcance em `ranges` é aberto, então a escala de `p-value` será em relação ao menor/maior alcance
   * absoluto definido em `p-ranges`.
   * Se passado um `p-value` inferior em relação ao mínimo valor definido em `p-ranges`, o domínio mínimo do gauge partirá de `p-value`.
   * A mesma regra prevalece para valores máximos.
   *
   */
  set value(gaugeValue) {
    if (typeof gaugeValue === "number" || typeof gaugeValue === "string" && gaugeValue.trim()) {
      const value = !isNaN(gaugeValue) ? Number(gaugeValue) : void 0;
      this._value = value;
    } else {
      this._value = void 0;
    }
  }
  get value() {
    return this._value;
  }
  constructor(colorService) {
    this.colorService = colorService;
  }
  verifyColors(ranges) {
    return this.colorService.getColors(ranges);
  }
  setGaugeHeight(height) {
    const gaugeHeight = convertToInt(height);
    return gaugeHeight && gaugeHeight > poGaugeMinHeight ? gaugeHeight : poGaugeMinHeight;
  }
  static ɵfac = function PoGaugeBaseComponent_Factory(t) {
    return new (t || _PoGaugeBaseComponent)(ɵɵdirectiveInject(PoColorService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoGaugeBaseComponent, inputs: { description: [InputFlags.None, "p-description", "description"], height: [InputFlags.None, "p-height", "height"], ranges: [InputFlags.None, "p-ranges", "ranges"], title: [InputFlags.None, "p-title", "title"], value: [InputFlags.None, "p-value", "value"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeBaseComponent, [{
    type: Directive
  }], () => [{ type: PoColorService }], { description: [{
    type: Input,
    args: ["p-description"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], ranges: [{
    type: Input,
    args: ["p-ranges"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
function PoGaugeTitleComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
var PoGaugeTitleComponent = class _PoGaugeTitleComponent {
  title;
  static ɵfac = function PoGaugeTitleComponent_Factory(t) {
    return new (t || _PoGaugeTitleComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugeTitleComponent, selectors: [["po-gauge-title"]], inputs: { title: [InputFlags.None, "p-title", "title"] }, decls: 1, vars: 1, consts: [["class", "po-gauge-title", 4, "ngIf"], [1, "po-gauge-title"]], template: function PoGaugeTitleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoGaugeTitleComponent_div_0_Template, 2, 1, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.title);
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeTitleComponent, [{
    type: Component,
    args: [{ selector: "po-gauge-title", template: '<div *ngIf="title" class="po-gauge-title">{{ title }}</div>\n' }]
  }], null, { title: [{
    type: Input,
    args: ["p-title"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeTitleComponent, { className: "PoGaugeTitleComponent", filePath: "lib/components/po-gauge/po-gauge-title/po-gauge-title.component.ts", lineNumber: 7 });
})();
function PoGaugeLegendComponent_li_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c0$w = (a0) => ({ $implicit: a0 });
function PoGaugeLegendComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 4);
    ɵɵtemplate(1, PoGaugeLegendComponent_li_1_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementStart(2, "p", 6);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const range_r5 = ctx.$implicit;
    ɵɵnextContext();
    const _r2 = ɵɵreference(3);
    const _r4 = ɵɵreference(5);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", (range_r5.color == null ? null : range_r5.color.includes("po-color")) ? _r2 : _r4)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c0$w, range_r5));
    ɵɵadvance(2);
    ɵɵtextInterpolate(range_r5.label);
  }
}
function PoGaugeLegendComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const range_r7 = ctx.$implicit;
    ɵɵclassMap(range_r7.color);
  }
}
function PoGaugeLegendComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const range_r8 = ctx.$implicit;
    ɵɵstyleProp("background", range_r8.color);
  }
}
var PoGaugeLegendComponent = class _PoGaugeLegendComponent {
  _ranges;
  set ranges(value) {
    this._ranges = value.length ? this.filterLabel(value) : [];
  }
  get ranges() {
    return this._ranges;
  }
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  filterLabel(ranges) {
    return ranges.filter((range) => range.label);
  }
  static ɵfac = function PoGaugeLegendComponent_Factory(t) {
    return new (t || _PoGaugeLegendComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugeLegendComponent, selectors: [["po-gauge-legend"]], inputs: { ranges: [InputFlags.None, "p-ranges", "ranges"] }, decls: 6, vars: 2, consts: [[1, "po-gauge-legend"], ["class", "po-gauge-legend-item", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["colorpalette", ""], ["colorstyle", ""], [1, "po-gauge-legend-item"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-gauge-legend-text"], [1, "po-gauge-legend-square"]], template: function PoGaugeLegendComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, PoGaugeLegendComponent_li_1_Template, 4, 5, "li", 1);
      ɵɵelementEnd();
      ɵɵtemplate(2, PoGaugeLegendComponent_ng_template_2_Template, 1, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor)(4, PoGaugeLegendComponent_ng_template_4_Template, 1, 2, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.ranges)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf, NgTemplateOutlet], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeLegendComponent, [{
    type: Component,
    args: [{ selector: "po-gauge-legend", template: `<ul class="po-gauge-legend">
  <li class="po-gauge-legend-item" *ngFor="let range of ranges; trackBy: trackBy">
    <ng-container
      *ngTemplateOutlet="range.color?.includes('po-color') ? colorpalette : colorstyle; context: { $implicit: range }"
    ></ng-container>
    <p class="po-gauge-legend-text">{{ range.label }}</p>
  </li>
</ul>

<ng-template #colorpalette let-range>
  <span class="po-gauge-legend-square" [class]="range.color"></span>
</ng-template>

<ng-template #colorstyle let-range>
  <span class="po-gauge-legend-square" [style.background]="range.color"></span>
</ng-template>
` }]
  }], () => [], { ranges: [{
    type: Input,
    args: ["p-ranges"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeLegendComponent, { className: "PoGaugeLegendComponent", filePath: "lib/components/po-gauge/po-gauge-legend/po-gauge-legend.component.ts", lineNumber: 9 });
})();
var _c0$v = ["po-gauge-path", ""];
function PoGaugePathComponent__svg_path_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path");
  }
  if (rf & 2) {
    const range_r1 = ctx.$implicit;
    ɵɵclassMap((range_r1 == null ? null : range_r1.color == null ? null : range_r1.color.includes("po-color")) ? range_r1.color : "");
    ɵɵattribute("d", range_r1 == null ? null : range_r1.coordinates)("fill", range_r1 == null ? null : range_r1.color);
  }
}
var PoGaugePathComponent = class _PoGaugePathComponent {
  baseCoordinates;
  rangesCoordinates;
  constructor() {
  }
  trackBy(index) {
    return index;
  }
  static ɵfac = function PoGaugePathComponent_Factory(t) {
    return new (t || _PoGaugePathComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugePathComponent, selectors: [["", "po-gauge-path", ""]], inputs: { baseCoordinates: [InputFlags.None, "p-base-coordinates", "baseCoordinates"], rangesCoordinates: [InputFlags.None, "p-ranges-coordinates", "rangesCoordinates"] }, attrs: _c0$v, decls: 3, vars: 3, consts: [[1, "po-gauge-base"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"]], template: function PoGaugePathComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵelement(1, "path", 0);
      ɵɵtemplate(2, PoGaugePathComponent__svg_path_2_Template, 1, 4, "path", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵattribute("d", ctx.baseCoordinates == null ? null : ctx.baseCoordinates.coordinates);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.rangesCoordinates)("ngForTrackBy", ctx.trackBy);
    }
  }, dependencies: [NgForOf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugePathComponent, [{
    type: Component,
    args: [{ selector: "[po-gauge-path]", template: `<svg:g>
  <svg:path
    class="po-gauge-base"
    [attr.d]="baseCoordinates?.coordinates">
  </svg:path> 

  <svg:path *ngFor="let range of rangesCoordinates; trackBy: trackBy"
    [class]="range?.color?.includes('po-color') ? range.color : ''"
    [attr.d]="range?.coordinates"
    [attr.fill]="range?.color">
  </svg:path> 
</svg:g>
` }]
  }], () => [], { baseCoordinates: [{
    type: Input,
    args: ["p-base-coordinates"]
  }], rangesCoordinates: [{
    type: Input,
    args: ["p-ranges-coordinates"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugePathComponent, { className: "PoGaugePathComponent", filePath: "lib/components/po-gauge/po-gauge-svg/po-gauge-path/po-gauge-path.component.ts", lineNumber: 9 });
})();
var _c0$u = ["pointer"];
var _c1$b = ["po-gauge-pointer", ""];
var PoGaugePointerComponent = class _PoGaugePointerComponent {
  renderer;
  pointer;
  radiusScale;
  _coordinates;
  afterViewInit = false;
  set coordinates(value) {
    this._coordinates = value;
    if (this._coordinates?.radius) {
      this.calculateRadiusScale(this.coordinates.radius);
    }
    if (this._coordinates?.hasOwnProperty("pointerDegrees") && this.afterViewInit) {
      this.applyPointerRotation(this.coordinates.pointerDegrees);
    }
  }
  get coordinates() {
    return this._coordinates;
  }
  constructor(renderer) {
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (this._coordinates?.pointerDegrees) {
      this.applyPointerRotation(this.coordinates.pointerDegrees);
    }
    this.afterViewInit = true;
  }
  calculateRadiusScale(radius) {
    const scale = radius / 20;
    const maxScaleValue = 24;
    this.radiusScale = scale < maxScaleValue ? scale : maxScaleValue;
  }
  applyPointerRotation(degrees) {
    this.renderer.setStyle(this.pointer.nativeElement, "transformOrigin", `${this.coordinates.radius}px ${this.coordinates.radius}px`);
    this.renderer.setStyle(this.pointer.nativeElement, "transform", `rotate(${degrees}deg)`);
  }
  static ɵfac = function PoGaugePointerComponent_Factory(t) {
    return new (t || _PoGaugePointerComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugePointerComponent, selectors: [["", "po-gauge-pointer", ""]], viewQuery: function PoGaugePointerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$u, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pointer = _t.first);
    }
  }, inputs: { coordinates: [InputFlags.None, "p-coordinates", "coordinates"] }, attrs: _c1$b, decls: 4, vars: 4, consts: [[1, "po-gauge-pointer"], ["pointer", ""], [1, "po-gauge-pointer-circle"]], template: function PoGaugePointerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵnamespaceSVG();
      ɵɵelementStart(0, "g");
      ɵɵelement(1, "path", 0, 1)(3, "circle", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵattribute("d", ctx.coordinates == null ? null : ctx.coordinates.coordinates);
      ɵɵadvance(2);
      ɵɵattribute("cx", ctx.coordinates == null ? null : ctx.coordinates.radius)("cy", ctx.coordinates == null ? null : ctx.coordinates.radius)("r", ctx.radiusScale);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugePointerComponent, [{
    type: Component,
    args: [{ selector: "[po-gauge-pointer]", template: '<svg:g>\n  <svg:path #pointer\n    class="po-gauge-pointer"\n    [attr.d]="coordinates?.coordinates"\n  >\n  </svg:path> \n\n  <svg:circle \n    class="po-gauge-pointer-circle" \n    [attr.cx]="coordinates?.radius" \n    [attr.cy]="coordinates?.radius" \n    [attr.r]="radiusScale"\n  >\n  </svg:circle>\n</svg:g>' }]
  }], () => [{ type: Renderer2 }], { pointer: [{
    type: ViewChild,
    args: ["pointer"]
  }], coordinates: [{
    type: Input,
    args: ["p-coordinates"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugePointerComponent, { className: "PoGaugePointerComponent", filePath: "lib/components/po-gauge/po-gauge-svg/po-gauge-pointer/po-gauge-pointer.component.ts", lineNumber: 8 });
})();
function PoGaugeSvgComponent__svg_svg_0__svg_g_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "g", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-coordinates", ctx_r1.pointerCoordinates);
  }
}
function PoGaugeSvgComponent__svg_svg_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 1);
    ɵɵelement(1, "g", 2);
    ɵɵtemplate(2, PoGaugeSvgComponent__svg_svg_0__svg_g_2_Template, 1, 1, "g", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("viewBox", ctx_r0.viewBox)("height", ctx_r0.container == null ? null : ctx_r0.container.height);
    ɵɵadvance();
    ɵɵproperty("p-base-coordinates", ctx_r0.baseCoordinates)("p-ranges-coordinates", ctx_r0.coordinates);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.hasRanges);
  }
}
var poGaugeStartAngle = -Math.PI;
var PoGaugeSvgComponent = class _PoGaugeSvgComponent {
  container;
  ranges;
  value;
  addSvgElement = false;
  baseCoordinates;
  coordinates;
  pointerCoordinates;
  viewBox;
  get hasRanges() {
    return this.ranges.length > 0;
  }
  ngOnChanges(changes) {
    if (this.container && changes.value || this.container && changes.ranges || this.container) {
      this.setCoordinates(this.value, this.ranges, this.container);
    }
  }
  setCoordinates(value, ranges, container) {
    const { height } = container;
    this.addSvgElement = true;
    this.setViewBox(height);
    this.setBaseCoordinates(height);
    if (!ranges.length) {
      this.setSingleRangeCoordinates(height, value);
      return;
    }
    this.setRangesCoordinates(height, value, ranges);
  }
  setBaseCoordinates(height) {
    const endAngleRadian = 0;
    const coordinates = this.calculateCoordinates(height, poGaugeStartAngle, endAngleRadian);
    this.baseCoordinates = { coordinates };
  }
  setRangesCoordinates(height, value = 0, ranges) {
    const { minRange, maxRange } = this.calculateMinAndMaxValues(ranges);
    const minValue = value < minRange ? value : minRange;
    const maxValue = value > maxRange ? value : maxRange;
    this.setPointerCoordinates(height, value, maxValue, minValue);
    const rangesCoordinates = ranges.map((range) => {
      const from2 = range.from ?? 0;
      const to = range.to ?? maxRange;
      const startAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(from2, maxValue, minValue);
      const endAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(to, maxValue, minValue);
      const coordinates = this.calculateCoordinates(height, startAngleRadian, endAngleRadian);
      return { coordinates, color: range.color };
    }).reverse();
    this.coordinates = rangesCoordinates;
  }
  setSingleRangeCoordinates(height, value) {
    const verifiedValue = value > 100 ? 100 : value;
    const endAngleRadian = poGaugeStartAngle + this.calculateAngleRadius(verifiedValue, poGaugeTotalValueDefault);
    const coordinates = value > 0 ? this.calculateCoordinates(height, poGaugeStartAngle, endAngleRadian) : void 0;
    const color = PoDefaultColors[0][0];
    this.coordinates = [{ coordinates, color }];
  }
  setPointerCoordinates(height, value, maxValue, minValue) {
    const coordinates = this.calculatePointerInitialCoordinates(height, poGaugeStartAngle);
    const pointerDegrees = this.pointerRotation(value, maxValue, minValue);
    this.pointerCoordinates = __spreadProps(__spreadValues({}, coordinates), { pointerDegrees });
  }
  pointerRotation(value, maxValue, minValue) {
    const percent = this.convertValueToPercentage(value, maxValue, minValue);
    const minRotation = 0;
    const maxRotation = 180;
    return percent * (maxRotation - minRotation) / 100 + minRotation;
  }
  calculatePointerInitialCoordinates(height, startAngleRadian) {
    const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
    const scale = 40;
    const pointerScaledWidth = radius / scale;
    const pointerScaledBorderRadius = radius / (scale * 2);
    const sinAlpha = Math.sin(startAngleRadian);
    const cosAlpha = Math.cos(startAngleRadian);
    const targetX = radius + cosAlpha * radius;
    const targetY = radius + sinAlpha * radius;
    const startX = radius;
    const startY = radius + pointerScaledWidth;
    const endX = radius;
    const endY = radius - pointerScaledWidth;
    const coordinates = [
      "M",
      startX,
      startY,
      "L",
      targetX,
      targetY + pointerScaledBorderRadius,
      "A",
      1,
      1,
      0,
      "0,1",
      targetX,
      targetY - pointerScaledBorderRadius,
      "L",
      endX,
      endY,
      "Z"
    ].join(" ");
    return { coordinates, radius };
  }
  calculateCoordinates(height, startAngleRadian, endAngleRadian) {
    const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
    const innerRadius = radius - PoGaugeThickness;
    const sinAlpha = Math.sin(startAngleRadian);
    const cosAlpha = Math.cos(startAngleRadian);
    const sinBeta = Math.sin(endAngleRadian);
    const cosBeta = Math.cos(endAngleRadian);
    const startX = Math.round(radius + cosAlpha * radius);
    const startY = Math.round(radius + sinAlpha * radius);
    const endX = Math.round(radius + cosBeta * radius);
    const endY = Math.round(radius + sinBeta * radius);
    const startInnerX = Math.round(radius + cosAlpha * innerRadius);
    const startInnerY = Math.round(radius + sinAlpha * innerRadius);
    const endInnerX = Math.round(radius + cosBeta * innerRadius);
    const endInnerY = Math.round(radius + sinBeta * innerRadius);
    return [
      "M",
      startX,
      startY,
      "A",
      radius,
      radius,
      0,
      "0,1",
      endX,
      endY,
      "A",
      1,
      1,
      0,
      "0,1",
      endInnerX,
      endInnerY,
      "A",
      innerRadius,
      innerRadius,
      0,
      "0,0",
      startInnerX,
      startInnerY,
      "A",
      1,
      1,
      0,
      "0,1",
      startX,
      startY,
      "Z"
    ].join(" ");
  }
  calculateAngleRadius(value, maxValue, minValue = 0) {
    const angle = (value - minValue) / (maxValue - minValue) * (Math.PI * 2);
    return angle / 2;
  }
  convertValueToPercentage(value, maxValue, minValue) {
    return (value - minValue) / (maxValue - minValue) * 100;
  }
  setViewBox(height) {
    const width = this.calculateDiameter(height);
    this.viewBox = `0 ${-PoGaugePointerEnd} ${width} ${height}`;
  }
  calculateDiameter(height) {
    const radius = height - PoGaugePointerEnd - PoGaugeThickness / 2;
    return radius + Math.cos(0) * radius;
  }
  calculateMinAndMaxValues(ranges) {
    const minRange = this.getDomain(ranges, "min");
    const maxRange = this.getDomain(ranges, "max");
    return {
      minRange: this.verifyIfFloatOrInteger(minRange) ? minRange : 0,
      maxRange: this.verifyIfFloatOrInteger(maxRange) ? maxRange : 100
    };
  }
  verifyIfFloatOrInteger(number) {
    const notABoolean = typeof number !== "boolean";
    const notInfinity = number !== Infinity;
    const isInteger = Number(number) === number && number % 1 === 0 && notInfinity;
    const isFloat = Number(number) === number && number % 1 !== 0 && notInfinity;
    return notABoolean && isInteger || notABoolean && isFloat;
  }
  getDomain(ranges, type) {
    const rangeType = { min: "from", max: "to" };
    return Math[type](...ranges.map((range) => range[rangeType[type]]));
  }
  static ɵfac = function PoGaugeSvgComponent_Factory(t) {
    return new (t || _PoGaugeSvgComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugeSvgComponent, selectors: [["po-gauge-svg"]], inputs: { container: [InputFlags.None, "p-container", "container"], ranges: [InputFlags.None, "p-ranges", "ranges"], value: [InputFlags.None, "p-value", "value"] }, features: [ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["class", "po-gauge-svg", "preserveAspectRatio", "xMidYMax meet", "width", "100%", 4, "ngIf"], ["preserveAspectRatio", "xMidYMax meet", "width", "100%", 1, "po-gauge-svg"], ["po-gauge-path", "", 3, "p-base-coordinates", "p-ranges-coordinates"], ["po-gauge-pointer", "", 3, "p-coordinates", 4, "ngIf"], ["po-gauge-pointer", "", 3, "p-coordinates"]], template: function PoGaugeSvgComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoGaugeSvgComponent__svg_svg_0_Template, 3, 5, "svg", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.addSvgElement);
    }
  }, dependencies: [NgIf, PoGaugePathComponent, PoGaugePointerComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeSvgComponent, [{
    type: Component,
    args: [{ selector: "po-gauge-svg", template: '<svg:svg\n  *ngIf="addSvgElement"\n  class="po-gauge-svg"\n  preserveAspectRatio="xMidYMax meet"\n  width="100%"\n  [attr.viewBox]="viewBox"\n  [attr.height]="container?.height"\n>\n  <!-- GAUGE PATHS -->\n  <svg:g po-gauge-path [p-base-coordinates]="baseCoordinates" [p-ranges-coordinates]="coordinates"></svg:g>\n\n  <!-- GAUGE POINTER -->\n  <svg:g *ngIf="hasRanges" po-gauge-pointer [p-coordinates]="pointerCoordinates"></svg:g>\n</svg:svg>\n' }]
  }], null, { container: [{
    type: Input,
    args: ["p-container"]
  }], ranges: [{
    type: Input,
    args: ["p-ranges"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeSvgComponent, { className: "PoGaugeSvgComponent", filePath: "lib/components/po-gauge/po-gauge-svg/po-gauge-svg.component.ts", lineNumber: 17 });
})();
var _c0$t = ["descriptionText"];
function PoGaugeDescriptionComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGaugeDescriptionComponent_ng_template_2_p_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "p", 5, 6);
    ɵɵlistener("mouseenter", function PoGaugeDescriptionComponent_ng_template_2_p_0_Template_p_mouseenter_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r7.verifyIfHasEllipsis());
    });
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵproperty("p-tooltip", ctx_r5.tooltip);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r5.description, " ");
  }
}
function PoGaugeDescriptionComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoGaugeDescriptionComponent_ng_template_2_p_0_Template, 3, 2, "p", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.description);
  }
}
function PoGaugeDescriptionComponent_ng_template_4_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r9.value, "%");
  }
}
function PoGaugeDescriptionComponent_ng_template_4_p_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "p", 11, 6);
    ɵɵlistener("mouseenter", function PoGaugeDescriptionComponent_ng_template_4_p_2_Template_p_mouseenter_0_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r12.verifyIfHasEllipsis());
    });
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(2);
    ɵɵproperty("p-tooltip", ctx_r10.tooltip);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r10.description, " ");
  }
}
function PoGaugeDescriptionComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, PoGaugeDescriptionComponent_ng_template_4_p_1_Template, 2, 1, "p", 8)(2, PoGaugeDescriptionComponent_ng_template_4_p_2_Template, 3, 2, "p", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r3.descriptionWidth, "px");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.isValidValue);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.description);
  }
}
var PoGaugeDescriptionComponent = class _PoGaugeDescriptionComponent {
  description;
  hasRanges;
  descriptionWidth;
  value;
  descriptionText;
  tooltip;
  get isValidValue() {
    return this.value || this.value === 0;
  }
  verifyIfHasEllipsis() {
    const { offsetWidth, scrollWidth } = this.descriptionText.nativeElement;
    setTimeout(() => {
      this.tooltip = offsetWidth < scrollWidth ? this.description : void 0;
    });
  }
  static ɵfac = function PoGaugeDescriptionComponent_Factory(t) {
    return new (t || _PoGaugeDescriptionComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugeDescriptionComponent, selectors: [["po-gauge-description"]], viewQuery: function PoGaugeDescriptionComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$t, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.descriptionText = _t.first);
    }
  }, inputs: { description: [InputFlags.None, "p-description", "description"], hasRanges: [InputFlags.None, "p-has-ranges", "hasRanges"], descriptionWidth: [InputFlags.None, "p-description-width", "descriptionWidth"], value: [InputFlags.None, "p-value", "value"] }, decls: 6, vars: 1, consts: [[1, "po-gauge-description"], [4, "ngTemplateOutlet"], ["rangesDescription", ""], ["percentageDescription", ""], ["class", "po-gauge-description-text po-gauge-description-upper-text", 3, "p-tooltip", "mouseenter", 4, "ngIf"], [1, "po-gauge-description-text", "po-gauge-description-upper-text", 3, "p-tooltip", "mouseenter"], ["descriptionText", ""], ["tabindex", "0", 1, "po-gauge-description-bottom"], ["class", "po-gauge-description-bottom-value", 4, "ngIf"], ["class", "po-gauge-description-text po-gauge-description-bottom-text", 3, "p-tooltip", "mouseenter", 4, "ngIf"], [1, "po-gauge-description-bottom-value"], [1, "po-gauge-description-text", "po-gauge-description-bottom-text", 3, "p-tooltip", "mouseenter"]], template: function PoGaugeDescriptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoGaugeDescriptionComponent_ng_container_1_Template, 1, 0, "ng-container", 1);
      ɵɵelementEnd();
      ɵɵtemplate(2, PoGaugeDescriptionComponent_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor)(4, PoGaugeDescriptionComponent_ng_template_4_Template, 3, 4, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(3);
      const _r4 = ɵɵreference(5);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.hasRanges ? _r2 : _r4);
    }
  }, dependencies: [NgIf, NgTemplateOutlet, PoTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeDescriptionComponent, [{
    type: Component,
    args: [{ selector: "po-gauge-description", template: '<div class="po-gauge-description">\n  <ng-container *ngTemplateOutlet="hasRanges ? rangesDescription : percentageDescription"> </ng-container>\n</div>\n\n<ng-template #rangesDescription>\n  <p\n    #descriptionText\n    *ngIf="description"\n    class="po-gauge-description-text po-gauge-description-upper-text"\n    [p-tooltip]="tooltip"\n    (mouseenter)="verifyIfHasEllipsis()"\n  >\n    {{ description }}\n  </p>\n</ng-template>\n\n<ng-template #percentageDescription>\n  <div class="po-gauge-description-bottom" tabindex="0" [style.width.px]="descriptionWidth">\n    <p *ngIf="isValidValue" class="po-gauge-description-bottom-value">{{ value }}%</p>\n    <p\n      #descriptionText\n      *ngIf="description"\n      class="po-gauge-description-text po-gauge-description-bottom-text"\n      [p-tooltip]="tooltip"\n      (mouseenter)="verifyIfHasEllipsis()"\n    >\n      {{ description }}\n    </p>\n  </div>\n</ng-template>\n' }]
  }], null, { description: [{
    type: Input,
    args: ["p-description"]
  }], hasRanges: [{
    type: Input,
    args: ["p-has-ranges"]
  }], descriptionWidth: [{
    type: Input,
    args: ["p-description-width"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }], descriptionText: [{
    type: ViewChild,
    args: ["descriptionText"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeDescriptionComponent, { className: "PoGaugeDescriptionComponent", filePath: "lib/components/po-gauge/po-gauge-description/po-gauge-description.component.ts", lineNumber: 7 });
})();
var _c0$s = ["descriptionEl"];
var _c1$a = ["legendEl"];
var _c2$3 = ["titleEl"];
var _c3$2 = ["svgEl"];
var PoGaugeComponent = class _PoGaugeComponent extends PoGaugeBaseComponent {
  colorService;
  changeDetector;
  descriptionEl;
  legendEl;
  titleEl;
  svgEl;
  svgContainer;
  isLoaded = false;
  constructor(colorService, changeDetector) {
    super(colorService);
    this.colorService = colorService;
    this.changeDetector = changeDetector;
  }
  get hasElementRef() {
    return !!this.svgEl?.nativeElement.offsetWidth;
  }
  get hasRanges() {
    return this.ranges.length > 0;
  }
  ngDoCheck() {
    if (!this.isLoaded && this.hasElementRef) {
      this.isLoaded = true;
      this.svgContainerSize();
    }
  }
  svgContainerSize() {
    if (this.svgEl?.nativeElement.offsetWidth) {
      this.changeDetector.detectChanges();
      const titleHeight = this.titleEl.nativeElement?.offsetHeight ?? 0;
      const legendHeight = this.legendEl.nativeElement?.offsetHeight ?? 0;
      const descriptionHeight = this.descriptionEl.nativeElement?.offsetHeight ?? 0;
      const height = this.height - titleHeight - legendHeight - descriptionHeight - PoGaugePadding * 2;
      const width = this.svgEl.nativeElement.offsetWidth;
      this.svgContainer = { width, height };
    }
  }
  static ɵfac = function PoGaugeComponent_Factory(t) {
    return new (t || _PoGaugeComponent)(ɵɵdirectiveInject(PoColorService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGaugeComponent, selectors: [["po-gauge"]], viewQuery: function PoGaugeComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$s, 5, ElementRef);
      ɵɵviewQuery(_c1$a, 5, ElementRef);
      ɵɵviewQuery(_c2$3, 5, ElementRef);
      ɵɵviewQuery(_c3$2, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.descriptionEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.legendEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.svgEl = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 9, vars: 11, consts: [[1, "po-gauge-wrapper"], [3, "p-title"], ["titleEl", ""], [3, "p-description", "p-description-width", "p-has-ranges", "p-value"], ["descriptionEl", ""], [3, "p-container", "p-ranges", "p-value"], ["svgEl", ""], [3, "p-ranges"], ["legendEl", ""]], template: function PoGaugeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵelement(1, "po-gauge-title", 1, 2)(3, "po-gauge-description", 3, 4)(5, "po-gauge-svg", 5, 6)(7, "po-gauge-legend", 7, 8);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.height, "px");
      ɵɵadvance();
      ɵɵproperty("p-title", ctx.title);
      ɵɵadvance(2);
      ɵɵproperty("p-description", ctx.description)("p-description-width", ctx.height)("p-has-ranges", ctx.hasRanges)("p-value", ctx.value);
      ɵɵadvance(2);
      ɵɵproperty("p-container", ctx.svgContainer)("p-ranges", ctx.ranges)("p-value", ctx.value);
      ɵɵadvance(2);
      ɵɵproperty("p-ranges", ctx.ranges);
    }
  }, dependencies: [PoGaugeTitleComponent, PoGaugeLegendComponent, PoGaugeSvgComponent, PoGaugeDescriptionComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeComponent, [{
    type: Component,
    args: [{ selector: "po-gauge", template: '<div class="po-gauge-wrapper" [style.height.px]="height">\n  <po-gauge-title #titleEl [p-title]="title"></po-gauge-title>\n\n  <po-gauge-description\n    #descriptionEl\n    [p-description]="description"\n    [p-description-width]="height"\n    [p-has-ranges]="hasRanges"\n    [p-value]="value"\n  ></po-gauge-description>\n\n  <po-gauge-svg #svgEl [p-container]="svgContainer" [p-ranges]="ranges" [p-value]="value"></po-gauge-svg>\n\n  <po-gauge-legend #legendEl [p-ranges]="ranges"> </po-gauge-legend>\n</div>\n' }]
  }], () => [{ type: PoColorService }, { type: ChangeDetectorRef }], { descriptionEl: [{
    type: ViewChild,
    args: ["descriptionEl", { read: ElementRef }]
  }], legendEl: [{
    type: ViewChild,
    args: ["legendEl", { read: ElementRef }]
  }], titleEl: [{
    type: ViewChild,
    args: ["titleEl", { read: ElementRef }]
  }], svgEl: [{
    type: ViewChild,
    args: ["svgEl", { read: ElementRef }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGaugeComponent, { className: "PoGaugeComponent", filePath: "lib/components/po-gauge/po-gauge.component.ts", lineNumber: 32 });
})();
var PoGaugeModule = class _PoGaugeModule {
  static ɵfac = function PoGaugeModule_Factory(t) {
    return new (t || _PoGaugeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoGaugeModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGaugeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoTooltipModule],
      declarations: [
        PoGaugeComponent,
        PoGaugeTitleComponent,
        PoGaugeLegendComponent,
        PoGaugeSvgComponent,
        PoGaugePathComponent,
        PoGaugeDescriptionComponent,
        PoGaugePointerComponent
      ],
      exports: [PoGaugeComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoGaugeModule, { declarations: [
    PoGaugeComponent,
    PoGaugeTitleComponent,
    PoGaugeLegendComponent,
    PoGaugeSvgComponent,
    PoGaugePathComponent,
    PoGaugeDescriptionComponent,
    PoGaugePointerComponent
  ], imports: [CommonModule, PoTooltipModule], exports: [PoGaugeComponent] });
})();
var PoGridCellActionComponent = class _PoGridCellActionComponent {
  position = "";
  value;
  constructor() {
  }
  onKeyDownContent(event) {
    if (event.keyCode === 13) {
      event.preventDefault();
    }
  }
  static ɵfac = function PoGridCellActionComponent_Factory(t) {
    return new (t || _PoGridCellActionComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGridCellActionComponent, selectors: [["po-grid-cell-action"]], inputs: { position: [InputFlags.None, "p-position", "position"], value: [InputFlags.None, "p-value", "value"] }, decls: 5, vars: 2, consts: [["tabindex", "0", 1, "po-grid-cell-action-content", 3, "id", "keydown"], ["contentElement", ""]], template: function PoGridCellActionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div")(1, "div", 0, 1);
      ɵɵlistener("keydown", function PoGridCellActionComponent_Template_div_keydown_1_listener($event) {
        return ctx.onKeyDownContent($event);
      });
      ɵɵelementStart(3, "span");
      ɵɵtext(4);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("id", ctx.position);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.value || " ");
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridCellActionComponent, [{
    type: Component,
    args: [{ selector: "po-grid-cell-action", template: `<div>
  <div
    #contentElement
    [id]="position"
    class="po-grid-cell-action-content"
    tabindex="0"
    (keydown)="onKeyDownContent($event)"
  >
    <span>{{ value || '&nbsp;' }}</span>
  </div>
</div>
` }]
  }], () => [], { position: [{
    type: Input,
    args: ["p-position"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridCellActionComponent, { className: "PoGridCellActionComponent", filePath: "lib/components/po-grid/po-grid-cell-action/po-grid-cell-action.component.ts", lineNumber: 7 });
})();
var _c0$r = ["inputElement"];
var _c1$9 = ["contentElement"];
function PoGridCellComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridCellComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3, 4);
    ɵɵlistener("keydown", function PoGridCellComponent_ng_template_2_Template_div_keydown_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.onKeyDownContent($event));
    })("dblclick", function PoGridCellComponent_ng_template_2_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.dblclick($event));
    });
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMapInterpolate2("po-grid-cell-content po-grid-cell-", ctx_r1.align, " ", !ctx_r1.value && ctx_r1.required ? "po-grid-cell-required" : "", "");
    ɵɵpropertyInterpolate("tabindex", ctx_r1.readonly ? -1 : 0);
    ɵɵproperty("id", ctx_r1.position);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r1.value || " ");
  }
}
function PoGridCellComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 5, 6);
    ɵɵtwoWayListener("ngModelChange", function PoGridCellComponent_ng_template_4_Template_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r10.editValue, $event) || (ctx_r10.editValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("keydown.arrowup", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowup_0_listener($event) {
      return $event.stopPropagation();
    })("keydown.arrowdown", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowdown_0_listener($event) {
      return $event.stopPropagation();
    })("keydown.arrowleft", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowleft_0_listener($event) {
      return $event.stopPropagation();
    })("keydown.arrowright", function PoGridCellComponent_ng_template_4_Template_input_keydown_arrowright_0_listener($event) {
      return $event.stopPropagation();
    })("keydown", function PoGridCellComponent_ng_template_4_Template_input_keydown_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.onKeyDownInput($event));
    })("blur", function PoGridCellComponent_ng_template_4_Template_input_blur_0_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r17 = ɵɵnextContext();
      return ɵɵresetView(ctx_r17.onBlurInput());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r3.position);
    ɵɵtwoWayProperty("ngModel", ctx_r3.editValue);
  }
}
var PoGridCellComponent = class _PoGridCellComponent {
  changeDetectorRef;
  align = "left";
  freeze = false;
  tabIndex = -1;
  position = "";
  readonly = false;
  required = false;
  valueChange = new EventEmitter();
  inputElement;
  contentElement;
  _value = "";
  edit = false;
  editValue = "";
  _width;
  set width(value) {
    this._width = value;
    if (this.freeze && !this._width) {
      this._width = 100;
    }
  }
  get width() {
    return this._width ? `${this._width}px` : "100%";
  }
  set value(value) {
    this._value = value;
    this.valueChange.emit(this._value);
  }
  get value() {
    return this._value;
  }
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
  }
  onKeyDownContent(event) {
    if (!event.ctrlKey && (event.keyCode === 8 || event.keyCode === 46)) {
      if (this.readonly) {
        return;
      }
      event.preventDefault();
      this.value = "";
      return;
    }
    if (event.keyCode === 13) {
      event.preventDefault();
      this.onEditCell(this.value);
      return;
    }
    if (event.keyCode >= 65 && event.keyCode <= 90 || event.keyCode >= 48 && event.keyCode <= 57) {
      event.preventDefault();
      this.onEditCell(event.key);
    }
  }
  dblclick(event) {
    event.preventDefault();
    this.onEditCell(this.value);
  }
  onBlurInput() {
    this.value = this.editValue;
    this.editValue = void 0;
    this.edit = false;
  }
  onKeyDownInput(event) {
    if (event.keyCode === 13) {
      event.target.blur();
      this.changeDetectorRef.detectChanges();
      this.contentElement.nativeElement.focus();
    }
    if (event.keyCode === 27) {
      this.editValue = void 0;
      this.edit = false;
      this.changeDetectorRef.detectChanges();
      this.contentElement.nativeElement.focus();
      event.stopPropagation();
    }
  }
  onEditCell(value) {
    if (this.readonly) {
      return;
    }
    this.editValue = value;
    this.edit = true;
    this.changeDetectorRef.detectChanges();
    this.inputElement.nativeElement.focus();
  }
  static ɵfac = function PoGridCellComponent_Factory(t) {
    return new (t || _PoGridCellComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGridCellComponent, selectors: [["po-grid-cell"]], viewQuery: function PoGridCellComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$r, 5);
      ɵɵviewQuery(_c1$9, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentElement = _t.first);
    }
  }, inputs: { align: [InputFlags.None, "p-align", "align"], freeze: [InputFlags.None, "p-freeze", "freeze"], tabIndex: [InputFlags.None, "p-tab-index", "tabIndex"], position: [InputFlags.None, "p-position", "position"], readonly: [InputFlags.None, "p-readonly", "readonly"], required: [InputFlags.None, "p-required", "required"], width: [InputFlags.None, "p-width", "width"], value: [InputFlags.None, "p-value", "value"] }, outputs: { valueChange: "p-valueChange" }, decls: 6, vars: 3, consts: [[4, "ngIf", "ngIfThen", "ngIfElse"], ["content", ""], ["input", ""], [3, "id", "tabindex", "keydown", "dblclick"], ["contentElement", ""], [1, "po-grid-cell-input", 3, "id", "ngModel", "ngModelChange", "keydown.arrowup", "keydown.arrowdown", "keydown.arrowleft", "keydown.arrowright", "keydown", "blur"], ["inputElement", ""]], template: function PoGridCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div");
      ɵɵtemplate(1, PoGridCellComponent_ng_container_1_Template, 1, 0, "ng-container", 0)(2, PoGridCellComponent_ng_template_2_Template, 4, 7, "ng-template", null, 1, ɵɵtemplateRefExtractor)(4, PoGridCellComponent_ng_template_4_Template, 2, 2, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(3);
      const _r4 = ɵɵreference(5);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.edit)("ngIfThen", _r4)("ngIfElse", _r2);
    }
  }, dependencies: [NgIf, DefaultValueAccessor, NgControlStatus, NgModel], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridCellComponent, [{
    type: Component,
    args: [{ selector: "po-grid-cell", template: `<div>
  <ng-container *ngIf="edit; then input; else content"></ng-container>

  <ng-template #content>
    <div
      #contentElement
      [id]="position"
      class="po-grid-cell-content po-grid-cell-{{ align }} {{ !value && required ? 'po-grid-cell-required' : '' }}"
      (keydown)="onKeyDownContent($event)"
      tabindex="{{ readonly ? -1 : 0 }}"
      (dblclick)="dblclick($event)"
    >
      <span>{{ value || '&nbsp;' }}</span>
    </div>
  </ng-template>

  <ng-template #input>
    <input
      [id]="position"
      #inputElement
      class="po-grid-cell-input"
      [(ngModel)]="editValue"
      (keydown.arrowup)="$event.stopPropagation()"
      (keydown.arrowdown)="$event.stopPropagation()"
      (keydown.arrowleft)="$event.stopPropagation()"
      (keydown.arrowright)="$event.stopPropagation()"
      (keydown)="onKeyDownInput($event)"
      (blur)="onBlurInput()"
    />
  </ng-template>
</div>
` }]
  }], () => [{ type: ChangeDetectorRef }], { align: [{
    type: Input,
    args: ["p-align"]
  }], freeze: [{
    type: Input,
    args: ["p-freeze"]
  }], tabIndex: [{
    type: Input,
    args: ["p-tab-index"]
  }], position: [{
    type: Input,
    args: ["p-position"]
  }], readonly: [{
    type: Input,
    args: ["p-readonly"]
  }], required: [{
    type: Input,
    args: ["p-required"]
  }], valueChange: [{
    type: Output,
    args: ["p-valueChange"]
  }], inputElement: [{
    type: ViewChild,
    args: ["inputElement"]
  }], contentElement: [{
    type: ViewChild,
    args: ["contentElement"]
  }], width: [{
    type: Input,
    args: ["p-width"]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridCellComponent, { className: "PoGridCellComponent", filePath: "lib/components/po-grid/po-grid-cell/po-grid-cell.component.ts", lineNumber: 7 });
})();
var PoGridHeadComponent = class _PoGridHeadComponent {
  align = "left";
  boolean = false;
  position = "";
  tabIndex = -1;
  title;
  _width;
  set width(value) {
    this._width = value;
  }
  get width() {
    return this._width ? `${this._width}px` : "100%";
  }
  static ɵfac = function PoGridHeadComponent_Factory(t) {
    return new (t || _PoGridHeadComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGridHeadComponent, selectors: [["po-grid-head"]], inputs: { align: [InputFlags.None, "p-align", "align"], boolean: [InputFlags.None, "p-freeze", "boolean"], position: [InputFlags.None, "p-position", "position"], tabIndex: [InputFlags.None, "p-tab-index", "tabIndex"], title: [InputFlags.None, "p-title", "title"], width: [InputFlags.None, "p-width", "width"] }, decls: 4, vars: 6, consts: [[3, "id", "tabindex"]], template: function PoGridHeadComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div")(1, "div", 0)(2, "span");
      ɵɵtext(3);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵclassMapInterpolate1("po-grid-head-content po-grid-head-", ctx.align, "");
      ɵɵpropertyInterpolate("tabindex", ctx.title ? 0 : -1);
      ɵɵproperty("id", ctx.position);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.title || " ");
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridHeadComponent, [{
    type: Component,
    args: [{ selector: "po-grid-head", template: `<div>
  <div [id]="position" class="po-grid-head-content po-grid-head-{{ align }}" tabindex="{{ title ? 0 : -1 }}">
    <span>{{ title || '&nbsp;' }}</span>
  </div>
</div>
` }]
  }], null, { align: [{
    type: Input,
    args: ["p-align"]
  }], boolean: [{
    type: Input,
    args: ["p-freeze"]
  }], position: [{
    type: Input,
    args: ["p-position"]
  }], tabIndex: [{
    type: Input,
    args: ["p-tab-index"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], width: [{
    type: Input,
    args: ["p-width"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridHeadComponent, { className: "PoGridHeadComponent", filePath: "lib/components/po-grid/po-grid-head/po-grid-head.component.ts", lineNumber: 7 });
})();
var _c0$q = ["table"];
var _c1$8 = ["wrapper"];
function PoGridComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelement(2, "br");
    ɵɵtext(3);
    ɵɵelement(4, "br");
    ɵɵtext(5);
    ɵɵelement(6, "br")(7, "hr");
    ɵɵtext(8);
    ɵɵpipe(9, "json");
    ɵɵelement(10, "hr");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate2(" lastCell: ", ctx_r1.lastCell, " | currencyCell: ", ctx_r1.currencyCell, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate2(" lastRow: ", ctx_r1.lastRow, " | currencyRow: ", ctx_r1.currencyRow, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate2(" lastColumn: ", ctx_r1.lastColumn, " | currencyColumn: ", ctx_r1.currencyColumn, " ");
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" currencyObj: ", ɵɵpipeBind1(9, 7, ctx_r1.currencyObj), " ");
  }
}
function PoGridComponent_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 14);
    ɵɵtemplate(1, PoGridComponent_div_7_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r7 = ɵɵreference(12);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r7);
  }
}
function PoGridComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridComponent_div_10_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoGridComponent_div_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, PoGridComponent_div_10_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r11 = ɵɵreference(16);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r11);
  }
}
function PoGridComponent_ng_template_11_po_grid_head_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-head", 21);
  }
  if (rf & 2) {
    const column_r16 = ctx.$implicit;
    const i_r17 = ctx.index;
    ɵɵstyleProp("width", column_r16.cssWidth)("max-width", column_r16.cssWidth)("min-width", column_r16.cssWidth);
    ɵɵpropertyInterpolate("p-position", "0-" + i_r17);
    ɵɵproperty("p-width", column_r16.width)("p-align", column_r16.align)("p-title", column_r16.label);
  }
}
function PoGridComponent_ng_template_11_div_5_po_grid_cell_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-grid-cell", 24);
    ɵɵtwoWayListener("p-valueChange", function PoGridComponent_ng_template_11_div_5_po_grid_cell_1_Template_po_grid_cell_p_valueChange_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r25);
      const column_r21 = restoredCtx.$implicit;
      const row_r18 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(row_r18[column_r21.property], $event) || (row_r18[column_r21.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r21 = ctx.$implicit;
    const i_r22 = ctx.index;
    const ctx_r26 = ɵɵnextContext();
    const j_r19 = ctx_r26.index;
    const row_r18 = ctx_r26.$implicit;
    ɵɵstyleProp("width", column_r21.cssWidth)("max-width", column_r21.cssWidth)("min-width", column_r21.cssWidth);
    ɵɵpropertyInterpolate("p-position", j_r19 + 1 + "-" + i_r22);
    ɵɵproperty("p-align", column_r21.align)("p-readonly", column_r21.readonly)("p-required", column_r21.required)("p-width", column_r21.width);
    ɵɵtwoWayProperty("p-value", row_r18[column_r21.property]);
  }
}
function PoGridComponent_ng_template_11_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22);
    ɵɵlistener("keydown.control.delete", function PoGridComponent_ng_template_11_div_5_Template_div_keydown_control_delete_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r28);
      const row_r18 = restoredCtx.$implicit;
      const ctx_r27 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r27.removeRow($event, row_r18));
    })("keydown.esc", function PoGridComponent_ng_template_11_div_5_Template_div_keydown_esc_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r28);
      const row_r18 = restoredCtx.$implicit;
      const ctx_r29 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r29.cancelRow($event, row_r18));
    });
    ɵɵtemplate(1, PoGridComponent_ng_template_11_div_5_po_grid_cell_1_Template, 1, 12, "po-grid-cell", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r15 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r15.freezeColumns);
  }
}
function PoGridComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16)(1, "div", 17)(2, "div", 18);
    ɵɵtemplate(3, PoGridComponent_ng_template_11_po_grid_head_3_Template, 1, 10, "po-grid-head", 19);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 4);
    ɵɵtemplate(5, PoGridComponent_ng_template_11_div_5_Template, 2, 1, "div", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r6.freezeColumns);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r6.data);
  }
}
function PoGridComponent_ng_template_13_po_grid_head_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-head", 27);
  }
  if (rf & 2) {
    const column_r32 = ctx.$implicit;
    const i_r33 = ctx.index;
    const ctx_r30 = ɵɵnextContext(2);
    ɵɵstyleProp("width", column_r32.cssWidth)("max-width", column_r32.cssWidth)("min-width", column_r32.cssWidth);
    ɵɵpropertyInterpolate("p-position", "0-" + (i_r33 + ctx_r30.freezeColumns.length));
    ɵɵproperty("p-align", column_r32.align)("p-title", column_r32.label)("p-width", column_r32.width);
  }
}
function PoGridComponent_ng_template_13_div_5_po_grid_cell_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r41 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-grid-cell", 29);
    ɵɵtwoWayListener("p-valueChange", function PoGridComponent_ng_template_13_div_5_po_grid_cell_1_Template_po_grid_cell_p_valueChange_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r41);
      const column_r37 = restoredCtx.$implicit;
      const row_r34 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(row_r34[column_r37.property], $event) || (row_r34[column_r37.property] = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r37 = ctx.$implicit;
    const i_r38 = ctx.index;
    const ctx_r42 = ɵɵnextContext();
    const j_r35 = ctx_r42.index;
    const row_r34 = ctx_r42.$implicit;
    const ctx_r36 = ɵɵnextContext(2);
    ɵɵstyleProp("width", column_r37.cssWidth)("max-width", column_r37.cssWidth)("min-width", column_r37.cssWidth);
    ɵɵpropertyInterpolate("p-position", j_r35 + 1 + "-" + (i_r38 + ctx_r36.freezeColumns.length));
    ɵɵproperty("p-align", column_r37.align)("p-readonly", column_r37.readonly)("p-required", column_r37.required);
    ɵɵtwoWayProperty("p-value", row_r34[column_r37.property]);
    ɵɵproperty("p-width", column_r37.width);
  }
}
function PoGridComponent_ng_template_13_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r44 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22);
    ɵɵlistener("keydown.control.delete", function PoGridComponent_ng_template_13_div_5_Template_div_keydown_control_delete_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r44);
      const row_r34 = restoredCtx.$implicit;
      const ctx_r43 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r43.removeRow($event, row_r34));
    })("keydown.esc", function PoGridComponent_ng_template_13_div_5_Template_div_keydown_esc_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r44);
      const row_r34 = restoredCtx.$implicit;
      const ctx_r45 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r45.cancelRow($event, row_r34));
    });
    ɵɵtemplate(1, PoGridComponent_ng_template_13_div_5_po_grid_cell_1_Template, 1, 12, "po-grid-cell", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r31 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r31.columns);
  }
}
function PoGridComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25)(1, "div", 17)(2, "div", 18);
    ɵɵtemplate(3, PoGridComponent_ng_template_13_po_grid_head_3_Template, 1, 10, "po-grid-head", 26);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 4);
    ɵɵtemplate(5, PoGridComponent_ng_template_13_div_5_Template, 2, 1, "div", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r8.columns);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r8.data);
  }
}
function PoGridComponent_ng_template_15_po_grid_head_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-head", 32);
  }
  if (rf & 2) {
    const column_r48 = ctx.$implicit;
    const i_r49 = ctx.index;
    const ctx_r46 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate("p-position", "0-" + (i_r49 + ctx_r46.freezeColumns.length + ctx_r46.columns.length));
    ɵɵproperty("p-title", column_r48.label)("p-align", column_r48.align);
  }
}
function PoGridComponent_ng_template_15_div_5_po_grid_cell_action_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-grid-cell-action", 34);
  }
  if (rf & 2) {
    const column_r53 = ctx.$implicit;
    const i_r54 = ctx.index;
    const ctx_r55 = ɵɵnextContext();
    const j_r51 = ctx_r55.index;
    const row_r50 = ctx_r55.$implicit;
    const ctx_r52 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate("p-position", j_r51 + 1 + "-" + (i_r54 + ctx_r52.freezeColumns.length + ctx_r52.columns.length));
    ɵɵproperty("p-value", row_r50[column_r53.property]);
  }
}
function PoGridComponent_ng_template_15_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r57 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 22);
    ɵɵlistener("keydown.control.delete", function PoGridComponent_ng_template_15_div_5_Template_div_keydown_control_delete_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r57);
      const row_r50 = restoredCtx.$implicit;
      const ctx_r56 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r56.removeRow($event, row_r50));
    })("keydown.esc", function PoGridComponent_ng_template_15_div_5_Template_div_keydown_esc_0_listener($event) {
      const restoredCtx = ɵɵrestoreView(_r57);
      const row_r50 = restoredCtx.$implicit;
      const ctx_r58 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r58.cancelRow($event, row_r50));
    });
    ɵɵtemplate(1, PoGridComponent_ng_template_15_div_5_po_grid_cell_action_1_Template, 1, 2, "po-grid-cell-action", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r47 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r47.actionColumns);
  }
}
function PoGridComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30)(1, "div", 17)(2, "div", 18);
    ɵɵtemplate(3, PoGridComponent_ng_template_15_po_grid_head_3_Template, 1, 3, "po-grid-head", 31);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "div", 4);
    ɵɵtemplate(5, PoGridComponent_ng_template_15_div_5_Template, 2, 1, "div", 20);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r10.actionColumns);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r10.data);
  }
}
var PoGridComponent = class _PoGridComponent {
  changeDetectorRef;
  elRef;
  tableElement;
  tableWrapper;
  /**
   * @description
   *
   * Ações disparadas quando uma linha do grid é manipulada.
   */
  rowActions = {};
  /**
   * Lista com os dados que serão exibidos no grid.
   */
  data = [];
  lastCell = "0-0";
  lastRow = 0;
  lastColumn = 0;
  currencyCell = "0-0";
  currencyRow = 0;
  currencyColumn = 0;
  currencyObj;
  logger = false;
  width = "100%";
  widporeeze = 0;
  widthActions = 0;
  resizeListener;
  timeoutResize;
  _columns = [];
  /**
   * Colunas exibidas no grid.
   */
  set columns(value) {
    this._columns = [...value];
    this._columns.forEach((column) => {
      column.label = column.label || column.property;
      if (column.freeze === true) {
        column.cssWidth = `${column.width || 100}px`;
      } else {
        column.cssWidth = column.width ? `${column.width}px` : "100%";
      }
    });
  }
  get columns() {
    return this._columns.filter((column) => column.freeze !== true && column.action !== true);
  }
  constructor(changeDetectorRef, elRef, renderer) {
    this.changeDetectorRef = changeDetectorRef;
    this.elRef = elRef;
    this.debounceResize();
    this.resizeListener = renderer.listen("window", "resize", (event) => {
      this.debounceResize();
    });
  }
  ngOnDestroy() {
    if (this.resizeListener) {
      this.resizeListener();
    }
  }
  get freezeColumns() {
    const freezeColumns = this._columns.filter((column) => column.freeze === true);
    this.widporeeze = freezeColumns.reduce((prev, current) => prev + (current.width || 100), 0);
    return freezeColumns;
  }
  get actionColumns() {
    const actionsColumns = this._columns.filter((column) => column.action === true);
    this.widthActions = actionsColumns.length > 0 ? 56 : 0;
    return actionsColumns;
  }
  cancelRow(event, row) {
    const el = this.getEventPath(event).find((element) => element.id);
    if (!el) {
      return;
    }
    const [x] = el.id.split("-");
    if (this.isEmptyRow(x)) {
      if (!this.removeRow(event, row)) {
        return;
      }
      this.currencyObj = Object.assign({}, this.data[this.currencyRow - 1]);
    } else {
      this.data[+x - 1] = Object.assign({}, this.currencyObj);
      setTimeout(() => this.selectCell(this.currencyRow, this.currencyColumn));
    }
  }
  removeRow(event, row) {
    if (this.rowActions.beforeRemove && !this.rowActions.beforeRemove(Object.assign({}, row))) {
      return false;
    }
    const index = this.data.indexOf(row);
    this.data.splice(index, 1);
    this.changeDetectorRef.detectChanges();
    if (this.data.length === 0 || index === this.data.length) {
      this.selectCell(this.currencyRow - 1, this.currencyColumn);
    } else {
      this.selectCell(this.currencyRow, this.currencyColumn);
    }
    return true;
  }
  tableKeydown(event, direction) {
    let [row, col] = event.target.id.split("-");
    row = +row;
    col = +col;
    let prow = +row;
    let pcol = +col;
    if (direction === "down") {
      if (row <= this.data.length) {
        prow++;
      }
      if (row === this.data.length) {
        if (row === 0 || !this.isEmptyRow(row)) {
          if (this.saveRow(row)) {
            if (!this.insertRow()) {
              return;
            }
          } else {
            return;
          }
        } else {
          prow--;
        }
      }
    } else if (direction === "up" && row > 0) {
      prow--;
    } else if (direction === "left" && col > 0) {
      pcol--;
    } else if (direction === "right" && col < this._columns.length - 1) {
      pcol++;
    } else if (direction === "next") {
      if (col < this._columns.length - 1) {
        pcol++;
        event.preventDefault();
      } else if (row < this.data.length) {
        pcol = 0;
        prow++;
        event.preventDefault();
      }
    } else if (direction === "prior") {
      if (col > 0) {
        pcol--;
        event.preventDefault();
      } else if (row > 0) {
        pcol = this._columns.length - 1;
        prow--;
        event.preventDefault();
      }
    }
    if (this.currencyCell === `${prow}-${pcol}`) {
      return;
    }
    if (prow !== this.currencyRow && row > 0 && this.data.length >= row) {
      if (!this.isEmptyRow(row)) {
        if (!this.saveRow(row)) {
          return;
        }
      } else {
        if (!this.removeRow(event, row)) {
          return;
        }
      }
    }
    if (this.currencyRow !== prow) {
      this.currencyObj = Object.assign({}, this.data[prow - 1]);
    }
    this.lastCell = event.target.id;
    this.lastRow = row;
    this.lastColumn = col;
    this.selectCell(prow, pcol);
  }
  tableClick(event) {
    const el = this.getEventPath(event).find((element) => element.id);
    if (!el) {
      this.selectCell(this.currencyRow, this.currencyColumn);
      return;
    }
    if (this.currencyCell === el.id) {
      return;
    }
    const [row, col] = el.id.split("-");
    const prow = +row;
    const pcol = +col;
    if (prow !== this.currencyRow) {
      if (this.currencyRow > 0) {
        if (!this.isEmptyRow(this.currencyRow)) {
          if (!this.saveRow(this.currencyRow)) {
            this.selectCell(this.currencyRow, this.currencyColumn);
            return;
          }
        } else {
          if (!this.removeRow(event, row)) {
            return;
          }
        }
      }
      this.currencyObj = Object.assign({}, this.data[prow - 1]);
    }
    this.lastCell = this.currencyCell;
    this.lastRow = this.currencyRow;
    this.lastColumn = this.currencyColumn;
    this.currencyCell = el.id;
    this.currencyRow = prow;
    this.currencyColumn = pcol;
  }
  saveRow(row) {
    const obj = this.data[row - 1];
    if (!Object.keys(obj).some((prop) => obj[prop] !== this.currencyObj[prop])) {
      return true;
    }
    if (this.rowActions.beforeSave && !this.rowActions.beforeSave(obj, this.currencyObj)) {
      return false;
    }
    const requireds = [];
    this.columns.forEach((column) => {
      if (column.required === true && !obj[column.property]) {
        requireds.push(column.property);
      }
    });
    return requireds.length === 0;
  }
  insertRow() {
    const obj = {};
    if (this.rowActions.beforeInsert && !this.rowActions.beforeInsert(obj)) {
      return false;
    }
    this.data.push(obj);
    this.changeDetectorRef.detectChanges();
    return true;
  }
  isEmptyRow(row) {
    const obj = this.data[row - 1];
    if (!obj) {
      return false;
    }
    const filled = Object.keys(obj).some((property) => obj[property]);
    return !filled;
  }
  selectCell(row, col) {
    const nextCell = this.elRef.nativeElement.querySelector(`[id='${row}-${col}']`);
    if (nextCell) {
      this.currencyCell = `${row}-${col}`;
      this.currencyRow = row;
      this.currencyColumn = col;
      nextCell.focus();
    }
  }
  debounceResize() {
    clearTimeout(this.timeoutResize);
    this.timeoutResize = setTimeout(() => {
      const widthTableWrapper = this.tableWrapper.nativeElement.offsetWidth;
      this.width = `${widthTableWrapper - (this.widporeeze + 8) - this.widthActions}px`;
    }, 100);
  }
  getEventPath(event) {
    return event.path || event.composedPath();
  }
  static ɵfac = function PoGridComponent_Factory(t) {
    return new (t || _PoGridComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoGridComponent, selectors: [["po-grid"]], viewQuery: function PoGridComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$q, 7);
      ɵɵviewQuery(_c1$8, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tableWrapper = _t.first);
    }
  }, inputs: { rowActions: [InputFlags.None, "p-row-actions", "rowActions"], data: [InputFlags.None, "p-data", "data"], columns: [InputFlags.None, "p-columns", "columns"] }, decls: 17, vars: 10, consts: [[1, "po-grid-wrapper", "po-grid-row-wrapper"], ["wrapper", ""], [4, "ngIf"], [1, "po-grid"], [1, "po-grid-body"], [1, "po-grid-row", 3, "keydown.arrowup", "keydown.arrowdown", "keydown.arrowleft", "keydown.arrowright", "keydown.tab", "keydown.shift.tab", "click", "contextmenu", "dblclick"], ["table", ""], ["class", "po-grid-cell po-grid-cell-freeze", 4, "ngIf"], [1, "po-grid-cell", "po-grid-cell-normal"], [4, "ngTemplateOutlet"], ["class", "po-grid-cell po-grid-cell-action", 4, "ngIf"], ["divFreezeColumns", ""], ["divColumns", ""], ["divActionColumns", ""], [1, "po-grid-cell", "po-grid-cell-freeze"], [1, "po-grid-cell", "po-grid-cell-action"], [1, "po-grid", "po-grid-freeze"], [1, "po-grid-header-group"], [1, "po-grid-row"], ["class", "po-grid-title", "p-freeze", "true", 3, "width", "max-width", "min-width", "p-position", "p-width", "p-align", "p-title", 4, "ngFor", "ngForOf"], ["class", "po-grid-row", 3, "keydown.control.delete", "keydown.esc", 4, "ngFor", "ngForOf"], ["p-freeze", "true", 1, "po-grid-title", 3, "p-position", "p-width", "p-align", "p-title"], [1, "po-grid-row", 3, "keydown.control.delete", "keydown.esc"], ["class", "po-grid-cell", "p-freeze", "true", 3, "width", "max-width", "min-width", "p-align", "p-readonly", "p-required", "p-position", "p-width", "p-value", "p-valueChange", 4, "ngFor", "ngForOf"], ["p-freeze", "true", 1, "po-grid-cell", 3, "p-align", "p-readonly", "p-required", "p-position", "p-width", "p-value", "p-valueChange"], [1, "po-grid", "po-grid-normal"], ["class", "po-grid-title", 3, "width", "max-width", "min-width", "p-align", "p-position", "p-title", "p-width", 4, "ngFor", "ngForOf"], [1, "po-grid-title", 3, "p-align", "p-position", "p-title", "p-width"], ["class", "po-grid-cell", 3, "width", "max-width", "min-width", "p-align", "p-readonly", "p-required", "p-position", "p-value", "p-width", "p-valueChange", 4, "ngFor", "ngForOf"], [1, "po-grid-cell", 3, "p-align", "p-readonly", "p-required", "p-position", "p-value", "p-width", "p-valueChange"], [1, "po-grid", "po-grid-actions"], ["class", "po-grid-title", 3, "p-position", "p-title", "p-align", 4, "ngFor", "ngForOf"], [1, "po-grid-title", 3, "p-position", "p-title", "p-align"], ["class", "po-grid-cell", 3, "p-position", "p-value", 4, "ngFor", "ngForOf"], [1, "po-grid-cell", 3, "p-position", "p-value"]], template: function PoGridComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵtemplate(2, PoGridComponent_div_2_Template, 11, 9, "div", 2);
      ɵɵelementStart(3, "div", 3)(4, "div", 4)(5, "div", 5, 6);
      ɵɵlistener("keydown.arrowup", function PoGridComponent_Template_div_keydown_arrowup_5_listener($event) {
        return ctx.tableKeydown($event, "up");
      })("keydown.arrowdown", function PoGridComponent_Template_div_keydown_arrowdown_5_listener($event) {
        return ctx.tableKeydown($event, "down");
      })("keydown.arrowleft", function PoGridComponent_Template_div_keydown_arrowleft_5_listener($event) {
        return ctx.tableKeydown($event, "left");
      })("keydown.arrowright", function PoGridComponent_Template_div_keydown_arrowright_5_listener($event) {
        return ctx.tableKeydown($event, "right");
      })("keydown.tab", function PoGridComponent_Template_div_keydown_tab_5_listener($event) {
        return ctx.tableKeydown($event, "next");
      })("keydown.shift.tab", function PoGridComponent_Template_div_keydown_shift_tab_5_listener($event) {
        return ctx.tableKeydown($event, "prior");
      })("click", function PoGridComponent_Template_div_click_5_listener($event) {
        return ctx.tableClick($event);
      })("contextmenu", function PoGridComponent_Template_div_contextmenu_5_listener($event) {
        return ctx.tableClick($event);
      })("dblclick", function PoGridComponent_Template_div_dblclick_5_listener($event) {
        return ctx.tableClick($event);
      });
      ɵɵtemplate(7, PoGridComponent_div_7_Template, 2, 1, "div", 7);
      ɵɵelementStart(8, "div", 8);
      ɵɵtemplate(9, PoGridComponent_ng_container_9_Template, 1, 0, "ng-container", 9);
      ɵɵelementEnd();
      ɵɵtemplate(10, PoGridComponent_div_10_Template, 2, 1, "div", 10);
      ɵɵelementEnd()()()();
      ɵɵtemplate(11, PoGridComponent_ng_template_11_Template, 6, 2, "ng-template", null, 11, ɵɵtemplateRefExtractor)(13, PoGridComponent_ng_template_13_Template, 6, 2, "ng-template", null, 12, ɵɵtemplateRefExtractor)(15, PoGridComponent_ng_template_15_Template, 6, 2, "ng-template", null, 13, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r9 = ɵɵreference(14);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.logger);
      ɵɵadvance(5);
      ɵɵproperty("ngIf", ctx.freezeColumns.length > 0);
      ɵɵadvance();
      ɵɵstyleProp("width", ctx.width)("max-width", ctx.width)("min-width", ctx.width);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", _r9);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.actionColumns.length > 0);
    }
  }, dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoGridCellActionComponent, PoGridCellComponent, PoGridHeadComponent, JsonPipe], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridComponent, [{
    type: Component,
    args: [{ selector: "po-grid", template: `<div class="po-grid-wrapper po-grid-row-wrapper" #wrapper>
  <div *ngIf="logger">
    lastCell: {{ lastCell }} | currencyCell: {{ currencyCell }} <br />
    lastRow: {{ lastRow }} | currencyRow: {{ currencyRow }} <br />
    lastColumn: {{ lastColumn }} | currencyColumn: {{ currencyColumn }} <br />
    <hr />
    currencyObj: {{ currencyObj | json }}
    <hr />
  </div>

  <div class="po-grid">
    <div class="po-grid-body">
      <div
        class="po-grid-row"
        #table
        (keydown.arrowup)="tableKeydown($event, 'up')"
        (keydown.arrowdown)="tableKeydown($event, 'down')"
        (keydown.arrowleft)="tableKeydown($event, 'left')"
        (keydown.arrowright)="tableKeydown($event, 'right')"
        (keydown.tab)="tableKeydown($event, 'next')"
        (keydown.shift.tab)="tableKeydown($event, 'prior')"
        (click)="tableClick($event)"
        (contextmenu)="tableClick($event)"
        (dblclick)="tableClick($event)"
      >
        <div class="po-grid-cell po-grid-cell-freeze" *ngIf="freezeColumns.length > 0">
          <ng-container *ngTemplateOutlet="divFreezeColumns"></ng-container>
        </div>

        <div
          class="po-grid-cell po-grid-cell-normal"
          [style.width]="width"
          [style.max-width]="width"
          [style.min-width]="width"
        >
          <ng-container *ngTemplateOutlet="divColumns"></ng-container>
        </div>

        <div class="po-grid-cell po-grid-cell-action" *ngIf="actionColumns.length > 0">
          <ng-container *ngTemplateOutlet="divActionColumns"></ng-container>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Coluna com as colunas congeladas -->
<ng-template #divFreezeColumns>
  <div class="po-grid po-grid-freeze">
    <div class="po-grid-header-group">
      <div class="po-grid-row">
        <po-grid-head
          *ngFor="let column of freezeColumns; index as i"
          class="po-grid-title"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          p-freeze="true"
          p-position="{{ '0-' + i }}"
          [p-width]="column.width"
          [p-align]="column.align"
          [p-title]="column.label"
        >
        </po-grid-head>
      </div>
    </div>

    <div class="po-grid-body">
      <div
        class="po-grid-row"
        *ngFor="let row of data; index as j"
        (keydown.control.delete)="removeRow($event, row)"
        (keydown.esc)="cancelRow($event, row)"
      >
        <po-grid-cell
          *ngFor="let column of freezeColumns; index as i"
          class="po-grid-cell"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          p-freeze="true"
          [p-align]="column.align"
          [p-readonly]="column.readonly"
          [p-required]="column.required"
          p-position="{{ j + 1 + '-' + i }}"
          [p-width]="column.width"
          [(p-value)]="row[column.property]"
        >
        </po-grid-cell>
      </div>
    </div>
  </div>
</ng-template>
<!-- FIM: Coluna com as colunas congeladas -->

<!-- Coluna com as colunas nornais -->
<ng-template #divColumns>
  <div class="po-grid po-grid-normal">
    <div class="po-grid-header-group">
      <div class="po-grid-row">
        <po-grid-head
          *ngFor="let column of columns; index as i"
          class="po-grid-title"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          [p-align]="column.align"
          p-position="{{ '0-' + (i + freezeColumns.length) }}"
          [p-title]="column.label"
          [p-width]="column.width"
        >
        </po-grid-head>
      </div>
    </div>

    <div class="po-grid-body">
      <div
        class="po-grid-row"
        *ngFor="let row of data; index as j"
        (keydown.control.delete)="removeRow($event, row)"
        (keydown.esc)="cancelRow($event, row)"
      >
        <po-grid-cell
          *ngFor="let column of columns; index as i"
          class="po-grid-cell"
          [style.width]="column.cssWidth"
          [style.max-width]="column.cssWidth"
          [style.min-width]="column.cssWidth"
          [p-align]="column.align"
          [p-readonly]="column.readonly"
          [p-required]="column.required"
          p-position="{{ j + 1 + '-' + (i + freezeColumns.length) }}"
          [(p-value)]="row[column.property]"
          [p-width]="column.width"
        >
        </po-grid-cell>
      </div>
    </div>
  </div>
</ng-template>
<!-- FIM: Coluna com as colunas nornais -->

<!-- Coluna com as colunas de ação -->
<ng-template #divActionColumns>
  <div class="po-grid po-grid-actions">
    <div class="po-grid-header-group">
      <div class="po-grid-row">
        <po-grid-head
          *ngFor="let column of actionColumns; index as i"
          class="po-grid-title"
          p-position="{{ '0-' + (i + freezeColumns.length + columns.length) }}"
          [p-title]="column.label"
          [p-align]="column.align"
        >
        </po-grid-head>
      </div>
    </div>

    <div class="po-grid-body">
      <div
        class="po-grid-row"
        *ngFor="let row of data; index as j"
        (keydown.control.delete)="removeRow($event, row)"
        (keydown.esc)="cancelRow($event, row)"
      >
        <po-grid-cell-action
          *ngFor="let column of actionColumns; index as i"
          class="po-grid-cell"
          p-position="{{ j + 1 + '-' + (i + freezeColumns.length + columns.length) }}"
          [p-value]="row[column.property]"
        >
        </po-grid-cell-action>
      </div>
    </div>
  </div>
</ng-template>
<!-- FIM: Coluna com as colunas de ação -->
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: ElementRef }, { type: Renderer2 }], { tableElement: [{
    type: ViewChild,
    args: ["table", { static: true }]
  }], tableWrapper: [{
    type: ViewChild,
    args: ["wrapper", { static: true }]
  }], rowActions: [{
    type: Input,
    args: ["p-row-actions"]
  }], data: [{
    type: Input,
    args: ["p-data"]
  }], columns: [{
    type: Input,
    args: ["p-columns"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoGridComponent, { className: "PoGridComponent", filePath: "lib/components/po-grid/po-grid.component.ts", lineNumber: 38 });
})();
var PoGridModule = class _PoGridModule {
  static ɵfac = function PoGridModule_Factory(t) {
    return new (t || _PoGridModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoGridModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoFieldModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, PoFieldModule],
      declarations: [PoGridCellActionComponent, PoGridCellComponent, PoGridComponent, PoGridHeadComponent],
      exports: [PoGridComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoGridModule, { declarations: [PoGridCellActionComponent, PoGridCellComponent, PoGridComponent, PoGridHeadComponent], imports: [CommonModule, FormsModule, PoFieldModule], exports: [PoGridComponent] });
})();
var poListViewLiteralsDefault = {
  en: {
    hideDetails: "Hide details",
    loadMoreData: "Load more data",
    noData: "No data found",
    selectAll: "Select all",
    showDetails: "Show details"
  },
  es: {
    hideDetails: "Ocultar detalles",
    loadMoreData: "Cargar más resultados",
    noData: "Datos no encontrados",
    selectAll: "Seleccionar todos",
    showDetails: "Mostrar detalles"
  },
  pt: {
    hideDetails: "Ocultar detalhes",
    loadMoreData: "Carregar mais resultados",
    noData: "Nenhum dado encontrado",
    selectAll: "Selecionar todos",
    showDetails: "Exibir detalhes"
  },
  ru: {
    hideDetails: "Скрыть детали",
    loadMoreData: "Загрузить больше результатов",
    noData: "Данные не найдены",
    selectAll: "Выбрать все",
    showDetails: "Посмотреть детали"
  }
};
var PoListViewBaseComponent = class _PoListViewBaseComponent {
  /** Recebe uma propriedade que será utilizada para recuperar o valor do objeto que será usado como link para o título. */
  propertyLink;
  /** Recebe uma propriedade que será utilizada para recuperar o valor do objeto que será exibido como o título de cada item. */
  propertyTitle;
  /**
   * @optional
   *
   * @description
   *
   * Recebe uma ação, que será executada quando clicar no botão "Carregar mais resultados".
   *
   * > Caso nenhuma ação for definida o mesmo não ficará visível.
   */
  showMore = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada ao clicar no título.
   *
   * Ao ser disparado, o método inserido na ação irá receber como parâmetro o item da lista clicado.
   */
  titleAction = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada ao clicar no botão exibir detalhes.
   *
   * Ao ser disparado, o método passa como parâmetros os detalhes que serão exibidos.
   */
  showDetail = new EventEmitter();
  popupTarget;
  selectAll = false;
  showHeader = false;
  _actions;
  _height;
  _hideSelectAll;
  _items;
  _literals;
  _select;
  _showMoreDisabled;
  language = poLocaleDefault;
  /**
   * @optional
   *
   * @description
   *
   * Lista de ações que serão exibidas no componente.
   */
  set actions(value) {
    this._actions = Array.isArray(value) ? value : [];
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do `po-list-view` em *pixels*.
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * @description
   *
   * Esconde o *checkbox* para seleção de todos os itens.
   *
   * @default `false`
   */
  set hideSelectAll(hideSelectAll) {
    this._hideSelectAll = convertToBoolean(hideSelectAll);
    this.showMainHeader();
  }
  get hideSelectAll() {
    return this._hideSelectAll;
  }
  /** Lista de itens que serão exibidos no componente. */
  set items(value) {
    this._items = Array.isArray(value) ? value : [];
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-list-view`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoListViewLiterals = {
   *    hideDetail: 'Ocultar detalhes completamente',
   *    loadMoreData: 'Mais dados',
   *    showDetail: 'Mostrar mais detalhes',
   *    selectAll: 'Selecionar todos os itens'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoListViewLiterals = {
   *    showDetail: 'Mostrar mais detalhes'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-list-view
   *   [p-literals]="customLiterals">
   * </po-list-view>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poListViewLiteralsDefault[poLocaleDefault]), poListViewLiteralsDefault[this.language]), value);
    } else {
      this._literals = poListViewLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poListViewLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita um *checkbox* para cada item da lista. Todos os items possuem a propriedade dinâmica `$selected` para identificar se o
   * item está selecionado, por exemplo:
   *
   * ```
   *  item.$selected
   *
   *  // ou
   *
   *  item['$selected']
   * ```
   *
   * @default `false`
   */
  set select(select) {
    this._select = convertToBoolean(select);
    this.showMainHeader();
  }
  get select() {
    return this._select;
  }
  /**
   * @optional
   *
   * @description
   *
   * Indica que o botão `Carregar Mais Resultados` será desabilitado.
   */
  set showMoreDisabled(value) {
    this._showMoreDisabled = convertToBoolean(value);
  }
  get showMoreDisabled() {
    return this._showMoreDisabled;
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  onClickAction(listViewAction, item) {
    const cleanItem = this.deleteInternalAttrs(item);
    if (listViewAction.action) {
      listViewAction.action(cleanItem);
    }
  }
  onShowMore() {
    this.showMore.emit();
  }
  runTitleAction(listItem) {
    const itemWithPublicProperties = this.deleteInternalAttrs(listItem);
    this.titleAction.emit(itemWithPublicProperties);
  }
  selectAllListItems() {
    if (!this.hideSelectAll) {
      this.selectAll = !this.selectAll;
      this.items.forEach((item) => {
        item.$selected = this.selectAll;
      });
    }
  }
  selectListItem(row) {
    row.$selected = !row.$selected;
    this.selectAll = this.checkIfItemsAreSelected(this.items);
  }
  deleteInternalAttrs(item) {
    const itemCopy = item ? __spreadValues({}, item) : void 0;
    for (const key in itemCopy) {
      if (itemCopy.hasOwnProperty(key) && key.startsWith("$")) {
        delete itemCopy[key];
      }
    }
    return itemCopy;
  }
  checkIfItemsAreSelected(items) {
    const someCheckedOrIndeterminate = (item) => item.$selected || item.$selected === null;
    const everyChecked = (item) => item.$selected;
    if (items.every(everyChecked)) {
      return true;
    }
    if (items.some(someCheckedOrIndeterminate)) {
      return null;
    }
    return false;
  }
  showMainHeader() {
    this.showHeader = !!(this.select && !this.hideSelectAll && this.items && this.items.length);
  }
  static ɵfac = function PoListViewBaseComponent_Factory(t) {
    return new (t || _PoListViewBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoListViewBaseComponent, inputs: { propertyLink: [InputFlags.None, "p-property-link", "propertyLink"], propertyTitle: [InputFlags.None, "p-property-title", "propertyTitle"], actions: [InputFlags.None, "p-actions", "actions"], height: [InputFlags.None, "p-height", "height"], hideSelectAll: [InputFlags.None, "p-hide-select-all", "hideSelectAll"], items: [InputFlags.None, "p-items", "items"], literals: [InputFlags.None, "p-literals", "literals"], select: [InputFlags.None, "p-select", "select"], showMoreDisabled: [InputFlags.None, "p-show-more-disabled", "showMoreDisabled"] }, outputs: { showMore: "p-show-more", titleAction: "p-title-action", showDetail: "p-show-detail" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { propertyLink: [{
    type: Input,
    args: ["p-property-link"]
  }], propertyTitle: [{
    type: Input,
    args: ["p-property-title"]
  }], showMore: [{
    type: Output,
    args: ["p-show-more"]
  }], titleAction: [{
    type: Output,
    args: ["p-title-action"]
  }], showDetail: [{
    type: Output,
    args: ["p-show-detail"]
  }], actions: [{
    type: Input,
    args: ["p-actions"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], hideSelectAll: [{
    type: Input,
    args: ["p-hide-select-all"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], select: [{
    type: Input,
    args: ["p-select"]
  }], showMoreDisabled: [{
    type: Input,
    args: ["p-show-more-disabled"]
  }] });
})();
var PoListViewContentTemplateDirective = class _PoListViewContentTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Função que deve retornar um valor do tipo `string`, que será utilizado como o título de cada item da lista.
   *
   * > Por parâmetro será enviado o item corrente, onde poderá utilizá-lo para recuperar dados sobre o mesmo.
   */
  title;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoListViewContentTemplateDirective_Factory(t) {
    return new (t || _PoListViewContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoListViewContentTemplateDirective, selectors: [["", "p-list-view-content-template", ""]], inputs: { title: [InputFlags.None, "p-title", "title"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-list-view-content-template]"
    }]
  }], () => [{ type: TemplateRef }], { title: [{
    type: Input,
    args: ["p-title"]
  }] });
})();
var PoListViewDetailTemplateDirective = class _PoListViewDetailTemplateDirective {
  templateRef;
  /**
   * @optional
   *
   * @description
   *
   * Função que deve retornar um valor do tipo `boolean`, que será utilizado como a validação para que o detalhe de item
   * da lista inicie aberto ou fechado.
   *
   */
  showDetail;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoListViewDetailTemplateDirective_Factory(t) {
    return new (t || _PoListViewDetailTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoListViewDetailTemplateDirective, selectors: [["", "p-list-view-detail-template", ""]], inputs: { showDetail: [InputFlags.None, "p-show-detail", "showDetail"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewDetailTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-list-view-detail-template]"
    }]
  }], () => [{ type: TemplateRef }], { showDetail: [{
    type: Input,
    args: ["p-show-detail"]
  }] });
})();
var _c0$p = ["popup"];
function PoListViewComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7)(1, "div", 8)(2, "div", 9)(3, "po-checkbox", 10);
    ɵɵtwoWayListener("ngModelChange", function PoListViewComponent_div_1_Template_po_checkbox_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r5.selectAll, $event) || (ctx_r5.selectAll = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoListViewComponent_div_1_Template_po_checkbox_p_change_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.selectAllListItems());
    })("click", function PoListViewComponent_div_1_Template_po_checkbox_click_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.selectAllListItems());
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵtwoWayProperty("ngModel", ctx_r0.selectAll);
    ɵɵproperty("p-label", ctx_r0.literals.selectAll);
  }
}
function PoListViewComponent_po_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 11)(1, "div", 12)(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-no-padding", true);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.literals.noData, " ");
  }
}
function PoListViewComponent_ng_container_4_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 25)(1, "po-checkbox", 26);
    ɵɵtwoWayListener("ngModelChange", function PoListViewComponent_ng_container_4_div_5_Template_po_checkbox_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r22);
      const item_r9 = ɵɵnextContext().$implicit;
      ɵɵtwoWayBindingSet(item_r9.$selected, $event) || (item_r9.$selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoListViewComponent_ng_container_4_div_5_Template_po_checkbox_p_change_1_listener() {
      ɵɵrestoreView(_r22);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r23 = ɵɵnextContext();
      return ɵɵresetView(ctx_r23.selectListItem(item_r9));
    })("click", function PoListViewComponent_ng_container_4_div_5_Template_po_checkbox_click_1_listener() {
      ɵɵrestoreView(_r22);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r25 = ɵɵnextContext();
      return ɵɵresetView(ctx_r25.selectListItem(item_r9));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r9 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtwoWayProperty("ngModel", item_r9.$selected);
  }
}
function PoListViewComponent_ng_container_4_a_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r30 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 27);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_a_6_Template_a_click_0_listener() {
      ɵɵrestoreView(_r30);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r28 = ɵɵnextContext();
      return ɵɵresetView(ctx_r28.runTitleAction(item_r9));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r9 = ɵɵnextContext().$implicit;
    const ctx_r12 = ɵɵnextContext();
    ɵɵproperty("href", item_r9[ctx_r12.propertyLink], ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r12.getItemTitle(item_r9), " ");
  }
}
function PoListViewComponent_ng_container_4_a_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 28);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_a_7_Template_a_click_0_listener() {
      ɵɵrestoreView(_r34);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r32 = ɵɵnextContext();
      return ɵɵresetView(ctx_r32.runTitleAction(item_r9));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r9 = ɵɵnextContext().$implicit;
    const ctx_r13 = ɵɵnextContext();
    ɵɵproperty("routerLink", item_r9[ctx_r13.propertyLink]);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r13.getItemTitle(item_r9), " ");
  }
}
function PoListViewComponent_ng_container_4_span_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 29);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_span_8_Template_span_click_0_listener() {
      ɵɵrestoreView(_r37);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r36 = ɵɵnextContext();
      return ɵɵresetView(ctx_r36.titleHasAction && ctx_r36.runTitleAction(item_r9));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r9 = ɵɵnextContext().$implicit;
    const ctx_r14 = ɵɵnextContext();
    ɵɵclassProp("po-list-view-title-link", ctx_r14.titleHasAction);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r14.getItemTitle(item_r9), " ");
  }
}
function PoListViewComponent_ng_container_4_div_9_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r43 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 32);
    ɵɵlistener("p-click", function PoListViewComponent_ng_container_4_div_9_po_button_1_Template_po_button_p_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r43);
      const action_r41 = restoredCtx.$implicit;
      const item_r9 = ɵɵnextContext(2).$implicit;
      const ctx_r42 = ɵɵnextContext();
      return ɵɵresetView(ctx_r42.onClickAction(action_r41, item_r9));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r41 = ctx.$implicit;
    const item_r9 = ɵɵnextContext(2).$implicit;
    const ctx_r40 = ɵɵnextContext();
    ɵɵproperty("p-disabled", ctx_r40.returnBooleanValue(action_r41, item_r9, "disabled"))("p-icon", action_r41.icon)("p-label", action_r41.label)("p-danger", action_r41.type === "danger");
  }
}
function PoListViewComponent_ng_container_4_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30);
    ɵɵtemplate(1, PoListViewComponent_ng_container_4_div_9_po_button_1_Template, 1, 4, "po-button", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r15 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r15.visibleActions);
  }
}
function PoListViewComponent_ng_container_4_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r49 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 33)(1, "span", 34, 35);
    ɵɵlistener("click", function PoListViewComponent_ng_container_4_div_10_Template_span_click_1_listener() {
      ɵɵrestoreView(_r49);
      const _r46 = ɵɵreference(2);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r47 = ɵɵnextContext();
      return ɵɵresetView(ctx_r47.togglePopup(item_r9, _r46));
    });
    ɵɵelementEnd()();
  }
}
function PoListViewComponent_ng_container_4_div_11_ng_template_1_Template(rf, ctx) {
}
var _c1$7 = (a0, a1) => ({ $implicit: a0, index: a1 });
function PoListViewComponent_ng_container_4_div_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 36);
    ɵɵtemplate(1, PoListViewComponent_ng_container_4_div_11_ng_template_1_Template, 0, 0, "ng-template", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r51 = ɵɵnextContext();
    const item_r9 = ctx_r51.$implicit;
    const index_r10 = ctx_r51.index;
    const ctx_r17 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r17.listViewContentTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c1$7, item_r9, index_r10));
  }
}
function PoListViewComponent_ng_container_4_div_12_ng_template_1_Template(rf, ctx) {
}
function PoListViewComponent_ng_container_4_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r55 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 38);
    ɵɵlistener("@showHideDetail.start", function PoListViewComponent_ng_container_4_div_12_Template_div_animation_showHideDetail_start_0_listener($event) {
      ɵɵrestoreView(_r55);
      const item_r9 = ɵɵnextContext().$implicit;
      const ctx_r53 = ɵɵnextContext();
      return ɵɵresetView(item_r9.$showDetail ? ctx_r53.onAnimationEvent($event, item_r9) : "undefined");
    });
    ɵɵtemplate(1, PoListViewComponent_ng_container_4_div_12_ng_template_1_Template, 0, 0, "ng-template", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r56 = ɵɵnextContext();
    const item_r9 = ctx_r56.$implicit;
    const index_r10 = ctx_r56.index;
    const ctx_r18 = ɵɵnextContext();
    ɵɵproperty("@showHideDetail", void 0);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r18.listViewDetailTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c1$7, item_r9, index_r10));
  }
}
function PoListViewComponent_ng_container_4_div_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r59 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 39)(1, "po-button", 40);
    ɵɵlistener("p-click", function PoListViewComponent_ng_container_4_div_13_Template_po_button_p_click_1_listener() {
      ɵɵrestoreView(_r59);
      const item_r9 = ɵɵnextContext().$implicit;
      return ɵɵresetView(item_r9.$showDetail = !item_r9.$showDetail);
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r9 = ɵɵnextContext().$implicit;
    const ctx_r19 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-label", item_r9.$showDetail ? ctx_r19.literals.hideDetails : ctx_r19.literals.showDetails);
  }
}
function PoListViewComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-container", 11)(2, "div", 13)(3, "div", 14)(4, "div", 15);
    ɵɵtemplate(5, PoListViewComponent_ng_container_4_div_5_Template, 2, 1, "div", 16)(6, PoListViewComponent_ng_container_4_a_6_Template, 2, 2, "a", 17)(7, PoListViewComponent_ng_container_4_a_7_Template, 2, 2, "a", 18)(8, PoListViewComponent_ng_container_4_span_8_Template, 2, 3, "span", 19);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoListViewComponent_ng_container_4_div_9_Template, 2, 1, "div", 20)(10, PoListViewComponent_ng_container_4_div_10_Template, 3, 0, "div", 21);
    ɵɵelementEnd();
    ɵɵtemplate(11, PoListViewComponent_ng_container_4_div_11_Template, 2, 5, "div", 22)(12, PoListViewComponent_ng_container_4_div_12_Template, 2, 6, "div", 23);
    ɵɵelementEnd();
    ɵɵtemplate(13, PoListViewComponent_ng_container_4_div_13_Template, 2, 1, "div", 24);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r9 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-no-padding", true);
    ɵɵadvance(3);
    ɵɵproperty("ngSwitch", ctx_r2.checkTitleType(item_r9));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.select);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "externalLink");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "internalLink");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "noLink");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showButtonsActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showPopupActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.hasContentTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.hasDetailTemplate && item_r9.$showDetail);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.hasDetailTemplate);
  }
}
function PoListViewComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r62 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 41)(1, "po-button", 42);
    ɵɵlistener("p-click", function PoListViewComponent_div_5_Template_po_button_p_click_1_listener() {
      ɵɵrestoreView(_r62);
      const ctx_r61 = ɵɵnextContext();
      return ɵɵresetView(ctx_r61.onShowMore());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-disabled", ctx_r3.showMoreDisabled)("p-label", ctx_r3.literals.loadMoreData);
  }
}
var PoListViewComponent = class _PoListViewComponent extends PoListViewBaseComponent {
  changeDetector;
  listViewContentTemplate;
  listViewDetailTemplate;
  poPopupComponent;
  differ;
  constructor(changeDetector, differs, languageService) {
    super(languageService);
    this.changeDetector = changeDetector;
    this.differ = differs.find([]).create(null);
  }
  get hasContentTemplate() {
    return !!this.listViewContentTemplate;
  }
  get hasDetailTemplate() {
    return !!this.listViewDetailTemplate;
  }
  get displayShowMoreButton() {
    return this.items && this.items.length > 0 && this.showMore.observers.length > 0;
  }
  get showButtonsActions() {
    return this.visibleActions && this.visibleActions.length > 0 && this.visibleActions.length <= 2;
  }
  get showPopupActions() {
    return this.visibleActions && this.visibleActions.length > 2;
  }
  get titleHasAction() {
    return this.titleAction.observers.length > 0;
  }
  get visibleActions() {
    return this.actions && this.actions.filter((action) => this.returnBooleanValue(action, action.visible, "visible") !== false);
  }
  ngAfterContentInit() {
    this.initShowDetail();
  }
  ngDoCheck() {
    this.checkItemsChange();
  }
  checkTitleType(item) {
    if (this.propertyLink && item[this.propertyLink]) {
      return item[this.propertyLink].startsWith("http") ? "externalLink" : "internalLink";
    }
    return "noLink";
  }
  getItemTitle(item) {
    return this.hasContentTemplate && this.listViewContentTemplate.title ? this.listViewContentTemplate.title(item) : item[this.propertyTitle];
  }
  hasItems() {
    return this.items && this.items.length > 0;
  }
  returnBooleanValue(listViewAction, item, property) {
    return isTypeof(listViewAction[property], "function") ? listViewAction[property](item) : listViewAction[property];
  }
  trackBy(index) {
    return index;
  }
  togglePopup(item, targetRef) {
    this.popupTarget = targetRef;
    this.changeDetector.detectChanges();
    this.poPopupComponent.toggle(item);
  }
  onAnimationEvent(event, detail) {
    this.showDetail.emit(detail);
  }
  checkItemsChange() {
    const changesItems = this.differ.diff(this.items);
    if (changesItems && this.selectAll) {
      this.selectAll = null;
    }
    if (changesItems && this.items && this.items.length && this.select && !this.hideSelectAll) {
      this.showHeader = true;
    }
  }
  initShowDetail() {
    if (this.items && this.items.length > 0 && this.hasDetailTemplate && this.listViewDetailTemplate.showDetail) {
      this.items.forEach((item) => item.$showDetail = this.listViewDetailTemplate.showDetail(item));
    }
  }
  static ɵfac = function PoListViewComponent_Factory(t) {
    return new (t || _PoListViewComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoListViewComponent, selectors: [["po-list-view"]], contentQueries: function PoListViewComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoListViewContentTemplateDirective, 7);
      ɵɵcontentQuery(dirIndex, PoListViewDetailTemplateDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listViewContentTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listViewDetailTemplate = _t.first);
    }
  }, viewQuery: function PoListViewComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$p, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPopupComponent = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 8, vars: 13, consts: [["class", "po-list-view-main-header", 4, "ngIf"], [1, "po-list-view-main-content"], [3, "p-no-padding", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-mb-2 po-text-center", 4, "ngIf"], [3, "p-actions", "p-target"], ["popup", ""], [1, "po-list-view-main-header"], [1, "po-checkbox-group-item"], [1, "po-list-view-main-select"], ["name", "selectAll", 3, "ngModel", "p-label", "ngModelChange", "p-change", "click"], [3, "p-no-padding"], [1, "po-list-view-container-no-data", "po-text-center"], [1, "po-list-view-container"], [1, "po-list-view-header"], [1, "po-list-view-title", 3, "ngSwitch"], ["class", "po-list-view-select", 4, "ngIf"], ["class", "po-list-view-title-link", "target", "_blank", 3, "href", "click", 4, "ngSwitchCase"], ["class", "po-list-view-title-link", 3, "routerLink", "click", 4, "ngSwitchCase"], ["class", "po-list-view-title-no-link", 3, "po-list-view-title-link", "click", 4, "ngSwitchCase"], ["class", "po-list-view-actions", 4, "ngIf"], ["class", "po-list-view-more-actions", 4, "ngIf"], ["class", "po-list-view-content", 4, "ngIf"], ["class", "po-list-view-detail", 4, "ngIf"], ["class", "po-list-view-detail-button", 4, "ngIf"], [1, "po-list-view-select"], ["name", "checkbox", 3, "ngModel", "ngModelChange", "p-change", "click"], ["target", "_blank", 1, "po-list-view-title-link", 3, "href", "click"], [1, "po-list-view-title-link", 3, "routerLink", "click"], [1, "po-list-view-title-no-link", 3, "click"], [1, "po-list-view-actions"], [3, "p-disabled", "p-icon", "p-label", "p-danger", "p-click", 4, "ngFor", "ngForOf"], [3, "p-disabled", "p-icon", "p-label", "p-danger", "p-click"], [1, "po-list-view-more-actions"], [1, "po-icon", "po-icon-more", "po-list-view-more-icon", "po-clickable", 3, "click"], ["popupTarget", ""], [1, "po-list-view-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-list-view-detail"], [1, "po-list-view-detail-button"], ["p-kind", "tertiary", 3, "p-label", "p-click"], [1, "po-mb-2", "po-text-center"], [3, "p-disabled", "p-label", "p-click"]], template: function PoListViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div");
      ɵɵtemplate(1, PoListViewComponent_div_1_Template, 4, 2, "div", 0);
      ɵɵelementStart(2, "div", 1);
      ɵɵtemplate(3, PoListViewComponent_po_container_3_Template, 4, 2, "po-container", 2)(4, PoListViewComponent_ng_container_4_Template, 14, 11, "ng-container", 3);
      ɵɵelementEnd()();
      ɵɵtemplate(5, PoListViewComponent_div_5_Template, 2, 2, "div", 4);
      ɵɵelement(6, "po-popup", 5, 6);
    }
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.height, "px");
      ɵɵclassProp("po-list-view-main-container-header", ctx.showHeader)("po-list-view-main-container", !ctx.showHeader);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHeader);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.hasItems());
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.items)("ngForTrackBy", ctx.trackBy);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.displayShowMoreButton);
      ɵɵadvance();
      ɵɵproperty("p-actions", ctx.actions)("p-target", ctx.popupTarget);
    }
  }, dependencies: [NgForOf, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgControlStatus, NgModel, RouterLink, PoButtonComponent, PoPopupComponent, PoCheckboxComponent, PoContainerComponent], encapsulation: 2, data: { animation: [
    trigger("showHideDetail", [
      state("*", style({ "overflow-y": "visible" })),
      state("void", style({ "overflow-y": "hidden" })),
      transition("* => void", [style({ height: "*", "overflow-y": "hidden" }), animate(100, style({ height: 0 }))]),
      transition("void => *", [style({ height: "0" }), animate(100, style({ height: "*" }))])
    ])
  ] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewComponent, [{
    type: Component,
    args: [{ selector: "po-list-view", animations: [
      trigger("showHideDetail", [
        state("*", style({ "overflow-y": "visible" })),
        state("void", style({ "overflow-y": "hidden" })),
        transition("* => void", [style({ height: "*", "overflow-y": "hidden" }), animate(100, style({ height: 0 }))]),
        transition("void => *", [style({ height: "0" }), animate(100, style({ height: "*" }))])
      ])
    ], template: `<div
  [class.po-list-view-main-container-header]="showHeader"
  [class.po-list-view-main-container]="!showHeader"
  [style.height.px]="height"
>
  <div *ngIf="showHeader" class="po-list-view-main-header">
    <div class="po-checkbox-group-item">
      <div class="po-list-view-main-select">
        <po-checkbox
          name="selectAll"
          [(ngModel)]="selectAll"
          [p-label]="literals.selectAll"
          (p-change)="selectAllListItems()"
          (click)="selectAllListItems()"
        ></po-checkbox>
      </div>
    </div>
  </div>

  <div class="po-list-view-main-content">
    <po-container [p-no-padding]="true" *ngIf="!hasItems()">
      <div class="po-list-view-container-no-data po-text-center">
        <span> {{ literals.noData }} </span>
      </div>
    </po-container>

    <ng-container *ngFor="let item of items; let index = index; trackBy: trackBy">
      <po-container [p-no-padding]="true">
        <div class="po-list-view-container">
          <div class="po-list-view-header">
            <div class="po-list-view-title" [ngSwitch]="checkTitleType(item)">
              <div *ngIf="select" class="po-list-view-select">
                <po-checkbox
                  [(ngModel)]="item.$selected"
                  name="checkbox"
                  (p-change)="selectListItem(item)"
                  (click)="selectListItem(item)"
                ></po-checkbox>
              </div>
              <a
                *ngSwitchCase="'externalLink'"
                class="po-list-view-title-link"
                target="_blank"
                [href]="item[propertyLink]"
                (click)="runTitleAction(item)"
              >
                {{ getItemTitle(item) }}
              </a>
              <a
                *ngSwitchCase="'internalLink'"
                class="po-list-view-title-link"
                [routerLink]="item[propertyLink]"
                (click)="runTitleAction(item)"
              >
                {{ getItemTitle(item) }}
              </a>
              <span
                *ngSwitchCase="'noLink'"
                class="po-list-view-title-no-link"
                [class.po-list-view-title-link]="titleHasAction"
                (click)="titleHasAction && runTitleAction(item)"
              >
                {{ getItemTitle(item) }}
              </span>
            </div>

            <div *ngIf="showButtonsActions" class="po-list-view-actions">
              <po-button
                *ngFor="let action of visibleActions"
                [p-disabled]="returnBooleanValue(action, item, 'disabled')"
                [p-icon]="action.icon"
                [p-label]="action.label"
                [p-danger]="action.type === 'danger'"
                (p-click)="onClickAction(action, item)"
              >
              </po-button>
            </div>

            <div *ngIf="showPopupActions" class="po-list-view-more-actions">
              <span
                #popupTarget
                class="po-icon po-icon-more po-list-view-more-icon po-clickable"
                (click)="togglePopup(item, popupTarget)"
              >
              </span>
            </div>
          </div>

          <div *ngIf="hasContentTemplate" class="po-list-view-content">
            <ng-template
              [ngTemplateOutlet]="listViewContentTemplate.templateRef"
              [ngTemplateOutletContext]="{ $implicit: item, index: index }"
            >
            </ng-template>
          </div>

          <div
            @showHideDetail
            (@showHideDetail.start)="item.$showDetail ? onAnimationEvent($event, item) : 'undefined'"
            *ngIf="hasDetailTemplate && item.$showDetail"
            class="po-list-view-detail"
          >
            <ng-template
              [ngTemplateOutlet]="listViewDetailTemplate.templateRef"
              [ngTemplateOutletContext]="{ $implicit: item, index: index }"
            >
            </ng-template>
          </div>
        </div>

        <div *ngIf="hasDetailTemplate" class="po-list-view-detail-button">
          <po-button
            p-kind="tertiary"
            [p-label]="item.$showDetail ? literals.hideDetails : literals.showDetails"
            (p-click)="item.$showDetail = !item.$showDetail"
          >
          </po-button>
        </div>
      </po-container>
    </ng-container>
  </div>
</div>

<div *ngIf="displayShowMoreButton" class="po-mb-2 po-text-center">
  <po-button [p-disabled]="showMoreDisabled" [p-label]="literals.loadMoreData" (p-click)="onShowMore()"> </po-button>
</div>

<po-popup #popup [p-actions]="actions" [p-target]="popupTarget"> </po-popup>
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: IterableDiffers }, { type: PoLanguageService }], { listViewContentTemplate: [{
    type: ContentChild,
    args: [PoListViewContentTemplateDirective, { static: true }]
  }], listViewDetailTemplate: [{
    type: ContentChild,
    args: [PoListViewDetailTemplateDirective, { static: true }]
  }], poPopupComponent: [{
    type: ViewChild,
    args: ["popup", { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoListViewComponent, { className: "PoListViewComponent", filePath: "lib/components/po-list-view/po-list-view.component.ts", lineNumber: 54 });
})();
var PoListViewModule = class _PoListViewModule {
  static ɵfac = function PoListViewModule_Factory(t) {
    return new (t || _PoListViewModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoListViewModule });
  static ɵinj = ɵɵdefineInjector({ imports: [
    CommonModule,
    FormsModule,
    RouterModule,
    PoButtonModule,
    PoPopupModule,
    PoCheckboxModule,
    PoContainerModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoListViewModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        FormsModule,
        RouterModule,
        PoButtonModule,
        PoPopupModule,
        PoCheckboxModule,
        PoContainerModule
      ],
      declarations: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective],
      exports: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoListViewModule, { declarations: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective], imports: [
    CommonModule,
    FormsModule,
    RouterModule,
    PoButtonModule,
    PoPopupModule,
    PoCheckboxModule,
    PoContainerModule
  ], exports: [PoListViewComponent, PoListViewContentTemplateDirective, PoListViewDetailTemplateDirective] });
})();
function PoLogoComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 2);
    ɵɵelement(1, "img", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMap(ctx_r0.className);
    ɵɵproperty("alt", ctx_r0.logoAlt)("src", ctx_r0.logo, ɵɵsanitizeUrl)("title", ctx_r0.logoAlt);
  }
}
function PoLogoComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.className);
    ɵɵproperty("alt", ctx_r1.logoAlt)("src", ctx_r1.logo, ɵɵsanitizeUrl)("title", ctx_r1.logoAlt);
  }
}
var poLogoLiteralsDefault = {
  en: {
    logomarcaHome: "Home logo"
  },
  es: {
    logomarcaHome: "Logomarca inicio"
  },
  pt: {
    logomarcaHome: "Logomarca início"
  },
  ru: {
    logomarcaHome: "Дом Логомарка"
  }
};
var MAX_LENGHT = 125;
var PoLogoComponent = class _PoLogoComponent {
  poLanguageService;
  literals;
  _logo;
  _logoAlt;
  /**
   * Define uma classe para o elemento `img` do componente.
   *
   * > **Importante**
   * > A classe deve ser definida apenas quando houver necessidade de ajustar o componente dentro de outro componente.
   *
   */
  className = "po-logo";
  /**
   * Define se o componente terá o elemento âncora para a página inicial.
   *
   * > Caso seja definido como false, o componente apenas renderizará o elemento `img`.
   * O valor inicial é `true`.
   *
   */
  link = true;
  /**
   * Definie o caminho para a imagem, que será exibida como logomarca.
   *
   */
  set logo(value) {
    this._logo = isTypeof(value, "string") && value.trim() ? value : void 0;
  }
  get logo() {
    return this._logo;
  }
  /**
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   */
  set logoAlt(value) {
    this._logoAlt = isTypeof(value, "string") && value.trim() ? this.maxLength(value) : this.literals.logomarcaHome;
  }
  get logoAlt() {
    return this._logoAlt;
  }
  constructor(poLanguageService) {
    this.poLanguageService = poLanguageService;
    this.literals = __spreadValues(__spreadValues({}, poLogoLiteralsDefault[this.poLanguageService?.getLanguageDefault()]), poLogoLiteralsDefault[this.poLanguageService?.getShortLanguage()]);
    this._logoAlt = this.literals.logomarcaHome;
  }
  maxLength(value) {
    return value.length > MAX_LENGHT ? value.toString().substring(0, MAX_LENGHT) : value;
  }
  static ɵfac = function PoLogoComponent_Factory(t) {
    return new (t || _PoLogoComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoLogoComponent, selectors: [["po-logo"]], inputs: { className: [InputFlags.None, "p-class", "className"], link: [InputFlags.None, "p-link", "link"], logo: [InputFlags.None, "p-logo", "logo"], logoAlt: [InputFlags.None, "p-logo-alt", "logoAlt"] }, decls: 3, vars: 2, consts: [["href", "/", 4, "ngIf", "ngIfElse"], ["noLink", ""], ["href", "/"], [3, "alt", "src", "title"]], template: function PoLogoComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoLogoComponent_a_0_Template, 2, 5, "a", 0)(1, PoLogoComponent_ng_template_1_Template, 1, 5, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.link)("ngIfElse", _r2);
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLogoComponent, [{
    type: Component,
    args: [{ selector: "po-logo", template: '<a *ngIf="link; else noLink" href="/">\n  <img [alt]="logoAlt" [class]="className" [src]="logo" [title]="logoAlt" />\n</a>\n\n<ng-template #noLink>\n  <img [alt]="logoAlt" [class]="className" [src]="logo" [title]="logoAlt" />\n</ng-template>\n' }]
  }], () => [{ type: PoLanguageService }], { className: [{
    type: Input,
    args: ["p-class"]
  }], link: [{
    type: Input,
    args: ["p-link"]
  }], logo: [{
    type: Input,
    args: ["p-logo"]
  }], logoAlt: [{
    type: Input,
    args: ["p-logo-alt"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoLogoComponent, { className: "PoLogoComponent", filePath: "lib/components/po-logo/po-logo.component.ts", lineNumber: 27 });
})();
var PoLogoModule = class _PoLogoModule {
  static ɵfac = function PoLogoModule_Factory(t) {
    return new (t || _PoLogoModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoLogoModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoLogoModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [PoLogoComponent],
      exports: [PoLogoComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoLogoModule, { declarations: [PoLogoComponent], imports: [CommonModule], exports: [PoLogoComponent] });
})();
var PoMenuPanelItemsService = class _PoMenuPanelItemsService {
  subjectChild = new Subject();
  subjectParent = new Subject();
  // Recebe do po-menu-panel-item sua informação de click.
  receiveFromChildMenuClicked() {
    return this.subjectChild.asObservable();
  }
  // Recebe do po-menu-panel as informações processadas do click de um po-menu-panel-item.
  receiveFromParentMenuClicked() {
    return this.subjectParent.asObservable();
  }
  // Envia informações do click do po-menu-panel-item para o po-menu
  sendToParentMenuClicked(menu) {
    this.subjectChild.next(menu);
  }
  // Envia para os po-menu-panel-item a resposta do processamento de click de um po-menu-panel-item.
  sendToChildMenuClicked(menu) {
    this.subjectParent.next(menu);
  }
  static ɵfac = function PoMenuPanelItemsService_Factory(t) {
    return new (t || _PoMenuPanelItemsService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoMenuPanelItemsService, factory: _PoMenuPanelItemsService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelItemsService, [{
    type: Injectable
  }], null, null);
})();
function PoMenuPanelItemComponent_a_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuPanelItemComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 4);
    ɵɵtemplate(1, PoMenuPanelItemComponent_a_0_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const _r4 = ɵɵreference(4);
    ɵɵproperty("routerLink", ctx_r0.menuItemInternal.link);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function PoMenuPanelItemComponent_a_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuPanelItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵtemplate(1, PoMenuPanelItemComponent_a_1_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const _r4 = ɵɵreference(4);
    ɵɵproperty("href", ctx_r1.menuItemInternal.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function PoMenuPanelItemComponent_a_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuPanelItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 7);
    ɵɵtemplate(1, PoMenuPanelItemComponent_a_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r4 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function PoMenuPanelItemComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8);
    ɵɵlistener("click", function PoMenuPanelItemComponent_ng_template_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.clickMenuItem($event));
    });
    ɵɵelement(1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("po-menu-panel-item-selected", ctx_r3.menuItemInternal.isSelected);
    ɵɵproperty("p-tooltip", ctx_r3.menuItemInternal.label);
    ɵɵadvance();
    ɵɵclassMapInterpolate1("po-icon ", ctx_r3.menuItemInternal.icon, "");
  }
}
var PoMenuPanelItemComponent = class _PoMenuPanelItemComponent {
  menuItemsService;
  menuItemInternal;
  itemsSubscription;
  constructor(menuItemsService) {
    this.menuItemsService = menuItemsService;
  }
  ngOnDestroy() {
    this.itemsSubscription.unsubscribe();
  }
  ngOnInit() {
    this.subscribeMenuClickedFromParent();
  }
  clickMenuItem(event) {
    if (!(event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      this.menuItemsService.sendToParentMenuClicked(this.menuItemInternal);
    }
  }
  activateMenu(menu) {
    this.menuItemInternal.isSelected = this.menuItemInternal.id === menu.id;
  }
  processMenuItem(menu) {
    if (this.menuItemInternal.type === "internalLink") {
      this.activateMenu(menu.active);
    }
  }
  subscribeMenuClickedFromParent() {
    this.itemsSubscription = this.menuItemsService.receiveFromParentMenuClicked().subscribe((menu) => {
      this.processMenuItem(menu);
    });
  }
  static ɵfac = function PoMenuPanelItemComponent_Factory(t) {
    return new (t || _PoMenuPanelItemComponent)(ɵɵdirectiveInject(PoMenuPanelItemsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMenuPanelItemComponent, selectors: [["po-menu-panel-item"]], inputs: { menuItemInternal: [InputFlags.None, "p-menu-item-internal", "menuItemInternal"] }, decls: 5, vars: 3, consts: [[3, "routerLink", 4, "ngIf"], [3, "href", 4, "ngIf"], ["href", "javascript:;", 4, "ngIf"], ["menuItemTemplate", ""], [3, "routerLink"], [4, "ngTemplateOutlet"], [3, "href"], ["href", "javascript:;"], ["p-tooltip-position", "right", 1, "po-menu-panel-item", 3, "p-tooltip", "click"]], template: function PoMenuPanelItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoMenuPanelItemComponent_a_0_Template, 2, 2, "a", 0)(1, PoMenuPanelItemComponent_a_1_Template, 2, 2, "a", 1)(2, PoMenuPanelItemComponent_a_2_Template, 2, 1, "a", 2)(3, PoMenuPanelItemComponent_ng_template_3_Template, 2, 6, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.menuItemInternal.type === "internalLink");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItemInternal.type === "externalLink");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItemInternal.type === "noLink");
    }
  }, dependencies: [NgIf, NgTemplateOutlet, RouterLink, PoTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelItemComponent, [{
    type: Component,
    args: [{ selector: "po-menu-panel-item", template: `<!-- menu com link interno -->
<a *ngIf="menuItemInternal.type === 'internalLink'" [routerLink]="menuItemInternal.link">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>

<!-- menu com link externo -->
<a *ngIf="menuItemInternal.type === 'externalLink'" [href]="menuItemInternal.link">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>

<!-- menu sem link -->
<a *ngIf="menuItemInternal.type === 'noLink'" href="javascript:;">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>

<ng-template #menuItemTemplate>
  <div
    class="po-menu-panel-item"
    p-tooltip-position="right"
    [class.po-menu-panel-item-selected]="menuItemInternal.isSelected"
    [p-tooltip]="menuItemInternal.label"
    (click)="clickMenuItem($event)"
  >
    <span class="po-icon {{ menuItemInternal.icon }}"></span>
  </div>
</ng-template>
` }]
  }], () => [{ type: PoMenuPanelItemsService }], { menuItemInternal: [{
    type: Input,
    args: ["p-menu-item-internal"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuPanelItemComponent, { className: "PoMenuPanelItemComponent", filePath: "lib/components/po-menu-panel/po-menu-panel-item/po-menu-panel-item.component.ts", lineNumber: 19 });
})();
var poDefaultLogo = "https://po-ui.io/assets/po-logos/po_black.svg";
var PoMenuPanelBaseComponent = class _PoMenuPanelBaseComponent {
  _menus;
  _logo = poDefaultLogo;
  /** Lista dos itens do `po-menu-panel`. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio. */
  set menus(menus) {
    this._menus = Array.isArray(menus) ? menus : [];
    this.setMenuExtraProperties(this._menus);
    this.validateMenus(this._menus);
  }
  get menus() {
    return this._menus;
  }
  /**
   * @optional
   *
   * @description
   *
   * Caminho para a logomarca localizada na parte superior do menu.
   *
   * > **Importante**
   * > Caso seja indefinida será aplicada a imagem default do PO UI.
   */
  set logo(src) {
    this._logo = src ?? poDefaultLogo;
  }
  get logo() {
    return this._logo;
  }
  /**
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   *
   * @default `Logomarca início`
   */
  logoAlt;
  setMenuExtraProperties(menus) {
    menus.forEach((menuItem) => this.setMenuItemProperties(menuItem));
  }
  setMenuItemProperties(menuItem) {
    menuItem.id = menuItem.id || uuid();
    menuItem.type = this.setMenuType(menuItem);
  }
  setMenuType(menuItem) {
    if (!menuItem.link) {
      return "noLink";
    }
    if (isExternalLink(menuItem.link)) {
      return "externalLink";
    }
    return "internalLink";
  }
  validateMenu(menuItem) {
    if (!menuItem.label) {
      throw new Error("O atributo PoMenuPanelItem.label não pode ser vazio.");
    }
    if (!menuItem.icon) {
      throw new Error("O atributo PoMenuPanelItem.icon não pode ser vazio.");
    }
  }
  validateMenus(menus) {
    menus.forEach((menu) => this.validateMenu(menu));
  }
  static ɵfac = function PoMenuPanelBaseComponent_Factory(t) {
    return new (t || _PoMenuPanelBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoMenuPanelBaseComponent, inputs: { menus: [InputFlags.None, "p-menus", "menus"], logo: [InputFlags.None, "p-logo", "logo"], logoAlt: [InputFlags.None, "p-logo-alt", "logoAlt"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelBaseComponent, [{
    type: Directive
  }], null, { menus: [{
    type: Input,
    args: ["p-menus"]
  }], logo: [{
    type: Input,
    args: ["p-logo"]
  }], logoAlt: [{
    type: Input,
    args: ["p-logo-alt"]
  }] });
})();
function PoMenuPanelComponent_po_logo_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-logo", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-logo", ctx_r0.logo)("p-logo-alt", ctx_r0.logoAlt);
  }
}
function PoMenuPanelComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "po-menu-panel-item", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const menu_r2 = ctx.$implicit;
    const menuIndex_r3 = ctx.index;
    ɵɵadvance();
    ɵɵclassProp("po-menu-panel-item-first", menuIndex_r3 === 0);
    ɵɵproperty("p-menu-item-internal", menu_r2);
  }
}
var PoMenuPanelComponent = class _PoMenuPanelComponent extends PoMenuPanelBaseComponent {
  location;
  menuItemsService;
  router;
  activeMenuItem;
  linkActive;
  routeSubscription;
  itemSubscription;
  constructor(viewRef, location2, menuItemsService, router) {
    super();
    this.location = location2;
    this.menuItemsService = menuItemsService;
    this.router = router;
  }
  ngOnDestroy() {
    this.itemSubscription.unsubscribe();
    this.routeSubscription.unsubscribe();
  }
  ngOnInit() {
    this.subscribeToMenuItem();
    this.subscribeToRoute();
  }
  activateMenuByUrl(urlPath, menus) {
    if (menus) {
      return menus.some((menu) => {
        if (getFormattedLink(menu.link) === urlPath) {
          this.activateMenuItem(menu);
          return true;
        }
      });
    }
  }
  activateMenuItem(menu) {
    this.activeMenuItem = menu;
    this.linkActive = getFormattedLink(menu.link);
    this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, activatedByRoute: true });
  }
  checkActiveMenuByUrl(urlPath) {
    if (!this.linkActive || this.linkActive !== urlPath) {
      this.activateMenuByUrl(urlPath, this.menus);
    }
  }
  clickMenuItem(menu) {
    if (menu.action) {
      menu.action(menu);
    }
    if (menu.type === "externalLink") {
      openExternalLink(menu.link);
    } else if (menu.type === "internalLink") {
      this.activateMenuItem(menu);
    }
  }
  subscribeToRoute() {
    this.routeSubscription = this.router.events.subscribe((rounterEvent) => {
      if (rounterEvent instanceof NavigationEnd) {
        this.checkActiveMenuByUrl(this.location.path());
      }
    });
  }
  subscribeToMenuItem() {
    this.itemSubscription = this.menuItemsService.receiveFromChildMenuClicked().subscribe((menu) => this.clickMenuItem(menu));
  }
  static ɵfac = function PoMenuPanelComponent_Factory(t) {
    return new (t || _PoMenuPanelComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Location), ɵɵdirectiveInject(PoMenuPanelItemsService), ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMenuPanelComponent, selectors: [["po-menu-panel"]], features: [ɵɵInheritDefinitionFeature], decls: 6, vars: 2, consts: [[1, "po-menu-panel"], [1, "po-menu-panel-logo-container"], ["p-class", "po-menu-panel-logo", 3, "p-logo", "p-logo-alt", 4, "ngIf"], [1, "po-menu-panel-container"], [1, "po-menu-panel-inner"], ["class", "po-menu-panel-item-wrapper", 4, "ngFor", "ngForOf"], ["p-class", "po-menu-panel-logo", 3, "p-logo", "p-logo-alt"], [1, "po-menu-panel-item-wrapper"], [3, "p-menu-item-internal"]], template: function PoMenuPanelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, PoMenuPanelComponent_po_logo_2_Template, 1, 2, "po-logo", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "nav", 3)(4, "div", 4);
      ɵɵtemplate(5, PoMenuPanelComponent_div_5_Template, 2, 3, "div", 5);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.logo);
      ɵɵadvance(3);
      ɵɵproperty("ngForOf", ctx.menus);
    }
  }, dependencies: [NgForOf, NgIf, PoLogoComponent, PoMenuPanelItemComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelComponent, [{
    type: Component,
    args: [{ selector: "po-menu-panel", template: '<div class="po-menu-panel">\n  <div class="po-menu-panel-logo-container">\n    <po-logo *ngIf="logo" p-class="po-menu-panel-logo" [p-logo]="logo" [p-logo-alt]="logoAlt"></po-logo>\n  </div>\n\n  <nav class="po-menu-panel-container">\n    <div class="po-menu-panel-inner">\n      <div *ngFor="let menu of menus; let menuIndex = index" class="po-menu-panel-item-wrapper">\n        <po-menu-panel-item\n          [class.po-menu-panel-item-first]="menuIndex === 0"\n          [p-menu-item-internal]="menu"\n        ></po-menu-panel-item>\n      </div>\n    </div>\n  </nav>\n</div>\n' }]
  }], () => [{ type: ViewContainerRef }, { type: Location }, { type: PoMenuPanelItemsService }, { type: Router }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuPanelComponent, { className: "PoMenuPanelComponent", filePath: "lib/components/po-menu-panel/po-menu-panel.component.ts", lineNumber: 86 });
})();
var PoMenuPanelModule = class _PoMenuPanelModule {
  static ɵfac = function PoMenuPanelModule_Factory(t) {
    return new (t || _PoMenuPanelModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoMenuPanelModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoMenuPanelItemsService], imports: [CommonModule, RouterModule, PoFieldModule, PoLogoModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuPanelModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoFieldModule, PoLogoModule, PoTooltipModule],
      declarations: [PoMenuPanelComponent, PoMenuPanelItemComponent],
      exports: [PoMenuPanelComponent],
      providers: [PoMenuPanelItemsService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoMenuPanelModule, { declarations: [PoMenuPanelComponent, PoMenuPanelItemComponent], imports: [CommonModule, RouterModule, PoFieldModule, PoLogoModule, PoTooltipModule], exports: [PoMenuPanelComponent] });
})();
var poBadgeColors = Object.values(PoColorPaletteEnum);
var PO_BADGE_COLOR_DEFAULT = "color-07";
var PoBadgeBaseComponent = class _PoBadgeBaseComponent {
  badgeValue;
  customColor;
  _color = PO_BADGE_COLOR_DEFAULT;
  _value;
  _status;
  _ariaLabel;
  /**
   * @description
   *
   * Define um `aria-label` para o `po-badge`
   */
  set ariaLabel(value) {
    if (value === void 0) {
      this._ariaLabel = "";
    }
    this._ariaLabel = value;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Determina a cor do `po-badge`. As maneiras de customizar as cores são:
   * - Hexadeximal, por exemplo `#c64840`;
   * - RGB, como `rgb(0, 0, 165)`;
   * - O nome da cor, por exemplo `blue`;
   * - Usando uma das cores do tema do PO:
   * Valores válidos:
   *  - <span class="dot po-color-01"></span> `color-01`
   *  - <span class="dot po-color-02"></span> `color-02`
   *  - <span class="dot po-color-03"></span> `color-03`
   *  - <span class="dot po-color-04"></span> `color-04`
   *  - <span class="dot po-color-05"></span> `color-05`
   *  - <span class="dot po-color-06"></span> `color-06`
   *  - <span class="dot po-color-07"></span> `color-07`
   *  - <span class="dot po-color-08"></span> `color-08`
   *  - <span class="dot po-color-09"></span> `color-09`
   *  - <span class="dot po-color-10"></span> `color-10`
   *  - <span class="dot po-color-11"></span> `color-11`
   *  - <span class="dot po-color-12"></span> `color-12`
   *
   * @default `color-07`
   */
  set color(value) {
    if (value !== void 0 && value.includes("color")) {
      this._color = poBadgeColors.includes(value) ? value : PO_BADGE_COLOR_DEFAULT;
    } else {
      CSS.supports("background-color", value) ? this.customColor = value : this.customColor = void 0;
    }
  }
  get color() {
    return this._color;
  }
  /**
   * @optional
   *
   * @description
   * Ícone exibido no `po-badge`.
   *
   * Para exibir icone do status atual declare a propriedade `p-icon`. conforme exemplo abaixo:
   * ```
   * <po-badge [p-icon]="true"></po-badge>
   * ```
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-badge p-icon="po-icon-user"></po-badge>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-badge p-icon="fa fa-podcast"></po-badge>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-badge [p-icon]="template"></po-badge>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   */
  icon;
  /**
   * @description
   *
   * Define o estado do `po-badge`
   *
   * Valores válidos:
   * - `positive`: Define a cor do `po-badge` com a cor de feedback positivo.;
   * - `negative`: Define a cor do `po-badge` com a cor de feedback negative.;
   * - `warning`: Define a cor do `po-badge` com a cor de feedback warning.;
   * - `disabled`: Define a cor do `po-badge` com a cor de feedback disabled;
   *
   */
  set status(value) {
    this._status = ["positive", "negative", "warning", "disabled"].includes(value) ? value : void 0;
  }
  get status() {
    return this._status;
  }
  /**
   * @description
   *
   * Define o tamanho do `po-badge`
   *
   * Valores válidos:
   * - `small`: o `po-badge` fica do tamanho padrão, com 8px de altura.;
   * - `medium`: o `po-badge` fica do tamanho padrão, com 16px de altura.;
   * - `large`: o `po-badge` fica do tamanho padrão, com 24px de altura.;
   *
   * @default `medium`
   */
  size = "medium";
  /**
   * @description
   *
   * Exibe uma borda para o `po-badge`
   *
   * > Pode personalizar cor da bordar com a propriedade `p-color-border`
   */
  showBorder = false;
  /**
   * @description
   *
   * Número exibido no componente, caso o mesmo seja maior que 9 o valor exibido será 9+.
   */
  set value(value) {
    this._value = value <= 0 ? 0 : convertToInt(value);
  }
  get value() {
    return this._value;
  }
  static ɵfac = function PoBadgeBaseComponent_Factory(t) {
    return new (t || _PoBadgeBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoBadgeBaseComponent, hostVars: 1, hostBindings: function PoBadgeBaseComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("p-status", ctx.status);
    }
  }, inputs: { ariaLabel: [InputFlags.None, "p-aria-label", "ariaLabel"], color: [InputFlags.None, "p-color", "color"], icon: [InputFlags.None, "p-icon", "icon"], status: [InputFlags.None, "p-status", "status"], size: [InputFlags.None, "p-size", "size"], showBorder: [InputFlags.HasDecoratorInputTransform, "p-show-border", "showBorder", convertToBoolean], value: [InputFlags.None, "p-value", "value"] }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBadgeBaseComponent, [{
    type: Directive
  }], null, { ariaLabel: [{
    type: Input,
    args: ["p-aria-label"]
  }], color: [{
    type: Input,
    args: ["p-color"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], status: [{
    type: HostBinding,
    args: ["attr.p-status"]
  }, {
    type: Input,
    args: ["p-status"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }], showBorder: [{
    type: Input,
    args: [{ alias: "p-show-border", transform: convertToBoolean }]
  }], value: [{
    type: Input,
    args: ["p-value"]
  }] });
})();
var PoBadgeLiteralsDefault = {
  en: {
    notification: "new notification",
    notifications: "new notifications"
  },
  es: {
    notification: "nueva notificación",
    notifications: "nuevas notificaciones"
  },
  pt: {
    notification: "nova notificação",
    notifications: "nova notificaçoes"
  },
  ru: {
    notification: "новое уведомление",
    notifications: "новые уведомления"
  }
};
function PoBadgeComponent_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-icon", ctx_r0.badgeIcon);
  }
}
function PoBadgeComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.badgeValue);
  }
}
var _c0$o = (a0) => ({ "background-color": a0 });
var _c1$6 = () => ({});
var PO_BADGE_MAX_NOTIFICATIONS = 9;
var PoBadgeComponent = class _PoBadgeComponent extends PoBadgeBaseComponent {
  isNotification = false;
  notificationLabel = "";
  literals;
  badgeIcon = "";
  isValidValue = false;
  poLanguageService = inject(PoLanguageService);
  ngOnInit() {
    this.literals = PoBadgeLiteralsDefault[this.poLanguageService.getShortLanguage()];
    this.initialize();
  }
  ngOnChanges(changes) {
    if (changes["status"] || changes["icon"]) {
      this.setStatus();
    }
    if (changes["value"]) {
      this.setBadgeValue();
      this.setBadgeNotification(changes["value"].currentValue);
      this.setLiterals();
    }
  }
  initialize() {
    this.setStatus();
    this.setLiterals();
    this.setBadgeValue();
    this.setBadgeNotification(this.value);
  }
  getChangeStyle() {
    if (this.color === "color-07" && !this.customColor || this.status) {
      return "po-badge-default";
    } else if (this.color) {
      return `po-${this.color}`;
    }
  }
  setLiterals() {
    if (this.value) {
      this.notificationLabel = this.value > 1 ? `${this.ariaLabel ?? ""} ${this.value} ${this.literals?.notifications}` : `${this.ariaLabel ?? ""} ${this.value} ${this.literals?.notification}`;
    } else {
      this.notificationLabel = `${this.ariaLabel ?? ""} ${this.literals?.notification}`;
    }
  }
  setStatus() {
    this.isNotification = false;
    this.badgeValue = null;
    this.switchIconStatus();
  }
  switchIconStatus() {
    if (typeof this.icon === "boolean" && this.icon) {
      this.badgeIcon = "";
      if (["positive", "negative", "warning", "disabled"].includes(this.status)) {
        switch (this.status) {
          case "positive":
            this.badgeIcon = "po-icon-ok";
            break;
          case "negative":
            this.badgeIcon = "po-icon-minus";
            break;
          case "warning":
            this.badgeIcon = "po-icon-warning";
            break;
        }
      }
    } else {
      this.badgeIcon = this.icon;
    }
  }
  setBadgeNotification(value) {
    if (value > 1 && !this.status) {
      this.isNotification = true;
      return true;
    } else {
      this.isNotification = false;
      this.badgeValue = null;
      return false;
    }
  }
  setBadgeValue() {
    if (this.value) {
      this.checkBadgeValue(this.value);
    }
  }
  checkBadgeValue(value) {
    this.isValidValue = Number.isInteger(value) && value >= 1;
    this.badgeValue = this.isValidValue ? this.formatBadgeValue(value) : "";
  }
  formatBadgeValue(value) {
    return value > PO_BADGE_MAX_NOTIFICATIONS ? "9+" : value.toString();
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoBadgeComponent_BaseFactory;
    return function PoBadgeComponent_Factory(t) {
      return (ɵPoBadgeComponent_BaseFactory || (ɵPoBadgeComponent_BaseFactory = ɵɵgetInheritedFactory(_PoBadgeComponent)))(t || _PoBadgeComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoBadgeComponent, selectors: [["po-badge"]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 3, vars: 16, consts: [[3, "ariaLabel", "ngStyle"], [3, "p-icon", 4, "ngIf"], ["class", "po-badge-value", "aria-hidden", "true", 4, "ngIf"], [3, "p-icon"], ["aria-hidden", "true", 1, "po-badge-value"]], template: function PoBadgeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoBadgeComponent_po_icon_1_Template, 1, 1, "po-icon", 1)(2, PoBadgeComponent_span_2_Template, 2, 1, "span", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate2("", ctx.getChangeStyle(), " po-badge po-badge-", ctx.size ? ctx.size : "medium", "");
      ɵɵclassProp("po-badge-notification", ctx.isNotification && !ctx.status)("po-badge-border", ctx.showBorder);
      ɵɵproperty("ariaLabel", ctx.notificationLabel)("ngStyle", ctx.customColor && !ctx.status ? ɵɵpureFunction1(13, _c0$o, ctx.customColor) : ɵɵpureFunction0(15, _c1$6));
      ɵɵattribute("data-status", ctx.status);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isNotification && ctx.size !== "small" && ctx.badgeIcon && ctx.status !== "disabled");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.value > 1);
    }
  }, dependencies: [NgIf, NgStyle, PoIconComponent], styles: ["[_nghost-%COMP%]{display:inline-block;vertical-align:middle}"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBadgeComponent, [{
    type: Component,
    args: [{ selector: "po-badge", template: `<div
  class="{{ getChangeStyle() }} po-badge po-badge-{{ size ? size : 'medium' }}"
  [class.po-badge-notification]="isNotification && !status"
  [class.po-badge-border]="showBorder"
  [attr.data-status]="status"
  [ariaLabel]="notificationLabel"
  [ngStyle]="customColor && !status ? { 'background-color': customColor } : {}"
>
  <po-icon
    *ngIf="!isNotification && size !== 'small' && badgeIcon && status !== 'disabled'"
    [p-icon]="badgeIcon"
  ></po-icon>
  <span *ngIf="value > 1" class="po-badge-value" aria-hidden="true">{{ badgeValue }}</span>
</div>
`, styles: [":host{display:inline-block;vertical-align:middle}\n"] }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoBadgeComponent, { className: "PoBadgeComponent", filePath: "lib/components/po-badge/po-badge.component.ts", lineNumber: 36 });
})();
var PoBadgeModule = class _PoBadgeModule {
  static ɵfac = function PoBadgeModule_Factory(t) {
    return new (t || _PoBadgeModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoBadgeModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoBadgeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoIconModule],
      declarations: [PoBadgeComponent],
      exports: [PoBadgeComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoBadgeModule, { declarations: [PoBadgeComponent], imports: [CommonModule, PoIconModule], exports: [PoBadgeComponent] });
})();
var _c0$n = ["inputFilter"];
function PoMenuFilterComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 8);
  }
}
function PoMenuFilterComponent_po_loading_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-loading-icon", 9);
  }
}
var poMenuFilterLiteralsDefault = {
  en: { search: "Search" },
  es: { search: "Buscar" },
  pt: { search: "Pesquisar" },
  ru: { search: "Поиск" }
};
var PoMenuFilterComponent = class _PoMenuFilterComponent {
  languageService;
  loading;
  enableCollapse = false;
  // utilizado para repassar ao po-clean
  inputFilterElement;
  filter = new EventEmitter();
  literals;
  constructor(languageService) {
    this.languageService = languageService;
    this.literals = __spreadValues(__spreadValues({}, poMenuFilterLiteralsDefault[this.languageService?.getLanguageDefault()]), poMenuFilterLiteralsDefault[this.languageService?.getShortLanguage()]);
  }
  filterItems(search) {
    this.filter.emit(search);
  }
  static ɵfac = function PoMenuFilterComponent_Factory(t) {
    return new (t || _PoMenuFilterComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMenuFilterComponent, selectors: [["po-menu-filter"]], viewQuery: function PoMenuFilterComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$n, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputFilterElement = _t.first);
    }
  }, inputs: { loading: [InputFlags.None, "p-loading", "loading"], enableCollapse: [InputFlags.None, "p-enable-collapse", "enableCollapse"] }, outputs: { filter: "p-filter" }, decls: 8, vars: 6, consts: [[1, "po-menu-filter-container"], ["type", "text", 1, "po-menu-filter", 3, "placeholder", "keyup"], ["inputFilter", ""], [1, "po-menu-filter-search-icon-container"], ["class", "po-icon po-menu-filter-icon po-icon-search", 4, "ngIf"], ["p-size", "sm", 4, "ngIf"], [1, "po-menu-filter-close-icon-container"], [3, "p-element-ref", "p-change-event"], [1, "po-icon", "po-menu-filter-icon", "po-icon-search"], ["p-size", "sm"]], template: function PoMenuFilterComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r3 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0)(1, "input", 1, 2);
      ɵɵlistener("keyup", function PoMenuFilterComponent_Template_input_keyup_1_listener() {
        ɵɵrestoreView(_r3);
        const _r0 = ɵɵreference(2);
        return ɵɵresetView(ctx.filterItems(_r0.value));
      });
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 3);
      ɵɵtemplate(4, PoMenuFilterComponent_span_4_Template, 1, 0, "span", 4)(5, PoMenuFilterComponent_po_loading_icon_5_Template, 1, 0, "po-loading-icon", 5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 6)(7, "po-clean", 7);
      ɵɵlistener("p-change-event", function PoMenuFilterComponent_Template_po_clean_p_change_event_7_listener() {
        ɵɵrestoreView(_r3);
        const _r0 = ɵɵreference(2);
        return ɵɵresetView(ctx.filterItems(_r0.value));
      });
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵclassProp("po-menu-filter-container-hidden", ctx.enableCollapse);
      ɵɵadvance();
      ɵɵproperty("placeholder", ctx.literals.search);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.loading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.loading);
      ɵɵadvance(2);
      ɵɵproperty("p-element-ref", ctx.inputFilterElement);
    }
  }, dependencies: [NgIf, PoCleanComponent, PoLoadingIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuFilterComponent, [{
    type: Component,
    args: [{ selector: "po-menu-filter", template: '<div class="po-menu-filter-container" [class.po-menu-filter-container-hidden]="enableCollapse">\n  <input\n    #inputFilter\n    type="text"\n    class="po-menu-filter"\n    [placeholder]="literals.search"\n    (keyup)="filterItems(inputFilter.value)"\n  />\n\n  <div class="po-menu-filter-search-icon-container">\n    <span *ngIf="!loading" class="po-icon po-menu-filter-icon po-icon-search"></span>\n    <po-loading-icon *ngIf="loading" p-size="sm"></po-loading-icon>\n  </div>\n  <div class="po-menu-filter-close-icon-container">\n    <po-clean [p-element-ref]="inputFilterElement" (p-change-event)="filterItems(inputFilter.value)"></po-clean>\n  </div>\n</div>\n' }]
  }], () => [{ type: PoLanguageService }], { loading: [{
    type: Input,
    args: ["p-loading"]
  }], enableCollapse: [{
    type: Input,
    args: ["p-enable-collapse"]
  }], inputFilterElement: [{
    type: ViewChild,
    args: ["inputFilter", { read: ElementRef, static: true }]
  }], filter: [{
    type: Output,
    args: ["p-filter"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuFilterComponent, { className: "PoMenuFilterComponent", filePath: "lib/components/po-menu/po-menu-filter/po-menu-filter.component.ts", lineNumber: 23 });
})();
var PoMenuHeaderTemplateDirective = class _PoMenuHeaderTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoMenuHeaderTemplateDirective_Factory(t) {
    return new (t || _PoMenuHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoMenuHeaderTemplateDirective, selectors: [["", "p-menu-header-template", ""]] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-menu-header-template]"
    }]
  }], () => [{ type: TemplateRef }], null);
})();
var PoMenuItemsService = class _PoMenuItemsService {
  subjectParent = new Subject();
  subjectChild = new Subject();
  // Envia informações do click do po-menu-item para o po-menu
  sendToParentMenuClicked(menu) {
    this.subjectChild.next(menu);
  }
  // Recebe do po-menu-item sua informação de click.
  receiveFromChildMenuClicked() {
    return this.subjectChild.asObservable();
  }
  // Envia para os po-menu-item a resposta do processamento de click de um po-menu-item.
  sendToChildMenuClicked(menu) {
    this.subjectParent.next(menu);
  }
  // Recebe do po-menu as informações processadas do click de um po-menu-item.
  receiveFromParentMenuClicked() {
    return this.subjectParent.asObservable();
  }
  static ɵfac = function PoMenuItemsService_Factory(t) {
    return new (t || _PoMenuItemsService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoMenuItemsService, factory: _PoMenuItemsService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuItemsService, [{
    type: Injectable
  }], null, null);
})();
var _c0$m = ["menuSubItems"];
function PoMenuItemComponent_a_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_a_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵtemplate(1, PoMenuItemComponent_a_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵproperty("routerLink", ctx_r0.link);
    ɵɵattribute("aria-label", ctx_r0.label);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
  }
}
function PoMenuItemComponent_a_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 8);
    ɵɵtemplate(1, PoMenuItemComponent_a_1_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵproperty("href", ctx_r1.link, ɵɵsanitizeUrl);
    ɵɵattribute("aria-label", ctx_r1.label);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
  }
}
function PoMenuItemComponent_a_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 9);
    ɵɵtemplate(1, PoMenuItemComponent_a_2_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵattribute("aria-label", ctx_r2.label);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
  }
}
function PoMenuItemComponent_div_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtemplate(1, PoMenuItemComponent_div_3_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
  }
}
function PoMenuItemComponent_div_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuItemComponent_div_4_li_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 16);
    ɵɵelement(1, "po-menu-item", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const subItem_r14 = ctx.$implicit;
    ɵɵattribute("aria-level", subItem_r14.level);
    ɵɵadvance();
    ɵɵproperty("p-action", subItem_r14.action)("p-badge-alert", subItem_r14.badgeAlert)("p-badge-color", subItem_r14.badge ? subItem_r14.badge.color : void 0)("p-badge-value", subItem_r14.badge ? subItem_r14.badge.value : void 0)("p-id", subItem_r14.id)("p-label", subItem_r14.label)("p-level", subItem_r14.level)("p-link", subItem_r14.link)("p-sub-items", subItem_r14.subItems)("p-type", subItem_r14.type);
  }
}
function PoMenuItemComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtemplate(1, PoMenuItemComponent_div_4_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵɵelementStart(2, "div", 12, 13)(4, "ul", 14);
    ɵɵtemplate(5, PoMenuItemComponent_div_4_li_5_Template, 2, 11, "li", 15);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const _r6 = ɵɵreference(6);
    ɵɵattribute("aria-expanded", ctx_r4.isOpened ? true : false);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r6);
    ɵɵadvance();
    ɵɵstyleProp("max-height", ctx_r4.maxHeight, "px");
    ɵɵproperty("hidden", ctx_r4.collapsedMenu || !ctx_r4.isOpened);
    ɵɵattribute("aria-expanded", ctx_r4.isOpened ? true : false)("aria-hidden", !ctx_r4.isOpened ? true : false);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r4.subItems);
  }
}
function PoMenuItemComponent_ng_template_5_po_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-icon", 23);
  }
  if (rf & 2) {
    const ctx_r15 = ɵɵnextContext(2);
    ɵɵproperty("p-icon", ctx_r15.icon);
  }
}
function PoMenuItemComponent_ng_template_5_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 24);
  }
  if (rf & 2) {
    const ctx_r16 = ɵɵnextContext(2);
    ɵɵclassProp("po-icon-arrow-up", ctx_r16.isOpened)("po-icon-arrow-down", !ctx_r16.isOpened);
  }
}
function PoMenuItemComponent_ng_template_5_po_badge_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-badge", 25);
  }
  if (rf & 2) {
    const ctx_r17 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", !ctx_r17.collapsedMenu ? "po-menu-badge-align" : "po-menu-badge-align-collapsed")("p-color", ctx_r17.badgeColor)("p-value", ctx_r17.badgeValue);
  }
}
function PoMenuItemComponent_ng_template_5_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 26);
  }
  if (rf & 2) {
    const ctx_r18 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", !ctx_r18.collapsedMenu ? "po-menu-badge-alert" : "po-menu-badge-alert-collapsed");
  }
}
function PoMenuItemComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18);
    ɵɵlistener("click", function PoMenuItemComponent_ng_template_5_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r20);
      const ctx_r19 = ɵɵnextContext();
      return ɵɵresetView(ctx_r19.clickMenuItem($event));
    })("keydown.enter", function PoMenuItemComponent_ng_template_5_Template_div_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r20);
      const ctx_r21 = ɵɵnextContext();
      return ɵɵresetView(ctx_r21.clickMenuItem($event));
    })("keydown.space", function PoMenuItemComponent_ng_template_5_Template_div_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r20);
      const ctx_r22 = ɵɵnextContext();
      return ɵɵresetView(ctx_r22.clickMenuItem($event));
    });
    ɵɵtemplate(1, PoMenuItemComponent_ng_template_5_po_icon_1_Template, 1, 1, "po-icon", 19)(2, PoMenuItemComponent_ng_template_5_span_2_Template, 1, 4, "span", 20);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵtemplate(5, PoMenuItemComponent_ng_template_5_po_badge_5_Template, 1, 3, "po-badge", 21)(6, PoMenuItemComponent_ng_template_5_span_6_Template, 1, 1, "span", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("po-menu-icon-container", ctx_r5.level === 1 && ctx_r5.icon)("po-menu-item-selected", ctx_r5.isSelected)("po-menu-item-level-two", ctx_r5.level === 2)("po-menu-item-level-three", ctx_r5.level === 3)("po-menu-item-level-four", ctx_r5.level === 4)("po-menu-item-grouper-up", ctx_r5.type === "subItems" && ctx_r5.isOpened)("po-menu-item-grouper-down", ctx_r5.type === "subItems" && !ctx_r5.isOpened)("po-menu-item-no-data", ctx_r5.type === "noData")("po-menu-sub-item-selected", ctx_r5.isSelectedSubItem);
    ɵɵproperty("tabindex", ctx_r5.type === "subItems" ? 0 : -1);
    ɵɵattribute("aria-label", ctx_r5.label)("aria-hidden", ctx_r5.type === "subItems" ? false : true)("role", ctx_r5.type === "subItems" ? "menuitem" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.level === 1 && ctx_r5.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.type === "subItems" && !ctx_r5.collapsedMenu);
    ɵɵadvance();
    ɵɵclassProp("po-menu-icon-label", ctx_r5.level === 1 && ctx_r5.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r5.label, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.canShowBadge);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.badgeAlert);
  }
}
var poMenuItemSubItemSize = 98;
var PoMenuItemComponent = class _PoMenuItemComponent {
  menuItemsService;
  // Ação que será chamada ao clicar no item.
  action;
  // Indica se contém algum item filho com o badge.
  badgeAlert;
  // Cor do badge.
  badgeColor;
  // Indica se o menu está colapsado
  collapsedMenu;
  // Ícone de menu
  icon;
  // Identificador do item.
  id;
  // Indica se o item está aberto (menu agrupado)
  isOpened;
  // Texto que aparecerá representando o item.
  label;
  // Indica qual em nível do po-menu encontra-se.
  level;
  // Link do item.
  link;
  // Texto que aparecerá representando o item.
  shortLabel;
  // Indica o tipo de item, como 'internalLink' ou 'subItems'.
  type;
  menuSubItems;
  isSelectedSubItem;
  maxHeight = 0;
  itemSubscription;
  _badgeValue;
  _isSelected = false;
  _isSubItem = false;
  _subItems;
  // Valor do badge.
  set badgeValue(badgeValue) {
    this._badgeValue = convertToInt(badgeValue);
  }
  get badgeValue() {
    return this._badgeValue;
  }
  // Indica se o item está selecionado.
  set isSelected(value) {
    this._isSelected = convertToBoolean(value);
    this.isSelectedSubItem = this.isSelected && this.isSubItem;
  }
  get isSelected() {
    return this._isSelected;
  }
  // Indica se o item é um sub item
  set isSubItem(value) {
    this._isSubItem = convertToBoolean(value);
  }
  get isSubItem() {
    return this._isSubItem;
  }
  // Lista de sub-items.
  set subItems(subitems) {
    this._subItems = subitems;
    if (this.isOpened) {
      this.calcMenuSubItemsMaxHeight();
    }
  }
  get subItems() {
    return this._subItems;
  }
  get canShowBadge() {
    return this.type !== "subItems" && (this.badgeValue || this.badgeValue === 0) && this.badgeValue >= 0;
  }
  constructor(menuItemsService) {
    this.menuItemsService = menuItemsService;
  }
  ngOnDestroy() {
    this.itemSubscription.unsubscribe();
  }
  ngOnInit() {
    this.itemSubscription = this.menuItemsService.receiveFromParentMenuClicked().subscribe((menu) => {
      this.processMenuItem(menu);
    });
  }
  clickMenuItem(event) {
    if (!(event.ctrlKey || event.metaKey)) {
      event.preventDefault();
      this.menuItemsService.sendToParentMenuClicked({
        link: this.link,
        action: this.action,
        id: this.id,
        icon: this.icon,
        label: this.label,
        level: this.level,
        subItems: this.subItems,
        isSelected: this.isSelected,
        isOpened: this.isOpened,
        shortLabel: this.shortLabel,
        type: this.type
      });
    }
  }
  accordionAnimation(menuActive, menuOpened, hasSubItemOpened, activatedByRoute) {
    if (this.id === menuOpened["id"]) {
      this.maxHeight = this.subItems.length * poMenuItemSubItemSize;
    }
    if (hasSubItemOpened) {
      this.maxHeight = menuOpened["isOpened"] ? this.maxHeight + menuOpened.subItems.length * poMenuItemSubItemSize : this.maxHeight - menuOpened.subItems.length * poMenuItemSubItemSize;
      if (activatedByRoute) {
        this.maxHeight = this.getMinimumHeight(0, this, menuActive);
      }
    }
  }
  activateMenu(menu) {
    this.isSelected = menu && this.id === menu.id;
  }
  calcMenuSubItemsMaxHeight() {
    setTimeout(() => {
      const subItems = Array.from(this.menuSubItems.nativeElement.querySelectorAll(".po-menu-item"));
      subItems.forEach((menuItem) => this.maxHeight += menuItem.offsetHeight);
    });
  }
  getMinimumHeight(minimumHeight, menuItem, menuActive) {
    minimumHeight += poMenuItemSubItemSize;
    if (menuItem.subItems && this.hasSubItem(menuItem.subItems, menuActive["id"])) {
      for (let index = 0; index < menuItem.subItems.length; index++) {
        minimumHeight = this.getMinimumHeight(minimumHeight, menuItem.subItems[index], menuActive);
      }
    }
    return minimumHeight;
  }
  groupedMenu(menuActive, menuOpened, activatedByRoute = false) {
    const hasSubItemOpened = menuOpened && this.id !== menuOpened["id"] ? this.hasSubItem(this.subItems, menuOpened["id"]) : false;
    this.isOpened = this.isMenuOpened(menuOpened, hasSubItemOpened);
    this.isSelected = menuActive && !this.isOpened ? this.hasSubItem(this.subItems, menuActive["id"]) : false;
    if (!this.isOpened) {
      this.maxHeight = 0;
      return;
    }
    this.accordionAnimation(menuActive, menuOpened, hasSubItemOpened, activatedByRoute);
  }
  hasSubItem(subItems, id) {
    if (subItems) {
      return subItems.some((item) => item["id"] === id ? true : this.hasSubItem(item.subItems, id));
    }
  }
  isMenuOpened(menuOpened, hasSubItemOpened) {
    if (menuOpened) {
      return this.id === menuOpened["id"] ? menuOpened["isOpened"] : hasSubItemOpened;
    }
    return false;
  }
  processMenuItem(menu) {
    if (this.type === "internalLink") {
      this.activateMenu(menu.active);
      return;
    }
    if (this.type === "subItems") {
      this.groupedMenu(menu.active, menu.grouped, menu.activatedByRoute);
    }
  }
  static ɵfac = function PoMenuItemComponent_Factory(t) {
    return new (t || _PoMenuItemComponent)(ɵɵdirectiveInject(PoMenuItemsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMenuItemComponent, selectors: [["po-menu-item"]], viewQuery: function PoMenuItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$m, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuSubItems = _t.first);
    }
  }, inputs: { action: [InputFlags.None, "p-action", "action"], badgeAlert: [InputFlags.None, "p-badge-alert", "badgeAlert"], badgeColor: [InputFlags.None, "p-badge-color", "badgeColor"], collapsedMenu: [InputFlags.None, "p-collapsed-menu", "collapsedMenu"], icon: [InputFlags.None, "p-icon", "icon"], id: [InputFlags.None, "p-id", "id"], isOpened: [InputFlags.None, "p-is-opened", "isOpened"], label: [InputFlags.None, "p-label", "label"], level: [InputFlags.None, "p-level", "level"], link: [InputFlags.None, "p-link", "link"], shortLabel: [InputFlags.None, "p-short-label", "shortLabel"], type: [InputFlags.None, "p-type", "type"], badgeValue: [InputFlags.None, "p-badge-value", "badgeValue"], isSelected: [InputFlags.None, "p-is-selected", "isSelected"], isSubItem: [InputFlags.None, "p-is-sub-item", "isSubItem"], subItems: [InputFlags.None, "p-sub-items", "subItems"] }, decls: 7, vars: 5, consts: [["class", "po-menu-item-link", "role", "menuitem", 3, "routerLink", 4, "ngIf"], ["class", "po-menu-item-link", "role", "menuitem", 3, "href", 4, "ngIf"], ["class", "po-menu-item-link", "href", "javascript:;", "role", "menuitem", 4, "ngIf"], ["class", "po-menu-item-link", "role", "none", 4, "ngIf"], ["class", "po-menu-item-link po-clickable", "role", "menuitem", 4, "ngIf"], ["menuItemTemplate", ""], ["role", "menuitem", 1, "po-menu-item-link", 3, "routerLink"], [4, "ngTemplateOutlet"], ["role", "menuitem", 1, "po-menu-item-link", 3, "href"], ["href", "javascript:;", "role", "menuitem", 1, "po-menu-item-link"], ["role", "none", 1, "po-menu-item-link"], ["role", "menuitem", 1, "po-menu-item-link", "po-clickable"], ["role", "group", 1, "po-menu-sub-items", 3, "hidden"], ["menuSubItems", ""], [1, "po-menu-sub-items-list"], ["class", "po-menu-sub-items-list-item", 4, "ngFor", "ngForOf"], [1, "po-menu-sub-items-list-item"], ["p-is-sub-item", "", 3, "p-action", "p-badge-alert", "p-badge-color", "p-badge-value", "p-id", "p-label", "p-level", "p-link", "p-sub-items", "p-type"], [1, "po-menu-item", 3, "tabindex", "click", "keydown.enter", "keydown.space"], ["aria-hidden", "true", "class", "po-menu-icon-item", 3, "p-icon", 4, "ngIf"], ["class", "po-icon po-menu-group-icon", 3, "po-icon-arrow-up", "po-icon-arrow-down", 4, "ngIf"], ["aria-hidden", "true", 3, "ngClass", "p-color", "p-value", 4, "ngIf"], ["aria-hidden", "true", "class", "po-color-07", 3, "ngClass", 4, "ngIf"], ["aria-hidden", "true", 1, "po-menu-icon-item", 3, "p-icon"], [1, "po-icon", "po-menu-group-icon"], ["aria-hidden", "true", 3, "ngClass", "p-color", "p-value"], ["aria-hidden", "true", 1, "po-color-07", 3, "ngClass"]], template: function PoMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoMenuItemComponent_a_0_Template, 2, 3, "a", 0)(1, PoMenuItemComponent_a_1_Template, 2, 3, "a", 1)(2, PoMenuItemComponent_a_2_Template, 2, 2, "a", 2)(3, PoMenuItemComponent_div_3_Template, 2, 1, "div", 3)(4, PoMenuItemComponent_div_4_Template, 6, 8, "div", 4)(5, PoMenuItemComponent_ng_template_5_Template, 7, 29, "ng-template", null, 5, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.type === "internalLink");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "externalLink");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "noLink");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "noData");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.type === "subItems");
    }
  }, dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, RouterLink, PoBadgeComponent, PoIconComponent, _PoMenuItemComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuItemComponent, [{
    type: Component,
    args: [{ selector: "po-menu-item", template: `<!-- menu com link interno -->
<a
  *ngIf="type === 'internalLink'"
  class="po-menu-item-link"
  role="menuitem"
  [attr.aria-label]="label"
  [routerLink]="link"
>
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>
<!-- menu com link externo -->
<a *ngIf="type === 'externalLink'" class="po-menu-item-link" role="menuitem" [attr.aria-label]="label" [href]="link">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>
<!-- menu sem link -->
<a *ngIf="type === 'noLink'" class="po-menu-item-link" href="javascript:;" role="menuitem" [attr.aria-label]="label">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</a>
<!-- menu sem dados -->
<div *ngIf="type === 'noData'" class="po-menu-item-link" role="none">
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>
</div>
<!-- menu com sub itens -->
<div
  *ngIf="type === 'subItems'"
  class="po-menu-item-link po-clickable"
  role="menuitem"
  [attr.aria-expanded]="isOpened ? true : false"
>
  <ng-container *ngTemplateOutlet="menuItemTemplate"></ng-container>

  <div
    #menuSubItems
    class="po-menu-sub-items"
    [hidden]="collapsedMenu || !isOpened"
    [attr.aria-expanded]="isOpened ? true : false"
    [attr.aria-hidden]="!isOpened ? true : false"
    role="group"
    [style.maxHeight.px]="maxHeight"
  >
    <ul class="po-menu-sub-items-list">
      <li class="po-menu-sub-items-list-item" *ngFor="let subItem of subItems" [attr.aria-level]="subItem.level">
        <po-menu-item
          p-is-sub-item
          [p-action]="subItem.action"
          [p-badge-alert]="subItem.badgeAlert"
          [p-badge-color]="subItem.badge ? subItem.badge.color : undefined"
          [p-badge-value]="subItem.badge ? subItem.badge.value : undefined"
          [p-id]="subItem.id"
          [p-label]="subItem.label"
          [p-level]="subItem.level"
          [p-link]="subItem.link"
          [p-sub-items]="subItem.subItems"
          [p-type]="subItem.type"
        ></po-menu-item>
      </li>
    </ul>
  </div>
</div>

<ng-template #menuItemTemplate>
  <div
    class="po-menu-item"
    [tabindex]="type === 'subItems' ? 0 : -1"
    [attr.aria-label]="label"
    [attr.aria-hidden]="type === 'subItems' ? false : true"
    [attr.role]="type === 'subItems' ? 'menuitem' : undefined"
    [class.po-menu-icon-container]="level === 1 && icon"
    [class.po-menu-item-selected]="isSelected"
    [class.po-menu-item-level-two]="level === 2"
    [class.po-menu-item-level-three]="level === 3"
    [class.po-menu-item-level-four]="level === 4"
    [class.po-menu-item-grouper-up]="type === 'subItems' && isOpened"
    [class.po-menu-item-grouper-down]="type === 'subItems' && !isOpened"
    [class.po-menu-item-no-data]="type === 'noData'"
    [class.po-menu-sub-item-selected]="isSelectedSubItem"
    (click)="clickMenuItem($event)"
    (keydown.enter)="clickMenuItem($event)"
    (keydown.space)="clickMenuItem($event)"
  >
    <po-icon *ngIf="level === 1 && icon" aria-hidden="true" class="po-menu-icon-item" [p-icon]="icon"></po-icon>

    <span
      *ngIf="type === 'subItems' && !collapsedMenu"
      class="po-icon po-menu-group-icon"
      [class.po-icon-arrow-up]="isOpened"
      [class.po-icon-arrow-down]="!isOpened"
    ></span>

    <span [class.po-menu-icon-label]="level === 1 && icon">
      {{ label }}
    </span>

    <po-badge
      *ngIf="canShowBadge"
      aria-hidden="true"
      [ngClass]="!collapsedMenu ? 'po-menu-badge-align' : 'po-menu-badge-align-collapsed'"
      [p-color]="badgeColor"
      [p-value]="badgeValue"
    ></po-badge>

    <span
      *ngIf="badgeAlert"
      aria-hidden="true"
      class="po-color-07"
      [ngClass]="!collapsedMenu ? 'po-menu-badge-alert' : 'po-menu-badge-alert-collapsed'"
    ></span>
  </div>
</ng-template>
` }]
  }], () => [{ type: PoMenuItemsService }], { action: [{
    type: Input,
    args: ["p-action"]
  }], badgeAlert: [{
    type: Input,
    args: ["p-badge-alert"]
  }], badgeColor: [{
    type: Input,
    args: ["p-badge-color"]
  }], collapsedMenu: [{
    type: Input,
    args: ["p-collapsed-menu"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], id: [{
    type: Input,
    args: ["p-id"]
  }], isOpened: [{
    type: Input,
    args: ["p-is-opened"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], level: [{
    type: Input,
    args: ["p-level"]
  }], link: [{
    type: Input,
    args: ["p-link"]
  }], shortLabel: [{
    type: Input,
    args: ["p-short-label"]
  }], type: [{
    type: Input,
    args: ["p-type"]
  }], menuSubItems: [{
    type: ViewChild,
    args: ["menuSubItems"]
  }], badgeValue: [{
    type: Input,
    args: ["p-badge-value"]
  }], isSelected: [{
    type: Input,
    args: ["p-is-selected"]
  }], isSubItem: [{
    type: Input,
    args: ["p-is-sub-item"]
  }], subItems: [{
    type: Input,
    args: ["p-sub-items"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuItemComponent, { className: "PoMenuItemComponent", filePath: "lib/components/po-menu/po-menu-item/po-menu-item.component.ts", lineNumber: 24 });
})();
var PoMenuGlobalService = class _PoMenuGlobalService {
  applicationMenu = new Subject();
  menus = new Subject();
  removedApplicationMenu = new Subject();
  // eslint-disable-next-line @typescript-eslint/member-ordering
  receiveApplicationMenu$ = this.applicationMenu.asObservable();
  // eslint-disable-next-line @typescript-eslint/member-ordering
  receiveMenus$ = this.menus.asObservable();
  // eslint-disable-next-line @typescript-eslint/member-ordering
  receiveRemovedApplicationMenu$ = this.removedApplicationMenu.asObservable();
  sendApplicationMenu(menu) {
    this.applicationMenu.next(menu);
  }
  sendMenus(menus) {
    this.menus.next(menus);
  }
  sendRemovedApplicationMenu(id) {
    this.removedApplicationMenu.next(id);
  }
  static ɵfac = function PoMenuGlobalService_Factory(t) {
    return new (t || _PoMenuGlobalService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoMenuGlobalService, factory: _PoMenuGlobalService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuGlobalService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var PoMenuService = class _PoMenuService {
  http;
  _url;
  get url() {
    return this._url;
  }
  constructor(http) {
    this.http = http;
  }
  configProperties(url) {
    this._url = url;
  }
  getFilteredData(search, params) {
    const filterParams = __spreadValues({
      search
    }, params);
    return this.http.get(this.url, { params: filterParams }).pipe(map((response) => response && response.items));
  }
  static ɵfac = function PoMenuService_Factory(t) {
    return new (t || _PoMenuService)(ɵɵinject(HttpClient));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoMenuService, factory: _PoMenuService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuService, [{
    type: Injectable
  }], () => [{ type: HttpClient }], null);
})();
var poMenuLiteralsDefault = {
  en: {
    itemNotFound: "Item not found",
    emptyLabelError: "Attribute PoMenuItem.label can not be empty",
    close: "Close menu",
    open: "Open menu"
  },
  es: {
    itemNotFound: "Elemento no encontrado",
    emptyLabelError: "El atributo PoMenuItem.label no puede ser vacío",
    close: "Cerrar menú",
    open: "Abrir menú"
  },
  pt: {
    itemNotFound: "Item não encontrado",
    emptyLabelError: "O atributo PoMenuItem.label não pode ser vazio",
    close: "Fechar menu",
    open: "Abrir menu"
  },
  ru: {
    itemNotFound: "Предмет не найден",
    emptyLabelError: "Атрибут PoMenuItem.label не может быть пустым",
    close: "Закрыть меню",
    open: "Открыть меню"
  }
};
var PoMenuBaseComponent = class _PoMenuBaseComponent {
  menuGlobalService;
  menuService;
  languageService;
  allowIcons;
  allowCollapseMenu;
  allowCollapseHover;
  filteredItems;
  filterService;
  literals;
  _collapsed = false;
  _filter = false;
  _level;
  _maxLevel = 4;
  _menus = [];
  _params;
  _service;
  /**
   * @optional
   *
   * @description
   *
   * Expande e Colapsa (retrai) o menu automaticamente.
   *
   * @default `false`
   */
  automaticToggle = false;
  /**
   * @optional
   *
   * @description
   *
   * Colapsa (retrai) o menu e caso receba o valor `false` expande o menu.
   *
   * > Utilize esta propriedade para iniciar o menu colapsado.
   *
   * > Ao utilizar os métodos [`colapse`](documentation/po-menu#colapseMethod), [`expand`](documentation/po-menu#expandMethod) e
   * [`toggle`](documentation/po-menu#toggleMethod) o valor desta propriedade não é alterado.
   *
   * **Importante:**
   *
   * > O menu será colapsado/expandido apenas se todos os itens de menu tiverem valor nas propriedades `icon` e `shortLabel`.
   *
   * @default `false`
   */
  set collapsed(collapsed) {
    this._collapsed = convertToBoolean(collapsed);
    this.allowCollapseHover = this._collapsed;
    this.validateCollapseClass();
  }
  get collapsed() {
    return this._collapsed;
  }
  /** Lista dos itens do menu. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio. */
  set menus(menus) {
    this._menus = Array.isArray(menus) ? menus : [];
    this.menuGlobalService.sendMenus(menus);
    setTimeout(() => {
      const urlRouter = this.checkingRouterChildrenFragments();
      this.checkActiveMenuByUrl(urlRouter);
    });
  }
  get menus() {
    return this._menus;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita um campo para pesquisa no menu.
   * A pesquisa é realizada em todos os níveis do menu e busca apenas pelos itens que contém uma ação e/ou link definidos,
   * ou também, pode ser realizada através de um serviço definido na propriedade `p-service`.
   *
   * > O campo de pesquisa é desabilitado se o menu estiver colapsado.
   *
   * @default `false`
   */
  set filter(filter2) {
    this._filter = filter2 === "" ? true : convertToBoolean(filter2);
    this.filteredItems = [...this._menus];
  }
  get filter() {
    return this._filter;
  }
  /**
   * @optional
   *
   * @description
   *
   * Nesta propriedade deve ser informada a URL do serviço em que será utilizado para realizar o filtro de itens do
   * menu quando realizar uma busca. Caso haja a necessidade de customização, pode ser informado um
   * serviço implementando a interface `PoMenuFilter`.
   *
   * Caso utilizada uma URL, o serviço deve retornar os dados conforme o
   * [Guia de implementação de APIs](https://po-ui.io/guides/api) do PO UI.
   *
   * Quando utilizada uma URL de serviço, será realizado um *GET* na URL informada, passando o valor digitado
   * no parâmetro `search`, veja exemplo:
   *
   * > O filtro no serviço será realizado caso contenha no mínimo três caracteres no campo de busca, por exemplo `tot`.
   *
   * ```
   * <po-menu p-service="/api/v1/fnd/menu">
   * </po-menu>
   *
   * Requisição: GET /api/v1/fnd/menu?search=contas
   * ```
   *
   * > É necessário que propriedade `p-filter` esteja habilitada.
   */
  set service(value) {
    this._service = value || void 0;
    this.configService(this.service);
  }
  get service() {
    return this._service;
  }
  /**
   * @optional
   *
   * @description
   *
   * Deve ser informado um objeto que deseja-se utilizar na requisição de filtro dos itens de menu.
   *
   * Caso utilizado um serviço customizado, implementando a interface `PoMenuFilter`, o valor desta propriedade
   * será passado como parâmetro, na função `getFilteredData`.
   *
   * Quando utilizada uma URL de serviço, será realizado um *GET* na URL informada, passando os valores informados
   * nesta propriedade em conjunto com o parâmetro `search`, veja exemplo:
   *
   * ```
   * <po-menu p-service="/api/v1/fnd/menu" [p-params]="{ company: 1, user: 297767512 }">
   * </po-menu>
   *
   * Requisição: GET /api/v1/fnd/menu?search=contas&company=1&user=297767512
   * ```
   */
  set params(value) {
    this._params = value && isTypeof(value, "object") ? value : void 0;
  }
  get params() {
    return this._params;
  }
  /**
   * @optional
   *
   * @description
   *
   * Caminho para a logomarca, que será exibida quando o componente estiver expandido, localizada na parte superior.
   *
   * > **Importante:**
   * - Caso esta propriedade estiver indefinida ou inválida o espaço para logomarca será removido.
   * - Como boa prática, indica-se utilizar imagens com até `24px` de altura e `224px` de largura,
   * caso ultrapassar esses valores a imagem será readequada no espaço disponível.
   */
  logo;
  /**
   * @optional
   *
   * @description
   *
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   *
   * @default `Logomarca início`
   */
  logoAlt;
  /**
   * @optional
   *
   * @description
   *
   * Caminho para a logomarca, que será exibida quando o componente estiver colapsado, localizada na parte superior.
   *
   * > **Importante:**
   * - Caso esta propriedade estiver indefinida ou inválida passa a assumir o valor informado na propriedade `p-logo` e na ausência desta o
   * espaço para logomarca será removido.
   * - Como boa prática, indica-se utilizar imagens com até `48px` de altura e `48px` de largura,
   * caso ultrapassar esses valores a imagem será readequada no espaço disponível.
   * - Caso não informar um valor, esta propriedade passa a assumir o valor informado na propriedade `p-logo`.
   */
  shortLogo;
  constructor(menuGlobalService, menuService, languageService) {
    this.menuGlobalService = menuGlobalService;
    this.menuService = menuService;
    this.languageService = languageService;
    this.literals = __spreadValues(__spreadValues({}, poMenuLiteralsDefault[this.languageService?.getLanguageDefault()]), poMenuLiteralsDefault[this.languageService?.getShortLanguage()]);
  }
  setMenuExtraProperties() {
    this.allowIcons = !!this.menus.length;
    this.allowCollapseMenu = !!this.menus.length;
    this.menus.forEach((menuItem) => {
      this._level = 1;
      this.allowIcons = this.allowIcons ? validValue(menuItem.icon) : false;
      this.allowCollapseMenu = this.allowCollapseMenu && this.allowIcons ? validValue(menuItem.shortLabel) : false;
      this.removeBadgeAlert(menuItem);
      this.setMenuItemProperties(menuItem);
      if (menuItem.subItems) {
        this._level++;
        this.processSubItems(menuItem);
      }
    });
  }
  setMenuItemProperties(menuItem) {
    menuItem["id"] = menuItem["id"] || uuid();
    menuItem["level"] = this._level;
    menuItem["type"] = this.setMenuType(menuItem);
  }
  validateMenus(menus) {
    menus.forEach((menu) => this.validateMenu(menu));
  }
  setMenuType(menuItem) {
    if (menuItem.subItems && menuItem.subItems.length > 0 && this._level < this.maxLevel) {
      return "subItems";
    }
    if (!menuItem.link) {
      return "noLink";
    }
    if (isExternalLink(menuItem.link)) {
      return "externalLink";
    }
    return "internalLink";
  }
  configService(service) {
    if (typeof service === "string" && service.trim()) {
      this.menuService.configProperties(service);
      this.filterService = this.menuService;
    } else if (typeof service === "object" && service.getFilteredData) {
      this.filterService = service;
    } else {
      this.filterService = void 0;
    }
  }
  processSubItems(menu) {
    menu.subItems.forEach((menuItem, index, menuItems) => {
      const previousItem = menuItems[index - 1];
      if (previousItem && previousItem.subItems) {
        this._level = previousItem["level"];
      }
      if (this._level <= this.maxLevel) {
        this.setMenuItemProperties(menuItem);
        if (menuItem.subItems) {
          this._level++;
          this.processSubItems(menuItem);
        }
      }
      if (!menu["badgeAlert"]) {
        menu = this.setMenuBadgeAlert(menu, menuItem);
      }
    });
    menu.subItems = Object.assign([], menu.subItems);
  }
  removeBadgeAlert(menuItem) {
    if (menuItem["badgeAlert"]) {
      delete menuItem["badgeAlert"];
    }
    if (menuItem.subItems) {
      menuItem.subItems.forEach((subItem) => this.removeBadgeAlert(subItem));
    }
  }
  setMenuBadgeAlert(parent, child) {
    const childHasSubItems = child.subItems && child.subItems.length;
    const childHasBadgeAlert = child["badgeAlert"];
    const childHasBadge = child.badge && convertToInt(child.badge.value) >= 0;
    parent["badgeAlert"] = childHasBadgeAlert || childHasBadge && !childHasSubItems;
    return parent;
  }
  validateMenu(menuItem) {
    if (!menuItem.label || menuItem.label.trim() === "") {
      throw new Error(this.literals.emptyLabelError);
    } else if (menuItem.subItems) {
      menuItem.subItems.forEach((subItem) => {
        this.validateMenu(subItem);
      });
    }
  }
  static ɵfac = function PoMenuBaseComponent_Factory(t) {
    return new (t || _PoMenuBaseComponent)(ɵɵdirectiveInject(PoMenuGlobalService), ɵɵdirectiveInject(PoMenuService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoMenuBaseComponent, inputs: { automaticToggle: [InputFlags.HasDecoratorInputTransform, "p-automatic-toggle", "automaticToggle", convertToBoolean], collapsed: [InputFlags.None, "p-collapsed", "collapsed"], menus: [InputFlags.None, "p-menus", "menus"], filter: [InputFlags.None, "p-filter", "filter"], service: [InputFlags.None, "p-service", "service"], params: [InputFlags.None, "p-params", "params"], logo: [InputFlags.None, "p-logo", "logo"], logoAlt: [InputFlags.None, "p-logo-alt", "logoAlt"], shortLogo: [InputFlags.None, "p-short-logo", "shortLogo"] }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuBaseComponent, [{
    type: Directive
  }], () => [{ type: PoMenuGlobalService }, { type: PoMenuService }, { type: PoLanguageService }], { automaticToggle: [{
    type: Input,
    args: [{ alias: "p-automatic-toggle", transform: convertToBoolean }]
  }], collapsed: [{
    type: Input,
    args: ["p-collapsed"]
  }], menus: [{
    type: Input,
    args: ["p-menus"]
  }], filter: [{
    type: Input,
    args: ["p-filter"]
  }], service: [{
    type: Input,
    args: ["p-service"]
  }], params: [{
    type: Input,
    args: ["p-params"]
  }], logo: [{
    type: Input,
    args: ["p-logo"]
  }], logoAlt: [{
    type: Input,
    args: ["p-logo-alt"]
  }], shortLogo: [{
    type: Input,
    args: ["p-short-logo"]
  }] });
})();
function PoMenuComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("click", function PoMenuComponent_div_0_Template_div_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.toggleMenuMobile());
    });
    ɵɵelementEnd();
  }
}
function PoMenuComponent_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵelement(1, "po-logo", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-class", ctx_r1.enableCollapse ? "po-menu-short-logo" : "po-menu-logo")("p-logo", ctx_r1.enableCollapse ? ctx_r1.shortLogo || ctx_r1.logo : ctx_r1.logo)("p-logo-alt", ctx_r1.logoAlt);
  }
}
function PoMenuComponent_div_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoMenuComponent_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtemplate(1, PoMenuComponent_div_8_ng_container_1_Template, 1, 0, "ng-container", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2.menuHeaderTemplate.templateRef);
  }
}
function PoMenuComponent_po_menu_filter_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-menu-filter", 22);
    ɵɵlistener("p-filter", function PoMenuComponent_po_menu_filter_9_Template_po_menu_filter_p_filter_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.debounceFilter($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("p-enable-collapse", ctx_r3.enableCollapse)("p-loading", ctx_r3.filterLoading);
  }
}
function PoMenuComponent_li_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 23);
    ɵɵelement(1, "po-menu-item", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-level", 1)("p-label", ctx_r4.literals.itemNotFound)("p-short-label", ctx_r4.literals.itemNotFound);
  }
}
function PoMenuComponent_li_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 23);
    ɵɵelement(1, "po-menu-item", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const menu_r12 = ctx.$implicit;
    const menuIndex_r13 = ctx.index;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("po-menu-item-first", menuIndex_r13 === 0);
    ɵɵattribute("aria-level", menu_r12.level);
    ɵɵadvance();
    ɵɵproperty("p-action", menu_r12.action)("p-badge-alert", menu_r12.badgeAlert)("p-badge-color", menu_r12.badge ? menu_r12.badge.color : void 0)("p-badge-value", menu_r12.badge ? menu_r12.badge.value : void 0)("p-collapsed-menu", ctx_r5.enableCollapse)("p-icon", ctx_r5.allowIcons ? menu_r12.icon : null)("p-id", menu_r12.id)("p-label", menu_r12.label)("p-level", menu_r12.level)("p-link", menu_r12.link)("p-short-label", menu_r12.shortLabel)("p-sub-items", menu_r12.subItems)("p-type", menu_r12.type);
  }
}
function PoMenuComponent_div_17_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 30);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r14.literals.close);
  }
}
function PoMenuComponent_div_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 26)(1, "button", 27);
    ɵɵlistener("click", function PoMenuComponent_div_17_Template_button_click_1_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15.toggle());
    });
    ɵɵtemplate(2, PoMenuComponent_div_17_span_2_Template, 2, 1, "span", 28);
    ɵɵelement(3, "po-icon", 29);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r6.enableCollapseButton ? ctx_r6.literals.close : ctx_r6.literals.open);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r6.enableCollapseButton);
    ɵɵadvance();
    ɵɵproperty("p-icon", ctx_r6.enableCollapse ? "po-icon-menu-open" : "po-icon-menu-close");
  }
}
var _c0$l = (a0) => ({ "po-menu-animation": a0 });
var poMenuDebounceTime = 400;
var poMenuMinLength = 3;
var poMenuRootLevel = 1;
var PoMenuComponent = class _PoMenuComponent extends PoMenuBaseComponent {
  changeDetector;
  element;
  renderer;
  router;
  menuItemsService;
  menuHeaderTemplate;
  activeMenuItem;
  collapsedMobile;
  filterLoading = false;
  groupedMenuItem;
  id = uuid();
  linkActive;
  mobileOpened = false;
  noData = false;
  timeoutFilter;
  filteringItems = false;
  menuInitialized = false;
  menuPrevious = null;
  resizeListener;
  itemSubscription;
  routeSubscription;
  constructor(changeDetector, element, renderer, router, menuItemsService, menuGlobalService, menuService, languageService) {
    super(menuGlobalService, menuService, languageService);
    this.changeDetector = changeDetector;
    this.element = element;
    this.renderer = renderer;
    this.router = router;
    this.menuItemsService = menuItemsService;
  }
  get isActiveItemMenuSubMenu() {
    return this.activeMenuItem["level"] > this.groupedMenuItem["level"];
  }
  get enableCollapse() {
    return this.isCollapsed && !this.collapsedMobile;
  }
  get enableCollapseButton() {
    return this.allowCollapseMenu && !this.collapsed && !this.mobileOpened;
  }
  get hasFooter() {
    return this.enableCollapseButton || this.enableCollapse;
  }
  get isCollapsed() {
    return this.allowCollapseMenu && this.collapsed;
  }
  ngDoCheck() {
    if (this.filteringItems && this.filter) {
      return;
    }
    const menuCurrent = this.stringify(this.menus);
    if (this.menuPrevious !== menuCurrent || !this.menuInitialized) {
      this.updateMenu();
      this.validateCollapseClass();
    }
  }
  ngOnDestroy() {
    this.itemSubscription.unsubscribe();
    this.routeSubscription.unsubscribe();
    if (this.resizeListener) {
      this.resizeListener();
    }
    this.menuGlobalService.sendRemovedApplicationMenu(this.id);
  }
  ngOnInit() {
    this.subscribeToMenuItem();
    this.subscribeToRoute();
  }
  ngAfterViewInit() {
    this.menuGlobalService.sendApplicationMenu(this);
  }
  activateMenuByUrl(urlPath, menus) {
    if (menus) {
      const urlPathWithoutLastFragment = urlPath.substr(0, urlPath.lastIndexOf("/"));
      return menus.some((menu) => {
        const formattedMenuLink = getFormattedLink(menu.link);
        const menuLinkPath = `${urlPathWithoutLastFragment}${formattedMenuLink.substr(formattedMenuLink.lastIndexOf("/"))}`;
        if (menuLinkPath === urlPath && menuLinkPath === formattedMenuLink) {
          this.linkActive = formattedMenuLink;
          this.activateMenuItem(menu);
          return true;
        } else {
          return this.activateMenuByUrl(urlPath, menu.subItems);
        }
      });
    }
  }
  checkActiveMenuByUrl(urlPath) {
    if (!this.linkActive || this.linkActive !== urlPath) {
      this.activateMenuByUrl(urlPath, this.menus);
    }
  }
  /**
   * <a id="colapseMethod"></a>
   *
   * *Método para colapsar (retrair) o menu.
   */
  collapse() {
    this.validateToggleMenu(true);
  }
  debounceFilter(filter2) {
    clearTimeout(this.timeoutFilter);
    this.timeoutFilter = setTimeout(() => {
      this.filterProcess(filter2);
    }, poMenuDebounceTime);
  }
  /**
   * <a id="expandMethod"></a>
   *
   * *Método para expandir (aumentar) o menu.
   */
  expand() {
    this.validateToggleMenu(false);
  }
  subscribeToMenuItem() {
    this.itemSubscription = this.menuItemsService.receiveFromChildMenuClicked().subscribe((menu) => {
      this.clickMenuItem(menu);
    });
  }
  subscribeToRoute() {
    this.routeSubscription = this.router.events.subscribe((val) => {
      if (val instanceof NavigationEnd || val instanceof NavigationCancel) {
        const urlRouter = this.checkingRouterChildrenFragments();
        this.checkActiveMenuByUrl(urlRouter);
      }
    });
  }
  /**
   * <a id="toggleMethod"></a>
   * *Método que colapsa e expande o menu alternadamente.
   *
   * > *Os métodos apenas vão colapsar/expandir o menu se:
   *  - Todos os itens de menu tiverem valor nas propriedades `icon` e `shortLabel`.
   */
  toggle() {
    this.validateToggleMenu(!this.collapsed);
  }
  toggleMenuMobile() {
    this.mobileOpened = !this.mobileOpened;
    this.collapsedMobile = this.collapsed && this.mobileOpened;
    this.validateCollapseClass(this.collapsedMobile);
    if (isMobile()) {
      return;
    }
    if (this.mobileOpened) {
      this.createResizeListener();
    }
  }
  onMouseEnter() {
    if (this.collapsed && this.automaticToggle) {
      this.collapsed = false;
      this.allowCollapseHover = true;
    }
  }
  onMouseLeave() {
    if (!this.collapsed && this.allowCollapseHover && this.automaticToggle) {
      this.collapsed = true;
    }
  }
  checkingRouterChildrenFragments() {
    const childrenPrimary = this.router.parseUrl(this.router.url).root.children["primary"];
    return childrenPrimary ? `/${childrenPrimary.segments.map((it) => it.path).join("/")}` : "";
  }
  validateCollapseClass(collapsedMobile = false) {
    const wrapper = this.element.nativeElement.parentNode;
    this.renderer[this.isCollapsed && !collapsedMobile ? "addClass" : "removeClass"](wrapper, "po-collapsed-menu");
  }
  activateCollapseSubMenuItem() {
    this.clearGroupMenuIfFirstLevel(this.activeMenuItem);
    if (!this.collapsed && this.activeMenuItem["level"] > poMenuRootLevel && this.isActiveItemMenuSubMenu) {
      this.openParentMenu(this.activeMenuItem);
    }
  }
  activateMenuItem(menu) {
    this.activeMenuItem = menu;
    this.linkActive = menu.link;
    if (this.activeMenuItem["level"] > poMenuRootLevel) {
      this.openParentMenu(this.activeMenuItem);
    } else {
      this.groupedMenuItem = null;
    }
    this.menuItemsService.sendToChildMenuClicked({
      active: this.activeMenuItem,
      grouped: this.groupedMenuItem,
      activatedByRoute: true
    });
  }
  areSubMenus(menus) {
    return menus.every((menu) => menu["level"] > poMenuRootLevel);
  }
  clearGroupMenuIfFirstLevel(activeMenuItem) {
    if (activeMenuItem["level"] === poMenuRootLevel) {
      this.groupedMenuItem = void 0;
    }
  }
  clickMenuItem(menu) {
    if (menu.action) {
      this.executeMenuAction(menu);
    }
    if (menu["type"] === "externalLink") {
      openExternalLink(menu.link);
    } else if (menu["type"] === "internalLink") {
      this.activateMenuItem(menu);
    } else if (menu["type"] === "subItems") {
      if (this.filteringItems) {
        this.filteringItems = false;
      }
      this.groupMenuItem(menu);
    }
    if (menu["type"] !== "subItems") {
      this.mobileOpened = false;
    }
  }
  convertToMenuItemFiltered(menuItem = { label: "", link: "", action: () => {
  } }) {
    const { label, link, action } = menuItem;
    const menuItemFiltered = { label, link, action };
    this.setMenuItemProperties(menuItemFiltered);
    return menuItemFiltered;
  }
  createResizeListener() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.toggleResize();
      this.resizeListener();
    });
  }
  executeMenuAction(menu) {
    menu.action(menu);
  }
  filterItems(filter2) {
    return __async(this, null, function* () {
      const trimFilter = filter2 && filter2.trim();
      if (trimFilter) {
        this.filteredItems = [];
        this.filteredItems = this.filterService ? yield this.filterOnService(trimFilter) : this.filterLocalItems(trimFilter);
        this.filteringItems = true;
      } else {
        this.filteredItems = [...this.menus];
        this.filteringItems = false;
      }
    });
  }
  filterLocalItems(filter2) {
    const filteredItems = [];
    this.findItems(this.menus, filter2.toLowerCase(), filteredItems);
    return filteredItems;
  }
  filterProcess(filter2) {
    this.filterLoading = true;
    this.filterItems(filter2).then(() => {
      this.filterLoading = false;
      this.showNoData();
      this.changeDetector.detectChanges();
      this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, grouped: this.groupedMenuItem });
    }).catch((error) => {
      this.filterLoading = false;
      Promise.reject(error);
    });
  }
  filterOnService(search = "") {
    return __async(this, null, function* () {
      if (search.length >= poMenuMinLength) {
        return yield this.filterService.getFilteredData(search, this.params).pipe(map((menuItemsFiltered) => menuItemsFiltered.map((menuItem) => this.convertToMenuItemFiltered(menuItem)))).toPromise();
      } else {
        return this.filteredItems;
      }
    });
  }
  findItems(menus, filter2, filteredItems) {
    menus.forEach((menu) => {
      const hasAction = menu.action || menu.link;
      const labelHasFilter = menu.label.toLowerCase().includes(filter2);
      if (labelHasFilter && hasAction) {
        const newMenu = __spreadValues({}, menu);
        if (newMenu.subItems?.length) {
          delete newMenu.subItems;
          newMenu["type"] = this.setMenuType(newMenu);
        }
        filteredItems.push(newMenu);
      }
      if (menu.subItems) {
        this.findItems(menu.subItems, filter2, filteredItems);
      }
    });
  }
  findParent(menus, menuItem) {
    const getParent = function(menuItems, id) {
      if (menuItems) {
        for (let index = 0; index < menuItems.length; index++) {
          const menu = menuItems[index];
          if (menu.subItems && menu.subItems.find((subItem) => subItem["id"] === id)) {
            return menu;
          }
          const found = getParent(menu.subItems, id);
          if (found) {
            return found;
          }
        }
      }
    };
    return getParent(menus, menuItem["id"]);
  }
  findRootParent(menus, menu) {
    const findParent = this.findParent;
    const getRootParent = function(menuItems, menuItem) {
      let parent = findParent(menuItems, menuItem);
      if (parent["level"] !== poMenuRootLevel) {
        parent = getRootParent(menuItems, parent);
      }
      return parent;
    };
    return getRootParent(menus, menu);
  }
  getActiveMenuParent(menus, activeMenuItem, groupedMenuItem) {
    if (this.areSubMenus([groupedMenuItem, activeMenuItem])) {
      return this.findRootParent(menus, activeMenuItem);
    }
  }
  groupMenuItem(menu) {
    if (this.collapsed) {
      this.toggleMenuCollapse();
    }
    menu["isOpened"] = !menu["isOpened"];
    this.groupedMenuItem = menu;
    if (this.activeMenuItem && menu["isOpened"] && this.isActiveItemMenuSubMenu && this.isRootMenuEqualGroupedMenu(this.menus, this.activeMenuItem, menu)) {
      this.activateMenuItem(this.activeMenuItem);
    }
    this.menuItemsService.sendToChildMenuClicked({ active: this.activeMenuItem, grouped: this.groupedMenuItem });
  }
  isRootMenuEqualGroupedMenu(menus, activeMenuItem, groupedMenuItem) {
    const activeMenuRootParent = this.findRootParent(menus, activeMenuItem);
    return activeMenuRootParent["id"] === groupedMenuItem["id"];
  }
  openParentMenu(childMenu) {
    const parent = this.findParent(this.menus, childMenu);
    parent["isOpened"] = true;
    this.groupedMenuItem = parent;
  }
  showNoData() {
    this.noData = this.filteredItems.length === 0;
  }
  stringify(menus) {
    return JSON.stringify(this.menus, (key, value) => {
      if (key !== "icon") {
        return value;
      }
    });
  }
  toggleGroupedMenuItem() {
    this.groupedMenuItem["isOpened"] = !this.collapsed && this.allowCollapseMenu;
  }
  toggleMenuCollapse(collapsed = false) {
    this.collapsed = collapsed;
    if (this.groupedMenuItem && this.activeMenuItem) {
      this.groupedMenuItem = this.getActiveMenuParent(this.menus, this.activeMenuItem, this.groupedMenuItem) || this.groupedMenuItem;
      this.toggleGroupedMenuItem();
    }
    if (this.activeMenuItem) {
      this.activateCollapseSubMenuItem();
      this.menuItemsService.sendToChildMenuClicked({
        active: this.activeMenuItem,
        grouped: this.groupedMenuItem,
        activatedByRoute: true
      });
    }
    this.updateMenu();
  }
  toggleResize() {
    if (this.mobileOpened) {
      this.mobileOpened = false;
      this.collapsedMobile = false;
      this.validateCollapseClass(this.collapsedMobile);
    }
  }
  validateToggleMenu(collapsed) {
    if (!this.allowCollapseMenu) {
      return;
    }
    this.toggleMenuCollapse(collapsed);
  }
  updateMenu() {
    this.menuInitialized = true;
    this.setMenuExtraProperties();
    this.filteredItems = [...this.menus];
    this.menuPrevious = this.stringify(this.menus);
    this.validateMenus(this.menus);
  }
  static ɵfac = function PoMenuComponent_Factory(t) {
    return new (t || _PoMenuComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(PoMenuItemsService), ɵɵdirectiveInject(PoMenuGlobalService), ɵɵdirectiveInject(PoMenuService), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoMenuComponent, selectors: [["po-menu"]], contentQueries: function PoMenuComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoMenuHeaderTemplateDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuHeaderTemplate = _t.first);
    }
  }, features: [ɵɵProvidersFeature([PoMenuItemsService, PoMenuService]), ɵɵInheritDefinitionFeature], decls: 18, vars: 11, consts: [["class", "po-menu-overlay", 3, "click", 4, "ngIf"], [1, "po-menu-mobile", "po-clickable", 3, "click"], ["p-icon", "po-icon-menu"], [1, "po-menu", 3, "ngClass"], [1, "po-menu-container", 3, "mouseenter", "mouseleave"], [1, "po-menu-header"], ["class", "po-menu-header-container-logo", 4, "ngIf"], ["class", "po-menu-header-template", 4, "ngIf"], [3, "p-enable-collapse", "p-loading", "p-filter", 4, "ngIf"], [1, "po-menu-body"], [1, "po-menu-outer"], [1, "po-menu-inner"], [1, "po-menu-nav"], ["role", "menu", 1, "po-menu-list"], ["class", "po-menu-list-item", "role", "presentation", 4, "ngIf"], ["class", "po-menu-list-item", "role", "presentation", 3, "po-menu-item-first", 4, "ngFor", "ngForOf"], ["class", "po-menu-footer", 4, "ngIf"], [1, "po-menu-overlay", 3, "click"], [1, "po-menu-header-container-logo"], [3, "p-class", "p-logo", "p-logo-alt"], [1, "po-menu-header-template"], [4, "ngTemplateOutlet"], [3, "p-enable-collapse", "p-loading", "p-filter"], ["role", "presentation", 1, "po-menu-list-item"], ["p-icon", "po-icon-info", "p-type", "noData", 3, "p-level", "p-label", "p-short-label"], [3, "p-action", "p-badge-alert", "p-badge-color", "p-badge-value", "p-collapsed-menu", "p-icon", "p-id", "p-label", "p-level", "p-link", "p-short-label", "p-sub-items", "p-type"], [1, "po-menu-footer"], ["type", "button", 1, "po-menu-collapse-button-icon", 3, "click"], ["aria-hidden", "true", 4, "ngIf"], [3, "p-icon"], ["aria-hidden", "true"]], template: function PoMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoMenuComponent_div_0_Template, 1, 0, "div", 0);
      ɵɵelementStart(1, "div")(2, "div", 1);
      ɵɵlistener("click", function PoMenuComponent_Template_div_click_2_listener() {
        return ctx.toggleMenuMobile();
      });
      ɵɵelement(3, "po-icon", 2);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3)(5, "div", 4);
      ɵɵlistener("mouseenter", function PoMenuComponent_Template_div_mouseenter_5_listener() {
        return ctx.onMouseEnter();
      })("mouseleave", function PoMenuComponent_Template_div_mouseleave_5_listener() {
        return ctx.onMouseLeave();
      });
      ɵɵelementStart(6, "div", 5);
      ɵɵtemplate(7, PoMenuComponent_div_7_Template, 2, 3, "div", 6)(8, PoMenuComponent_div_8_Template, 2, 1, "div", 7)(9, PoMenuComponent_po_menu_filter_9_Template, 1, 2, "po-menu-filter", 8);
      ɵɵelementEnd();
      ɵɵelementStart(10, "div", 9)(11, "div", 10)(12, "div", 11)(13, "nav", 12)(14, "ul", 13);
      ɵɵtemplate(15, PoMenuComponent_li_15_Template, 2, 3, "li", 14)(16, PoMenuComponent_li_16_Template, 2, 16, "li", 15);
      ɵɵelementEnd()()()()()();
      ɵɵtemplate(17, PoMenuComponent_div_17_Template, 4, 3, "div", 16);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.mobileOpened);
      ɵɵadvance(4);
      ɵɵproperty("ngClass", ɵɵpureFunction1(9, _c0$l, ctx.mobileOpened));
      ɵɵattribute("aria-expanded", !ctx.collapsed);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.logo || ctx.shortLogo && ctx.enableCollapse);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.enableCollapse && ctx.menuHeaderTemplate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.filter);
      ɵɵadvance(6);
      ɵɵproperty("ngIf", ctx.noData);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.filteredItems);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasFooter);
    }
  }, dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, PoLogoComponent, PoIconComponent, PoMenuFilterComponent, PoMenuItemComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuComponent, [{
    type: Component,
    args: [{ selector: "po-menu", providers: [PoMenuItemsService, PoMenuService], template: `<div *ngIf="mobileOpened" class="po-menu-overlay" (click)="toggleMenuMobile()"></div>

<div>
  <div class="po-menu-mobile po-clickable" (click)="toggleMenuMobile()">
    <po-icon p-icon="po-icon-menu"></po-icon>
  </div>

  <div class="po-menu" [attr.aria-expanded]="!collapsed" [ngClass]="{ 'po-menu-animation': mobileOpened }">
    <div class="po-menu-container" (mouseenter)="onMouseEnter()" (mouseleave)="onMouseLeave()">
      <div class="po-menu-header">
        <div *ngIf="logo || (shortLogo && enableCollapse)" class="po-menu-header-container-logo">
          <po-logo
            [p-class]="enableCollapse ? 'po-menu-short-logo' : 'po-menu-logo'"
            [p-logo]="enableCollapse ? shortLogo || logo : logo"
            [p-logo-alt]="logoAlt"
          ></po-logo>
        </div>

        <div *ngIf="!enableCollapse && menuHeaderTemplate" class="po-menu-header-template">
          <ng-container *ngTemplateOutlet="menuHeaderTemplate.templateRef"></ng-container>
        </div>

        <po-menu-filter
          *ngIf="filter"
          [p-enable-collapse]="enableCollapse"
          [p-loading]="filterLoading"
          (p-filter)="debounceFilter($event)"
        ></po-menu-filter>
      </div>

      <div class="po-menu-body">
        <div class="po-menu-outer">
          <div class="po-menu-inner">
            <nav class="po-menu-nav">
              <ul class="po-menu-list" role="menu">
                <li *ngIf="noData" class="po-menu-list-item" role="presentation">
                  <po-menu-item
                    p-icon="po-icon-info"
                    p-type="noData"
                    [p-level]="1"
                    [p-label]="literals.itemNotFound"
                    [p-short-label]="literals.itemNotFound"
                  ></po-menu-item>
                </li>
                <li
                  *ngFor="let menu of filteredItems; let menuIndex = index"
                  class="po-menu-list-item"
                  role="presentation"
                  [attr.aria-level]="menu.level"
                  [class.po-menu-item-first]="menuIndex === 0"
                >
                  <po-menu-item
                    [p-action]="menu.action"
                    [p-badge-alert]="menu.badgeAlert"
                    [p-badge-color]="menu.badge ? menu.badge.color : undefined"
                    [p-badge-value]="menu.badge ? menu.badge.value : undefined"
                    [p-collapsed-menu]="enableCollapse"
                    [p-icon]="allowIcons ? menu.icon : null"
                    [p-id]="menu.id"
                    [p-label]="menu.label"
                    [p-level]="menu.level"
                    [p-link]="menu.link"
                    [p-short-label]="menu.shortLabel"
                    [p-sub-items]="menu.subItems"
                    [p-type]="menu.type"
                  ></po-menu-item>
                </li>
              </ul>
            </nav>
          </div>
        </div>
      </div>
    </div>

    <div *ngIf="hasFooter" class="po-menu-footer">
      <button
        class="po-menu-collapse-button-icon"
        type="button"
        [attr.aria-label]="enableCollapseButton ? literals.close : literals.open"
        (click)="toggle()"
      >
        <span *ngIf="enableCollapseButton" aria-hidden="true">{{ literals.close }}</span>

        <po-icon [p-icon]="enableCollapse ? 'po-icon-menu-open' : 'po-icon-menu-close'"></po-icon>
      </button>
    </div>
  </div>
</div>
` }]
  }], () => [{ type: ChangeDetectorRef }, { type: ElementRef }, { type: Renderer2 }, { type: Router }, { type: PoMenuItemsService }, { type: PoMenuGlobalService }, { type: PoMenuService }, { type: PoLanguageService }], { menuHeaderTemplate: [{
    type: ContentChild,
    args: [PoMenuHeaderTemplateDirective, { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoMenuComponent, { className: "PoMenuComponent", filePath: "lib/components/po-menu/po-menu.component.ts", lineNumber: 120 });
})();
var PoMenuModule = class _PoMenuModule {
  static ɵfac = function PoMenuModule_Factory(t) {
    return new (t || _PoMenuModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoMenuModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule, PoBadgeModule, PoFieldModule, PoLoadingModule, PoLogoModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoBadgeModule, PoFieldModule, PoLoadingModule, PoLogoModule, PoIconModule],
      declarations: [PoMenuComponent, PoMenuFilterComponent, PoMenuHeaderTemplateDirective, PoMenuItemComponent],
      exports: [PoMenuComponent, PoMenuHeaderTemplateDirective]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoMenuModule, { declarations: [PoMenuComponent, PoMenuFilterComponent, PoMenuHeaderTemplateDirective, PoMenuItemComponent], imports: [CommonModule, RouterModule, PoBadgeModule, PoFieldModule, PoLoadingModule, PoLogoModule, PoIconModule], exports: [PoMenuComponent, PoMenuHeaderTemplateDirective] });
})();
var PoNavbarActionComponent = class _PoNavbarActionComponent {
  router;
  action;
  icon;
  label;
  link;
  tooltip;
  constructor(viewContainerRef, router) {
    this.router = router;
  }
  click() {
    if (this.action) {
      this.action();
      return;
    }
    if (this.link) {
      return this.openUrl(this.link);
    }
  }
  openUrl(url) {
    if (isExternalLink(url)) {
      return openExternalLink(url);
    }
    if (url) {
      return this.router.navigate([url]);
    }
  }
  static ɵfac = function PoNavbarActionComponent_Factory(t) {
    return new (t || _PoNavbarActionComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarActionComponent, selectors: [["po-navbar-action"]], inputs: { action: [InputFlags.None, "p-action", "action"], icon: [InputFlags.None, "p-icon", "icon"], label: [InputFlags.None, "p-label", "label"], link: [InputFlags.None, "p-link", "link"], tooltip: [InputFlags.None, "p-tooltip-text", "tooltip"] }, decls: 1, vars: 2, consts: [["tabindex", "0", 1, "po-navbar-action-content", "po-clickable", 3, "p-icon", "p-tooltip", "click"]], template: function PoNavbarActionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-icon", 0);
      ɵɵlistener("click", function PoNavbarActionComponent_Template_po_icon_click_0_listener() {
        return ctx.click();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-icon", ctx.icon)("p-tooltip", ctx.tooltip);
    }
  }, dependencies: [PoTooltipDirective, PoIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-action", template: '<po-icon\n  tabindex="0"\n  class="po-navbar-action-content po-clickable"\n  [p-icon]="icon"\n  [p-tooltip]="tooltip"\n  (click)="click()"\n></po-icon>\n' }]
  }], () => [{ type: ViewContainerRef }, { type: Router }], { action: [{
    type: Input,
    args: ["p-action"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], link: [{
    type: Input,
    args: ["p-link"]
  }], tooltip: [{
    type: Input,
    args: ["p-tooltip-text"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarActionComponent, { className: "PoNavbarActionComponent", filePath: "lib/components/po-navbar/po-navbar-actions/po-navbar-action/po-navbar-action.component.ts", lineNumber: 10 });
})();
var PoNavbarActionPopupComponent = class _PoNavbarActionPopupComponent {
  iconActions;
  getLastIconAction() {
    if (this.iconActions && this.iconActions.length) {
      return this.iconActions[this.iconActions.length - 1].icon;
    }
  }
  static ɵfac = function PoNavbarActionPopupComponent_Factory(t) {
    return new (t || _PoNavbarActionPopupComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarActionPopupComponent, selectors: [["po-navbar-action-popup"]], inputs: { iconActions: [InputFlags.None, "p-icon-actions", "iconActions"] }, decls: 5, vars: 5, consts: [["tabindex", "0", 1, "po-navbar-action-popup-content", "po-clickable", 3, "click"], ["target", ""], [3, "p-actions", "p-target"], ["popup", ""]], template: function PoNavbarActionPopupComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r2 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("click", function PoNavbarActionPopupComponent_Template_div_click_0_listener() {
        ɵɵrestoreView(_r2);
        const _r1 = ɵɵreference(4);
        return ɵɵresetView(_r1.toggle());
      });
      ɵɵelement(2, "span");
      ɵɵelementEnd();
      ɵɵelement(3, "po-popup", 2, 3);
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵclassMapInterpolate1("po-icon ", ctx.getLastIconAction(), "");
      ɵɵadvance();
      ɵɵproperty("p-actions", ctx.iconActions)("p-target", _r0);
    }
  }, dependencies: [PoPopupComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionPopupComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-action-popup", template: '<div tabindex="0" #target class="po-navbar-action-popup-content po-clickable" (click)="popup.toggle()">\n  <span class="po-icon {{ getLastIconAction() }}"></span>\n</div>\n\n<po-popup #popup [p-actions]="iconActions" [p-target]="target"> </po-popup>\n' }]
  }], null, { iconActions: [{
    type: Input,
    args: ["p-icon-actions"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarActionPopupComponent, { className: "PoNavbarActionPopupComponent", filePath: "lib/components/po-navbar/po-navbar-actions/po-navbar-action-popup/po-navbar-action-popup.component.ts", lineNumber: 9 });
})();
function PoNavbarActionsComponent_po_navbar_action_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-navbar-action", 2);
  }
  if (rf & 2) {
    const iconAction_r1 = ctx.$implicit;
    ɵɵproperty("p-action", iconAction_r1.action)("p-icon", iconAction_r1.icon)("p-label", iconAction_r1.label)("p-link", iconAction_r1.link)("p-tooltip-text", iconAction_r1.tooltip);
  }
}
var PoNavbarActionsComponent = class _PoNavbarActionsComponent {
  _iconActions;
  set iconActions(actions) {
    this._iconActions = actions.map((action) => __spreadProps(__spreadValues({}, action), { separator: true, url: action.link }));
  }
  get iconActions() {
    return this._iconActions;
  }
  static ɵfac = function PoNavbarActionsComponent_Factory(t) {
    return new (t || _PoNavbarActionsComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarActionsComponent, selectors: [["po-navbar-actions"]], inputs: { iconActions: [InputFlags.None, "p-icon-actions", "iconActions"] }, decls: 2, vars: 2, consts: [["class", "po-navbar-action", 3, "p-action", "p-icon", "p-label", "p-link", "p-tooltip-text", 4, "ngFor", "ngForOf"], [1, "po-navbar-action-popup", 3, "p-icon-actions"], [1, "po-navbar-action", 3, "p-action", "p-icon", "p-label", "p-link", "p-tooltip-text"]], template: function PoNavbarActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoNavbarActionsComponent_po_navbar_action_0_Template, 1, 5, "po-navbar-action", 0);
      ɵɵelement(1, "po-navbar-action-popup", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.iconActions);
      ɵɵadvance();
      ɵɵproperty("p-icon-actions", ctx.iconActions);
    }
  }, dependencies: [NgForOf, PoNavbarActionComponent, PoNavbarActionPopupComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionsComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-actions", template: '<po-navbar-action\n  *ngFor="let iconAction of iconActions"\n  class="po-navbar-action"\n  [p-action]="iconAction.action"\n  [p-icon]="iconAction.icon"\n  [p-label]="iconAction.label"\n  [p-link]="iconAction.link"\n  [p-tooltip-text]="iconAction.tooltip"\n>\n</po-navbar-action>\n\n<po-navbar-action-popup class="po-navbar-action-popup" [p-icon-actions]="iconActions"> </po-navbar-action-popup>\n' }]
  }], null, { iconActions: [{
    type: Input,
    args: ["p-icon-actions"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarActionsComponent, { className: "PoNavbarActionsComponent", filePath: "lib/components/po-navbar/po-navbar-actions/po-navbar-actions.component.ts", lineNumber: 9 });
})();
var PoNavbarActionsModule = class _PoNavbarActionsModule {
  static ɵfac = function PoNavbarActionsModule_Factory(t) {
    return new (t || _PoNavbarActionsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoNavbarActionsModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoPopupModule, PoTooltipModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarActionsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoPopupModule, PoTooltipModule, PoIconModule],
      declarations: [PoNavbarActionComponent, PoNavbarActionPopupComponent, PoNavbarActionsComponent],
      exports: [PoNavbarActionsComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarActionsModule, { declarations: [PoNavbarActionComponent, PoNavbarActionPopupComponent, PoNavbarActionsComponent], imports: [CommonModule, PoPopupModule, PoTooltipModule, PoIconModule], exports: [PoNavbarActionsComponent] });
})();
var _c0$k = (a0, a1) => ({ "po-navbar-item-navigation-icon-disabled": a0, "po-clickable": a1 });
var PoNavbarItemNavigationIconComponent = class _PoNavbarItemNavigationIconComponent {
  disabled;
  icon;
  click = new EventEmitter();
  static ɵfac = function PoNavbarItemNavigationIconComponent_Factory(t) {
    return new (t || _PoNavbarItemNavigationIconComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarItemNavigationIconComponent, selectors: [["po-navbar-item-navigation-icon"]], inputs: { disabled: [InputFlags.None, "p-disabled", "disabled"], icon: [InputFlags.None, "p-icon", "icon"] }, outputs: { click: "p-click" }, decls: 2, vars: 7, consts: [["tabindex", "0", 3, "ngClass", "click"]], template: function PoNavbarItemNavigationIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoNavbarItemNavigationIconComponent_Template_div_click_0_listener() {
        return ctx.disabled ? void 0 : ctx.click.emit(ctx.icon);
      });
      ɵɵelement(1, "span");
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction2(4, _c0$k, ctx.disabled, !ctx.disabled));
      ɵɵadvance();
      ɵɵclassMapInterpolate1("po-icon po-icon-arrow-", ctx.icon, "");
    }
  }, dependencies: [NgClass], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemNavigationIconComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-item-navigation-icon", template: `<div
  [ngClass]="{ 'po-navbar-item-navigation-icon-disabled': disabled, 'po-clickable': !disabled }"
  tabindex="0"
  (click)="disabled ? undefined : click.emit(icon)"
>
  <span class="po-icon po-icon-arrow-{{ icon }}"></span>
</div>
` }]
  }], null, { disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], icon: [{
    type: Input,
    args: ["p-icon"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemNavigationIconComponent, { className: "PoNavbarItemNavigationIconComponent", filePath: "lib/components/po-navbar/po-navbar-item-navigation/po-navbar-item-navigation-icon/po-navbar-item-navigation-icon.component.ts", lineNumber: 7 });
})();
var PoNavbarItemNavigationComponent = class _PoNavbarItemNavigationComponent {
  disableLeft;
  disableRight;
  click = new EventEmitter();
  static ɵfac = function PoNavbarItemNavigationComponent_Factory(t) {
    return new (t || _PoNavbarItemNavigationComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarItemNavigationComponent, selectors: [["po-navbar-item-navigation"]], inputs: { disableLeft: [InputFlags.None, "p-disable-left", "disableLeft"], disableRight: [InputFlags.None, "p-disable-right", "disableRight"] }, outputs: { click: "p-click" }, decls: 2, vars: 2, consts: [["p-icon", "left", 1, "po-navbar-item-navigation-icon", 3, "p-disabled", "p-click"], ["p-icon", "right", 1, "po-navbar-item-navigation-icon", 3, "p-disabled", "p-click"]], template: function PoNavbarItemNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-navbar-item-navigation-icon", 0);
      ɵɵlistener("p-click", function PoNavbarItemNavigationComponent_Template_po_navbar_item_navigation_icon_p_click_0_listener($event) {
        return ctx.click.emit($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(1, "po-navbar-item-navigation-icon", 1);
      ɵɵlistener("p-click", function PoNavbarItemNavigationComponent_Template_po_navbar_item_navigation_icon_p_click_1_listener($event) {
        return ctx.click.emit($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("p-disabled", ctx.disableLeft);
      ɵɵadvance();
      ɵɵproperty("p-disabled", ctx.disableRight);
    }
  }, dependencies: [PoNavbarItemNavigationIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemNavigationComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-item-navigation", template: '<po-navbar-item-navigation-icon\n  class="po-navbar-item-navigation-icon"\n  p-icon="left"\n  [p-disabled]="disableLeft"\n  (p-click)="click.emit($event)"\n>\n</po-navbar-item-navigation-icon>\n\n<po-navbar-item-navigation-icon\n  class="po-navbar-item-navigation-icon"\n  p-icon="right"\n  [p-disabled]="disableRight"\n  (p-click)="click.emit($event)"\n>\n</po-navbar-item-navigation-icon>\n' }]
  }], null, { disableLeft: [{
    type: Input,
    args: ["p-disable-left"]
  }], disableRight: [{
    type: Input,
    args: ["p-disable-right"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemNavigationComponent, { className: "PoNavbarItemNavigationComponent", filePath: "lib/components/po-navbar/po-navbar-item-navigation/po-navbar-item-navigation.component.ts", lineNumber: 7 });
})();
var PoNavbarItemNavigationModule = class _PoNavbarItemNavigationModule {
  static ɵfac = function PoNavbarItemNavigationModule_Factory(t) {
    return new (t || _PoNavbarItemNavigationModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoNavbarItemNavigationModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: [PoNavbarItemNavigationComponent, PoNavbarItemNavigationIconComponent],
      exports: [PoNavbarItemNavigationComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarItemNavigationModule, { declarations: [PoNavbarItemNavigationComponent, PoNavbarItemNavigationIconComponent], imports: [CommonModule, RouterModule], exports: [PoNavbarItemNavigationComponent] });
})();
function PoNavbarItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 3);
    ɵɵlistener("click", function PoNavbarItemComponent_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.itemClick());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", ctx_r0.clickable);
    ɵɵproperty("href", ctx_r0.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.label, " ");
  }
}
function PoNavbarItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function PoNavbarItemComponent_a_2_Template_a_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.itemClick(ctx_r4.label, ctx_r4.link));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-clickable", ctx_r1.clickable);
    ɵɵproperty("routerLink", ctx_r1.link);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.label, " ");
  }
}
var PoNavbarItemComponent = class _PoNavbarItemComponent {
  action;
  clickable;
  label;
  link;
  click = new EventEmitter();
  get type() {
    return isExternalLink(this.link) ? "externalLink" : "internalLink";
  }
  itemClick(label, link) {
    if (this.action) {
      this.action({ label, link });
    }
    this.click.emit();
  }
  static ɵfac = function PoNavbarItemComponent_Factory(t) {
    return new (t || _PoNavbarItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarItemComponent, selectors: [["po-navbar-item"]], inputs: { action: [InputFlags.None, "p-action", "action"], clickable: [InputFlags.None, "p-clickable", "clickable"], label: [InputFlags.None, "p-label", "label"], link: [InputFlags.None, "p-link", "link"] }, outputs: { click: "p-click" }, decls: 3, vars: 3, consts: [[3, "ngSwitch"], ["class", "po-navbar-item-link", "target", "_blank", 3, "po-clickable", "href", "click", 4, "ngSwitchCase"], ["class", "po-navbar-item-link", 3, "po-clickable", "routerLink", "click", 4, "ngSwitchCase"], ["target", "_blank", 1, "po-navbar-item-link", 3, "href", "click"], [1, "po-navbar-item-link", 3, "routerLink", "click"]], template: function PoNavbarItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 0);
      ɵɵtemplate(1, PoNavbarItemComponent_a_1_Template, 2, 4, "a", 1)(2, PoNavbarItemComponent_a_2_Template, 2, 4, "a", 2);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngSwitch", ctx.type);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "externalLink");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "internalLink");
    }
  }, dependencies: [NgSwitch, NgSwitchCase, RouterLink], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-item", template: `<ng-container [ngSwitch]="type">
  <a
    *ngSwitchCase="'externalLink'"
    class="po-navbar-item-link"
    [class.po-clickable]="clickable"
    [href]="link"
    target="_blank"
    (click)="itemClick()"
  >
    {{ label }}
  </a>

  <a
    *ngSwitchCase="'internalLink'"
    class="po-navbar-item-link"
    [class.po-clickable]="clickable"
    [routerLink]="link"
    (click)="itemClick(label, link)"
  >
    {{ label }}
  </a>
</ng-container>
` }]
  }], null, { action: [{
    type: Input,
    args: ["p-action"]
  }], clickable: [{
    type: Input,
    args: ["p-clickable"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], link: [{
    type: Input,
    args: ["p-link"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemComponent, { className: "PoNavbarItemComponent", filePath: "lib/components/po-navbar/po-navbar-items/po-navbar-item/po-navbar-item.component.ts", lineNumber: 11 });
})();
var _c0$j = ["navbarItemsContainer"];
function PoNavbarItemsComponent_li_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3);
    ɵɵelement(1, "po-navbar-item", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("po-navbar-item-selected", ctx_r1.selectedItem === item_r2);
    ɵɵadvance();
    ɵɵproperty("p-action", item_r2.action)("p-clickable", ctx_r1.selectedItem !== item_r2)("p-label", item_r2.label)("p-link", item_r2.link);
  }
}
var PoNavbarItemsComponent = class _PoNavbarItemsComponent {
  router;
  navbarItemsContainer;
  allNavbarItems;
  items;
  selectedItem;
  routeSubscription;
  constructor(router) {
    this.router = router;
  }
  ngOnDestroy() {
    this.routeSubscription.unsubscribe();
  }
  ngOnInit() {
    this.subscribeToRoute();
  }
  checkActiveItemByUrl(urlRouter) {
    const urlArray = urlRouter.split("/");
    let counter = urlArray.length;
    while (counter >= 0) {
      const url = urlArray.slice(0, counter).join("/");
      this.selectedItem = this.items.find((item) => item.link === url);
      if (this.selectedItem) {
        break;
      }
      counter--;
    }
  }
  checkRouterChildrenFragments() {
    const childrenPrimary = this.router.parseUrl(this.router.url).root.children["primary"];
    return childrenPrimary ? `/${childrenPrimary.segments.map((it) => it.path).join("/")}` : "/";
  }
  subscribeToRoute() {
    this.routeSubscription = this.router.events.subscribe((val) => {
      if (val instanceof NavigationEnd || val instanceof NavigationCancel) {
        const urlRouter = this.checkRouterChildrenFragments();
        this.checkActiveItemByUrl(urlRouter);
      }
    });
  }
  static ɵfac = function PoNavbarItemsComponent_Factory(t) {
    return new (t || _PoNavbarItemsComponent)(ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarItemsComponent, selectors: [["po-navbar-items"]], viewQuery: function PoNavbarItemsComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$j, 7, ElementRef);
      ɵɵviewQuery(PoNavbarItemComponent, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navbarItemsContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allNavbarItems = _t);
    }
  }, inputs: { items: [InputFlags.None, "p-items", "items"] }, decls: 4, vars: 1, consts: [[1, "po-navbar-items-container"], ["navbarItemsContainer", ""], ["class", "po-navbar-item", 3, "po-navbar-item-selected", 4, "ngFor", "ngForOf"], [1, "po-navbar-item"], [3, "p-action", "p-clickable", "p-label", "p-link"]], template: function PoNavbarItemsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nav")(1, "ul", 0, 1);
      ɵɵtemplate(3, PoNavbarItemsComponent_li_3_Template, 2, 6, "li", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngForOf", ctx.items);
    }
  }, dependencies: [NgForOf, PoNavbarItemComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemsComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-items", template: '<nav>\n  <ul class="po-navbar-items-container" #navbarItemsContainer>\n    <li *ngFor="let item of items" class="po-navbar-item" [class.po-navbar-item-selected]="selectedItem === item">\n      <po-navbar-item\n        [p-action]="item.action"\n        [p-clickable]="selectedItem !== item"\n        [p-label]="item.label"\n        [p-link]="item.link"\n      >\n      </po-navbar-item>\n    </li>\n  </ul>\n</nav>\n' }]
  }], () => [{ type: Router }], { navbarItemsContainer: [{
    type: ViewChild,
    args: ["navbarItemsContainer", { read: ElementRef, static: true }]
  }], allNavbarItems: [{
    type: ViewChildren,
    args: [PoNavbarItemComponent, { read: ElementRef }]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarItemsComponent, { className: "PoNavbarItemsComponent", filePath: "lib/components/po-navbar/po-navbar-items/po-navbar-items.component.ts", lineNumber: 13 });
})();
var PoNavbarItemsModule = class _PoNavbarItemsModule {
  static ɵfac = function PoNavbarItemsModule_Factory(t) {
    return new (t || _PoNavbarItemsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoNavbarItemsModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarItemsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule],
      declarations: [PoNavbarItemComponent, PoNavbarItemsComponent],
      exports: [PoNavbarItemsComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarItemsModule, { declarations: [PoNavbarItemComponent, PoNavbarItemsComponent], imports: [CommonModule, RouterModule], exports: [PoNavbarItemsComponent] });
})();
function PoNavbarLogoComponent_po_logo_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-logo", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-logo", ctx_r0.logo)("p-logo-alt", ctx_r0.logoAlt);
  }
}
var PoNavbarLogoComponent = class _PoNavbarLogoComponent {
  logo;
  logoAlt;
  static ɵfac = function PoNavbarLogoComponent_Factory(t) {
    return new (t || _PoNavbarLogoComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarLogoComponent, selectors: [["po-navbar-logo"]], inputs: { logo: [InputFlags.None, "p-logo", "logo"], logoAlt: [InputFlags.None, "p-logo-alt", "logoAlt"] }, decls: 1, vars: 1, consts: [["p-class", "po-navbar-logo-image", 3, "p-logo", "p-logo-alt", 4, "ngIf"], ["p-class", "po-navbar-logo-image", 3, "p-logo", "p-logo-alt"]], template: function PoNavbarLogoComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoNavbarLogoComponent_po_logo_0_Template, 1, 2, "po-logo", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.logo);
    }
  }, dependencies: [NgIf, PoLogoComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarLogoComponent, [{
    type: Component,
    args: [{ selector: "po-navbar-logo", template: '<po-logo *ngIf="logo" p-class="po-navbar-logo-image" [p-logo]="logo" [p-logo-alt]="logoAlt"></po-logo>\n' }]
  }], null, { logo: [{
    type: Input,
    args: ["p-logo"]
  }], logoAlt: [{
    type: Input,
    args: ["p-logo-alt"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarLogoComponent, { className: "PoNavbarLogoComponent", filePath: "lib/components/po-navbar/po-navbar-logo/po-navbar-logo.component.ts", lineNumber: 7 });
})();
var poNavbarLiteralsDefault = {
  en: {
    navbarLinks: "Navbar links"
  },
  es: {
    navbarLinks: "Navbar links"
  },
  pt: {
    navbarLinks: "Navbar links"
  },
  ru: {
    navbarLinks: "Navbar связи"
  }
};
var PoNavbarBaseComponent = class _PoNavbarBaseComponent {
  // Menu que esta sendo exibido na pagina corrente.
  applicationMenu;
  _iconActions = [];
  _items = [];
  _literals;
  _logo;
  _shadow = false;
  language = poLocaleDefault;
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de ações apresentadas em ícones no lado direito do `po-navbar`.
   */
  set iconActions(value) {
    this._iconActions = Array.isArray(value) ? value : [];
  }
  get iconActions() {
    return this._iconActions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de items do `po-navbar`.
   */
  set items(value) {
    this._items = Array.isArray(value) ? value : [];
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com a literal usada na propriedade `p-literals`.
   *
   * Para customizar a literal, basta declarar um objeto do tipo `PoNavbarLiterals` conforme exemplo abaixo:
   *
   * ```
   *  const customLiterals: PoNavbarLiterals = {
   *    navbarLinks: 'Itens de navegação'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-navbar
   *   [p-literals]="customLiterals">
   * </po-navbar>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poNavbarLiteralsDefault[poLocaleDefault]), poNavbarLiteralsDefault[this.language]), value);
    } else {
      this._literals = poNavbarLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poNavbarLiteralsDefault[this.language];
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a logo apresentada `po-navbar`.
   */
  set logo(value) {
    this._logo = value;
    if (this.applicationMenu) {
      this.validateMenuLogo();
    }
  }
  get logo() {
    return this._logo;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o texto alternativo para a logomarca.
   *
   * > **Importante**
   * > Caso esta propriedade não seja definida o texto padrão será "Logomarca início".
   *
   * @default `Logomarca início`
   */
  logoAlt;
  /**
   * @optional
   *
   * @description
   *
   * Aplica uma sombra na parte inferior do `po-navbar`.
   *
   * @default `false`
   */
  set shadow(value) {
    this._shadow = convertToBoolean(value);
  }
  get shadow() {
    return this._shadow;
  }
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoNavbarBaseComponent_Factory(t) {
    return new (t || _PoNavbarBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoNavbarBaseComponent, inputs: { iconActions: [InputFlags.None, "p-icon-actions", "iconActions"], items: [InputFlags.None, "p-items", "items"], literals: [InputFlags.None, "p-literals", "literals"], logo: [InputFlags.None, "p-logo", "logo"], logoAlt: [InputFlags.None, "p-logo-alt", "logoAlt"], shadow: [InputFlags.None, "p-shadow", "shadow"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { iconActions: [{
    type: Input,
    args: ["p-icon-actions"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], logo: [{
    type: Input,
    args: ["p-logo"]
  }], logoAlt: [{
    type: Input,
    args: ["p-logo-alt"]
  }], shadow: [{
    type: Input,
    args: ["p-shadow"]
  }] });
})();
function PoNavbarComponent_po_navbar_item_navigation_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-navbar-item-navigation", 6);
    ɵɵlistener("p-click", function PoNavbarComponent_po_navbar_item_navigation_3_Template_po_navbar_item_navigation_p_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.navigateItems($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-disable-left", ctx_r0.navbarItemNavigationDisableLeft)("p-disable-right", ctx_r0.navbarItemNavigationDisableRight);
  }
}
function PoNavbarComponent_po_menu_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-menu", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-menus", ctx_r1.items);
  }
}
var _c0$i = (a0) => ({ "po-navbar-shadow": a0 });
var _c1$5 = (a0, a1) => ({ "po-navbar-logo-menu": a0, "po-navbar-no-logo": a1 });
var poNavbarNavigationWidth = 88;
var poNavbarMenuMedia = 768;
var poNavbarMatchMedia = `(max-width: ${poNavbarMenuMedia}px)`;
var poNavbarTiming = "250ms ease";
var PoNavbarComponent = class _PoNavbarComponent extends PoNavbarBaseComponent {
  renderer;
  builder;
  changeDetector;
  menuGlobalService;
  navbarItemsElement;
  navbarItems;
  disableRight;
  showItemsNavigation = false;
  windowResizeListener;
  _menuComponent;
  isNavbarUpdateMenu = false;
  id = uuid();
  mediaQuery;
  offset = 0;
  player;
  menuItems;
  previousMenuComponentId;
  previousMenusItems = [];
  applicationMenuSubscription;
  menusSubscription;
  removedMenuSubscription;
  get navbarItemNavigationDisableLeft() {
    return this.offset === 0;
  }
  get navbarItemNavigationDisableRight() {
    return this.disableRight && this.offset !== 0;
  }
  set menuComponent(menu) {
    this._menuComponent = menu;
    this.previousMenuComponentId = menu?.id || this.previousMenuComponentId;
  }
  get isCollapsedMedia() {
    return window.innerWidth < poNavbarMenuMedia;
  }
  constructor(poLanguageService, renderer, builder, changeDetector, menuGlobalService) {
    super(poLanguageService);
    this.renderer = renderer;
    this.builder = builder;
    this.changeDetector = changeDetector;
    this.menuGlobalService = menuGlobalService;
    this.windowResizeListener = this.renderer.listen(window, "resize", this.displayItemsNavigation.bind(this));
  }
  ngOnInit() {
    this.menusSubscription = this.menuGlobalService.receiveMenus$.subscribe((newMenus) => {
      const previousMenusiIsNavbarLinks = this.previousMenusItems?.length === 1 && this.previousMenusItems[0].id === this.id;
      if (this.applicationMenu && this.isCollapsedMedia && this.isNavbarUpdateMenu && previousMenusiIsNavbarLinks) {
        this.isNavbarUpdateMenu = false;
        this.applicationMenu.menus = [
          { label: this.literals.navbarLinks, subItems: this.items, id: this.id },
          ...newMenus
        ];
      }
      this.isNavbarUpdateMenu = false;
      this.previousMenusItems = newMenus;
    });
    this.removedMenuSubscription = this.menuGlobalService.receiveRemovedApplicationMenu$.subscribe((removedMenuId) => {
      this.applicationMenu = this.applicationMenu && this.previousMenuComponentId === removedMenuId ? this.applicationMenu : void 0;
      this.changeDetector.detectChanges();
      if (!this.applicationMenu && this.mediaQuery) {
        this.mediaQuery.removeListener(this.onMediaQueryChange);
      }
    });
    this.applicationMenuSubscription = this.menuGlobalService.receiveApplicationMenu$.pipe(delay(100)).subscribe((newMenu) => {
      this.applicationMenu = this.previousMenuComponentId === newMenu.id ? void 0 : newMenu;
      this.changeDetector.detectChanges();
      if (this.applicationMenu) {
        this.initNavbarMenu();
      }
    });
  }
  ngAfterViewInit() {
    this.displayItemsNavigation();
  }
  ngOnDestroy() {
    if (this.mediaQuery) {
      this.mediaQuery.removeListener(this.onMediaQueryChange);
    }
    this.removedMenuSubscription?.unsubscribe();
    this.applicationMenuSubscription?.unsubscribe();
    this.menusSubscription?.unsubscribe();
  }
  navigateItems(orientation) {
    orientation === "left" ? this.navigateLeft() : this.navigateRight();
    this.animate(this.offset);
  }
  validateMenuLogo() {
    if (this.applicationMenu.logo && this.logo) {
      this.applicationMenu.logo = void 0;
      this.changeDetector.detectChanges();
    }
  }
  allNavbarItemsWidth() {
    return this.navbarItems.allNavbarItems.reduce((previous, current) => previous + current.nativeElement.offsetWidth, 0);
  }
  animate(offset) {
    const animation = this.buildTransitionAnimation(offset);
    this.player = animation.create(this.navbarItems.navbarItemsContainer.nativeElement);
    this.player.play();
  }
  buildTransitionAnimation(offset) {
    return this.builder.build([animate(poNavbarTiming, keyframes([style({ transform: `translateX(${-offset}px)` })]))]);
  }
  changeNavbarMenuItems(isCollapsedMedia, navbarItems, label) {
    if (isCollapsedMedia) {
      this.applicationMenu.menus = [{ label, subItems: navbarItems, id: this.id }, ...this.applicationMenu.menus];
    } else {
      this.applicationMenu.menus = this.applicationMenu.menus.filter((m) => m.id !== this.id);
    }
    this.isNavbarUpdateMenu = true;
    this.changeDetector.detectChanges();
  }
  calculateLeftNavigation() {
    let calculatedOffset;
    this.navbarItems.allNavbarItems.some((navbarItem) => {
      const navbarItemOffset = navbarItem.nativeElement.offsetLeft;
      const navbarItemWidth = navbarItem.nativeElement.offsetWidth;
      if (navbarItemOffset >= this.offset) {
        calculatedOffset = navbarItemOffset - (this.navbarItemsWidth() - navbarItemWidth);
        return true;
      }
    });
    return calculatedOffset;
  }
  calculateRightNavigation(itemBreakPoint) {
    let calculatedOffset;
    this.navbarItems.allNavbarItems.some((navbarItem) => {
      const offsetLeft = navbarItem.nativeElement.offsetLeft;
      const finalPosition = navbarItem.nativeElement.offsetWidth + offsetLeft;
      if (itemBreakPoint < finalPosition) {
        calculatedOffset = offsetLeft;
        return true;
      }
    });
    return calculatedOffset;
  }
  displayItemsNavigation() {
    this.showItemsNavigation = this.navbarItemsWidth() < this.allNavbarItemsWidth() + poNavbarNavigationWidth;
    this.changeDetector.detectChanges();
    if (this.offset !== 0) {
      this.setOffsetToZero();
      this.animate(this.offset);
    }
  }
  initNavbarMenu() {
    this.mediaQuery = window.matchMedia(poNavbarMatchMedia);
    if (this.isCollapsedMedia) {
      this.changeNavbarMenuItems(true, this.items, this.literals.navbarLinks);
    }
    this.validateMenuLogo();
    this.mediaQuery.addListener(this.onMediaQueryChange);
  }
  navbarItemsWidth() {
    return this.navbarItemsElement.nativeElement.offsetWidth;
  }
  navigateLeft() {
    this.disableRight = false;
    this.offset = this.calculateLeftNavigation();
    if (this.offset < 0) {
      this.setOffsetToZero();
    }
  }
  navigateRight() {
    const maxAllowedOffset = this.allNavbarItemsWidth() - this.navbarItemsWidth();
    const itemBreakPoint = this.offset + this.navbarItemsWidth();
    this.offset = this.calculateRightNavigation(itemBreakPoint);
    this.validateMaxOffset(maxAllowedOffset);
  }
  onMediaQueryChange = (changed) => {
    this.changeNavbarMenuItems(changed.matches, this.items, this.literals.navbarLinks);
  };
  setOffsetToZero() {
    this.offset = 0;
  }
  validateMaxOffset(maxAllowedOffset) {
    if (this.offset >= maxAllowedOffset) {
      this.offset = maxAllowedOffset;
      this.disableRight = true;
    }
  }
  static ɵfac = function PoNavbarComponent_Factory(t) {
    return new (t || _PoNavbarComponent)(ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(AnimationBuilder), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoMenuGlobalService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoNavbarComponent, selectors: [["po-navbar"]], viewQuery: function PoNavbarComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoNavbarItemsComponent, 7, ElementRef);
      ɵɵviewQuery(PoNavbarItemsComponent, 7);
      ɵɵviewQuery(PoMenuComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navbarItemsElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.navbarItems = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuComponent = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature], decls: 6, vars: 12, consts: [[1, "po-navbar", 3, "ngClass"], [1, "po-navbar-logo", 3, "ngClass", "p-logo"], [1, "po-navbar-items", 3, "p-items"], ["class", "po-navbar-item-navigation", 3, "p-disable-left", "p-disable-right", "p-click", 4, "ngIf"], [1, "po-navbar-actions", 3, "p-icon-actions"], [3, "p-menus", 4, "ngIf"], [1, "po-navbar-item-navigation", 3, "p-disable-left", "p-disable-right", "p-click"], [3, "p-menus"]], template: function PoNavbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "header", 0);
      ɵɵelement(1, "po-navbar-logo", 1)(2, "po-navbar-items", 2);
      ɵɵtemplate(3, PoNavbarComponent_po_navbar_item_navigation_3_Template, 1, 2, "po-navbar-item-navigation", 3);
      ɵɵelement(4, "po-navbar-actions", 4);
      ɵɵelementEnd();
      ɵɵtemplate(5, PoNavbarComponent_po_menu_5_Template, 1, 1, "po-menu", 5);
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c0$i, ctx.shadow));
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction2(9, _c1$5, !!ctx.applicationMenu, !ctx.logo))("p-logo", ctx.logo);
      ɵɵadvance();
      ɵɵproperty("p-items", ctx.items);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showItemsNavigation);
      ɵɵadvance();
      ɵɵproperty("p-icon-actions", ctx.iconActions);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.applicationMenu);
    }
  }, dependencies: [NgClass, NgIf, PoMenuComponent, PoNavbarActionsComponent, PoNavbarItemNavigationComponent, PoNavbarItemsComponent, PoNavbarLogoComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarComponent, [{
    type: Component,
    args: [{ selector: "po-navbar", template: `<header class="po-navbar" [ngClass]="{ 'po-navbar-shadow': shadow }">
  <po-navbar-logo
    class="po-navbar-logo"
    [ngClass]="{ 'po-navbar-logo-menu': !!applicationMenu, 'po-navbar-no-logo': !logo }"
    [p-logo]="logo"
  >
  </po-navbar-logo>

  <po-navbar-items class="po-navbar-items" [p-items]="items"> </po-navbar-items>

  <po-navbar-item-navigation
    *ngIf="showItemsNavigation"
    class="po-navbar-item-navigation"
    [p-disable-left]="navbarItemNavigationDisableLeft"
    [p-disable-right]="navbarItemNavigationDisableRight"
    (p-click)="navigateItems($event)"
  >
  </po-navbar-item-navigation>

  <po-navbar-actions class="po-navbar-actions" [p-icon-actions]="iconActions"> </po-navbar-actions>
</header>

<po-menu *ngIf="!applicationMenu" [p-menus]="items"> </po-menu>
` }]
  }], () => [{ type: PoLanguageService }, { type: Renderer2 }, { type: AnimationBuilder }, { type: ChangeDetectorRef }, { type: PoMenuGlobalService }], { navbarItemsElement: [{
    type: ViewChild,
    args: [PoNavbarItemsComponent, { read: ElementRef, static: true }]
  }], navbarItems: [{
    type: ViewChild,
    args: [PoNavbarItemsComponent, { static: true }]
  }], menuComponent: [{
    type: ViewChild,
    args: [PoMenuComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoNavbarComponent, { className: "PoNavbarComponent", filePath: "lib/components/po-navbar/po-navbar.component.ts", lineNumber: 38 });
})();
var PoNavbarModule = class _PoNavbarModule {
  static ɵfac = function PoNavbarModule_Factory(t) {
    return new (t || _PoNavbarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoNavbarModule });
  static ɵinj = ɵɵdefineInjector({ imports: [
    CommonModule,
    PoIconModule,
    PoLogoModule,
    PoMenuModule,
    PoNavbarActionsModule,
    PoNavbarItemNavigationModule,
    PoNavbarItemsModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoNavbarModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        PoIconModule,
        PoLogoModule,
        PoMenuModule,
        PoNavbarActionsModule,
        PoNavbarItemNavigationModule,
        PoNavbarItemsModule
      ],
      declarations: [PoNavbarComponent, PoNavbarLogoComponent],
      exports: [PoNavbarComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoNavbarModule, { declarations: [PoNavbarComponent, PoNavbarLogoComponent], imports: [
    CommonModule,
    PoIconModule,
    PoLogoModule,
    PoMenuModule,
    PoNavbarActionsModule,
    PoNavbarItemNavigationModule,
    PoNavbarItemsModule
  ], exports: [PoNavbarComponent] });
})();
var PoPageContentBaseComponent = class {
  resizeListener;
};
var _c0$h = ["*"];
var PoPageContentComponent = class _PoPageContentComponent extends PoPageContentBaseComponent {
  renderer;
  contentOpacity = 0;
  height = "90%";
  overflowY = "none";
  constructor(renderer) {
    super();
    this.renderer = renderer;
    this.initializeListeners();
  }
  ngAfterViewInit() {
    this.recalculateHeaderSize();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  recalculateHeaderSize() {
    setTimeout(() => {
      const pageHeaderElement = document.querySelector("div.po-page-header");
      this.setHeightContent(pageHeaderElement);
      this.contentOpacity = 1;
    });
  }
  setHeightContent(poPageHeader) {
    const bodyHeight = document.body.clientHeight;
    const pageHeaderHeight = poPageHeader ? poPageHeader.offsetTop + poPageHeader.offsetHeight : 0;
    const newHeight = bodyHeight - pageHeaderHeight;
    this.height = `${newHeight}px`;
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", () => {
      this.recalculateHeaderSize();
    });
  }
  removeListeners() {
    this.resizeListener();
  }
  static ɵfac = function PoPageContentComponent_Factory(t) {
    return new (t || _PoPageContentComponent)(ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageContentComponent, selectors: [["po-page-content"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$h, decls: 2, vars: 6, consts: [[1, "po-page-content"]], template: function PoPageContentComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.height)("opacity", ctx.contentOpacity)("overflow-y", ctx.overflowY);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageContentComponent, [{
    type: Component,
    args: [{ selector: "po-page-content", template: '<div class="po-page-content" [style.height]="height" [style.opacity]="contentOpacity" [style.overflow-y]="overflowY">\n  <ng-content></ng-content>\n</div>\n' }]
  }], () => [{ type: Renderer2 }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageContentComponent, { className: "PoPageContentComponent", filePath: "lib/components/po-page/po-page-content/po-page-content.component.ts", lineNumber: 14 });
})();
var poPageDefaultLiteralsDefault = {
  en: {
    otherActions: "Other actions"
  },
  es: {
    otherActions: "Otras acciones"
  },
  pt: {
    otherActions: "Outras ações"
  },
  ru: {
    otherActions: "Другие действия"
  }
};
var PoPageDefaultBaseComponent = class _PoPageDefaultBaseComponent {
  poPageContent;
  /** Objeto com propriedades do breadcrumb. */
  breadcrumb;
  visibleActions = [];
  language;
  _actions = [];
  _literals;
  _title;
  /**
   * @optional
   *
   * @description
   *
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface `PoPageAction`.
   */
  set actions(actions) {
    this._actions = Array.isArray(actions) ? actions : [];
    this.visibleActions = this.actions.filter((action) => action.visible !== false);
    this.setDropdownActions();
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-default`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageDefaultLiterals = {
   *    otherActions: 'Mais ações'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageDefaultLiterals = {
   *    otherActions: 'Ações da página'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-default
   *   [p-literals]="customLiterals">
   * </po-page-default>
   * ```
   *
   * > O valor padrão será traduzido de acordo com o idioma configurado no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageDefaultLiteralsDefault[poLocaleDefault]), poPageDefaultLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageDefaultLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageDefaultLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageDefaultBaseComponent_Factory(t) {
    return new (t || _PoPageDefaultBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPageDefaultBaseComponent, viewQuery: function PoPageDefaultBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoPageContentComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
    }
  }, inputs: { breadcrumb: [InputFlags.None, "p-breadcrumb", "breadcrumb"], actions: [InputFlags.None, "p-actions", "actions"], literals: [InputFlags.None, "p-literals", "literals"], title: [InputFlags.None, "p-title", "title"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDefaultBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { poPageContent: [{
    type: ViewChild,
    args: [PoPageContentComponent, { static: true }]
  }], breadcrumb: [{
    type: Input,
    args: ["p-breadcrumb"]
  }], actions: [{
    type: Input,
    args: ["p-actions"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }] });
})();
var PoPageBaseComponent = class {
};
var _c0$g = ["*"];
var PoPageComponent = class _PoPageComponent extends PoPageBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageComponent_BaseFactory;
    return function PoPageComponent_Factory(t) {
      return (ɵPoPageComponent_BaseFactory || (ɵPoPageComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageComponent)))(t || _PoPageComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageComponent, selectors: [["po-page"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$g, decls: 2, vars: 0, consts: [[1, "po-page"]], template: function PoPageComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageComponent, [{
    type: Component,
    args: [{ selector: "po-page", template: '<div class="po-page">\n  <ng-content> </ng-content>\n</div>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageComponent, { className: "PoPageComponent", filePath: "lib/components/po-page/po-page.component.ts", lineNumber: 14 });
})();
var PoPageHeaderBaseComponent = class _PoPageHeaderBaseComponent {
  /** Título da página. */
  title;
  /** Subtítulo da página. */
  subtitle;
  _breadcrumb;
  /** Objeto com propriedades do breadcrumb. */
  set breadcrumb(value) {
    this._breadcrumb = value;
  }
  get breadcrumb() {
    return this._breadcrumb;
  }
  static ɵfac = function PoPageHeaderBaseComponent_Factory(t) {
    return new (t || _PoPageHeaderBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPageHeaderBaseComponent, inputs: { title: [InputFlags.None, "p-title", "title"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"], breadcrumb: [InputFlags.None, "p-breadcrumb", "breadcrumb"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageHeaderBaseComponent, [{
    type: Directive
  }], null, { title: [{
    type: Input,
    args: ["p-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }], breadcrumb: [{
    type: Input,
    args: ["p-breadcrumb"]
  }] });
})();
function PoPageHeaderComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵelement(1, "po-breadcrumb", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-favorite-service", ctx_r0.breadcrumb.favorite)("p-items", ctx_r0.breadcrumb.items)("p-params-service", ctx_r0.breadcrumb.params);
  }
}
function PoPageHeaderComponent_div_3_h1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "h1", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.title, " ");
  }
}
function PoPageHeaderComponent_div_3_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.subtitle, " ");
  }
}
function PoPageHeaderComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, PoPageHeaderComponent_div_3_h1_1_Template, 2, 1, "h1", 7)(2, PoPageHeaderComponent_div_3_div_2_Template, 2, 1, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.subtitle);
  }
}
var _c0$f = ["*"];
var PoPageHeaderComponent = class _PoPageHeaderComponent extends PoPageHeaderBaseComponent {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageHeaderComponent_BaseFactory;
    return function PoPageHeaderComponent_Factory(t) {
      return (ɵPoPageHeaderComponent_BaseFactory || (ɵPoPageHeaderComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageHeaderComponent)))(t || _PoPageHeaderComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageHeaderComponent, selectors: [["po-page-header"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$f, decls: 5, vars: 2, consts: [[1, "po-page-header"], ["class", "po-page-header-breadcrumb", 4, "ngIf"], [1, "po-page-header-container"], ["class", "po-page-header-title-container", 4, "ngIf"], [1, "po-page-header-breadcrumb"], [3, "p-favorite-service", "p-items", "p-params-service"], [1, "po-page-header-title-container"], ["class", "po-page-header-title", 4, "ngIf"], ["class", "po-page-header-subtitle", 4, "ngIf"], [1, "po-page-header-title"], [1, "po-page-header-subtitle"]], template: function PoPageHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoPageHeaderComponent_div_1_Template, 2, 3, "div", 1);
      ɵɵelementStart(2, "div", 2);
      ɵɵtemplate(3, PoPageHeaderComponent_div_3_Template, 3, 2, "div", 3);
      ɵɵprojection(4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.breadcrumb && ctx.breadcrumb.items.length);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.title || ctx.subtitle);
    }
  }, dependencies: [NgIf, PoBreadcrumbComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageHeaderComponent, [{
    type: Component,
    args: [{ selector: "po-page-header", template: '<div class="po-page-header">\n  <!-- Breadcrumb -->\n  <div class="po-page-header-breadcrumb" *ngIf="breadcrumb && breadcrumb.items.length">\n    <po-breadcrumb\n      [p-favorite-service]="breadcrumb.favorite"\n      [p-items]="breadcrumb.items"\n      [p-params-service]="breadcrumb.params"\n    >\n    </po-breadcrumb>\n  </div>\n\n  <div class="po-page-header-container">\n    <!-- Titulo e SubTitulo-->\n    <div class="po-page-header-title-container" *ngIf="title || subtitle">\n      <h1 class="po-page-header-title" *ngIf="title">\n        {{ title }}\n      </h1>\n      <div class="po-page-header-subtitle" *ngIf="subtitle">\n        {{ subtitle }}\n      </div>\n    </div>\n\n    <!-- Operações -->\n    <ng-content></ng-content>\n  </div>\n</div>\n' }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageHeaderComponent, { className: "PoPageHeaderComponent", filePath: "lib/components/po-page/po-page-header/po-page-header.component.ts", lineNumber: 13 });
})();
function PoPageDefaultComponent_po_page_header_1_po_dropdown_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dropdown", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-label", ctx_r1.literals.otherActions)("p-actions", ctx_r1.dropdownActions);
  }
}
function PoPageDefaultComponent_po_page_header_1_po_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 7);
    ɵɵlistener("p-click", function PoPageDefaultComponent_po_page_header_1_po_button_3_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.callAction(ctx_r5.visibleActions[2]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r2.actionIsDisabled(ctx_r2.visibleActions[2]))("p-label", ctx_r2.visibleActions[2].label);
  }
}
function PoPageDefaultComponent_po_page_header_1_po_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 7);
    ɵɵlistener("p-click", function PoPageDefaultComponent_po_page_header_1_po_button_4_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r7.callAction(ctx_r7.visibleActions[1]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r3.actionIsDisabled(ctx_r3.visibleActions[1]))("p-label", ctx_r3.visibleActions[1].label);
  }
}
function PoPageDefaultComponent_po_page_header_1_po_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 8);
    ɵɵlistener("p-click", function PoPageDefaultComponent_po_page_header_1_po_button_5_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r9.callAction(ctx_r9.visibleActions[0]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r4.actionIsDisabled(ctx_r4.visibleActions[0]))("p-icon", ctx_r4.visibleActions[0].icon)("p-label", ctx_r4.visibleActions[0].label);
  }
}
function PoPageDefaultComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1)(1, "div", 2);
    ɵɵtemplate(2, PoPageDefaultComponent_po_page_header_1_po_dropdown_2_Template, 1, 2, "po-dropdown", 3)(3, PoPageDefaultComponent_po_page_header_1_po_button_3_Template, 1, 2, "po-button", 4)(4, PoPageDefaultComponent_po_page_header_1_po_button_4_Template, 1, 2, "po-button", 4)(5, PoPageDefaultComponent_po_page_header_1_po_button_5_Template, 1, 3, "po-button", 5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-breadcrumb", ctx_r0.breadcrumb)("p-title", ctx_r0.title)("p-subtitle", ctx_r0.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.visibleActions.length > ctx_r0.limitPrimaryActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions.length === 3 && ctx_r0.visibleActions[2] && !ctx_r0.isMobile);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions[1] && (ctx_r0.visibleActions.length === 2 || !ctx_r0.isMobile));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions[0]);
  }
}
var _c0$e = ["*"];
var PoPageDefaultComponent = class _PoPageDefaultComponent extends PoPageDefaultBaseComponent {
  renderer;
  router;
  limitPrimaryActions = 3;
  dropdownActions;
  isMobile;
  maxWidthMobile = 480;
  constructor(viewRef, languageService, renderer, router) {
    super(languageService);
    this.renderer = renderer;
    this.router = router;
  }
  ngAfterContentInit() {
    this.setIsMobile();
    this.setDropdownActions();
    this.renderer.listen("window", "resize", (event) => {
      this.onResize(event);
    });
  }
  ngOnChanges(changes) {
    this.setDropdownActions();
  }
  actionIsDisabled(action) {
    return isTypeof(action.disabled, "function") ? action.disabled(action) : action.disabled;
  }
  callAction(item) {
    if (item.url) {
      isExternalLink(item.url) ? openExternalLink(item.url) : this.router.navigate([item.url]);
    } else if (item.action) {
      item.action();
    }
  }
  hasPageHeader() {
    return !!(this.title || this.visibleActions && this.visibleActions.length || this.breadcrumb && this.breadcrumb.items.length);
  }
  setDropdownActions() {
    if (this.visibleActions.length > this.limitPrimaryActions) {
      this.dropdownActions = this.visibleActions.slice(this.limitPrimaryActions - 1);
    }
  }
  onResize(event) {
    const width = event.target.innerWidth;
    if (width < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
      this.setDropdownActions();
    } else {
      this.isMobile = false;
      this.limitPrimaryActions = 3;
      this.setDropdownActions();
    }
  }
  setIsMobile() {
    if (window.innerWidth < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
    }
  }
  static ɵfac = function PoPageDefaultComponent_Factory(t) {
    return new (t || _PoPageDefaultComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageDefaultComponent, selectors: [["po-page-default"]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], ngContentSelectors: _c0$e, decls: 4, vars: 1, consts: [[3, "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], [1, "po-page-header-actions"], [3, "p-label", "p-actions", 4, "ngIf"], [3, "p-disabled", "p-label", "p-click", 4, "ngIf"], ["p-kind", "primary", 3, "p-disabled", "p-icon", "p-label", "p-click", 4, "ngIf"], [3, "p-label", "p-actions"], [3, "p-disabled", "p-label", "p-click"], ["p-kind", "primary", 3, "p-disabled", "p-icon", "p-label", "p-click"]], template: function PoPageDefaultComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "po-page");
      ɵɵtemplate(1, PoPageDefaultComponent_po_page_header_1_Template, 6, 7, "po-page-header", 0);
      ɵɵelementStart(2, "po-page-content");
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasPageHeader());
    }
  }, dependencies: [NgIf, PoButtonComponent, PoDropdownComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDefaultComponent, [{
    type: Component,
    args: [{ selector: "po-page-default", template: '<po-page>\n  <!-- HEADER -->\n  <po-page-header *ngIf="hasPageHeader()" [p-breadcrumb]="breadcrumb" [p-title]="title" [p-subtitle]="subtitle">\n    <!-- OPERATIONS -->\n    <div class="po-page-header-actions">\n      <po-dropdown\n        *ngIf="visibleActions.length > limitPrimaryActions"\n        [p-label]="literals.otherActions"\n        [p-actions]="dropdownActions"\n      >\n      </po-dropdown>\n\n      <po-button\n        *ngIf="visibleActions.length === 3 && visibleActions[2] && !isMobile"\n        [p-disabled]="actionIsDisabled(visibleActions[2])"\n        [p-label]="visibleActions[2].label"\n        (p-click)="callAction(visibleActions[2])"\n      >\n      </po-button>\n\n      <po-button\n        *ngIf="visibleActions[1] && (visibleActions.length === 2 || !isMobile)"\n        [p-disabled]="actionIsDisabled(visibleActions[1])"\n        [p-label]="visibleActions[1].label"\n        (p-click)="callAction(visibleActions[1])"\n      >\n      </po-button>\n\n      <po-button\n        *ngIf="visibleActions[0]"\n        p-kind="primary"\n        [p-disabled]="actionIsDisabled(visibleActions[0])"\n        [p-icon]="visibleActions[0].icon"\n        [p-label]="visibleActions[0].label"\n        (p-click)="callAction(visibleActions[0])"\n      >\n      </po-button>\n    </div>\n  </po-page-header>\n\n  <!-- CONTENT -->\n  <po-page-content>\n    <ng-content></ng-content>\n  </po-page-content>\n</po-page>\n' }]
  }], () => [{ type: ViewContainerRef }, { type: PoLanguageService }, { type: Renderer2 }, { type: Router }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageDefaultComponent, { className: "PoPageDefaultComponent", filePath: "lib/components/po-page/po-page-default/po-page-default.component.ts", lineNumber: 36 });
})();
var poPageDetailLiteralsDefault = {
  en: {
    back: "Back",
    edit: "Edit",
    remove: "Remove"
  },
  es: {
    back: "Volver",
    edit: "Editar",
    remove: "Eliminar"
  },
  pt: {
    back: "Voltar",
    edit: "Editar",
    remove: "Remover"
  },
  ru: {
    back: "возвращение",
    edit: "редактировать",
    remove: "удаление"
  }
};
var PoPageDetailBaseComponent = class _PoPageDetailBaseComponent {
  poPageContent;
  /** Objeto com propriedades do breadcrumb. */
  breadcrumb;
  /**
   * Evento que será disparado ao clicar no botão de "Voltar".
   *
   * ```
   * <po-page-detail (p-back)="myBackFunction()">
   * </po-page-detail>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Voltar" não será exibido.
   */
  back = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Editar".
   *
   * ```
   * <po-page-detail (p-edit)="myEditFunction()">
   * </po-page-detail>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Editar" não será exibido.
   */
  edit = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Remover".
   *
   * ```
   * <po-page-detail (p-remove)="myRemoveFunction()">
   * </po-page-detail>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Remover" não será exibido.
   */
  remove = new EventEmitter();
  _literals;
  _title;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-detail`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageDetailLiterals = {
   *    edit: 'Edição',
   *    remove: 'Exclusão',
   *    back: 'Menu'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageDetailLiterals = {
   *    remove: 'Excluir registro permanentemente'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-detail
   *   [p-literals]="customLiterals">
   * </po-page-detail>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageDetailLiteralsDefault[poLocaleDefault]), poPageDetailLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageDetailLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageDetailLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageDetailBaseComponent_Factory(t) {
    return new (t || _PoPageDetailBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPageDetailBaseComponent, viewQuery: function PoPageDetailBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoPageContentComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
    }
  }, inputs: { breadcrumb: [InputFlags.None, "p-breadcrumb", "breadcrumb"], literals: [InputFlags.None, "p-literals", "literals"], title: [InputFlags.None, "p-title", "title"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"] }, outputs: { back: "p-back", edit: "p-edit", remove: "p-remove" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDetailBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { poPageContent: [{
    type: ViewChild,
    args: [PoPageContentComponent, { static: true }]
  }], breadcrumb: [{
    type: Input,
    args: ["p-breadcrumb"]
  }], back: [{
    type: Output,
    args: ["p-back"]
  }], edit: [{
    type: Output,
    args: ["p-edit"]
  }], remove: [{
    type: Output,
    args: ["p-remove"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }] });
})();
function PoPageDetailComponent_po_page_header_1_div_1_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 6);
    ɵɵlistener("p-click", function PoPageDetailComponent_po_page_header_1_div_1_po_button_1_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r5.back.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵproperty("p-icon", ctx_r2.hasEditOrRemoveFn("icon"))("p-label", ctx_r2.literals.back)("p-kind", ctx_r2.hasEditOrRemoveFn("type"));
  }
}
function PoPageDetailComponent_po_page_header_1_div_1_po_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 6);
    ɵɵlistener("p-click", function PoPageDetailComponent_po_page_header_1_div_1_po_button_2_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r7.remove.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("p-icon", ctx_r3.hasEditFn("icon"))("p-label", ctx_r3.literals.remove)("p-kind", ctx_r3.hasEditFn("type"));
  }
}
function PoPageDetailComponent_po_page_header_1_div_1_po_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 7);
    ɵɵlistener("p-click", function PoPageDetailComponent_po_page_header_1_div_1_po_button_3_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r9.edit.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("p-label", ctx_r4.literals.edit);
  }
}
function PoPageDetailComponent_po_page_header_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, PoPageDetailComponent_po_page_header_1_div_1_po_button_1_Template, 1, 3, "po-button", 4)(2, PoPageDetailComponent_po_page_header_1_div_1_po_button_2_Template, 1, 3, "po-button", 4)(3, PoPageDetailComponent_po_page_header_1_div_1_po_button_3_Template, 1, 1, "po-button", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("back"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("remove"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("edit"));
  }
}
function PoPageDetailComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1);
    ɵɵtemplate(1, PoPageDetailComponent_po_page_header_1_div_1_Template, 4, 3, "div", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-breadcrumb", ctx_r0.breadcrumb)("p-title", ctx_r0.title)("p-subtitle", ctx_r0.subtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.hasAnyAction());
  }
}
var _c0$d = ["*"];
var PoPageDetailComponent = class _PoPageDetailComponent extends PoPageDetailBaseComponent {
  hasAnyAction() {
    return this.hasEvent("back") || this.hasEvent("edit") || this.hasEvent("remove");
  }
  hasEditFn(property) {
    if (property === "icon") {
      return this.hasEvent("edit") ? "" : "po-icon-delete";
    } else if (property === "type") {
      return this.hasEvent("edit") ? "secondary" : "primary";
    } else {
      return "";
    }
  }
  hasEditOrRemoveFn(property) {
    if (property === "icon") {
      return this.hasEvent("edit") || this.hasEvent("remove") ? "" : "po-icon-arrow-left";
    } else if (property === "type") {
      return this.hasEvent("edit") || this.hasEvent("remove") ? "secondary" : "primary";
    } else {
      return "";
    }
  }
  hasEvent(event) {
    return !!this[event].observers.length;
  }
  hasPageHeader() {
    return !!(this.title || this.hasAnyAction() || this.breadcrumb && this.breadcrumb.items.length);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageDetailComponent_BaseFactory;
    return function PoPageDetailComponent_Factory(t) {
      return (ɵPoPageDetailComponent_BaseFactory || (ɵPoPageDetailComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageDetailComponent)))(t || _PoPageDetailComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageDetailComponent, selectors: [["po-page-detail"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$d, decls: 4, vars: 1, consts: [[3, "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], ["class", "po-page-header-actions", 4, "ngIf"], [1, "po-page-header-actions"], [3, "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], ["p-icon", "po-icon-edit", "p-kind", "primary", 3, "p-label", "p-click", 4, "ngIf"], [3, "p-icon", "p-label", "p-kind", "p-click"], ["p-icon", "po-icon-edit", "p-kind", "primary", 3, "p-label", "p-click"]], template: function PoPageDetailComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "po-page");
      ɵɵtemplate(1, PoPageDetailComponent_po_page_header_1_Template, 2, 4, "po-page-header", 0);
      ɵɵelementStart(2, "po-page-content");
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasPageHeader());
    }
  }, dependencies: [NgIf, PoButtonComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageDetailComponent, [{
    type: Component,
    args: [{ selector: "po-page-detail", template: `<po-page>
  <!-- HEADER -->
  <po-page-header *ngIf="hasPageHeader()" [p-breadcrumb]="breadcrumb" [p-title]="title" [p-subtitle]="subtitle">
    <!-- OPERATIONS -->
    <div *ngIf="hasAnyAction()" class="po-page-header-actions">
      <po-button
        *ngIf="hasEvent('back')"
        [p-icon]="hasEditOrRemoveFn('icon')"
        [p-label]="literals.back"
        [p-kind]="hasEditOrRemoveFn('type')"
        (p-click)="back.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('remove')"
        [p-icon]="hasEditFn('icon')"
        [p-label]="literals.remove"
        [p-kind]="hasEditFn('type')"
        (p-click)="remove.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('edit')"
        p-icon="po-icon-edit"
        p-kind="primary"
        [p-label]="literals.edit"
        (p-click)="edit.emit()"
      >
      </po-button>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content> </ng-content>
  </po-page-content>
</po-page>
` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageDetailComponent, { className: "PoPageDetailComponent", filePath: "lib/components/po-page/po-page-detail/po-page-detail.component.ts", lineNumber: 29 });
})();
var poPageEditLiteralsDefault = {
  en: {
    cancel: "Cancel",
    save: "Save",
    saveNew: "Save and New"
  },
  es: {
    cancel: "Cancelar",
    save: "Guardar",
    saveNew: "Guardar y Nuevo"
  },
  pt: {
    cancel: "Cancelar",
    save: "Salvar",
    saveNew: "Salvar e Novo"
  },
  ru: {
    cancel: "отменить",
    save: "экономить",
    saveNew: "Сохранить и новый"
  }
};
var PoPageEditBaseComponent = class _PoPageEditBaseComponent {
  poPageContent;
  /** Objeto com propriedades do breadcrumb. */
  breadcrumb;
  /** Desabilita botões de submissão (save e saveNew) */
  disableSubmit;
  /**
   * Evento que será disparado ao clicar no botão de "Cancelar".
   *
   * ```
   * <po-page-edit (p-cancel)="myCancelFunction()">
   * </po-page-edit>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Cancelar" não será exibido.
   */
  cancel = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Salvar".
   *
   * ```
   * <po-page-edit (p-save)="mySaveFunction()">
   * </po-page-edit>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Salvar" não será exibido.
   */
  save = new EventEmitter();
  /**
   * Evento que será disparado ao clicar no botão de "Salvar e Novo".
   *
   * ```
   * <po-page-edit (p-save-new)="mySaveNewFunction()">
   * </po-page-edit>
   * ```
   *
   * > Caso não utilizar esta propriedade, o botão de "Salvar e Novo" não será exibido.
   */
  saveNew = new EventEmitter();
  _literals;
  _title;
  language;
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-edit`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageEditLiterals = {
   *    cancel: 'Voltar',
   *    save: 'Confirmar',
   *    saveNew: 'Confirmar e criar um novo'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageEditLiterals = {
   *    cancel: 'Cancelar processo'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-edit
   *   [p-literals]="customLiterals">
   * </po-page-edit>
   * ```
   *
   * > O objeto padrão de literais será traduzido de acordo com o idioma do
   * [`PoI18nService`](/documentation/po-i18n) ou do browser.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageEditLiteralsDefault[poLocaleDefault]), poPageEditLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageEditLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageEditLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageEditBaseComponent_Factory(t) {
    return new (t || _PoPageEditBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPageEditBaseComponent, viewQuery: function PoPageEditBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoPageContentComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
    }
  }, inputs: { breadcrumb: [InputFlags.None, "p-breadcrumb", "breadcrumb"], disableSubmit: [InputFlags.None, "p-disable-submit", "disableSubmit"], literals: [InputFlags.None, "p-literals", "literals"], title: [InputFlags.None, "p-title", "title"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"] }, outputs: { cancel: "p-cancel", save: "p-save", saveNew: "p-save-new" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageEditBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { poPageContent: [{
    type: ViewChild,
    args: [PoPageContentComponent, { static: true }]
  }], breadcrumb: [{
    type: Input,
    args: ["p-breadcrumb"]
  }], disableSubmit: [{
    type: Input,
    args: ["p-disable-submit"]
  }], cancel: [{
    type: Output,
    args: ["p-cancel"]
  }], save: [{
    type: Output,
    args: ["p-save"]
  }], saveNew: [{
    type: Output,
    args: ["p-save-new"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }] });
})();
function PoPageEditComponent_po_page_header_1_div_1_po_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 7);
    ɵɵlistener("p-click", function PoPageEditComponent_po_page_header_1_div_1_po_button_1_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r5.cancel.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵproperty("p-icon", ctx_r2.getIcon("cancel"))("p-label", ctx_r2.literals.cancel)("p-kind", ctx_r2.getType("cancel"));
  }
}
function PoPageEditComponent_po_page_header_1_div_1_po_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 8);
    ɵɵlistener("p-click", function PoPageEditComponent_po_page_header_1_div_1_po_button_2_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r7.saveNew.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("p-disabled", ctx_r3.disableSubmit)("p-icon", ctx_r3.getIcon("saveNew"))("p-label", ctx_r3.literals.saveNew)("p-kind", ctx_r3.getType("saveNew"));
  }
}
function PoPageEditComponent_po_page_header_1_div_1_po_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 9);
    ɵɵlistener("p-click", function PoPageEditComponent_po_page_header_1_div_1_po_button_3_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r9.save.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("p-disabled", ctx_r4.disableSubmit)("p-label", ctx_r4.literals.save);
  }
}
function PoPageEditComponent_po_page_header_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, PoPageEditComponent_po_page_header_1_div_1_po_button_1_Template, 1, 3, "po-button", 4)(2, PoPageEditComponent_po_page_header_1_div_1_po_button_2_Template, 1, 4, "po-button", 5)(3, PoPageEditComponent_po_page_header_1_div_1_po_button_3_Template, 1, 2, "po-button", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("cancel"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("saveNew"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hasEvent("save"));
  }
}
function PoPageEditComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1);
    ɵɵtemplate(1, PoPageEditComponent_po_page_header_1_div_1_Template, 4, 3, "div", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-breadcrumb", ctx_r0.breadcrumb)("p-title", ctx_r0.title)("p-subtitle", ctx_r0.subtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.hasAnyAction());
  }
}
var _c0$c = ["*"];
var PoPageEditComponent = class _PoPageEditComponent extends PoPageEditBaseComponent {
  getIcon(icon) {
    if (icon === "cancel") {
      return this.isPrimaryAction("cancel") ? "po-icon-close" : "";
    }
    if (icon === "saveNew") {
      return this.isPrimaryAction("saveNew") ? "po-icon-ok" : "";
    }
    return "";
  }
  getType(type) {
    const isCancelPrimaryAction = type === "cancel" && this.isPrimaryAction("cancel");
    const isSaveNewPrimaryAction = type === "saveNew" && this.isPrimaryAction("saveNew");
    return isCancelPrimaryAction || isSaveNewPrimaryAction ? "primary" : "secondary";
  }
  hasAnyAction() {
    return this.hasEvent("cancel") || this.hasEvent("saveNew") || this.hasEvent("save");
  }
  hasPageHeader() {
    return !!(this.title || this.hasAnyAction() || this.breadcrumb && this.breadcrumb.items.length);
  }
  hasEvent(event) {
    return !!this[event].observers.length;
  }
  isPrimaryAction(action) {
    const hasSaveAction = this.hasEvent("save");
    if (action === "saveNew") {
      return !hasSaveAction;
    }
    if (action === "cancel") {
      const hasSaveNewAction = this.hasEvent("saveNew");
      return !hasSaveNewAction && !hasSaveAction;
    }
    return false;
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoPageEditComponent_BaseFactory;
    return function PoPageEditComponent_Factory(t) {
      return (ɵPoPageEditComponent_BaseFactory || (ɵPoPageEditComponent_BaseFactory = ɵɵgetInheritedFactory(_PoPageEditComponent)))(t || _PoPageEditComponent);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageEditComponent, selectors: [["po-page-edit"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$c, decls: 4, vars: 1, consts: [[3, "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], ["class", "po-page-header-actions", 4, "ngIf"], [1, "po-page-header-actions"], [3, "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], [3, "p-disabled", "p-icon", "p-label", "p-kind", "p-click", 4, "ngIf"], ["p-icon", "po-icon-ok", "p-kind", "primary", 3, "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-icon", "p-label", "p-kind", "p-click"], [3, "p-disabled", "p-icon", "p-label", "p-kind", "p-click"], ["p-icon", "po-icon-ok", "p-kind", "primary", 3, "p-disabled", "p-label", "p-click"]], template: function PoPageEditComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "po-page");
      ɵɵtemplate(1, PoPageEditComponent_po_page_header_1_Template, 2, 4, "po-page-header", 0);
      ɵɵelementStart(2, "po-page-content");
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasPageHeader());
    }
  }, dependencies: [NgIf, PoButtonComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageEditComponent, [{
    type: Component,
    args: [{ selector: "po-page-edit", template: `<po-page>
  <!-- HEADER -->
  <po-page-header *ngIf="hasPageHeader()" [p-breadcrumb]="breadcrumb" [p-title]="title" [p-subtitle]="subtitle">
    <!-- OPERATIONS -->
    <div *ngIf="hasAnyAction()" class="po-page-header-actions">
      <po-button
        *ngIf="hasEvent('cancel')"
        [p-icon]="getIcon('cancel')"
        [p-label]="literals.cancel"
        [p-kind]="getType('cancel')"
        (p-click)="cancel.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('saveNew')"
        [p-disabled]="disableSubmit"
        [p-icon]="getIcon('saveNew')"
        [p-label]="literals.saveNew"
        [p-kind]="getType('saveNew')"
        (p-click)="saveNew.emit()"
      >
      </po-button>

      <po-button
        *ngIf="hasEvent('save')"
        p-icon="po-icon-ok"
        p-kind="primary"
        [p-disabled]="disableSubmit"
        [p-label]="literals.save"
        (p-click)="save.emit()"
      >
      </po-button>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content> </ng-content>
  </po-page-content>
</po-page>
` }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageEditComponent, { className: "PoPageEditComponent", filePath: "lib/components/po-page/po-page-edit/po-page-edit.component.ts", lineNumber: 29 });
})();
var poPageListLiteralsDefault = {
  en: {
    otherActions: "Other actions"
  },
  es: {
    otherActions: "Otras acciones"
  },
  pt: {
    otherActions: "Outras ações"
  },
  ru: {
    otherActions: "Другие действия"
  }
};
var PoPageListBaseComponent = class _PoPageListBaseComponent {
  poPageContent;
  /**
   * @optional
   *
   * @description
   *
   * Objeto que implementa as propriedades da interface `PoBreadcrumb`.
   */
  breadcrumb;
  /**
   * @description
   *
   * Objeto que implementa as propriedades da interface `PoPageFilter`.
   */
  filter;
  /**
   * @optional
   *
   * @description
   *
   * Valor padrão na busca rápida ao inicializar o componente
   *
   */
  quickSearchValue;
  visibleActions = [];
  language;
  resizeListener;
  _actions = [];
  _disclaimerGroup;
  _literals;
  _title;
  /**
   * @optional
   *
   * @description
   *
   * Nesta propriedade deve ser definido um array de objetos que implementam a interface `PoPageAction`.
   */
  set actions(actions) {
    this._actions = Array.isArray(actions) ? actions : [];
    this.visibleActions = this.actions.filter((action) => action.visible !== false);
    this.setDropdownActions();
  }
  get actions() {
    return this._actions;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto que implementa as propriedades da interface `PoDisclaimerGroup`.
   */
  set disclaimerGroup(value) {
    if (!value) {
      value = {};
    }
    this._disclaimerGroup = value;
  }
  get disclaimerGroup() {
    return this._disclaimerGroup;
  }
  /**
   * @optional
   *
   * @description
   *
   * Objeto com as literais usadas no `po-page-list`.
   *
   * Existem duas maneiras de customizar o componente, passando um objeto com todas as literais disponíveis:
   *
   * ```
   *  const customLiterals: PoPageListLiterals = {
   *    otherActions: 'Mais ações'
   *  };
   * ```
   *
   * Ou passando apenas as literais que deseja customizar:
   *
   * ```
   *  const customLiterals: PoPageListLiterals = {
   *    otherActions: 'Ações da página'
   *  };
   * ```
   *
   * E para carregar as literais customizadas, basta apenas passar o objeto para o componente.
   *
   * ```
   * <po-page-list
   *   [p-literals]="customLiterals">
   * </po-page-list>
   * ```
   *
   * > O valor padrão será traduzido de acordo com o idioma configurado no [`PoI18nService`](/documentation/po-i18n) ou *browser*.
   */
  set literals(value) {
    if (value instanceof Object && !(value instanceof Array)) {
      this._literals = __spreadValues(__spreadValues(__spreadValues({}, poPageListLiteralsDefault[poLocaleDefault]), poPageListLiteralsDefault[this.language]), value);
    } else {
      this._literals = poPageListLiteralsDefault[this.language];
    }
  }
  get literals() {
    return this._literals || poPageListLiteralsDefault[this.language];
  }
  /** Título da página. */
  set title(title) {
    this._title = title;
    setTimeout(() => this.poPageContent.recalculateHeaderSize());
  }
  get title() {
    return this._title;
  }
  /**
   * @optional
   *
   * @description
   *
   * Subtitulo do Header da página
   */
  subtitle;
  constructor(languageService) {
    this.language = languageService.getShortLanguage();
  }
  static ɵfac = function PoPageListBaseComponent_Factory(t) {
    return new (t || _PoPageListBaseComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoPageListBaseComponent, viewQuery: function PoPageListBaseComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoPageContentComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poPageContent = _t.first);
    }
  }, inputs: { breadcrumb: [InputFlags.None, "p-breadcrumb", "breadcrumb"], filter: [InputFlags.None, "p-filter", "filter"], quickSearchValue: [InputFlags.None, "p-quick-search-value", "quickSearchValue"], actions: [InputFlags.None, "p-actions", "actions"], disclaimerGroup: [InputFlags.None, "p-disclaimer-group", "disclaimerGroup"], literals: [InputFlags.None, "p-literals", "literals"], title: [InputFlags.None, "p-title", "title"], subtitle: [InputFlags.None, "p-subtitle", "subtitle"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageListBaseComponent, [{
    type: Directive
  }], () => [{ type: PoLanguageService }], { poPageContent: [{
    type: ViewChild,
    args: [PoPageContentComponent, { static: true }]
  }], breadcrumb: [{
    type: Input,
    args: ["p-breadcrumb"]
  }], filter: [{
    type: Input,
    args: ["p-filter"]
  }], quickSearchValue: [{
    type: Input,
    args: ["p-quick-search-value"]
  }], actions: [{
    type: Input,
    args: ["p-actions"]
  }], disclaimerGroup: [{
    type: Input,
    args: ["p-disclaimer-group"]
  }], literals: [{
    type: Input,
    args: ["p-literals"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], subtitle: [{
    type: Input,
    args: ["p-subtitle"]
  }] });
})();
var _c0$b = ["filterInput"];
function PoPageListComponent_po_page_header_1_po_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 10);
    ɵɵlistener("p-click", function PoPageListComponent_po_page_header_1_po_button_4_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r7.callAction(ctx_r7.visibleActions[0]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r1.actionIsDisabled(ctx_r1.actions[0]))("p-icon", ctx_r1.visibleActions[0].icon)("p-label", ctx_r1.visibleActions[0].label);
  }
}
function PoPageListComponent_po_page_header_1_po_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 11);
    ɵɵlistener("p-click", function PoPageListComponent_po_page_header_1_po_button_5_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r9.callAction(ctx_r9.visibleActions[1]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r2.actionIsDisabled(ctx_r2.actions[1]))("p-label", ctx_r2.visibleActions[1].label);
  }
}
function PoPageListComponent_po_page_header_1_po_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-button", 11);
    ɵɵlistener("p-click", function PoPageListComponent_po_page_header_1_po_button_6_Template_po_button_p_click_0_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r11 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r11.callAction(ctx_r11.visibleActions[2]));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("p-disabled", ctx_r3.actionIsDisabled(ctx_r3.visibleActions[2]))("p-label", ctx_r3.visibleActions[2].label);
  }
}
function PoPageListComponent_po_page_header_1_po_dropdown_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-dropdown", 12);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("p-actions", ctx_r4.dropdownActions)("p-label", ctx_r4.literals.otherActions);
  }
}
function PoPageListComponent_po_page_header_1_div_8_div_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "span", 21);
    ɵɵlistener("click", function PoPageListComponent_po_page_header_1_div_8_div_6_Template_span_click_1_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r15 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r15.callActionFilter("advancedAction"));
    })("keydown.enter", function PoPageListComponent_po_page_header_1_div_8_div_6_Template_span_keydown_enter_1_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r17 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r17.callActionFilter("advancedAction"));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r14.advancedSearch, " ");
  }
}
function PoPageListComponent_po_page_header_1_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13)(1, "div", 14)(2, "div", 15)(3, "span", 16);
    ɵɵlistener("click", function PoPageListComponent_po_page_header_1_div_8_Template_span_click_3_listener() {
      ɵɵrestoreView(_r19);
      const ctx_r18 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r18.callActionFilter("action"));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(4, "input", 17, 18);
    ɵɵlistener("keypress", function PoPageListComponent_po_page_header_1_div_8_Template_input_keypress_4_listener($event) {
      ɵɵrestoreView(_r19);
      const ctx_r20 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r20.onkeypress($event.keyCode));
    });
    ɵɵelementEnd()();
    ɵɵtemplate(6, PoPageListComponent_po_page_header_1_div_8_div_6_Template, 3, 1, "div", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r5.hasCustomFilterSize() ? ctx_r5.filterSizeClass(ctx_r5.filter.width) : "");
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r5.hasCustomFilterSize() ? ctx_r5.filter.advancedAction ? "po-page-filter-input-variable-size" : "po-page-filter-input-variable-size-wo-adv-search" : "");
    ɵɵadvance(3);
    ɵɵproperty("placeholder", ctx_r5.filter.placeholder || "")("value", ctx_r5.quickSearchValue || "");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r5.filter.advancedAction);
  }
}
function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-disclaimer-group", 22);
    ɵɵlistener("p-change", function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template_po_disclaimer_group_p_change_0_listener($event) {
      ɵɵrestoreView(_r22);
      const ctx_r21 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r21.onChangeDisclaimerGroup($event));
    })("p-remove", function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template_po_disclaimer_group_p_remove_0_listener($event) {
      ɵɵrestoreView(_r22);
      const ctx_r23 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r23.onRemoveDisclaimer($event));
    })("p-remove-all", function PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template_po_disclaimer_group_p_remove_all_0_listener($event) {
      ɵɵrestoreView(_r22);
      const ctx_r24 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r24.onRemoveAllDisclaimers($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵclassProp("po-page-list-disclaimer-group", !!(ctx_r6.disclaimerGroup == null ? null : ctx_r6.disclaimerGroup.disclaimers == null ? null : ctx_r6.disclaimerGroup.disclaimers.length));
    ɵɵproperty("p-disclaimers", ctx_r6.disclaimerGroup == null ? null : ctx_r6.disclaimerGroup.disclaimers)("p-hide-remove-all", ctx_r6.disclaimerGroup == null ? null : ctx_r6.disclaimerGroup.hideRemoveAll)("p-title", ctx_r6.disclaimerGroup == null ? null : ctx_r6.disclaimerGroup.title);
  }
}
function PoPageListComponent_po_page_header_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-page-header", 1)(1, "div", 2)(2, "div", 3)(3, "div", 4);
    ɵɵtemplate(4, PoPageListComponent_po_page_header_1_po_button_4_Template, 1, 3, "po-button", 5)(5, PoPageListComponent_po_page_header_1_po_button_5_Template, 1, 2, "po-button", 6)(6, PoPageListComponent_po_page_header_1_po_button_6_Template, 1, 2, "po-button", 6)(7, PoPageListComponent_po_page_header_1_po_dropdown_7_Template, 1, 2, "po-dropdown", 7);
    ɵɵelementEnd();
    ɵɵtemplate(8, PoPageListComponent_po_page_header_1_div_8_Template, 7, 5, "div", 8);
    ɵɵelementEnd();
    ɵɵtemplate(9, PoPageListComponent_po_page_header_1_po_disclaimer_group_9_Template, 1, 5, "po-disclaimer-group", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-page-list-header-padding", ctx_r0.filter && !ctx_r0.visibleActions.length);
    ɵɵproperty("p-breadcrumb", ctx_r0.breadcrumb)("p-title", ctx_r0.title)("p-subtitle", ctx_r0.subtitle);
    ɵɵadvance(3);
    ɵɵclassProp("po-page-list-actions-padding", ctx_r0.filter);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions[0]);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions[1] && (ctx_r0.visibleActions.length === 2 || !ctx_r0.isMobile));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions.length === 3 && ctx_r0.visibleActions[2] && !ctx_r0.isMobile);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.visibleActions.length > ctx_r0.limitPrimaryActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.filter);
    ɵɵadvance();
    ɵɵproperty("ngIf", !!ctx_r0.disclaimerGroup);
  }
}
var _c1$4 = ["*"];
var PoPageListComponent = class _PoPageListComponent extends PoPageListBaseComponent {
  renderer;
  router;
  changeDetector;
  filterInput;
  advancedSearch;
  dropdownActions;
  isMobile;
  limitPrimaryActions = 3;
  callFunction = callFunction;
  isRecalculate = true;
  maxWidthMobile = 480;
  /* istanbul ignore next */
  constructor(viewRef, languageService, renderer, router, changeDetector) {
    super(languageService);
    this.renderer = renderer;
    this.router = router;
    this.changeDetector = changeDetector;
    this.initializeListeners();
  }
  ngOnInit() {
    this.advancedSearch = this.initializeFixedLiterals();
  }
  ngAfterContentInit() {
    this.setIsMobile();
    this.setDropdownActions();
  }
  ngOnChanges(changes) {
    this.setDropdownActions();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  actionIsDisabled(action) {
    return isTypeof(action.disabled, "function") ? action.disabled(action) : action.disabled;
  }
  callAction(item) {
    if (item.url) {
      isExternalLink(item.url) ? openExternalLink(item.url) : this.router.navigate([item.url]);
    } else if (item.action) {
      item.action();
    }
  }
  hasPageHeader() {
    return !!(this.title || this.visibleActions && this.visibleActions.length || this.breadcrumb && this.breadcrumb.items.length);
  }
  hasCustomFilterSize() {
    if (!this.filter) {
      return false;
    }
    return this.filter.width >= 1 && this.filter.width <= 6;
  }
  filterSizeClass(width) {
    const smWidth = Math.max(this.filter?.advancedAction ? 6 : 2, width);
    const mdWidth = Math.max(this.filter?.advancedAction ? 4 : 1, width);
    if (this.filter?.advancedAction) {
      width = Math.max(width, 2);
    }
    return `po-sm-${smWidth} po-md-${mdWidth} po-lg-${width} po-xl-${width}`;
  }
  setDropdownActions() {
    if (this.visibleActions.length > this.limitPrimaryActions) {
      this.dropdownActions = this.visibleActions.slice(this.limitPrimaryActions - 1);
    }
  }
  callActionFilter(field) {
    this.filter[field](this.filterInput.nativeElement.value);
    this.changeDetector.detectChanges();
  }
  /**
   * Limpa o campo de pesquisa.
   */
  clearInputSearch() {
    this.filterInput.nativeElement.value = null;
  }
  onkeypress(key) {
    if (key === 13) {
      this.callActionFilter("action");
    }
  }
  // Recebe evento change do disclaimer e recalcula tela
  onChangeDisclaimerGroup(disclaimers) {
    if (disclaimers && disclaimers.length && this.isRecalculate || disclaimers.length === 0 && !this.isRecalculate) {
      this.poPageContent.recalculateHeaderSize();
      this.isRecalculate = !this.isRecalculate;
    }
    if (this.disclaimerGroup && this.disclaimerGroup.change) {
      this.disclaimerGroup.change(disclaimers);
    }
  }
  onRemoveDisclaimer(removeData) {
    if (this.disclaimerGroup.remove) {
      this.disclaimerGroup.remove(removeData);
    }
  }
  onRemoveAllDisclaimers(removedDisclaimers) {
    if (this.disclaimerGroup.removeAll) {
      this.disclaimerGroup.removeAll(removedDisclaimers);
    }
  }
  initializeFixedLiterals() {
    const literal = {
      pt: {
        advancedSearch: "Busca avançada"
      },
      en: {
        advancedSearch: "Advanced search"
      },
      es: {
        advancedSearch: "Búsqueda avanzada"
      },
      ru: {
        advancedSearch: "полный поиск"
      }
    };
    return literal[this.language].advancedSearch;
  }
  initializeListeners() {
    this.resizeListener = this.renderer.listen("window", "resize", (event) => {
      this.onResize(event);
    });
  }
  removeListeners() {
    this.resizeListener();
  }
  onResize(event) {
    const width = event.target.innerWidth;
    if (width < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
      this.setDropdownActions();
    } else {
      this.isMobile = false;
      this.limitPrimaryActions = 3;
      this.setDropdownActions();
    }
  }
  setIsMobile() {
    if (window.innerWidth < this.maxWidthMobile) {
      this.isMobile = true;
      this.limitPrimaryActions = 2;
    }
  }
  static ɵfac = function PoPageListComponent_Factory(t) {
    return new (t || _PoPageListComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoPageListComponent, selectors: [["po-page-list"]], viewQuery: function PoPageListComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$b, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
    }
  }, features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], ngContentSelectors: _c1$4, decls: 4, vars: 1, consts: [[3, "po-page-list-header-padding", "p-breadcrumb", "p-title", "p-subtitle", 4, "ngIf"], [3, "p-breadcrumb", "p-title", "p-subtitle"], [1, "po-page-list-container"], [1, "po-page-list-operations"], [1, "po-page-list-actions"], ["p-kind", "primary", 3, "p-disabled", "p-icon", "p-label", "p-click", 4, "ngIf"], [3, "p-disabled", "p-label", "p-click", 4, "ngIf"], [3, "p-actions", "p-label", 4, "ngIf"], ["class", "po-page-list-filter-wrapper", 3, "ngClass", 4, "ngIf"], [3, "po-page-list-disclaimer-group", "p-disclaimers", "p-hide-remove-all", "p-title", "p-change", "p-remove", "p-remove-all", 4, "ngIf"], ["p-kind", "primary", 3, "p-disabled", "p-icon", "p-label", "p-click"], [3, "p-disabled", "p-label", "p-click"], [3, "p-actions", "p-label"], [1, "po-page-list-filter-wrapper", 3, "ngClass"], [1, "po-field-container-content", "po-page-filter-content", 3, "ngClass"], [1, "po-field-icon-container-right"], [1, "po-icon", "po-icon-search", "po-field-icon", "po-icon-input", 3, "click"], ["name", "model", "type", "text", 1, "po-input", "po-input-icon-right", 3, "placeholder", "value", "keypress"], ["filterInput", ""], ["class", "po-page-list-filter-search", 4, "ngIf"], [1, "po-page-list-filter-search"], ["tabindex", "0", 1, "po-page-list-filter-search-link", 3, "click", "keydown.enter"], [3, "p-disclaimers", "p-hide-remove-all", "p-title", "p-change", "p-remove", "p-remove-all"]], template: function PoPageListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "po-page");
      ɵɵtemplate(1, PoPageListComponent_po_page_header_1_Template, 10, 13, "po-page-header", 0);
      ɵɵelementStart(2, "po-page-content");
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasPageHeader());
    }
  }, dependencies: [NgClass, NgIf, PoButtonComponent, PoDisclaimerGroupComponent, PoDropdownComponent, PoPageComponent, PoPageContentComponent, PoPageHeaderComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageListComponent, [{
    type: Component,
    args: [{ selector: "po-page-list", template: `<po-page>
  <!-- HEADER -->
  <po-page-header
    *ngIf="hasPageHeader()"
    [class.po-page-list-header-padding]="filter && !visibleActions.length"
    [p-breadcrumb]="breadcrumb"
    [p-title]="title"
    [p-subtitle]="subtitle"
  >
    <div class="po-page-list-container">
      <!-- OPERATIONS -->
      <div class="po-page-list-operations">
        <div class="po-page-list-actions" [class.po-page-list-actions-padding]="filter">
          <po-button
            *ngIf="visibleActions[0]"
            p-kind="primary"
            [p-disabled]="actionIsDisabled(actions[0])"
            [p-icon]="visibleActions[0].icon"
            [p-label]="visibleActions[0].label"
            (p-click)="callAction(visibleActions[0])"
          >
          </po-button>

          <po-button
            *ngIf="visibleActions[1] && (visibleActions.length === 2 || !isMobile)"
            [p-disabled]="actionIsDisabled(actions[1])"
            [p-label]="visibleActions[1].label"
            (p-click)="callAction(visibleActions[1])"
          >
          </po-button>

          <po-button
            *ngIf="visibleActions.length === 3 && visibleActions[2] && !isMobile"
            [p-disabled]="actionIsDisabled(visibleActions[2])"
            [p-label]="visibleActions[2].label"
            (p-click)="callAction(visibleActions[2])"
          >
          </po-button>

          <po-dropdown
            *ngIf="visibleActions.length > limitPrimaryActions"
            [p-actions]="dropdownActions"
            [p-label]="literals.otherActions"
          >
          </po-dropdown>
        </div>

        <!-- FILTER -->
        <div
          class="po-page-list-filter-wrapper"
          *ngIf="filter"
          [ngClass]="hasCustomFilterSize() ? filterSizeClass(filter.width) : ''"
        >
          <div
            class="po-field-container-content po-page-filter-content"
            [ngClass]="
              hasCustomFilterSize()
                ? filter.advancedAction
                  ? 'po-page-filter-input-variable-size'
                  : 'po-page-filter-input-variable-size-wo-adv-search'
                : ''
            "
          >
            <div class="po-field-icon-container-right">
              <span class="po-icon po-icon-search po-field-icon po-icon-input" (click)="callActionFilter('action')">
              </span>
            </div>

            <input
              #filterInput
              class="po-input po-input-icon-right"
              name="model"
              type="text"
              [placeholder]="filter.placeholder || ''"
              (keypress)="onkeypress($event.keyCode)"
              [value]="quickSearchValue || ''"
            />
          </div>

          <div class="po-page-list-filter-search" *ngIf="filter.advancedAction">
            <span
              class="po-page-list-filter-search-link"
              tabindex="0"
              (click)="callActionFilter('advancedAction')"
              (keydown.enter)="callActionFilter('advancedAction')"
            >
              {{ advancedSearch }}
            </span>
          </div>
        </div>
      </div>

      <!-- DISCLAIMER -->
      <po-disclaimer-group
        *ngIf="!!disclaimerGroup"
        [class.po-page-list-disclaimer-group]="!!disclaimerGroup?.disclaimers?.length"
        [p-disclaimers]="disclaimerGroup?.disclaimers"
        [p-hide-remove-all]="disclaimerGroup?.hideRemoveAll"
        [p-title]="disclaimerGroup?.title"
        (p-change)="onChangeDisclaimerGroup($event)"
        (p-remove)="onRemoveDisclaimer($event)"
        (p-remove-all)="onRemoveAllDisclaimers($event)"
      >
      </po-disclaimer-group>
    </div>
  </po-page-header>

  <!-- CONTENT -->
  <po-page-content>
    <ng-content></ng-content>
  </po-page-content>
</po-page>
` }]
  }], () => [{ type: ViewContainerRef }, { type: PoLanguageService }, { type: Renderer2 }, { type: Router }, { type: ChangeDetectorRef }], { filterInput: [{
    type: ViewChild,
    args: ["filterInput"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoPageListComponent, { className: "PoPageListComponent", filePath: "lib/components/po-page/po-page-list/po-page-list.component.ts", lineNumber: 50 });
})();
var PoPageModule = class _PoPageModule {
  static ɵfac = function PoPageModule_Factory(t) {
    return new (t || _PoPageModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoPageModule });
  static ɵinj = ɵɵdefineInjector({ imports: [
    CommonModule,
    FormsModule,
    RouterModule,
    PoBreadcrumbModule,
    PoButtonModule,
    PoDisclaimerGroupModule,
    PoDropdownModule,
    PoFieldModule,
    PoLanguageModule,
    PoModalModule,
    PoPageSlideModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPageModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        FormsModule,
        RouterModule,
        PoBreadcrumbModule,
        PoButtonModule,
        PoDisclaimerGroupModule,
        PoDropdownModule,
        PoFieldModule,
        PoLanguageModule,
        PoModalModule,
        PoPageSlideModule
      ],
      declarations: [
        PoPageComponent,
        PoPageContentComponent,
        PoPageDefaultComponent,
        PoPageDetailComponent,
        PoPageEditComponent,
        PoPageHeaderComponent,
        PoPageListComponent
      ],
      exports: [
        PoPageDefaultComponent,
        PoPageDetailComponent,
        PoPageEditComponent,
        PoPageListComponent,
        PoPageSlideComponent
      ]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPageModule, { declarations: [
    PoPageComponent,
    PoPageContentComponent,
    PoPageDefaultComponent,
    PoPageDetailComponent,
    PoPageEditComponent,
    PoPageHeaderComponent,
    PoPageListComponent
  ], imports: [
    CommonModule,
    FormsModule,
    RouterModule,
    PoBreadcrumbModule,
    PoButtonModule,
    PoDisclaimerGroupModule,
    PoDropdownModule,
    PoFieldModule,
    PoLanguageModule,
    PoModalModule,
    PoPageSlideModule
  ], exports: [
    PoPageDefaultComponent,
    PoPageDetailComponent,
    PoPageEditComponent,
    PoPageListComponent,
    PoPageSlideComponent
  ] });
})();
function PoSlideCirclesComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2);
    ɵɵlistener("click", function PoSlideCirclesComponent_ng_container_1_Template_div_click_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r4);
      const index_r2 = restoredCtx.index;
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.click.emit(index_r2));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const index_r2 = ctx.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-slide-active-circle", index_r2 === ctx_r0.currentSlideIndex);
  }
}
var PoSlideCirclesComponent = class _PoSlideCirclesComponent {
  /** Index do slide atual. */
  currentSlideIndex;
  /** Itens do slide. */
  items;
  /** Evento emitido ao clicar em um controle. */
  click = new EventEmitter();
  static ɵfac = function PoSlideCirclesComponent_Factory(t) {
    return new (t || _PoSlideCirclesComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSlideCirclesComponent, selectors: [["po-slide-circles"]], inputs: { currentSlideIndex: [InputFlags.None, "p-current-slide-index", "currentSlideIndex"], items: [InputFlags.None, "p-items", "items"] }, outputs: { click: "p-click" }, decls: 2, vars: 1, consts: [[1, "po-slide-circles"], [4, "ngFor", "ngForOf"], [1, "po-slide-circle", 3, "click"]], template: function PoSlideCirclesComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoSlideCirclesComponent_ng_container_1_Template, 2, 2, "ng-container", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.items);
    }
  }, dependencies: [NgForOf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideCirclesComponent, [{
    type: Component,
    args: [{ selector: "po-slide-circles", template: '<div class="po-slide-circles">\n  <ng-container *ngFor="let item of items; let index = index">\n    <div\n      class="po-slide-circle"\n      [class.po-slide-active-circle]="index === currentSlideIndex"\n      (click)="click.emit(index)"\n    ></div>\n  </ng-container>\n</div>\n' }]
  }], null, { currentSlideIndex: [{
    type: Input,
    args: ["p-current-slide-index"]
  }], items: [{
    type: Input,
    args: ["p-items"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideCirclesComponent, { className: "PoSlideCirclesComponent", filePath: "lib/components/po-slide/po-slide-circles/po-slide-circles.component.ts", lineNumber: 14 });
})();
var poSlideIntervalDefault = 4e3;
var PoSlideBaseComponent = class _PoSlideBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define a exibição das setas de navegação.
   *
   * @default `false`
   */
  hideArrows = false;
  _interval = poSlideIntervalDefault;
  _height;
  _slides;
  /**
   * @optional
   *
   * @description
   * Altura do po-slide, caso seja slide com template customizado, não assume o valor `default`.
   *
   * @default `336`
   */
  set height(value) {
    this._height = convertToInt(value);
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Valor em milissegundos que define o tempo de troca dos slides, caso o valor seja menor que `1000` os slides não trocam automaticamente.
   *
   * @default `4000`
   */
  set interval(value) {
    this._interval = convertToInt(value, poSlideIntervalDefault);
    this._interval >= 1e3 ? this.startInterval() : this.cancelInterval();
  }
  get interval() {
    return this._interval;
  }
  /**
   * @description
   *
   * Array de imagens ou dados para o slide, pode ser de três formas:
   *
   * - Array implementando objetos da interface `PoSlideItem`:
   * ```
   * [{ image: '/assets/image-1', action: 'imageClick.bind(this)'}, { image: '/assets/image-2' }]
   * ```
   * - Array de `strings` com os caminhos das imagens:
   * ```
   * ['/assets/image-1', '/assets/image-2' ]
   * ```
   * - Array com lista de itens (para utilizar template):
   * ```
   * [{ label: '1', img: '/assets/image-1' }, { label: '2', img: '/assets/image-1' }]
   * ```
   *
   * > As setas de navegação e o controle com círculos apenas serão renderizados caso possua mais de um slide.
   */
  set slides(value) {
    this._slides = value;
    this.setSlideItems(value);
    if (value && value.length) {
      this.startSlide();
    }
  }
  get slides() {
    return this._slides;
  }
  static ɵfac = function PoSlideBaseComponent_Factory(t) {
    return new (t || _PoSlideBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoSlideBaseComponent, inputs: { hideArrows: [InputFlags.HasDecoratorInputTransform, "p-hide-arrows", "hideArrows", convertToBoolean], height: [InputFlags.None, "p-height", "height"], interval: [InputFlags.None, "p-interval", "interval"], slides: [InputFlags.None, "p-slides", "slides"] }, features: [ɵɵInputTransformsFeature] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideBaseComponent, [{
    type: Directive
  }], null, { hideArrows: [{
    type: Input,
    args: [{ alias: "p-hide-arrows", transform: convertToBoolean }]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], interval: [{
    type: Input,
    args: ["p-interval"]
  }], slides: [{
    type: Input,
    args: ["p-slides"]
  }] });
})();
var PoSlideContentTemplateDirective = class _PoSlideContentTemplateDirective {
  templateRef;
  // Necessário manter templateRef para o funcionamento do row template.
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function PoSlideContentTemplateDirective_Factory(t) {
    return new (t || _PoSlideContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoSlideContentTemplateDirective, selectors: [["", "p-slide-content-template", ""]] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[p-slide-content-template]"
    }]
  }], () => [{ type: TemplateRef }], null);
})();
var _c0$a = ["slideItem"];
var _c1$3 = (a0, a1) => ({ alt: a0, image: a1 });
var _c2$2 = (a0) => ({ item: a0 });
function PoSlideItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 8);
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const _r7 = ɵɵreference(8);
    ɵɵproperty("routerLink", ctx_r1.link);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r7)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c2$2, ɵɵpureFunction2(3, _c1$3, ctx_r1.alt, ctx_r1.image)));
  }
}
function PoSlideItemComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 10);
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const _r7 = ɵɵreference(8);
    ɵɵproperty("href", ctx_r2.link, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r7)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c2$2, ɵɵpureFunction2(3, _c1$3, ctx_r2.alt, ctx_r2.image)));
  }
}
var _c3$1 = (a0, a1, a2) => ({ alt: a0, image: a1, data: a2 });
function PoSlideItemComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 11);
    ɵɵlistener("click", function PoSlideItemComponent_a_4_Template_a_click_0_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.action ? ctx_r8.action(ctx_r8.data) : void 0);
    });
    ɵɵelementContainer(1, 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const _r5 = ɵɵreference(6);
    const _r7 = ɵɵreference(8);
    ɵɵproperty("ngClass", ctx_r3.action ? "po-slide-item-link" : "po-slide-item-no-link");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r3.template ? _r5 : _r7)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c2$2, ɵɵpureFunction3(3, _c3$1, ctx_r3.alt, ctx_r3.image, ctx_r3.data)));
  }
}
function PoSlideItemComponent_ng_template_5_div_0_ng_template_1_Template(rf, ctx) {
}
var _c4 = (a0, a1) => ({ $implicit: a0, index: a1 });
function PoSlideItemComponent_ng_template_5_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, PoSlideItemComponent_ng_template_5_div_0_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext();
    const item_r10 = ctx_r14.item;
    const index_r11 = ctx_r14.index;
    const ctx_r12 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r12.template.templateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c4, item_r10.data, index_r11));
  }
}
function PoSlideItemComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoSlideItemComponent_ng_template_5_div_0_Template, 2, 5, "div", 12);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r4.template);
  }
}
function PoSlideItemComponent_ng_template_7_img_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 15);
  }
  if (rf & 2) {
    const item_r15 = ɵɵnextContext().item;
    const ctx_r16 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r16.imageHeight, "px");
    ɵɵproperty("alt", item_r15.alt)("src", item_r15.image, ɵɵsanitizeUrl);
  }
}
function PoSlideItemComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoSlideItemComponent_ng_template_7_img_0_Template, 1, 4, "img", 14);
  }
  if (rf & 2) {
    const item_r15 = ctx.item;
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("ngIf", item_r15.image && !ctx_r6.isIEOrEdge);
  }
}
var PoSlideItemComponent = class _PoSlideItemComponent {
  itemElement;
  /** Ação executada ao clicar em uma imagem */
  action;
  /** Texto alternativo quando a imagem não é encontrada */
  alt;
  /** Dados para o template customizado */
  data;
  /** Caminho da imagem */
  image;
  /** Altura da imagem */
  imageHeight;
  /** Template customizado */
  template;
  /** Link executado ao clicar em uma imagem */
  link;
  isIEOrEdge = isIEOrEdge();
  setLinkType() {
    if (!this.template && this.link) {
      return this.link.startsWith("http") ? "externalLink" : "internalLink";
    }
    return "noLink";
  }
  static ɵfac = function PoSlideItemComponent_Factory(t) {
    return new (t || _PoSlideItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSlideItemComponent, selectors: [["po-slide-item"]], viewQuery: function PoSlideItemComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$a, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemElement = _t.first);
    }
  }, inputs: { action: [InputFlags.None, "p-action", "action"], alt: [InputFlags.None, "p-alt", "alt"], data: [InputFlags.None, "p-data", "data"], image: [InputFlags.None, "p-image", "image"], imageHeight: [InputFlags.None, "p-image-height", "imageHeight"], template: [InputFlags.None, "p-template", "template"], link: [InputFlags.None, "p-link", "link"] }, decls: 9, vars: 8, consts: [[1, "po-slide-item", 3, "ngSwitch"], ["slideItem", ""], ["class", "po-slide-item-link", 3, "routerLink", 4, "ngSwitchCase"], ["class", "po-slide-item-link", 3, "href", 4, "ngSwitchCase"], [3, "ngClass", "click", 4, "ngSwitchCase"], [";", ""], ["slideItemTemplate", ""], ["slideItemImage", ""], [1, "po-slide-item-link", 3, "routerLink"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "po-slide-item-link", 3, "href"], [3, "ngClass", "click"], ["class", "po-slide-item-content", 4, "ngIf"], [1, "po-slide-item-content"], ["class", "po-slide-image", 3, "alt", "src", "height", 4, "ngIf"], [1, "po-slide-image", 3, "alt", "src"]], template: function PoSlideItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵtemplate(2, PoSlideItemComponent_a_2_Template, 2, 8, "a", 2)(3, PoSlideItemComponent_a_3_Template, 2, 8, "a", 3)(4, PoSlideItemComponent_a_4_Template, 2, 9, "a", 4);
      ɵɵelementEnd();
      ɵɵtemplate(5, PoSlideItemComponent_ng_template_5_Template, 1, 1, "ng-template", 5, 6, ɵɵtemplateRefExtractor)(7, PoSlideItemComponent_ng_template_7_Template, 1, 1, "ng-template", null, 7, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵstyleProp("background-image", !ctx.template && ctx.isIEOrEdge ? "url(" + ctx.image + ")" : "");
      ɵɵclassProp("po-slide-item-background-image", !ctx.template && ctx.isIEOrEdge);
      ɵɵproperty("ngSwitch", ctx.setLinkType());
      ɵɵadvance(2);
      ɵɵproperty("ngSwitchCase", "internalLink");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "externalLink");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "noLink");
    }
  }, dependencies: [NgClass, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, RouterLink], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideItemComponent, [{
    type: Component,
    args: [{ selector: "po-slide-item", template: `<div
  #slideItem
  class="po-slide-item"
  [class.po-slide-item-background-image]="!template && isIEOrEdge"
  [style.background-image]="!template && isIEOrEdge ? 'url(' + image + ')' : ''"
  [ngSwitch]="setLinkType()"
>
  <!-- slide com link interno -->
  <a *ngSwitchCase="'internalLink'" class="po-slide-item-link" [routerLink]="link">
    <ng-container [ngTemplateOutlet]="slideItemImage" [ngTemplateOutletContext]="{ item: { alt: alt, image: image } }">
    </ng-container>
  </a>
  <!-- slide com link externo -->
  <a *ngSwitchCase="'externalLink'" class="po-slide-item-link" [href]="link">
    <ng-container [ngTemplateOutlet]="slideItemImage" [ngTemplateOutletContext]="{ item: { alt: alt, image: image } }">
    </ng-container>
  </a>
  <!-- slide sem link -->
  <a
    *ngSwitchCase="'noLink'"
    [ngClass]="action ? 'po-slide-item-link' : 'po-slide-item-no-link'"
    (click)="action ? action(data) : undefined"
  >
    <ng-container
      [ngTemplateOutlet]="template ? slideItemTemplate : slideItemImage"
      [ngTemplateOutletContext]="{ item: { alt: alt, image: image, data: data } }"
    >
    </ng-container>
  </a>
</div>

<ng-template #slideItemTemplate let-item="item" ; let-index="index">
  <div *ngIf="template" class="po-slide-item-content">
    <ng-template
      [ngTemplateOutlet]="template.templateRef"
      [ngTemplateOutletContext]="{ $implicit: item.data, index: index }"
    >
    </ng-template>
  </div>
</ng-template>

<ng-template #slideItemImage let-item="item">
  <img
    *ngIf="item.image && !isIEOrEdge"
    class="po-slide-image"
    [alt]="item.alt"
    [src]="item.image"
    [style.height.px]="imageHeight"
  />
</ng-template>
` }]
  }], null, { itemElement: [{
    type: ViewChild,
    args: ["slideItem", { static: true }]
  }], action: [{
    type: Input,
    args: ["p-action"]
  }], alt: [{
    type: Input,
    args: ["p-alt"]
  }], data: [{
    type: Input,
    args: ["p-data"]
  }], image: [{
    type: Input,
    args: ["p-image"]
  }], imageHeight: [{
    type: Input,
    args: ["p-image-height"]
  }], template: [{
    type: Input,
    args: ["p-template"]
  }], link: [{
    type: Input,
    args: ["p-link"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideItemComponent, { className: "PoSlideItemComponent", filePath: "lib/components/po-slide/po-slide-item/po-slide-item.component.ts", lineNumber: 18 });
})();
var PoSlideControlComponent = class _PoSlideControlComponent {
  /** Tipo de controle que aceita os valores: 'previous' e 'next'. */
  control;
  /** Evento emitido ao clicar em um controle. */
  click = new EventEmitter();
  static ɵfac = function PoSlideControlComponent_Factory(t) {
    return new (t || _PoSlideControlComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSlideControlComponent, selectors: [["po-slide-control"]], inputs: { control: [InputFlags.None, "p-control", "control"] }, outputs: { click: "p-click" }, decls: 3, vars: 6, consts: [[1, "po-slide-arrow-circle", 3, "click"]], template: function PoSlideControlComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div")(1, "div", 0);
      ɵɵlistener("click", function PoSlideControlComponent_Template_div_click_1_listener() {
        return ctx.click.emit();
      });
      ɵɵelement(2, "div");
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("po-slide-control-", ctx.control, "");
      ɵɵadvance(2);
      ɵɵclassMapInterpolate1("po-slide-arrow po-slide-arrow-", ctx.control, "");
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideControlComponent, [{
    type: Component,
    args: [{ selector: "po-slide-control", template: '<div class="po-slide-control-{{ control }}">\n  <div class="po-slide-arrow-circle" (click)="click.emit()">\n    <div class="po-slide-arrow po-slide-arrow-{{ control }}"></div>\n  </div>\n</div>\n' }]
  }], null, { control: [{
    type: Input,
    args: ["p-control"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideControlComponent, { className: "PoSlideControlComponent", filePath: "lib/components/po-slide/po-slide-control/po-slide-control.component.ts", lineNumber: 14 });
})();
var _c0$9 = ["slide"];
function PoSlideComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "po-slide-item", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-action", item_r5.action)("p-data", item_r5)("p-image", item_r5.image)("p-image-height", ctx_r1.imageHeight)("p-template", ctx_r1.slideContentTemplate)("p-alt", item_r5.alt)("p-link", item_r5.link);
  }
}
function PoSlideComponent_po_slide_control_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-slide-control", 9);
    ɵɵlistener("p-click", function PoSlideComponent_po_slide_control_5_Template_po_slide_control_p_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.previousControl());
    });
    ɵɵelementEnd();
  }
}
function PoSlideComponent_po_slide_control_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-slide-control", 10);
    ɵɵlistener("p-click", function PoSlideComponent_po_slide_control_6_Template_po_slide_control_p_click_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.nextControl());
    });
    ɵɵelementEnd();
  }
}
function PoSlideComponent_po_slide_circles_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-slide-circles", 11);
    ɵɵlistener("p-click", function PoSlideComponent_po_slide_circles_7_Template_po_slide_circles_p_click_0_listener($event) {
      ɵɵrestoreView(_r12);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.goToItem($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("p-current-slide-index", ctx_r4.currentSlideIndex)("p-items", ctx_r4.slideItems);
  }
}
var poSlideDefaultHeight = 336;
var poSlideIntervalMin = 1e3;
var poSlideMinHeight = 192;
var poSlideTiming = "250ms ease";
var PoSlideComponent = class _PoSlideComponent extends PoSlideBaseComponent {
  builder;
  slideContentTemplate;
  slide;
  itemsElements;
  currentSlideIndex = 0;
  imageHeight;
  slideItems = [];
  slideItemWidth;
  isLoaded = false;
  player;
  setInterval;
  resize$ = new Subject();
  resizeSubscription;
  get hasElements() {
    return !!this.slide.nativeElement.offsetWidth && !!this.itemsElements && !!this.itemsElements.length;
  }
  get isImageSlide() {
    return !this.slideContentTemplate;
  }
  get offset() {
    return this.currentSlideIndex * this.slideItemWidth;
  }
  get hasSlides() {
    return !!this.slides && !!this.slides.length;
  }
  constructor(builder) {
    super();
    this.builder = builder;
  }
  onResize() {
    this.resize$.next({});
  }
  ngOnInit() {
    this.resizeSubscription = this.resize$.pipe(debounceTime(150)).subscribe(() => {
      this.setSlideItemWidth();
      this.goToItem(this.currentSlideIndex);
    });
  }
  ngDoCheck() {
    if (!this.isLoaded && this.hasElements) {
      this.setSlideItemWidth();
      this.isLoaded = true;
      if (this.hasSlides) {
        this.startSlide();
      }
    }
  }
  ngOnChanges(changes) {
    if (changes.height) {
      this.setSlideHeight(this.height);
    }
  }
  ngOnDestroy() {
    this.resizeSubscription?.unsubscribe();
  }
  /**
   * Método que retorna o index do slide atual
   *
   * ```
   * @ViewChild('slideComponent', { static: true }) slideComponent: PoSlideComponent;
   *  myFunction() {
   *    let currentIndex = this.slideComponent.getCurrentSlideIndex();
   * }
   *
   * ```
   */
  getCurrentSlideIndex() {
    return this.currentSlideIndex;
  }
  goToItem(index) {
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.currentSlideIndex = index;
    this.animate(this.offset);
  }
  nextControl() {
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.next();
  }
  /**
   * Método para chamar o próximo slide.
   *
   * ```
   * @ViewChild('slideComponent', { static: true }) slideComponent: PoSlideComponent;
   *
   * myFunction() {
   *  this.slideComponent.next();
   * }
   * ```
   */
  next() {
    if (this.currentSlideIndex + 1 === this.slideItems.length) {
      this.currentSlideIndex = 0;
      this.animate(0);
      return;
    }
    this.currentSlideIndex = (this.currentSlideIndex + 1) % this.slideItems.length;
    this.animate(this.offset);
  }
  /**
   * Método para chamar o slide anterior.
   *
   * ```
   * @ViewChild('slideComponent', { static: true }) slideComponent: PoSlideComponent;
   *
   * myFunction() {
   *  this.slideComponent.previous();
   * }
   * ```
   */
  previous() {
    if (this.currentSlideIndex === 0) {
      this.currentSlideIndex = this.slideItems.length - 1;
      this.animate(this.offset);
      return;
    }
    this.currentSlideIndex = (this.currentSlideIndex - 1 + this.slideItems.length) % this.slideItems.length;
    this.animate(this.offset);
  }
  previousControl() {
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.previous();
  }
  setSlideHeight(height) {
    this.setHeight(height);
  }
  cancelInterval() {
    clearInterval(this.setInterval);
  }
  setSlideItems(slides) {
    if (this.hasSlides) {
      this.slideContentTemplate ? this.createArrayForTemplate(slides) : this.createArrayFromSlides(slides);
    } else {
      this.slideItems = [];
      this.cancelInterval();
    }
  }
  startSlide() {
    this.setSlideHeight(this.height);
    if (this.interval > poSlideIntervalMin) {
      this.startInterval();
    }
    this.currentSlideIndex = 0;
  }
  startInterval() {
    if (this.setInterval) {
      this.cancelInterval();
    }
    this.setInterval = this.hasSlides && this.hasElements ? setInterval(() => {
      this.next();
    }, this.interval) : void 0;
  }
  animate(offset) {
    if (this.hasElements) {
      const animation = this.buildTransitionAnimation(offset);
      this.player = animation.create(this.slide.nativeElement);
      this.player.play();
    }
  }
  buildTransitionAnimation(offset) {
    return this.builder.build([animate(poSlideTiming, keyframes([style({ transform: `translateX(-${offset}px)` })]))]);
  }
  createArrayForTemplate(slides) {
    this.slideItems = [...slides];
  }
  createArrayFromSlides(slides) {
    const isStringArray = slides.every((item) => typeof item === "string");
    if (isStringArray) {
      slides.forEach((element) => this.slideItems.push({ image: `${element}` }));
    } else {
      this.slideItems = [...slides];
    }
  }
  setDefaultHeight(height) {
    if (height && height <= poSlideMinHeight || !height && this.isImageSlide) {
      this.slide.nativeElement.style.height = `${poSlideDefaultHeight}px`;
      this.imageHeight = poSlideDefaultHeight;
    } else {
      this.imageHeight = void 0;
    }
  }
  setHeight(height) {
    if (height && height > poSlideMinHeight) {
      this.slide.nativeElement.style.height = `${height}px`;
      this.imageHeight = height;
    } else {
      this.setDefaultHeight(height);
    }
  }
  setSlideItemWidth() {
    if (this.hasElements) {
      this.slideItemWidth = this.itemsElements.first.itemElement.nativeElement.getBoundingClientRect().width;
    }
  }
  static ɵfac = function PoSlideComponent_Factory(t) {
    return new (t || _PoSlideComponent)(ɵɵdirectiveInject(AnimationBuilder));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoSlideComponent, selectors: [["po-slide"]], contentQueries: function PoSlideComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoSlideContentTemplateDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.slideContentTemplate = _t.first);
    }
  }, viewQuery: function PoSlideComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$9, 7);
      ɵɵviewQuery(PoSlideItemComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.slide = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemsElements = _t);
    }
  }, hostBindings: function PoSlideComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("resize", function PoSlideComponent_resize_HostBindingHandler() {
        return ctx.onResize();
      }, false, ɵɵresolveWindow);
    }
  }, features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 8, vars: 4, consts: [[1, "po-slide-wrapper"], [1, "po-slide-outer"], [1, "po-slide-inner"], ["slide", ""], [4, "ngFor", "ngForOf"], ["p-control", "previous", 3, "p-click", 4, "ngIf"], ["p-control", "next", 3, "p-click", 4, "ngIf"], [3, "p-current-slide-index", "p-items", "p-click", 4, "ngIf"], [3, "p-action", "p-data", "p-image", "p-image-height", "p-template", "p-alt", "p-link"], ["p-control", "previous", 3, "p-click"], ["p-control", "next", 3, "p-click"], [3, "p-current-slide-index", "p-items", "p-click"]], template: function PoSlideComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "div", 2, 3);
      ɵɵtemplate(4, PoSlideComponent_ng_container_4_Template, 2, 7, "ng-container", 4);
      ɵɵelementEnd();
      ɵɵtemplate(5, PoSlideComponent_po_slide_control_5_Template, 1, 0, "po-slide-control", 5)(6, PoSlideComponent_po_slide_control_6_Template, 1, 0, "po-slide-control", 6);
      ɵɵelementEnd();
      ɵɵtemplate(7, PoSlideComponent_po_slide_circles_7_Template, 1, 2, "po-slide-circles", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("ngForOf", ctx.slideItems);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hideArrows && ctx.hasSlides && ctx.slides.length > 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hideArrows && ctx.hasSlides && ctx.slides.length > 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasSlides && ctx.slides.length > 1);
    }
  }, dependencies: [NgForOf, NgIf, PoSlideCirclesComponent, PoSlideControlComponent, PoSlideItemComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideComponent, [{
    type: Component,
    args: [{ selector: "po-slide", template: '<div class="po-slide-wrapper">\n  <div class="po-slide-outer">\n    <div class="po-slide-inner" #slide>\n      <ng-container *ngFor="let item of slideItems; let index = index">\n        <po-slide-item\n          [p-action]="item.action"\n          [p-data]="item"\n          [p-image]="item.image"\n          [p-image-height]="imageHeight"\n          [p-template]="slideContentTemplate"\n          [p-alt]="item.alt"\n          [p-link]="item.link"\n        >\n        </po-slide-item>\n      </ng-container>\n    </div>\n\n    <po-slide-control\n      *ngIf="!hideArrows && hasSlides && slides.length > 1"\n      p-control="previous"\n      (p-click)="previousControl()"\n    >\n    </po-slide-control>\n\n    <po-slide-control *ngIf="!hideArrows && hasSlides && slides.length > 1" p-control="next" (p-click)="nextControl()">\n    </po-slide-control>\n  </div>\n\n  <po-slide-circles\n    *ngIf="hasSlides && slides.length > 1"\n    [p-current-slide-index]="currentSlideIndex"\n    [p-items]="slideItems"\n    (p-click)="goToItem($event)"\n  >\n  </po-slide-circles>\n</div>\n' }]
  }], () => [{ type: AnimationBuilder }], { slideContentTemplate: [{
    type: ContentChild,
    args: [PoSlideContentTemplateDirective, { static: true }]
  }], slide: [{
    type: ViewChild,
    args: ["slide", { static: true }]
  }], itemsElements: [{
    type: ViewChildren,
    args: [PoSlideItemComponent]
  }], onResize: [{
    type: HostListener,
    args: ["window:resize"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoSlideComponent, { className: "PoSlideComponent", filePath: "lib/components/po-slide/po-slide.component.ts", lineNumber: 64 });
})();
var PoSlideModule = class _PoSlideModule {
  static ɵfac = function PoSlideModule_Factory(t) {
    return new (t || _PoSlideModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoSlideModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, RouterModule, PoContainerModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoSlideModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, RouterModule, PoContainerModule],
      declarations: [
        PoSlideCirclesComponent,
        PoSlideComponent,
        PoSlideControlComponent,
        PoSlideContentTemplateDirective,
        PoSlideItemComponent
      ],
      exports: [PoSlideComponent, PoSlideContentTemplateDirective],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoSlideModule, { declarations: [
    PoSlideCirclesComponent,
    PoSlideComponent,
    PoSlideControlComponent,
    PoSlideContentTemplateDirective,
    PoSlideItemComponent
  ], imports: [CommonModule, RouterModule, PoContainerModule], exports: [PoSlideComponent, PoSlideContentTemplateDirective] });
})();
var PoStepperStatus;
(function(PoStepperStatus2) {
  PoStepperStatus2["Active"] = "active";
  PoStepperStatus2["Default"] = "default";
  PoStepperStatus2["Disabled"] = "disabled";
  PoStepperStatus2["Done"] = "done";
  PoStepperStatus2["Error"] = "error";
})(PoStepperStatus || (PoStepperStatus = {}));
var _c0$8 = ["*"];
var PoStepComponent = class _PoStepComponent {
  elementRef;
  /**
   * @optional
   *
   * @description
   *
   * Função chamada quando o próximo *step* for clicado ou quando o método `PoStepperComponent.next()` for chamado.
   * Ao retornar `true` define que esse *step* ficará ativo e o atual como concluído (*done*).
   * Também aceita funções que retornem `Observable<boolean>`. Ao retornar um `Observable<boolean>`,
   * garanta que esse `Observable` será completado, caso houver algum erro durante o processo não será possível prosseguir
   * ao próximo *step*.
   *
   * Ao ser disparada, a mesma receberá por parâmetro o `PoStepComponent` atual.
   *
   * O contexto da função que será chamada, será o mesmo que o do `PoStepComponent`, então para poder alterar
   * para o contexto do componente que o está utilizando, pode ser utilizado a propriedade `bind` do Javascript.
   * Por exemplo, para a função `validate`:
   *
   * ```
   * <po-step p-label="Step 1" [p-can-active-next-step]="validate.bind(this)">
   * ...
   * </po-step>
   * ```
   */
  canActiveNextStep;
  /** Título que será exibido descrevendo o passo (*step*). */
  label;
  // ID do step
  id = uuid();
  _status = PoStepperStatus.Disabled;
  // Estado de exibição do `po-step`.
  set status(status) {
    this._status = status;
    this.setDisplayOnActiveOrError();
  }
  get status() {
    return this._status;
  }
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  ngAfterContentInit() {
    this.setDisplayOnActiveOrError();
  }
  setDisplayOnActiveOrError() {
    this.elementRef.nativeElement.style.display = this.status === PoStepperStatus.Active || this.status === PoStepperStatus.Error ? "" : "none";
  }
  static ɵfac = function PoStepComponent_Factory(t) {
    return new (t || _PoStepComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoStepComponent, selectors: [["po-step"]], inputs: { canActiveNextStep: [InputFlags.None, "p-can-active-next-step", "canActiveNextStep"], label: [InputFlags.None, "p-label", "label"], status: [InputFlags.None, "p-status", "status"] }, ngContentSelectors: _c0$8, decls: 1, vars: 0, template: function PoStepComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepComponent, [{
    type: Component,
    args: [{ selector: "po-step", template: "<ng-content></ng-content>\n" }]
  }], () => [{ type: ElementRef }], { canActiveNextStep: [{
    type: Input,
    args: ["p-can-active-next-step"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], status: [{
    type: Input,
    args: ["p-status"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepComponent, { className: "PoStepComponent", filePath: "lib/components/po-stepper/po-step/po-step.component.ts", lineNumber: 49 });
})();
function PoStepperCircleComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("po-icon", ctx_r0.icons || ctx_r0.isDone)("po-icon-exclamation", ctx_r0.icons && ctx_r0.isError)("po-icon-info", ctx_r0.icons && (ctx_r0.isActive || ctx_r0.isDefault || ctx_r0.isDisabled))("po-icon-ok", ctx_r0.isDone)("po-stepper-circle-content-lg", ctx_r0.isLargeStep)("po-stepper-circle-content-md", ctx_r0.isMediumStep);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", !ctx_r0.icons && !ctx_r0.isDone ? ctx_r0.content : "", " ");
  }
}
function PoStepperCircleComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
}
var poMediumStepSize = 32;
var poLargeStepSize = 48;
var PoStepperCircleComponent = class _PoStepperCircleComponent {
  // Conteúdo que irá aparecer no círculo do *step*.
  content;
  // Define se serão exibidos ícones no lugar de números nos steps.
  icons;
  // Tamanho do *step-circle*.
  size;
  // Status do *step*.
  status;
  get isActive() {
    return this.status === PoStepperStatus.Active;
  }
  get isDefault() {
    return this.status === PoStepperStatus.Default;
  }
  get isDisabled() {
    return this.status === PoStepperStatus.Disabled;
  }
  get isDone() {
    return this.status === PoStepperStatus.Done;
  }
  get isError() {
    return this.status === PoStepperStatus.Error;
  }
  get isLargeStep() {
    return this.size >= poLargeStepSize;
  }
  get isMediumStep() {
    return this.size >= poMediumStepSize && !this.isLargeStep;
  }
  static ɵfac = function PoStepperCircleComponent_Factory(t) {
    return new (t || _PoStepperCircleComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoStepperCircleComponent, selectors: [["po-stepper-circle"]], inputs: { content: [InputFlags.None, "p-content", "content"], icons: [InputFlags.None, "p-icons", "icons"], size: [InputFlags.None, "p-size", "size"], status: [InputFlags.None, "p-status", "status"] }, decls: 3, vars: 7, consts: [[1, "po-stepper-circle", 3, "tabindex"], ["class", "po-stepper-circle-content", 3, "po-icon", "po-icon-exclamation", "po-icon-info", "po-icon-ok", "po-stepper-circle-content-lg", "po-stepper-circle-content-md", 4, "ngIf"], ["class", "po-stepper-circle-active", 4, "ngIf"], [1, "po-stepper-circle-content"], [1, "po-stepper-circle-active"]], template: function PoStepperCircleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoStepperCircleComponent_span_1_Template, 2, 13, "span", 1)(2, PoStepperCircleComponent_div_2_Template, 1, 0, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("height", ctx.size, "px")("width", ctx.size, "px");
      ɵɵproperty("tabindex", ctx.isDisabled ? -1 : 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isActive);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isActive || ctx.isError);
    }
  }, dependencies: [NgIf], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperCircleComponent, [{
    type: Component,
    args: [{ selector: "po-stepper-circle", template: `<div class="po-stepper-circle" [style.height.px]="size" [style.width.px]="size" [tabindex]="isDisabled ? -1 : 0">
  <span
    *ngIf="!isActive"
    class="po-stepper-circle-content"
    [class.po-icon]="icons || isDone"
    [class.po-icon-exclamation]="icons && isError"
    [class.po-icon-info]="icons && (isActive || isDefault || isDisabled)"
    [class.po-icon-ok]="isDone"
    [class.po-stepper-circle-content-lg]="isLargeStep"
    [class.po-stepper-circle-content-md]="isMediumStep"
  >
    {{ !icons && !isDone ? content : '' }}
  </span>

  <div *ngIf="isActive || isError" class="po-stepper-circle-active"></div>
</div>
` }]
  }], null, { content: [{
    type: Input,
    args: ["p-content"]
  }], icons: [{
    type: Input,
    args: ["p-icons"]
  }], size: [{
    type: Input,
    args: ["p-size"]
  }], status: [{
    type: Input,
    args: ["p-status"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperCircleComponent, { className: "PoStepperCircleComponent", filePath: "lib/components/po-stepper/po-stepper-circle/po-stepper-circle.component.ts", lineNumber: 19 });
})();
var PoStepperOrientation;
(function(PoStepperOrientation2) {
  PoStepperOrientation2["Horizontal"] = "horizontal";
  PoStepperOrientation2["Vertical"] = "vertical";
})(PoStepperOrientation || (PoStepperOrientation = {}));
var poStepperOrientationDefault = PoStepperOrientation.Horizontal;
var PoStepperBaseComponent = class _PoStepperBaseComponent {
  /**
   *
   * @optional
   *
   * @description
   *
   * <a id="stepIconsProperty"></a>
   *
   * Habilita a exibição de ícone ao invés de número no centro do círculo dos *steps*.
   *
   * @default `false`
   */
  stepIcons;
  /**
   * @optional
   *
   * @description
   *
   * Define o tamanho dos *steps* em *pixels*, possibilitando um maior destaque.
   *
   * O valor informado deve ser entre `24` e `64`.
   *
   * > Valores que não se enquadrarem a esta regra serão ignorados, mantendo-se o valor *default*.
   *
   * @default `24`
   */
  stepSize;
  /** Ação que será executada quando o usuário mudar o passo do `po-stepper`. */
  onChangeStep = new EventEmitter();
  _orientation = poStepperOrientationDefault;
  _sequential = true;
  _step = 1;
  _steps = [];
  /**
   * @optional
   *
   * @description
   *
   * Define a orientação de exibição do `po-stepper`.
   *
   * > Veja os valores válidos no *enum* [PoStepperOrientation](documentation/po-stepper#stepperOrientation).
   *
   * @default `PoStepperOrientation.Horizontal`
   */
  set orientation(value) {
    this._orientation = Object.values(PoStepperOrientation).includes(value) ? value : poStepperOrientationDefault;
  }
  get orientation() {
    return this._orientation;
  }
  /**
   * @optional
   *
   * @description
   *
   * Controla o passo atual do `po-stepper`.
   *
   * > Ao utilizar esta propriedade e também utilizar o componente [**po-step**](/documentation/po-step),
   * o valor desta propriedade será ignorada permanecendo a definição do [**po-step**](/documentation/po-step).
   *
   * @default `1`
   */
  set step(step) {
    if (step >= 1 && step <= this.steps.length) {
      this._step = step;
      this._steps[this._step - 1].status = PoStepperStatus.Active;
    }
  }
  get step() {
    return this._step;
  }
  /**
   * @optional
   *
   * @description
   *
   * Lista dos itens do stepper. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio.
   *
   * > Ao utilizar esta propriedade e também utilizar o componente [**po-step**](/documentation/po-step),
   * o valor desta propriedade será ignorada permanecendo a definição do [**po-step**](/documentation/po-step).
   */
  set steps(steps) {
    this._steps = Array.isArray(steps) ? steps : [];
    this._steps.forEach((step) => step.status = PoStepperStatus.Default);
    this.step = 1;
  }
  get steps() {
    return this._steps;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define se o `po-stepper` será sequencial ou aleatório.
   *
   * > Ao utilizar o componente [**po-step**](/documentation/po-step), o valor desta propriedade sempre será verdadeiro.
   *
   * @default `true`
   */
  set sequential(sequential) {
    this._sequential = convertToBoolean(sequential);
  }
  get sequential() {
    return this._sequential;
  }
  static ɵfac = function PoStepperBaseComponent_Factory(t) {
    return new (t || _PoStepperBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoStepperBaseComponent, inputs: { stepIcons: [InputFlags.None, "p-step-icons", "stepIcons"], stepSize: [InputFlags.None, "p-step-size", "stepSize"], orientation: [InputFlags.None, "p-orientation", "orientation"], step: [InputFlags.None, "p-step", "step"], steps: [InputFlags.None, "p-steps", "steps"], sequential: [InputFlags.None, "p-sequential", "sequential"] }, outputs: { onChangeStep: "p-change-step" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperBaseComponent, [{
    type: Directive
  }], null, { stepIcons: [{
    type: Input,
    args: ["p-step-icons"]
  }], stepSize: [{
    type: Input,
    args: ["p-step-size"]
  }], onChangeStep: [{
    type: Output,
    args: ["p-change-step"]
  }], orientation: [{
    type: Input,
    args: ["p-orientation"]
  }], step: [{
    type: Input,
    args: ["p-step"]
  }], steps: [{
    type: Input,
    args: ["p-steps"]
  }], sequential: [{
    type: Input,
    args: ["p-sequential"]
  }] });
})();
var PoStepperLabelComponent = class _PoStepperLabelComponent {
  // Conteúdo da label.
  content;
  static ɵfac = function PoStepperLabelComponent_Factory(t) {
    return new (t || _PoStepperLabelComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoStepperLabelComponent, selectors: [["po-stepper-label"]], inputs: { content: [InputFlags.None, "p-content", "content"] }, decls: 2, vars: 1, consts: [[1, "po-stepper-label"]], template: function PoStepperLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.content, "\n");
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperLabelComponent, [{
    type: Component,
    args: [{ selector: "po-stepper-label", template: '<div class="po-stepper-label">\n  {{ content }}\n</div>\n' }]
  }], null, { content: [{
    type: Input,
    args: ["p-content"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperLabelComponent, { className: "PoStepperLabelComponent", filePath: "lib/components/po-stepper/po-stepper-label/po-stepper-label.component.ts", lineNumber: 14 });
})();
var poStepperStepSizeDefault = 24;
var poStepperStepSizeMax = 64;
var poStepLiteralsDefault = {
  en: { label: "Step" },
  es: { label: "Paso" },
  pt: { label: "Passo" }
};
var PoStepperStepComponent = class _PoStepperStepComponent {
  // Conteúdo que será repassado para o componente `p-circle-content` através da propriedade `p-content`.
  circleContent;
  // Define a orientação de exibição.
  orientation;
  // Informa o status da proxima etapa.
  nextStatus;
  // Evento que será emitido quando o status do *step* estiver ativo (`PoStepperStatus.Active`).
  activated = new EventEmitter();
  // Evento que será emitido ao clicar no *step*.
  click = new EventEmitter();
  // Evento que será emitido ao focar no *step* e pressionar a tecla *enter*.
  enter = new EventEmitter();
  literals = __spreadValues(__spreadValues({}, poStepLiteralsDefault[poLocaleDefault]), poStepLiteralsDefault[getShortBrowserLanguage()]);
  _label;
  _status;
  _stepIcons = false;
  _stepSize = poStepperStepSizeDefault;
  // Label do *step*.
  set label(value) {
    this._label = isTypeof(value, "string") ? value : `${this.literals.label} ${this.circleContent}`;
  }
  get label() {
    return this._label;
  }
  // Define o estado de exibição.
  set status(value) {
    this._status = value ? value : void 0;
    if (this.status === PoStepperStatus.Active) {
      this.activated.emit();
    }
  }
  get status() {
    return this._status;
  }
  set stepIcons(stepIcons) {
    this._stepIcons = convertToBoolean(stepIcons);
  }
  get stepIcons() {
    return this._stepIcons;
  }
  // Tamanho do `step` em *pixels*, possibilitando um maior destaque.
  // O valor informado deve ser entre `24` e `64`.
  set stepSize(value) {
    this._stepSize = value >= poStepperStepSizeDefault && value <= poStepperStepSizeMax ? value : poStepperStepSizeDefault;
  }
  get stepSize() {
    return this._stepSize;
  }
  get halfStepSize() {
    return this.stepSize / 2;
  }
  get isVerticalOrientation() {
    return this.orientation === PoStepperOrientation.Vertical;
  }
  get marginHorizontalBar() {
    return this.isVerticalOrientation ? void 0 : this.halfStepSize;
  }
  getStatusClass(status) {
    switch (status) {
      case PoStepperStatus.Active:
        return "po-stepper-step-default";
      case PoStepperStatus.Disabled:
        return "po-stepper-step-disabled";
      case PoStepperStatus.Done:
        return "po-stepper-step-default";
      case PoStepperStatus.Error:
        return "po-stepper-step-error";
      default:
        return "po-stepper-step-default";
    }
  }
  onClick() {
    if (this.status !== PoStepperStatus.Disabled) {
      this.click.emit();
    }
  }
  onEnter() {
    if (this.status !== PoStepperStatus.Disabled) {
      this.enter.emit();
    }
  }
  static ɵfac = function PoStepperStepComponent_Factory(t) {
    return new (t || _PoStepperStepComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoStepperStepComponent, selectors: [["po-stepper-step"]], inputs: { circleContent: [InputFlags.None, "p-circle-content", "circleContent"], orientation: [InputFlags.None, "p-orientation", "orientation"], nextStatus: [InputFlags.None, "p-next-status", "nextStatus"], label: [InputFlags.None, "p-label", "label"], status: [InputFlags.None, "p-status", "status"], stepIcons: [InputFlags.None, "p-step-icons", "stepIcons"], stepSize: [InputFlags.None, "p-step-size", "stepSize"] }, outputs: { activated: "p-activated", click: "p-click", enter: "p-enter" }, decls: 6, vars: 24, consts: [[1, "po-stepper-step", 3, "ngClass", "click", "keydown.enter"], [1, "po-stepper-step-container"], [3, "p-content", "p-icons", "p-size", "p-status"], [1, "po-stepper-step-label-position", 3, "p-content"]], template: function PoStepperStepComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoStepperStepComponent_Template_div_click_0_listener() {
        return ctx.onClick();
      })("keydown.enter", function PoStepperStepComponent_Template_div_keydown_enter_0_listener() {
        return ctx.onEnter();
      });
      ɵɵelementStart(1, "div", 1);
      ɵɵelement(2, "div")(3, "po-stepper-circle", 2)(4, "div");
      ɵɵelementEnd();
      ɵɵelement(5, "po-stepper-label", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ctx.getStatusClass(ctx.status));
      ɵɵadvance();
      ɵɵstyleProp("width", ctx.isVerticalOrientation ? ctx.stepSize : void 0, "px");
      ɵɵadvance();
      ɵɵstyleProp("margin-right", ctx.marginHorizontalBar, "px");
      ɵɵclassProp("po-stepper-step-bar-top", ctx.isVerticalOrientation)("po-stepper-step-bar-left", !ctx.isVerticalOrientation);
      ɵɵadvance();
      ɵɵproperty("p-content", ctx.circleContent)("p-icons", ctx.stepIcons)("p-size", ctx.stepSize)("p-status", ctx.status);
      ɵɵadvance();
      ɵɵstyleProp("margin-left", ctx.marginHorizontalBar, "px");
      ɵɵclassProp("po-stepper-step-bar-bottom", ctx.isVerticalOrientation)("po-stepper-step-bar-right", !ctx.isVerticalOrientation)("po-stepper-step-dashed-border", ctx.nextStatus === "disabled" && !ctx.isVerticalOrientation)("po-stepper-step-dashed-border-vertical", ctx.nextStatus === "disabled" && ctx.isVerticalOrientation);
      ɵɵadvance();
      ɵɵproperty("p-content", ctx.label);
    }
  }, dependencies: [NgClass, PoStepperCircleComponent, PoStepperLabelComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperStepComponent, [{
    type: Component,
    args: [{ selector: "po-stepper-step", template: `<div class="po-stepper-step" [ngClass]="getStatusClass(status)" (click)="onClick()" (keydown.enter)="onEnter()">
  <div class="po-stepper-step-container" [style.width.px]="isVerticalOrientation ? stepSize : undefined">
    <div
      [class.po-stepper-step-bar-top]="isVerticalOrientation"
      [class.po-stepper-step-bar-left]="!isVerticalOrientation"
      [style.margin-right.px]="marginHorizontalBar"
    ></div>

    <po-stepper-circle [p-content]="circleContent" [p-icons]="stepIcons" [p-size]="stepSize" [p-status]="status">
    </po-stepper-circle>

    <div
      [class.po-stepper-step-bar-bottom]="isVerticalOrientation"
      [class.po-stepper-step-bar-right]="!isVerticalOrientation"
      [class.po-stepper-step-dashed-border]="nextStatus === 'disabled' && !isVerticalOrientation"
      [class.po-stepper-step-dashed-border-vertical]="nextStatus === 'disabled' && isVerticalOrientation"
      [style.margin-left.px]="marginHorizontalBar"
    ></div>
  </div>

  <po-stepper-label class="po-stepper-step-label-position" [p-content]="label"> </po-stepper-label>
</div>
` }]
  }], null, { circleContent: [{
    type: Input,
    args: ["p-circle-content"]
  }], orientation: [{
    type: Input,
    args: ["p-orientation"]
  }], nextStatus: [{
    type: Input,
    args: ["p-next-status"]
  }], activated: [{
    type: Output,
    args: ["p-activated"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], enter: [{
    type: Output,
    args: ["p-enter"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], status: [{
    type: Input,
    args: ["p-status"]
  }], stepIcons: [{
    type: Input,
    args: ["p-step-icons"]
  }], stepSize: [{
    type: Input,
    args: ["p-step-size"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperStepComponent, { className: "PoStepperStepComponent", filePath: "lib/components/po-stepper/po-stepper-step/po-stepper-step.component.ts", lineNumber: 27 });
})();
function PoStepperComponent_po_stepper_step_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-stepper-step", 3);
    ɵɵlistener("p-activated", function PoStepperComponent_po_stepper_step_2_Template_po_stepper_step_p_activated_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const step_r2 = restoredCtx.$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onStepActive(step_r2));
    })("p-click", function PoStepperComponent_po_stepper_step_2_Template_po_stepper_step_p_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const index_r3 = restoredCtx.index;
      const step_r2 = restoredCtx.$implicit;
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.changeStep(index_r3, step_r2));
    })("p-enter", function PoStepperComponent_po_stepper_step_2_Template_po_stepper_step_p_enter_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r5);
      const index_r3 = restoredCtx.index;
      const step_r2 = restoredCtx.$implicit;
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.changeStep(index_r3, step_r2));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r0 = ɵɵnextContext();
    let tmp_6_0;
    ɵɵproperty("p-circle-content", index_r3 + 1)("p-label", step_r2.label)("p-orientation", ctx_r0.orientation)("p-status", step_r2.status)("p-step-icons", ctx_r0.stepIcons)("p-step-size", ctx_r0.stepSize)("p-next-status", (tmp_6_0 = ctx_r0.poSteps.get(index_r3 + 1)) == null ? null : tmp_6_0.status);
  }
}
function PoStepperComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
}
var _c0$7 = ["*"];
var PoStepperComponent = class _PoStepperComponent extends PoStepperBaseComponent {
  changeDetector;
  poSteps;
  currentActiveStep;
  get currentStepIndex() {
    return this.step - 1;
  }
  get stepList() {
    return this.usePoSteps && this.poSteps || this.steps;
  }
  get usePoSteps() {
    return !!this.poSteps.length;
  }
  constructor(changeDetector) {
    super();
    this.changeDetector = changeDetector;
  }
  ngAfterContentInit() {
    this.activeFirstStep();
    this.poSteps.changes.subscribe(() => {
      this.controlStepsStatus(0, this.poSteps.first);
    });
  }
  /**
   * Altera o status do *step* para ativo.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   *
   * @param {number} index Índice do `po-step` que se deseja ativar.
   */
  active(index) {
    if (!this.usePoSteps) {
      return;
    }
    const stepsArray = this.getPoSteps();
    const step = stepsArray[index];
    this.changeStep(index, step);
  }
  /**
   * Ativa o primeiro *step*.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   */
  first() {
    if (!this.usePoSteps) {
      return;
    }
    const firstStep = this.poSteps.first;
    const firstStepIndex = 0;
    this.changeStep(firstStepIndex, firstStep);
  }
  /**
   * Ativa o próximo *step*.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   */
  next() {
    if (!this.usePoSteps) {
      return;
    }
    const { steps, stepIndex } = this.getStepsAndIndex(this.currentActiveStep);
    const nextIndex = stepIndex + 1;
    const nextStep = steps[nextIndex];
    this.changeStep(nextIndex, nextStep);
  }
  /**
   * Ativa o *step* anterior.
   *
   * > Este método é valido apenas para as implementações que utilizam o componente [**po-step**](/documentation/po-step).
   */
  previous() {
    if (!this.usePoSteps) {
      return;
    }
    const { steps, stepIndex } = this.getStepsAndIndex(this.currentActiveStep);
    const previousIndex = stepIndex - 1;
    const previousStep = steps[previousIndex];
    this.changeStep(previousIndex, previousStep);
  }
  changeStep(stepIndex, step) {
    this.allowNextStep(stepIndex).pipe(take(1)).subscribe((nextStepAllowed) => {
      if (nextStepAllowed) {
        const isDifferentStep = !this.currentActiveStep || step.id !== this.currentActiveStep.id;
        if (this.usePoSteps && isDifferentStep) {
          this.controlStepsStatus(stepIndex, step);
          this.onChangeStep.emit(step);
        } else if (!this.usePoSteps && stepIndex !== this.currentStepIndex) {
          this.onChangeStep.emit(stepIndex + 1);
        }
      }
    });
  }
  onStepActive(step) {
    this.currentActiveStep = step;
    const { stepIndex } = this.getStepsAndIndex(this.currentActiveStep);
    this.poSteps.forEach((stepChild, i) => {
      if (i < stepIndex) {
        stepChild.status = PoStepperStatus.Done;
      }
    });
  }
  trackByFn(step) {
    return step.id;
  }
  activeFirstStep() {
    const hasStepActive = this.poSteps.some((poStep) => poStep.status === PoStepperStatus.Active);
    if (this.usePoSteps && !hasStepActive) {
      this.changeStep(0, this.poSteps.first);
    }
  }
  allowNextStep(nextStepIndex) {
    if (!this.sequential) {
      return of(true);
    }
    const isAllowNextStep$ = this.usePoSteps ? this.isBeforeStep(nextStepIndex) || this.canActiveNextStep(this.currentActiveStep) : this.steps.slice(this.step, nextStepIndex).every((step) => step.status === PoStepperStatus.Done);
    return typeof isAllowNextStep$ === "boolean" ? of(isAllowNextStep$) : isAllowNextStep$;
  }
  canActiveNextStep(currentActiveStep = {}) {
    if (!currentActiveStep.canActiveNextStep) {
      return of(true);
    }
    const canActiveNextStep = currentActiveStep.canActiveNextStep(currentActiveStep);
    const canActiveNextStep$ = canActiveNextStep instanceof Observable ? canActiveNextStep : of(canActiveNextStep);
    return canActiveNextStep$.pipe(tap((isCanActiveNextStep) => {
      currentActiveStep.status = this.getStepperStatusByCanActive(isCanActiveNextStep);
    }), catchError((err) => {
      currentActiveStep.status = PoStepperStatus.Error;
      return throwError(err);
    }));
  }
  controlStepsStatus(stepIndex, step) {
    if (this.usePoSteps) {
      this.setStepAsActive(step);
      this.setNextStepAsDefault(step);
      if (this.isBeforeStep(stepIndex)) {
        this.setFinalSteppersAsDisabled(stepIndex);
      }
      this.changeDetector.detectChanges();
    }
  }
  getStepperStatusByCanActive(canActiveNextStep) {
    return canActiveNextStep ? PoStepperStatus.Done : PoStepperStatus.Error;
  }
  getStepsAndIndex(step = {}) {
    const steps = this.getPoSteps();
    const stepIndex = steps.findIndex((poStep) => poStep.id === step.id);
    return { steps, stepIndex };
  }
  getPoSteps() {
    return this.poSteps.toArray();
  }
  isBeforeStep(stepIndex) {
    const currentActiveStepIndex = () => this.getPoSteps().findIndex((step) => step.id === this.currentActiveStep.id);
    return !!this.currentActiveStep && currentActiveStepIndex() >= stepIndex;
  }
  setFinalSteppersAsDisabled(stepIndex) {
    this.getPoSteps().filter((step, index) => step && index >= stepIndex + 2).forEach((step) => step.status = PoStepperStatus.Disabled);
  }
  setStepAsActive(step) {
    step.status = PoStepperStatus.Active;
  }
  setNextStepAsDefault(currentStep) {
    const { steps, stepIndex } = this.getStepsAndIndex(currentStep);
    const nextIndex = stepIndex + 1;
    if (nextIndex < this.poSteps.length) {
      steps[nextIndex].status = PoStepperStatus.Default;
    }
  }
  static ɵfac = function PoStepperComponent_Factory(t) {
    return new (t || _PoStepperComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoStepperComponent, selectors: [["po-stepper"]], contentQueries: function PoStepperComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoStepComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.poSteps = _t);
    }
  }, features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$7, decls: 4, vars: 6, consts: [[1, "po-stepper-container"], ["class", "po-stepper-step-position", 3, "p-circle-content", "p-label", "p-orientation", "p-status", "p-step-icons", "p-step-size", "p-next-status", "p-activated", "p-click", "p-enter", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-stepper-content", 4, "ngIf"], [1, "po-stepper-step-position", 3, "p-circle-content", "p-label", "p-orientation", "p-status", "p-step-icons", "p-step-size", "p-next-status", "p-activated", "p-click", "p-enter"], [1, "po-stepper-content"]], template: function PoStepperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div")(1, "div", 0);
      ɵɵtemplate(2, PoStepperComponent_po_stepper_step_2_Template, 1, 7, "po-stepper-step", 1);
      ɵɵelementEnd();
      ɵɵtemplate(3, PoStepperComponent_div_3_Template, 2, 0, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassMapInterpolate1("po-stepper po-stepper-", ctx.orientation, "");
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.stepList)("ngForTrackBy", ctx.trackByFn);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.usePoSteps);
    }
  }, dependencies: [NgForOf, NgIf, PoStepperStepComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperComponent, [{
    type: Component,
    args: [{ selector: "po-stepper", template: '<div class="po-stepper po-stepper-{{ orientation }}">\n  <div class="po-stepper-container">\n    <po-stepper-step\n      *ngFor="let step of stepList; let index = index; trackBy: trackByFn"\n      class="po-stepper-step-position"\n      [p-circle-content]="index + 1"\n      [p-label]="step.label"\n      [p-orientation]="orientation"\n      [p-status]="step.status"\n      [p-step-icons]="stepIcons"\n      [p-step-size]="stepSize"\n      [p-next-status]="poSteps.get(index + 1)?.status"\n      (p-activated)="onStepActive(step)"\n      (p-click)="changeStep(index, step)"\n      (p-enter)="changeStep(index, step)"\n    >\n    </po-stepper-step>\n  </div>\n\n  <div *ngIf="usePoSteps" class="po-stepper-content">\n    <ng-content></ng-content>\n  </div>\n</div>\n' }]
  }], () => [{ type: ChangeDetectorRef }], { poSteps: [{
    type: ContentChildren,
    args: [PoStepComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoStepperComponent, { className: "PoStepperComponent", filePath: "lib/components/po-stepper/po-stepper.component.ts", lineNumber: 41 });
})();
var PoStepperModule = class _PoStepperModule {
  static ɵfac = function PoStepperModule_Factory(t) {
    return new (t || _PoStepperModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoStepperModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoStepperModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [
        PoStepComponent,
        PoStepperCircleComponent,
        PoStepperComponent,
        PoStepperLabelComponent,
        PoStepperStepComponent
      ],
      exports: [PoStepComponent, PoStepperComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoStepperModule, { declarations: [
    PoStepComponent,
    PoStepperCircleComponent,
    PoStepperComponent,
    PoStepperLabelComponent,
    PoStepperStepComponent
  ], imports: [CommonModule], exports: [PoStepComponent, PoStepperComponent] });
})();
var _c0$6 = ["tabButtom"];
var _c1$2 = (a0) => ({ "po-tab-focusable": a0 });
var _c2$1 = (a0, a1) => ({ "po-tab-border-active": a0, "po-tab-border-disabled": a1 });
var PoTabButtonComponent = class _PoTabButtonComponent {
  elementRef;
  changeDetector;
  tabButtom;
  // Desabilita o botão
  disabled;
  // Identificador do componente
  id;
  // Rótulo do botão
  label;
  // Diminui o tamanho do botão
  small;
  // Função sera emitida quando a tab ficar ativada
  activated = new EventEmitter();
  // Função sera emitida quando a tab ficar desabilitada ou escondida
  changeState = new EventEmitter();
  // Método recebido do usuário para ser disparado quando clicar na aba
  click = new EventEmitter();
  _active;
  _hide;
  widthButton;
  // Ativa o botão
  set active(value) {
    this._active = value;
    this.emitActivated();
  }
  get active() {
    return this._active;
  }
  // Oculta o botão
  set hide(value) {
    this._hide = convertToBoolean(value);
    this.setDisplayOnHide();
  }
  get hide() {
    return this._hide;
  }
  constructor(elementRef, changeDetector) {
    this.elementRef = elementRef;
    this.changeDetector = changeDetector;
  }
  ngAfterViewInit() {
    this.widthButton = this.tabButtom.nativeElement.offsetWidth;
    this.changeDetector.detectChanges();
  }
  ngOnChanges(changes) {
    if (changes.hide && changes.hide.currentValue || changes.disabled && changes.disabled.currentValue) {
      this.changeState.emit(this);
    }
  }
  onClick() {
    if (!this.disabled) {
      this.click.emit(this.id);
    }
  }
  emitActivated() {
    if (this.active) {
      this.activated.emit(this);
    }
  }
  setDisplayOnHide() {
    this.elementRef.nativeElement.style.display = this.hide ? "none" : "";
  }
  static ɵfac = function PoTabButtonComponent_Factory(t) {
    return new (t || _PoTabButtonComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTabButtonComponent, selectors: [["po-tab-button"]], viewQuery: function PoTabButtonComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$6, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabButtom = _t.first);
    }
  }, inputs: { disabled: [InputFlags.None, "p-disabled", "disabled"], id: [InputFlags.None, "p-id", "id"], label: [InputFlags.None, "p-label", "label"], small: [InputFlags.None, "p-small", "small"], active: [InputFlags.None, "p-active", "active"], hide: [InputFlags.None, "p-hide", "hide"] }, outputs: { activated: "p-activated", changeState: "p-change-state", click: "p-click" }, features: [ɵɵNgOnChangesFeature], decls: 5, vars: 16, consts: [["role", "tab", "p-tooltip-position", "top", 1, "po-tab-button-default", 3, "p-tooltip", "id", "ngClass", "click", "keyup.enter"], ["tabButtom", ""], [1, "po-tab-button-label", "po-text-ellipsis"], [3, "ngClass"]], template: function PoTabButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("click", function PoTabButtonComponent_Template_div_click_0_listener() {
        return ctx.onClick();
      })("keyup.enter", function PoTabButtonComponent_Template_div_keyup_enter_0_listener() {
        return ctx.onClick();
      });
      ɵɵelementStart(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd()();
      ɵɵelement(4, "div", 3);
    }
    if (rf & 2) {
      ɵɵclassProp("po-tab-button-active", ctx.active)("po-tab-button-disabled", ctx.disabled);
      ɵɵproperty("p-tooltip", ctx.widthButton > 239 ? ctx.label : "")("id", ctx.id)("ngClass", ɵɵpureFunction1(11, _c1$2, !ctx.disabled && !ctx.hide));
      ɵɵattribute("tabindex", ctx.disabled ? null : 0)("aria-selected", ctx.active);
      ɵɵadvance(3);
      ɵɵtextInterpolate1(" ", ctx.label, " ");
      ɵɵadvance();
      ɵɵproperty("ngClass", ɵɵpureFunction2(13, _c2$1, ctx.active, !ctx.active));
    }
  }, dependencies: [NgClass, PoTooltipDirective], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabButtonComponent, [{
    type: Component,
    args: [{ selector: "po-tab-button", template: `<div
  #tabButtom
  role="tab"
  [p-tooltip]="widthButton > 239 ? label : ''"
  p-tooltip-position="top"
  class="po-tab-button-default"
  [id]="id"
  [ngClass]="{ 'po-tab-focusable': !disabled && !hide }"
  [attr.tabindex]="disabled ? null : 0"
  [attr.aria-selected]="active"
  [class.po-tab-button-active]="active"
  [class.po-tab-button-disabled]="disabled"
  (click)="onClick()"
  (keyup.enter)="onClick()"
>
  <span class="po-tab-button-label po-text-ellipsis">
    {{ label }}
  </span>
</div>
<div [ngClass]="{ 'po-tab-border-active': active, 'po-tab-border-disabled': !active }"></div>
` }]
  }], () => [{ type: ElementRef }, { type: ChangeDetectorRef }], { tabButtom: [{
    type: ViewChild,
    args: ["tabButtom", { static: true }]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], id: [{
    type: Input,
    args: ["p-id"]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], small: [{
    type: Input,
    args: ["p-small"]
  }], activated: [{
    type: Output,
    args: ["p-activated"]
  }], changeState: [{
    type: Output,
    args: ["p-change-state"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], active: [{
    type: Input,
    args: ["p-active"]
  }], hide: [{
    type: Input,
    args: ["p-hide"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabButtonComponent, { className: "PoTabButtonComponent", filePath: "lib/components/po-tabs/po-tab-button/po-tab-button.component.ts", lineNumber: 27 });
})();
var PoTabBaseComponent = class _PoTabBaseComponent {
  /** Rótulo da aba. */
  label;
  /** Método disparado ao clicar na aba. */
  click = new EventEmitter();
  // ID da aba
  id = uuid();
  _active = false;
  _disabled = false;
  _hide = false;
  /**
   * @optional
   *
   * @description
   *
   * Ativa a aba exibindo seu conteúdo.
   *
   * > Sugere-se utilizar na aba de conteúdo inicial.
   *
   * @default `false`
   */
  set active(active) {
    this._active = convertToBoolean(active);
    this.setDisplayOnActive();
  }
  get active() {
    return this._active;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita a aba.
   *
   * @default `false`
   */
  set disabled(disabled) {
    this._disabled = convertToBoolean(disabled);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Oculta a aba.
   *
   * @default `false`
   */
  set hide(hide) {
    this._hide = convertToBoolean(hide);
  }
  get hide() {
    return this._hide;
  }
  static ɵfac = function PoTabBaseComponent_Factory(t) {
    return new (t || _PoTabBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTabBaseComponent, inputs: { label: [InputFlags.None, "p-label", "label"], active: [InputFlags.None, "p-active", "active"], disabled: [InputFlags.None, "p-disabled", "disabled"], hide: [InputFlags.None, "p-hide", "hide"] }, outputs: { click: "p-click" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabBaseComponent, [{
    type: Directive
  }], null, { label: [{
    type: Input,
    args: ["p-label"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], active: [{
    type: Input,
    args: ["p-active"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], hide: [{
    type: Input,
    args: ["p-hide"]
  }] });
})();
var PoTabsService = class _PoTabsService {
  onChangesTriggeredSource = new Subject();
  onChangesTriggered$ = this.onChangesTriggeredSource.asObservable();
  triggerOnChanges() {
    this.onChangesTriggeredSource.next();
  }
  static ɵfac = function PoTabsService_Factory(t) {
    return new (t || _PoTabsService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoTabsService, factory: _PoTabsService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsService, [{
    type: Injectable
  }], null, null);
})();
var _c0$5 = ["*"];
var PoTabComponent = class _PoTabComponent extends PoTabBaseComponent {
  elementRef;
  tabsService;
  constructor(elementRef, tabsService) {
    super();
    this.elementRef = elementRef;
    this.tabsService = tabsService;
  }
  ngAfterContentInit() {
    this.setDisplayOnActive();
  }
  ngOnChanges() {
    setTimeout(() => {
      this.tabsService.triggerOnChanges();
    }, 100);
  }
  setDisplayOnActive() {
    this.elementRef.nativeElement.style.display = this.active ? "" : "none";
  }
  static ɵfac = function PoTabComponent_Factory(t) {
    return new (t || _PoTabComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PoTabsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTabComponent, selectors: [["po-tab"]], features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], ngContentSelectors: _c0$5, decls: 1, vars: 0, template: function PoTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  }, encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabComponent, [{
    type: Component,
    args: [{ selector: "po-tab", template: "<ng-content></ng-content>\n" }]
  }], () => [{ type: ElementRef }, { type: PoTabsService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabComponent, { className: "PoTabComponent", filePath: "lib/components/po-tabs/po-tab/po-tab.component.ts", lineNumber: 13 });
})();
var _c0$4 = ["popover"];
var PoTabDropdownComponent = class _PoTabDropdownComponent {
  popover;
  button;
  // Rótulo do `po-tab-button`
  label;
  // Diminui o tamanho do botão
  small;
  // Lista de abas
  tabs = [];
  // Evento que será emitido ao ativar uma aba
  activated = new EventEmitter();
  // Evento que será emitido a aba for desabilitada ou ocultada
  changeState = new EventEmitter();
  // Evento de click
  click = new EventEmitter();
  closeAndReturnToButtom() {
    this.popover.close();
    this.button.focus();
  }
  get buttonElement() {
    return this.button.buttonElement;
  }
  static ɵfac = function PoTabDropdownComponent_Factory(t) {
    return new (t || _PoTabDropdownComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTabDropdownComponent, selectors: [["po-tab-dropdown"]], viewQuery: function PoTabDropdownComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$4, 7);
      ɵɵviewQuery(PoButtonComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popover = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
    }
  }, inputs: { label: [InputFlags.None, "p-label", "label"], small: [InputFlags.None, "p-small", "small"], tabs: [InputFlags.None, "p-tabs", "tabs"] }, outputs: { activated: "p-activated", changeState: "p-change-state", click: "p-click" }, decls: 9, vars: 4, consts: [[1, "po-tab-dropdown-content", "po-tab-button-default"], ["p-kind", "tertiary", "p-icon", "po-icon po-icon-arrow-down", 3, "p-aria-label"], ["button", ""], ["p-hide-arrow", "", "p-position", "bottom", 3, "p-target"], ["popover", ""], [1, "po-tab-dropdown-container"], ["p-type", "action", 3, "p-items", "p-is-tabs", "p-activated-tabs", "p-change-state-tabs", "p-click-tabs", "p-close"], ["listbox", "", "poListBoxRef", ""]], template: function PoTabDropdownComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r4 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0);
      ɵɵelement(1, "po-button", 1, 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "po-popover", 3, 4)(5, "div", 5)(6, "po-listbox", 6, 7);
      ɵɵlistener("p-activated-tabs", function PoTabDropdownComponent_Template_po_listbox_p_activated_tabs_6_listener($event) {
        return ctx.activated.emit($event);
      })("p-change-state-tabs", function PoTabDropdownComponent_Template_po_listbox_p_change_state_tabs_6_listener($event) {
        return ctx.changeState.emit($event);
      })("p-click-tabs", function PoTabDropdownComponent_Template_po_listbox_p_click_tabs_6_listener($event) {
        ɵɵrestoreView(_r4);
        const _r1 = ɵɵreference(4);
        _r1.close();
        return ɵɵresetView(ctx.click.emit($event));
      })("p-close", function PoTabDropdownComponent_Template_po_listbox_p_close_6_listener() {
        return ctx.closeAndReturnToButtom();
      });
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("p-aria-label", ctx.label);
      ɵɵadvance(2);
      ɵɵproperty("p-target", ctx.buttonElement);
      ɵɵadvance(3);
      ɵɵproperty("p-items", ctx.tabs)("p-is-tabs", true);
    }
  }, dependencies: [PoPopoverComponent, PoButtonComponent, PoListBoxComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabDropdownComponent, [{
    type: Component,
    args: [{ selector: "po-tab-dropdown", template: '<div class="po-tab-dropdown-content po-tab-button-default">\n  <po-button #button p-kind="tertiary" [p-aria-label]="label" p-icon="po-icon po-icon-arrow-down"> </po-button>\n</div>\n\n<po-popover #popover p-hide-arrow p-position="bottom" [p-target]="buttonElement">\n  <div class="po-tab-dropdown-container">\n    <po-listbox\n      #listbox\n      #poListBoxRef\n      p-type="action"\n      [p-items]="tabs"\n      [p-is-tabs]="true"\n      (p-activated-tabs)="activated.emit($event)"\n      (p-change-state-tabs)="changeState.emit($event)"\n      (p-click-tabs)="popover.close(); click.emit($event)"\n      (p-close)="closeAndReturnToButtom()"\n    >\n    </po-listbox>\n  </div>\n</po-popover>\n' }]
  }], null, { popover: [{
    type: ViewChild,
    args: ["popover", { static: true }]
  }], button: [{
    type: ViewChild,
    args: [PoButtonComponent, { static: true }]
  }], label: [{
    type: Input,
    args: ["p-label"]
  }], small: [{
    type: Input,
    args: ["p-small"]
  }], tabs: [{
    type: Input,
    args: ["p-tabs"]
  }], activated: [{
    type: Output,
    args: ["p-activated"]
  }], changeState: [{
    type: Output,
    args: ["p-change-state"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabDropdownComponent, { className: "PoTabDropdownComponent", filePath: "lib/components/po-tabs/po-tab-dropdown/po-tab-dropdown.component.ts", lineNumber: 19 });
})();
var PoTabsBaseComponent = class _PoTabsBaseComponent {
  _small = false;
  /**
   * @deprecated 17.x.x
   *
   * @optinal
   *
   * @description
   *
   * Diminui o tamanho das abas.
   *
   * @default `false`
   */
  set small(value) {
    this._small = convertToBoolean(value);
  }
  get small() {
    return this._small;
  }
  static ɵfac = function PoTabsBaseComponent_Factory(t) {
    return new (t || _PoTabsBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTabsBaseComponent, inputs: { small: [InputFlags.None, "p-small", "small"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsBaseComponent, [{
    type: Directive
  }], null, { small: [{
    type: Input,
    args: ["p-small"]
  }] });
})();
var _c0$3 = ["tabDropdown"];
var _c1$1 = ["containerTabs"];
var _c2 = ["tabButton"];
function PoTabsComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "po-tab-button", 7, 8);
    ɵɵlistener("keyup.enter", function PoTabsComponent_ng_container_4_Template_po_tab_button_keyup_enter_1_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.closePopover());
    })("p-activated", function PoTabsComponent_ng_container_4_Template_po_tab_button_p_activated_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r6);
      const tab_r3 = restoredCtx.$implicit;
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.onTabActive(tab_r3));
    })("p-change-state", function PoTabsComponent_ng_container_4_Template_po_tab_button_p_change_state_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r6);
      const tab_r3 = restoredCtx.$implicit;
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.onTabChangeState(tab_r3));
    })("p-click", function PoTabsComponent_ng_container_4_Template_po_tab_button_p_click_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r6);
      const tab_r3 = restoredCtx.$implicit;
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.selectedTab(tab_r3));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tab_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-active", tab_r3.active)("p-disabled", tab_r3.disabled)("p-hide", tab_r3.hide)("p-id", tab_r3.id)("hidden", tab_r3.hide)("p-label", tab_r3.label)("p-small", ctx_r1.small)("id", tab_r3.id);
    ɵɵattribute("disabled", tab_r3.disabled);
  }
}
function PoTabsComponent_po_tab_dropdown_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-tab-dropdown", 9, 10);
    ɵɵlistener("p-activated", function PoTabsComponent_po_tab_dropdown_5_Template_po_tab_dropdown_p_activated_0_listener($event) {
      ɵɵrestoreView(_r12);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.onTabActive($event));
    })("p-change-state", function PoTabsComponent_po_tab_dropdown_5_Template_po_tab_dropdown_p_change_state_0_listener($event) {
      ɵɵrestoreView(_r12);
      const ctx_r13 = ɵɵnextContext();
      return ɵɵresetView(ctx_r13.onTabChangeState($event));
    })("p-click", function PoTabsComponent_po_tab_dropdown_5_Template_po_tab_dropdown_p_click_0_listener($event) {
      ɵɵrestoreView(_r12);
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.selectedTab($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-tab-dropdown-device", !(ctx_r2.tabsDefault == null ? null : ctx_r2.tabsDefault.length));
    ɵɵproperty("p-label", ctx_r2.literals.moreTabs)("p-small", ctx_r2.small)("p-tabs", ctx_r2.overflowedTabs);
  }
}
var _c3 = ["*"];
var poTabsLiterals = {
  en: {
    moreTabs: "More"
  },
  es: {
    moreTabs: "Más"
  },
  pt: {
    moreTabs: "Mais"
  },
  ru: {
    moreTabs: "Ещё"
  }
};
var poTabsMaxNumberOfTabs = 5;
var PoTabsComponent = class _PoTabsComponent extends PoTabsBaseComponent {
  changeDetector;
  languageService;
  tabsService;
  // Tabs utilizados no ng-content
  tabsChildren;
  tabButton;
  tabDropdown;
  containerTabs;
  maxNumberOfTabs = poTabsMaxNumberOfTabs;
  literals;
  tabsDefault = [];
  tabsDropdown = [];
  initializeCalculation = true;
  initializeComponent = false;
  quantityTabsButton;
  previousActiveTab;
  subscription = new Subscription();
  subscriptionTabsService = new Subscription();
  constructor(changeDetector, languageService, tabsService) {
    super();
    this.changeDetector = changeDetector;
    this.languageService = languageService;
    this.tabsService = tabsService;
    const language = languageService.getShortLanguage();
    this.literals = __spreadValues({}, poTabsLiterals[language]);
  }
  ngOnInit() {
    this.subscriptionTabsService = this.tabsService.onChangesTriggered$.subscribe(() => {
      if (this.initializeComponent) {
        this.handleKeyboardNavigationTab();
      }
    });
  }
  ngAfterViewInit() {
    this.calculateTabs(this.initializeCalculation);
    this.initializeCalculation = false;
    this.changeDetector.detectChanges();
    this.handleKeyboardNavigationTab();
    this.initializeComponent = true;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.subscriptionTabsService.unsubscribe();
  }
  get isShowTabDropdown() {
    return this.tabsChildren["_results"].slice(this.quantityTabsButton).filter((item) => !item.hide).length;
  }
  // tabs que serão apresentadas na aba "Mais"
  get overflowedTabs() {
    return this.tabsChildren["_results"].slice(this.quantityTabsButton);
  }
  get tabs() {
    return this.tabsChildren["_results"].slice(0, this.quantityTabsButton);
  }
  closePopover() {
    const containsPopoverVisible = this.tabDropdown && this.tabDropdown.popover && !this.tabDropdown.popover.isHidden;
    if (containsPopoverVisible) {
      this.tabDropdown.popover.close();
    }
  }
  isVisibleTab(tab) {
    return !tab.hide;
  }
  // Função disparada quando alguma tab ficar ativa
  onTabActive(tab) {
    this.previousActiveTab = this.tabsChildren.find((tabChild) => tabChild.active && tabChild.id !== tab.id);
    this.deactivateTab();
  }
  // funcao será disparada quando mudar o estado do poTab para desabilitado ou escondido.
  onTabChangeState(tab) {
    if (tab.active) {
      tab.active = false;
      this.activeDistinctTab();
      this.changeDetector.detectChanges();
    }
  }
  // selectiona a aba informada por parametro, caso houver click faz a emição do evento.
  selectedTab(tab) {
    tab.active = true;
    if (tab.click) {
      tab.click.emit(tab);
    }
    this.changeDetector.detectChanges();
  }
  trackByFn(_i, tab) {
    return tab.id;
  }
  // ativa a previousActiveTab ou primeira tab encontrada.
  activeDistinctTab() {
    if (this.previousActiveTab) {
      this.previousActiveTab.active = true;
    } else {
      this.activeFirstTab();
    }
  }
  // Ativa a primeira Tab que não estiver desabilitada ou escondida.
  activeFirstTab() {
    this.tabs.some((tabChild) => {
      if (!tabChild.disabled && !tabChild.hide) {
        tabChild.active = true;
        return true;
      }
    });
  }
  // desativa previousActiveTab e dispara a detecção de mudança.
  deactivateTab() {
    if (this.previousActiveTab) {
      this.previousActiveTab.active = false;
      this.changeDetector.detectChanges();
    }
  }
  calculateTabs(initializeCalculation) {
    if (initializeCalculation) {
      let sumOfWidth = 150;
      const screenSize = this.containerTabs.nativeElement.offsetWidth;
      const listTabButton = [];
      if (this.tabButton?.length) {
        this.tabButton.forEach((element) => {
          const width = element.nativeElement.offsetWidth;
          if (sumOfWidth + width <= screenSize || screenSize < 1) {
            listTabButton.push(element);
          }
          sumOfWidth += width;
        });
      }
      this.quantityTabsButton = listTabButton.length;
    }
  }
  handleKeyboardNavigationTab(initialIndex = 0) {
    this.subscription.unsubscribe();
    this.subscription = new Subscription();
    if (this.tabButton?.length) {
      const tabFocusable = this.tabButton.filter((element, index) => element.nativeElement.children[0]?.id === this.tabsChildren["_results"][index]?.id).map((el) => {
        if (el.nativeElement.children[0].classList.contains("po-tab-focusable")) {
          return el.nativeElement.children[0];
        }
      }).filter(Boolean);
      if (tabFocusable) {
        this.initializeTabAccessibilityElements(tabFocusable, initialIndex);
      }
    }
  }
  /**
   * Função que atribui o número de tabs fora do dropdown.
   *
   * Para utilizá-la é necessário ter a instância do componente no DOM, podendo ser utilizado o ViewChild da seguinte forma:
   *
   * ```
   * import { PoTabsComponent } from '@po-ui/ng-components';
   *
   * ...
   *
   * @ViewChild('poTab', { static: true }) poTab: PoTabsComponent;
   *
   * changeQuantityTabs() {
   *   this.poTab.setQuantityTabsButton(1); //Número de tabs
   * }
   * ```
   */
  setQuantityTabsButton(number) {
    this.quantityTabsButton = number;
  }
  initializeTabAccessibilityElements(tabRemoveElements, initialIndex) {
    tabRemoveElements.forEach((tabRemoveElement, index) => {
      if (index === initialIndex) {
        this.setTabIndex(tabRemoveElements[initialIndex], 0);
      } else if (tabRemoveElements.length === initialIndex) {
        this.setTabIndex(tabRemoveElements[initialIndex - 1], 0);
      } else {
        this.setTabIndex(tabRemoveElement, -1);
      }
      this.subscription.add(fromEvent(tabRemoveElement, "keydown").subscribe((event) => {
        this.handleKeyDown(event, tabRemoveElements, index);
      }));
      if (index !== 0) {
        this.subscription.add(fromEvent(tabRemoveElements, "blur").subscribe(() => {
          this.setTabIndex(tabRemoveElements[index], -1);
          this.setTabIndex(tabRemoveElements[0], 0);
        }));
      }
    });
  }
  setTabIndex(element, tabIndex) {
    element.setAttribute("tabindex", tabIndex);
  }
  handleKeyDown(event, tabRemoveElements, index) {
    const KEY_SPACE = "Space";
    const KEY_ARROW_LEFT = "ArrowLeft";
    const KEY_ARROW_RIGHT = "ArrowRight";
    const KEY_HOME = "Home";
    const KEY_END = "End";
    if (event.code === KEY_SPACE || event.code === KEY_HOME || event.code === KEY_END) {
      event.preventDefault();
      event.stopPropagation();
    }
    if (event.key === KEY_ARROW_LEFT) {
      this.handleArrowLeft(tabRemoveElements, index);
    } else if (event.key === KEY_ARROW_RIGHT) {
      this.handleArrowRight(tabRemoveElements, index);
    } else if (event.key === KEY_HOME) {
      this.handleHomeKey(tabRemoveElements, index);
    } else if (event.key === KEY_END) {
      this.handleEndKey(tabRemoveElements, index);
    }
  }
  handleArrowLeft(tabRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[index - 1].focus();
      this.setTabIndex(tabRemoveElements[index - 1], 0);
    } else {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[tabRemoveElements.length - 1].focus();
      this.setTabIndex(tabRemoveElements[tabRemoveElements.length - 1], 0);
    }
  }
  handleHomeKey(tabRemoveElements, index) {
    if (index > 0) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[0].focus();
      this.setTabIndex(tabRemoveElements[0], 0);
    }
  }
  handleEndKey(tabRemoveElements, index) {
    if (index < tabRemoveElements.length - 1) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[tabRemoveElements.length - 1].focus();
      this.setTabIndex(tabRemoveElements[tabRemoveElements.length - 1], 0);
    }
  }
  handleArrowRight(tabRemoveElements, index) {
    if (index < tabRemoveElements.length - 1) {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[index + 1].focus();
      this.setTabIndex(tabRemoveElements[index + 1], 0);
    } else {
      this.setTabIndex(tabRemoveElements[index], -1);
      tabRemoveElements[0].focus();
      this.setTabIndex(tabRemoveElements[0], 0);
    }
  }
  static ɵfac = function PoTabsComponent_Factory(t) {
    return new (t || _PoTabsComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PoLanguageService), ɵɵdirectiveInject(PoTabsService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTabsComponent, selectors: [["po-tabs"]], contentQueries: function PoTabsComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PoTabComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabsChildren = _t);
    }
  }, viewQuery: function PoTabsComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$3, 7);
      ɵɵviewQuery(_c1$1, 7, ElementRef);
      ɵɵviewQuery(_c2, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabDropdown = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerTabs = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabButton = _t);
    }
  }, features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c3, decls: 8, vars: 3, consts: [[1, "po-tabs-container"], [1, "po-tabs-header"], ["containerTabs", ""], ["role", "tablist", 1, "po-tabs-button-wrapper"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "po-tab-dropdown", 3, "po-tab-dropdown-device", "p-label", "p-small", "p-tabs", "p-activated", "p-change-state", "p-click", 4, "ngIf"], [1, "po-tabs-content"], [1, "po-tab-button", 3, "p-active", "p-disabled", "p-hide", "p-id", "hidden", "p-label", "p-small", "id", "keyup.enter", "p-activated", "p-change-state", "p-click"], ["tabButton", ""], [1, "po-tab-dropdown", 3, "p-label", "p-small", "p-tabs", "p-activated", "p-change-state", "p-click"], ["tabDropdown", ""]], template: function PoTabsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1, 2)(3, "div", 3);
      ɵɵtemplate(4, PoTabsComponent_ng_container_4_Template, 3, 9, "ng-container", 4)(5, PoTabsComponent_po_tab_dropdown_5_Template, 2, 5, "po-tab-dropdown", 5);
      ɵɵelementEnd()()();
      ɵɵelementStart(6, "div", 6);
      ɵɵprojection(7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("ngForOf", ctx.tabs)("ngForTrackBy", ctx.trackByFn);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isShowTabDropdown);
    }
  }, dependencies: [NgForOf, NgIf, PoTabButtonComponent, PoTabDropdownComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsComponent, [{
    type: Component,
    args: [{ selector: "po-tabs", template: '<div class="po-tabs-container">\n  <div #containerTabs class="po-tabs-header">\n    <div class="po-tabs-button-wrapper" role="tablist">\n      <ng-container *ngFor="let tab of tabs; trackBy: trackByFn">\n        <po-tab-button\n          #tabButton\n          class="po-tab-button"\n          [p-active]="tab.active"\n          [p-disabled]="tab.disabled"\n          [p-hide]="tab.hide"\n          [p-id]="tab.id"\n          [hidden]="tab.hide"\n          [attr.disabled]="tab.disabled"\n          [p-label]="tab.label"\n          [p-small]="small"\n          [id]="tab.id"\n          (keyup.enter)="closePopover()"\n          (p-activated)="onTabActive(tab)"\n          (p-change-state)="onTabChangeState(tab)"\n          (p-click)="selectedTab(tab)"\n        >\n        </po-tab-button>\n      </ng-container>\n\n      <po-tab-dropdown\n        #tabDropdown\n        *ngIf="isShowTabDropdown"\n        class="po-tab-dropdown"\n        [class.po-tab-dropdown-device]="!tabsDefault?.length"\n        [p-label]="literals.moreTabs"\n        [p-small]="small"\n        [p-tabs]="overflowedTabs"\n        (p-activated)="onTabActive($event)"\n        (p-change-state)="onTabChangeState($event)"\n        (p-click)="selectedTab($event)"\n      >\n      </po-tab-dropdown>\n    </div>\n  </div>\n</div>\n<div class="po-tabs-content">\n  <ng-content></ng-content>\n</div>\n' }]
  }], () => [{ type: ChangeDetectorRef }, { type: PoLanguageService }, { type: PoTabsService }], { tabsChildren: [{
    type: ContentChildren,
    args: [PoTabComponent]
  }], tabButton: [{
    type: ViewChildren,
    args: ["tabButton", { read: ElementRef }]
  }], tabDropdown: [{
    type: ViewChild,
    args: ["tabDropdown", { static: true }]
  }], containerTabs: [{
    type: ViewChild,
    args: ["containerTabs", { read: ElementRef, static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTabsComponent, { className: "PoTabsComponent", filePath: "lib/components/po-tabs/po-tabs.component.ts", lineNumber: 68 });
})();
var PoTabsModule = class _PoTabsModule {
  static ɵfac = function PoTabsModule_Factory(t) {
    return new (t || _PoTabsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoTabsModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoTabsService], imports: [CommonModule, PoPopoverModule, PoDropdownModule, PoTooltipModule, PoButtonModule, PoListBoxModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTabsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoPopoverModule, PoDropdownModule, PoTooltipModule, PoButtonModule, PoListBoxModule],
      declarations: [PoTabButtonComponent, PoTabComponent, PoTabDropdownComponent, PoTabsComponent],
      exports: [PoTabComponent, PoTabsComponent],
      providers: [PoTabsService]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTabsModule, { declarations: [PoTabButtonComponent, PoTabComponent, PoTabDropdownComponent, PoTabsComponent], imports: [CommonModule, PoPopoverModule, PoDropdownModule, PoTooltipModule, PoButtonModule, PoListBoxModule], exports: [PoTabComponent, PoTabsComponent] });
})();
var poToolbarActionsIconDefault = "po-icon-more";
var PoToolbarActionsComponent = class _PoToolbarActionsComponent {
  /** Define uma lista de ações. */
  actions;
  _actionsIcon = poToolbarActionsIconDefault;
  /** Define o ícone das ações. */
  set actionsIcon(icon) {
    this._actionsIcon = isTypeof(icon, "string") || icon instanceof TemplateRef ? icon : poToolbarActionsIconDefault;
  }
  get actionsIcon() {
    return this._actionsIcon;
  }
  static ɵfac = function PoToolbarActionsComponent_Factory(t) {
    return new (t || _PoToolbarActionsComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoToolbarActionsComponent, selectors: [["po-toolbar-actions"]], inputs: { actions: [InputFlags.None, "p-actions", "actions"], actionsIcon: [InputFlags.None, "p-actions-icon", "actionsIcon"] }, decls: 6, vars: 3, consts: [[1, "po-toolbar-actions", 3, "click"], ["toolbarActions", ""], [1, "po-toolbar-icon", "po-clickable", 3, "p-icon"], [3, "p-actions", "p-target"], ["popup", ""]], template: function PoToolbarActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r2 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoToolbarActionsComponent_Template_div_click_0_listener() {
        ɵɵrestoreView(_r2);
        const _r1 = ɵɵreference(5);
        return ɵɵresetView(_r1.toggle());
      });
      ɵɵelementStart(1, "span", null, 1);
      ɵɵelement(3, "po-icon", 2);
      ɵɵelementEnd()();
      ɵɵelement(4, "po-popup", 3, 4);
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(2);
      ɵɵadvance(3);
      ɵɵproperty("p-icon", ctx.actionsIcon);
      ɵɵadvance();
      ɵɵproperty("p-actions", ctx.actions)("p-target", _r0);
    }
  }, dependencies: [PoPopupComponent, PoIconComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarActionsComponent, [{
    type: Component,
    args: [{ selector: "po-toolbar-actions", template: '<div class="po-toolbar-actions" (click)="popup.toggle()">\n  <span #toolbarActions>\n    <po-icon class="po-toolbar-icon po-clickable" [p-icon]="actionsIcon"></po-icon>\n  </span>\n</div>\n\n<po-popup #popup [p-actions]="actions" [p-target]="toolbarActions"> </po-popup>\n' }]
  }], null, { actions: [{
    type: Input,
    args: ["p-actions"]
  }], actionsIcon: [{
    type: Input,
    args: ["p-actions-icon"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarActionsComponent, { className: "PoToolbarActionsComponent", filePath: "lib/components/po-toolbar/po-toolbar-actions/po-toolbar-actions.component.ts", lineNumber: 22 });
})();
var PoToolbarBaseComponent = class _PoToolbarBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Define uma lista de ações que serão exibidas ao clicar no ícone declarado em `p-actions-icon`.
   */
  actions;
  /**
   * @optional
   *
   * @description
   *
   * Define um [ícone](/guides/icons) para a propriedade `p-actions`.
   *
   * É possível usar qualquer um dos ícones da [Biblioteca de ícones](/guides/icons). conforme exemplo abaixo:
   * ```
   * <po-toolbar p-actions-icon="po-icon-user" [p-actions]="actions"></po-toolbar>
   * ```
   * Também é possível utilizar outras fontes de ícones, por exemplo a biblioteca *Font Awesome*, da seguinte forma:
   * ```
   * <po-toolbar p-actions-icon="far fa-comment-alt" [p-actions]="actions"></po-toolbar>
   * ```
   * Outra opção seria a customização do ícone através do `TemplateRef`, conforme exemplo abaixo:
   * ```
   * <po-toolbar [p-actions-icon]="template" [p-actions]="actions"></po-toolbar>
   *
   * <ng-template #template>
   *  <ion-icon style="font-size: inherit" name="heart"></ion-icon>
   * </ng-template>
   * ```
   * > Para o ícone enquadrar corretamente, deve-se utilizar `font-size: inherit` caso o ícone utilizado não aplique-o.
   *
   * > Caso não haja ações definidas em `p-actions`, o ícone não será exibido.
   *
   * @default `po-icon-more`
   */
  actionsIcon;
  /** Define o objeto que será o cabeçalho da lista de ações com as informações do perfil. */
  profile;
  /** Define uma lista de ações que serão exibidas ao clicar no ícone do perfil. */
  profileActions;
  /** Se falso, oculta o ícone de notificações. */
  showNotification = true;
  /** Título do *toolbar* e aplicação. */
  title;
  /**
   * @optional
   *
   * @description
   *
   * Lista de ações da notificação.
   */
  notificationActions;
  _notificationNumber;
  /**
   * @optional
   *
   * @description
   *
   * Número de notificações.
   */
  set notificationNumber(value) {
    this._notificationNumber = convertToInt(value, 0);
  }
  get notificationNumber() {
    return this._notificationNumber;
  }
  get isShowProfile() {
    return !!(this.profile || this.profileActions);
  }
  static ɵfac = function PoToolbarBaseComponent_Factory(t) {
    return new (t || _PoToolbarBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoToolbarBaseComponent, inputs: { actions: [InputFlags.None, "p-actions", "actions"], actionsIcon: [InputFlags.None, "p-actions-icon", "actionsIcon"], profile: [InputFlags.None, "p-profile", "profile"], profileActions: [InputFlags.None, "p-profile-actions", "profileActions"], showNotification: [InputFlags.None, "p-show-notification", "showNotification"], title: [InputFlags.None, "p-title", "title"], notificationActions: [InputFlags.None, "p-notification-actions", "notificationActions"], notificationNumber: [InputFlags.None, "p-notification-number", "notificationNumber"] } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarBaseComponent, [{
    type: Directive
  }], null, { actions: [{
    type: Input,
    args: ["p-actions"]
  }], actionsIcon: [{
    type: Input,
    args: ["p-actions-icon"]
  }], profile: [{
    type: Input,
    args: ["p-profile"]
  }], profileActions: [{
    type: Input,
    args: ["p-profile-actions"]
  }], showNotification: [{
    type: Input,
    args: ["p-show-notification"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }], notificationActions: [{
    type: Input,
    args: ["p-notification-actions"]
  }], notificationNumber: [{
    type: Input,
    args: ["p-notification-number"]
  }] });
})();
function PoToolbarNotificationComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.notificationNumber, " ");
  }
}
var PoToolbarNotificationComponent = class _PoToolbarNotificationComponent {
  /** Define uma lista de ações. */
  notificationActions;
  _notificationNumber = 0;
  /** Define o número de notificações. */
  set notificationNumber(value) {
    this._notificationNumber = Number.isInteger(value) ? value : 0;
  }
  get notificationNumber() {
    return this._notificationNumber;
  }
  static ɵfac = function PoToolbarNotificationComponent_Factory(t) {
    return new (t || _PoToolbarNotificationComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoToolbarNotificationComponent, selectors: [["po-toolbar-notification"]], inputs: { notificationActions: [InputFlags.None, "p-notification-actions", "notificationActions"], notificationNumber: [InputFlags.None, "p-notification-number", "notificationNumber"] }, features: [ɵɵProvidersFeature([PoControlPositionService])], decls: 6, vars: 3, consts: [[1, "po-toolbar-notification", "po-clickable", 3, "click"], [1, "po-icon", "po-icon-notification", "po-toolbar-icon"], ["notification", ""], ["class", "po-toolbar-notification-badge", 4, "ngIf"], [3, "p-actions", "p-target"], ["popup", ""], [1, "po-toolbar-notification-badge"]], template: function PoToolbarNotificationComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r3 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoToolbarNotificationComponent_Template_div_click_0_listener() {
        ɵɵrestoreView(_r3);
        const _r2 = ɵɵreference(5);
        return ɵɵresetView(_r2.toggle());
      });
      ɵɵelement(1, "span", 1, 2);
      ɵɵtemplate(3, PoToolbarNotificationComponent_div_3_Template, 2, 1, "div", 3);
      ɵɵelementEnd();
      ɵɵelement(4, "po-popup", 4, 5);
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(2);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.notificationNumber);
      ɵɵadvance();
      ɵɵproperty("p-actions", ctx.notificationActions)("p-target", _r0);
    }
  }, dependencies: [NgIf, PoPopupComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarNotificationComponent, [{
    type: Component,
    args: [{ selector: "po-toolbar-notification", providers: [PoControlPositionService], template: '<div class="po-toolbar-notification po-clickable" (click)="popup.toggle()">\n  <span #notification class="po-icon po-icon-notification po-toolbar-icon"></span>\n  <div *ngIf="notificationNumber" class="po-toolbar-notification-badge">\n    {{ notificationNumber }}\n  </div>\n</div>\n\n<po-popup #popup [p-actions]="notificationActions" [p-target]="notification"> </po-popup>\n' }]
  }], null, { notificationActions: [{
    type: Input,
    args: ["p-notification-actions"]
  }], notificationNumber: [{
    type: Input,
    args: ["p-notification-number"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarNotificationComponent, { className: "PoToolbarNotificationComponent", filePath: "lib/components/po-toolbar/po-toolbar-notification/po-toolbar-notification.component.ts", lineNumber: 25 });
})();
function PoToolbarProfileComponent_div_5_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r3.profile.subtitle, " ");
  }
}
function PoToolbarProfileComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "po-avatar", 7);
    ɵɵelementStart(2, "div")(3, "div", 8);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵtemplate(5, PoToolbarProfileComponent_div_5_div_5_Template, 2, 1, "div", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-src", ctx_r2.profileAvatar);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r2.profile.title, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.profile.subtitle);
  }
}
var PoToolbarProfileComponent = class _PoToolbarProfileComponent {
  /** Objeto que implementa a interface `PoToolbarProfile`. */
  profile;
  /** Define uma lista de ações. */
  profileActions;
  get profileAvatar() {
    return this.profile ? this.profile.avatar : void 0;
  }
  static ɵfac = function PoToolbarProfileComponent_Factory(t) {
    return new (t || _PoToolbarProfileComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoToolbarProfileComponent, selectors: [["po-toolbar-profile"]], inputs: { profile: [InputFlags.None, "p-profile", "profile"], profileActions: [InputFlags.None, "p-profile-actions", "profileActions"] }, features: [ɵɵProvidersFeature([PoControlPositionService])], decls: 6, vars: 4, consts: [[1, "po-toolbar-profile", "po-clickable", 3, "click"], ["profileElement", ""], ["p-size", "xs", 3, "p-src"], [3, "p-actions", "p-target"], ["popup", ""], ["p-popup-header-template", "", "class", "po-toolbar-profile-item-header", 4, "ngIf"], ["p-popup-header-template", "", 1, "po-toolbar-profile-item-header"], ["p-size", "sm", 1, "po-toolbar-profile-item-avatar", 3, "p-src"], [1, "po-toolbar-profile-item-header-title"], ["class", "po-toolbar-profile-item-header-subtitle", 4, "ngIf"], [1, "po-toolbar-profile-item-header-subtitle"]], template: function PoToolbarProfileComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r4 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("click", function PoToolbarProfileComponent_Template_div_click_0_listener() {
        ɵɵrestoreView(_r4);
        const _r1 = ɵɵreference(4);
        return ɵɵresetView(_r1.toggle());
      });
      ɵɵelement(2, "po-avatar", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "po-popup", 3, 4);
      ɵɵtemplate(5, PoToolbarProfileComponent_div_5_Template, 6, 3, "div", 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r0 = ɵɵreference(1);
      ɵɵadvance(2);
      ɵɵproperty("p-src", ctx.profileAvatar);
      ɵɵadvance();
      ɵɵproperty("p-actions", ctx.profileActions)("p-target", _r0);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.profile == null ? null : ctx.profile.title);
    }
  }, dependencies: [NgIf, PoAvatarComponent, PoPopupComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarProfileComponent, [{
    type: Component,
    args: [{ selector: "po-toolbar-profile", providers: [PoControlPositionService], template: '<div #profileElement class="po-toolbar-profile po-clickable" (click)="popup.toggle()">\n  <po-avatar p-size="xs" [p-src]="profileAvatar"></po-avatar>\n</div>\n\n<po-popup #popup [p-actions]="profileActions" [p-target]="profileElement">\n  <div p-popup-header-template *ngIf="profile?.title" class="po-toolbar-profile-item-header">\n    <po-avatar class="po-toolbar-profile-item-avatar" p-size="sm" [p-src]="profileAvatar"> </po-avatar>\n\n    <div>\n      <div class="po-toolbar-profile-item-header-title">\n        {{ profile.title }}\n      </div>\n\n      <div *ngIf="profile.subtitle" class="po-toolbar-profile-item-header-subtitle">\n        {{ profile.subtitle }}\n      </div>\n    </div>\n  </div>\n</po-popup>\n' }]
  }], null, { profile: [{
    type: Input,
    args: ["p-profile"]
  }], profileActions: [{
    type: Input,
    args: ["p-profile-actions"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarProfileComponent, { className: "PoToolbarProfileComponent", filePath: "lib/components/po-toolbar/po-toolbar-profile/po-toolbar-profile.component.ts", lineNumber: 22 });
})();
function PoToolbarComponent_po_toolbar_actions_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-toolbar-actions", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("p-actions", ctx_r0.actions)("p-actions-icon", ctx_r0.actionsIcon);
  }
}
function PoToolbarComponent_po_toolbar_notification_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-toolbar-notification", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("p-notification-actions", ctx_r1.notificationActions)("p-notification-number", ctx_r1.notificationNumber);
  }
}
function PoToolbarComponent_po_toolbar_profile_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-toolbar-profile", 8);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("p-profile", ctx_r2.profile)("p-profile-actions", ctx_r2.profileActions);
  }
}
var PoToolbarComponent = class _PoToolbarComponent extends PoToolbarBaseComponent {
  titleService;
  constructor(titleService, viewRef) {
    super();
    this.titleService = titleService;
  }
  ngOnInit() {
    this.setTitle(this.title);
  }
  setTitle(newTitle) {
    this.titleService.setTitle(newTitle);
  }
  static ɵfac = function PoToolbarComponent_Factory(t) {
    return new (t || _PoToolbarComponent)(ɵɵdirectiveInject(Title), ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoToolbarComponent, selectors: [["po-toolbar"]], features: [ɵɵInheritDefinitionFeature], decls: 7, vars: 4, consts: [[1, "po-toolbar"], [1, "po-toolbar-title"], [1, "po-toolbar-group-icon"], [3, "p-actions", "p-actions-icon", 4, "ngIf"], [3, "p-notification-actions", "p-notification-number", 4, "ngIf"], [3, "p-profile", "p-profile-actions", 4, "ngIf"], [3, "p-actions", "p-actions-icon"], [3, "p-notification-actions", "p-notification-number"], [3, "p-profile", "p-profile-actions"]], template: function PoToolbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2);
      ɵɵtemplate(4, PoToolbarComponent_po_toolbar_actions_4_Template, 1, 2, "po-toolbar-actions", 3)(5, PoToolbarComponent_po_toolbar_notification_5_Template, 1, 2, "po-toolbar-notification", 4)(6, PoToolbarComponent_po_toolbar_profile_6_Template, 1, 2, "po-toolbar-profile", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.title);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.actions && ctx.actions.length);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showNotification && ctx.notificationActions);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isShowProfile);
    }
  }, dependencies: [NgIf, PoToolbarActionsComponent, PoToolbarNotificationComponent, PoToolbarProfileComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarComponent, [{
    type: Component,
    args: [{ selector: "po-toolbar", template: '<div class="po-toolbar">\n  <div class="po-toolbar-title">{{ title }}</div>\n\n  <div class="po-toolbar-group-icon">\n    <po-toolbar-actions *ngIf="actions && actions.length" [p-actions]="actions" [p-actions-icon]="actionsIcon">\n    </po-toolbar-actions>\n\n    <po-toolbar-notification\n      *ngIf="showNotification && notificationActions"\n      [p-notification-actions]="notificationActions"\n      [p-notification-number]="notificationNumber"\n    >\n    </po-toolbar-notification>\n\n    <po-toolbar-profile *ngIf="isShowProfile" [p-profile]="profile" [p-profile-actions]="profileActions">\n    </po-toolbar-profile>\n  </div>\n</div>\n' }]
  }], () => [{ type: Title }, { type: ViewContainerRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoToolbarComponent, { className: "PoToolbarComponent", filePath: "lib/components/po-toolbar/po-toolbar.component.ts", lineNumber: 30 });
})();
var PoToolbarModule = class _PoToolbarModule {
  static ɵfac = function PoToolbarModule_Factory(t) {
    return new (t || _PoToolbarModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoToolbarModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoAvatarModule, PoPopupModule, PoIconModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoToolbarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoAvatarModule, PoPopupModule, PoIconModule],
      declarations: [
        PoToolbarActionsComponent,
        PoToolbarComponent,
        PoToolbarNotificationComponent,
        PoToolbarProfileComponent
      ],
      exports: [PoToolbarComponent],
      providers: [],
      schemas: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoToolbarModule, { declarations: [
    PoToolbarActionsComponent,
    PoToolbarComponent,
    PoToolbarNotificationComponent,
    PoToolbarProfileComponent
  ], imports: [CommonModule, PoAvatarModule, PoPopupModule, PoIconModule], exports: [PoToolbarComponent] });
})();
var poTreeViewMaxLevel = 4;
var PoTreeViewBaseComponent = class _PoTreeViewBaseComponent {
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao colapsar um item.
   *
   * > Como parâmetro o componente envia o item colapsado.
   */
  collapsed = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao expandir um item.
   *
   * > Como parâmetro o componente envia o item expandido.
   */
  expanded = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao selecionar um item.
   *
   * > Como parâmetro o componente envia o item selecionado.
   */
  selected = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Ação que será disparada ao desfazer a seleção de um item.
   *
   * > Como parâmetro o componente envia o item que foi desmarcado.
   */
  unselected = new EventEmitter();
  _items = [];
  _selectable = false;
  _maxLevel = poTreeViewMaxLevel;
  _singleSelect = false;
  // armazena o value do item selecionado
  selectedValue;
  /**
   * Lista de itens do tipo `PoTreeViewItem` que será renderizada pelo componente.
   */
  inputedItems;
  set items(value) {
    this._items = Array.isArray(value) ? this.getItemsByMaxLevel(value) : [];
  }
  get items() {
    return this._items;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita uma caixa de seleção para selecionar e/ou desmarcar um item da lista.
   *
   * @default false
   */
  set selectable(value) {
    this._selectable = convertToBoolean(value);
  }
  get selectable() {
    return this._selectable;
  }
  /**
   * @optional
   *
   * @description
   *
   * Habilita a seleção para item único atráves de po-radio.
   *
   * @default false
   */
  set singleSelect(value) {
    this._singleSelect = convertToBoolean(value);
  }
  get singleSelect() {
    return this._singleSelect;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define o máximo de níveis para o tree-view.
   *
   * > O valor padrão é 4
   *
   * @default 4
   */
  set maxLevel(value) {
    this._maxLevel = convertToInt(value, poTreeViewMaxLevel);
  }
  get maxLevel() {
    return this._maxLevel;
  }
  emitExpanded(treeViewItem) {
    const event = treeViewItem.expanded ? "expanded" : "collapsed";
    this[event].emit(__spreadValues({}, treeViewItem));
  }
  emitSelected(treeViewItem) {
    const event = treeViewItem.selected ? "selected" : "unselected";
    this.selectedValue = treeViewItem.value;
    const _a = treeViewItem, { subItems } = _a, rest = __objRest(_a, ["subItems"]);
    const treeViewToEmit = this.singleSelect ? __spreadValues({}, rest) : treeViewItem;
    this.updateItemsOnSelect(treeViewToEmit);
    this[event].emit(__spreadValues({}, treeViewToEmit));
  }
  addChildItemInParent(childItem, parentItem) {
    if (!parentItem.subItems) {
      parentItem.subItems = [];
    }
    parentItem.subItems.push(childItem);
  }
  // caso houver parentItem:
  //  - expande o parentItem caso o filho estiver expandido;
  //  - adiciona o childItem no parentItem;
  //  - marca o parentItem caso conter subItems marcodos ou nulos;
  // Se não conter parentItem, adiciona o childItem no items.
  addItem(items, childItem, parentItem, isNewItem) {
    if (parentItem) {
      if (isNewItem) {
        this.expandParentItem(childItem, parentItem);
      }
      this.addChildItemInParent(childItem, parentItem);
      if (!this.singleSelect) {
        this.selectItemBySubItems(parentItem);
      }
      items.push(parentItem);
    } else {
      items.push(childItem);
    }
  }
  selectAllItems(items, isSelected) {
    items.forEach((item) => {
      if (item.subItems) {
        this.selectAllItems(item.subItems, isSelected);
      }
      item.selected = item.isSelectable !== false ? isSelected : false;
    });
  }
  selectItemBySubItems(item) {
    item.selected = this.everyItemSelected(item.subItems);
  }
  // retornará:
  //  - true: se todos os items estiverem marcados;
  //  - null: se no minimo um item esteja marcado ou nullo (indeterminate)
  //  - false: caso não corresponda em nenhuma das opções acima, no caso, nenhum marcado ou nulo;
  everyItemSelected(items = []) {
    const itemsLength = items.length;
    const lengthCheckedItems = items.filter((item) => item.selected).length;
    if (itemsLength && itemsLength === lengthCheckedItems) {
      return true;
    }
    const hasIndeterminateItems = items.filter((item) => item.selected || item.selected === null).length;
    if (hasIndeterminateItems) {
      return null;
    }
    return false;
  }
  // expande o item pai caso o filho estiver expandido.
  expandParentItem(childItem, parentItem) {
    if (childItem.expanded) {
      parentItem.expanded = true;
    }
  }
  getItemsByMaxLevel(items = [], level = 0, parentItem, newItems = []) {
    items.forEach((item) => {
      const _a = item, { subItems } = _a, currentItem = __objRest(_a, ["subItems"]);
      if (level === this.maxLevel) {
        return;
      }
      if (Array.isArray(subItems)) {
        if (currentItem.selected) {
          this.selectAllItems(subItems, currentItem.selected);
        }
        this.getItemsByMaxLevel(subItems, ++level, currentItem);
        --level;
      }
      if (item.selected) {
        this.selectedValue = currentItem.value;
      }
      this.addItem(newItems, currentItem, parentItem, true);
    });
    return newItems;
  }
  getItemsWithParentSelected(items = [], parentItem, newItems = []) {
    items.forEach((item) => {
      const _a = item, { subItems } = _a, currentItem = __objRest(_a, ["subItems"]);
      if (Array.isArray(subItems)) {
        this.getItemsWithParentSelected(subItems, currentItem);
      }
      this.addItem(newItems, currentItem, parentItem);
    });
    return newItems;
  }
  updateItemsOnSelect(selectedItem) {
    if (selectedItem.subItems && !this.singleSelect) {
      this.selectAllItems(selectedItem.subItems, selectedItem.selected);
    }
    this._items = this.getItemsWithParentSelected(this.items);
  }
  static ɵfac = function PoTreeViewBaseComponent_Factory(t) {
    return new (t || _PoTreeViewBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoTreeViewBaseComponent, inputs: { inputedItems: [InputFlags.None, "p-items", "inputedItems"], selectable: [InputFlags.None, "p-selectable", "selectable"], singleSelect: [InputFlags.None, "p-single-select", "singleSelect"], maxLevel: [InputFlags.None, "p-max-level", "maxLevel"] }, outputs: { collapsed: "p-collapsed", expanded: "p-expanded", selected: "p-selected", unselected: "p-unselected" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewBaseComponent, [{
    type: Directive
  }], null, { collapsed: [{
    type: Output,
    args: ["p-collapsed"]
  }], expanded: [{
    type: Output,
    args: ["p-expanded"]
  }], selected: [{
    type: Output,
    args: ["p-selected"]
  }], unselected: [{
    type: Output,
    args: ["p-unselected"]
  }], inputedItems: [{
    type: Input,
    args: ["p-items"]
  }], selectable: [{
    type: Input,
    args: ["p-selectable"]
  }], singleSelect: [{
    type: Input,
    args: ["p-single-select"]
  }], maxLevel: [{
    type: Input,
    args: ["p-max-level"]
  }] });
})();
var PoTreeViewService = class _PoTreeViewService {
  expandedEvent = new Subject();
  selectedEvent = new Subject();
  emitExpandedEvent(treeViewItem) {
    return this.expandedEvent.next(treeViewItem);
  }
  emitSelectedEvent(treeViewItem) {
    return this.selectedEvent.next(treeViewItem);
  }
  onExpand() {
    return this.expandedEvent.asObservable();
  }
  onSelect() {
    return this.selectedEvent.asObservable();
  }
  static ɵfac = function PoTreeViewService_Factory(t) {
    return new (t || _PoTreeViewService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoTreeViewService, factory: _PoTreeViewService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewService, [{
    type: Injectable
  }], null, null);
})();
var _c0$2 = ["inputCheckbox"];
function PoTreeViewItemHeaderComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function PoTreeViewItemHeaderComponent_button_1_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      return ɵɵresetView(ctx_r10.expanded.emit($event));
    });
    ɵɵelement(1, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("po-tree-view-item-header-button-icon-transform", ctx_r0.item.expanded);
  }
}
function PoTreeViewItemHeaderComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("po-tree-view-item-header-padding", !ctx_r2.hasSubItems);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.item.label, " ");
  }
}
function PoTreeViewItemHeaderComponent_ng_template_5_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoTreeViewItemHeaderComponent_ng_template_5_ng_container_0_Template, 1, 0, "ng-container", 2);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const _r9 = ɵɵreference(10);
    const _r7 = ɵɵreference(8);
    ɵɵproperty("ngIf", ctx_r4.singleSelect)("ngIfThen", _r9)("ngIfElse", _r7);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-checkbox", 10);
    ɵɵtwoWayListener("ngModelChange", function PoTreeViewItemHeaderComponent_ng_template_7_Template_po_checkbox_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r13 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r13.item.selected, $event) || (ctx_r13.item.selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change", function PoTreeViewItemHeaderComponent_ng_template_7_Template_po_checkbox_p_change_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r15 = ɵɵnextContext();
      return ɵɵresetView(ctx_r15.selected.emit(ctx_r15.item));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵclassProp("po-tree-view-item-header-padding", !ctx_r6.hasSubItems);
    ɵɵproperty("p-label", ctx_r6.item.label);
    ɵɵtwoWayProperty("ngModel", ctx_r6.item.selected);
    ɵɵproperty("p-disabled", ctx_r6.item.isSelectable === false);
  }
}
function PoTreeViewItemHeaderComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "po-radio", 11, 12);
    ɵɵtwoWayListener("ngModelChange", function PoTreeViewItemHeaderComponent_ng_template_9_Template_po_radio_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r17 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r17.item.selected, $event) || (ctx_r17.item.selected = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("p-change-selected", function PoTreeViewItemHeaderComponent_ng_template_9_Template_po_radio_p_change_selected_0_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r19 = ɵɵnextContext();
      return ɵɵresetView(ctx_r19.selected.emit(ctx_r19.item));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext();
    ɵɵclassProp("po-tree-view-item-header-padding", !ctx_r8.hasSubItems);
    ɵɵproperty("name", ctx_r8.idRadio);
    ɵɵtwoWayProperty("ngModel", ctx_r8.item.selected);
    ɵɵproperty("p-label", ctx_r8.item.label)("p-value", ctx_r8.item.value)("p-checked", ctx_r8.item.value === ctx_r8.selectedValue)("p-disabled", ctx_r8.item.isSelectable === false);
  }
}
var PoTreeViewItemHeaderComponent = class _PoTreeViewItemHeaderComponent {
  inputCheckbox;
  item;
  selectable = false;
  singleSelect;
  expanded = new EventEmitter();
  selected = new EventEmitter();
  selectedValue;
  idRadio = `po-radio[${uuid()}]`;
  get hasSubItems() {
    return !!(this.item.subItems && this.item.subItems.length);
  }
  static ɵfac = function PoTreeViewItemHeaderComponent_Factory(t) {
    return new (t || _PoTreeViewItemHeaderComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTreeViewItemHeaderComponent, selectors: [["po-tree-view-item-header"]], viewQuery: function PoTreeViewItemHeaderComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0$2, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputCheckbox = _t.first);
    }
  }, inputs: { item: [InputFlags.None, "p-item", "item"], selectable: [InputFlags.None, "p-selectable", "selectable"], singleSelect: [InputFlags.None, "p-single-select", "singleSelect"], selectedValue: [InputFlags.None, "p-selected-value", "selectedValue"] }, outputs: { expanded: "p-expanded", selected: "p-selected" }, decls: 11, vars: 4, consts: [[1, "po-tree-view-item-header"], ["class", "po-tree-view-item-header-button", 3, "click", 4, "ngIf"], [4, "ngIf", "ngIfThen", "ngIfElse"], ["labelTemplate", ""], ["selectionTemplate", ""], ["checkboxTemplate", ""], ["radioTemplate", ""], [1, "po-tree-view-item-header-button", 3, "click"], [1, "po-icon", "po-icon-arrow-down", "po-tree-view-item-header-button-icon"], [1, "po-tree-view-item-header-label"], [1, "po-tree-view-item-header-checkbox", 3, "p-label", "ngModel", "p-disabled", "ngModelChange", "p-change"], [1, "po-tree-view-item-header-checkbox", 3, "name", "ngModel", "p-label", "p-value", "p-checked", "p-disabled", "ngModelChange", "p-change-selected"], ["inputRadio", ""]], template: function PoTreeViewItemHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, PoTreeViewItemHeaderComponent_button_1_Template, 2, 2, "button", 1)(2, PoTreeViewItemHeaderComponent_ng_container_2_Template, 1, 0, "ng-container", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, PoTreeViewItemHeaderComponent_ng_template_3_Template, 2, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor)(5, PoTreeViewItemHeaderComponent_ng_template_5_Template, 1, 3, "ng-template", null, 4, ɵɵtemplateRefExtractor)(7, PoTreeViewItemHeaderComponent_ng_template_7_Template, 1, 5, "ng-template", null, 5, ɵɵtemplateRefExtractor)(9, PoTreeViewItemHeaderComponent_ng_template_9_Template, 2, 8, "ng-template", null, 6, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r3 = ɵɵreference(4);
      const _r5 = ɵɵreference(6);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasSubItems);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selectable)("ngIfThen", _r5)("ngIfElse", _r3);
    }
  }, dependencies: [NgIf, NgControlStatus, NgModel, PoCheckboxComponent, PoRadioComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewItemHeaderComponent, [{
    type: Component,
    args: [{ selector: "po-tree-view-item-header", changeDetection: ChangeDetectionStrategy.OnPush, template: '<div class="po-tree-view-item-header">\n  <button *ngIf="hasSubItems" class="po-tree-view-item-header-button" (click)="expanded.emit($event)">\n    <span\n      class="po-icon po-icon-arrow-down po-tree-view-item-header-button-icon"\n      [class.po-tree-view-item-header-button-icon-transform]="item.expanded"\n    >\n    </span>\n  </button>\n\n  <ng-container *ngIf="selectable; then selectionTemplate; else labelTemplate"></ng-container>\n</div>\n\n<ng-template #labelTemplate>\n  <span class="po-tree-view-item-header-label" [class.po-tree-view-item-header-padding]="!hasSubItems">\n    {{ item.label }}\n  </span>\n</ng-template>\n\n<ng-template #selectionTemplate>\n  <ng-container *ngIf="singleSelect; then radioTemplate; else checkboxTemplate"></ng-container>\n</ng-template>\n\n<ng-template #checkboxTemplate>\n  <po-checkbox\n    class="po-tree-view-item-header-checkbox"\n    [class.po-tree-view-item-header-padding]="!hasSubItems"\n    [p-label]="item.label"\n    [(ngModel)]="item.selected"\n    (p-change)="selected.emit(item)"\n    [p-disabled]="item.isSelectable === false"\n  >\n  </po-checkbox>\n</ng-template>\n\n<ng-template #radioTemplate>\n  <po-radio\n    class="po-tree-view-item-header-checkbox"\n    [class.po-tree-view-item-header-padding]="!hasSubItems"\n    #inputRadio\n    [name]="idRadio"\n    [(ngModel)]="item.selected"\n    [p-label]="item.label"\n    [p-value]="item.value"\n    [p-checked]="item.value === selectedValue"\n    (p-change-selected)="selected.emit(item)"\n    [p-disabled]="item.isSelectable === false"\n  >\n  </po-radio>\n</ng-template>\n' }]
  }], null, { inputCheckbox: [{
    type: ViewChild,
    args: ["inputCheckbox"]
  }], item: [{
    type: Input,
    args: ["p-item"]
  }], selectable: [{
    type: Input,
    args: ["p-selectable"]
  }], singleSelect: [{
    type: Input,
    args: ["p-single-select"]
  }], expanded: [{
    type: Output,
    args: ["p-expanded"]
  }], selected: [{
    type: Output,
    args: ["p-selected"]
  }], selectedValue: [{
    type: Input,
    args: ["p-selected-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTreeViewItemHeaderComponent, { className: "PoTreeViewItemHeaderComponent", filePath: "lib/components/po-tree-view/po-tree-view-item-header/po-tree-view-item-header.component.ts", lineNumber: 11 });
})();
function PoTreeViewItemComponent_ul_2_po_tree_view_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tree-view-item", 5);
  }
  if (rf & 2) {
    const subItem_r2 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-item", subItem_r2)("p-selectable", ctx_r1.selectable)("p-single-select", ctx_r1.singleSelect)("p-selected-value", ctx_r1.selectedValue);
  }
}
function PoTreeViewItemComponent_ul_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 3);
    ɵɵtemplate(1, PoTreeViewItemComponent_ul_2_po_tree_view_item_1_Template, 1, 4, "po-tree-view-item", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@toggleBody", ctx_r0.item.expanded ? "expanded" : "collapsed");
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.item.subItems)("ngForTrackBy", ctx_r0.trackByFunction);
  }
}
var PoTreeViewItemComponent = class _PoTreeViewItemComponent {
  treeViewService;
  item;
  selectable;
  singleSelect;
  selectedValue;
  get hasSubItems() {
    return !!(this.item.subItems && this.item.subItems.length);
  }
  constructor(treeViewService) {
    this.treeViewService = treeViewService;
  }
  onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    this.item.expanded = !this.item.expanded;
    this.treeViewService.emitExpandedEvent(__spreadValues({}, this.item));
  }
  onSelect(selectedItem) {
    this.treeViewService.emitSelectedEvent(__spreadValues({}, selectedItem));
  }
  trackByFunction(index) {
    return index;
  }
  static ɵfac = function PoTreeViewItemComponent_Factory(t) {
    return new (t || _PoTreeViewItemComponent)(ɵɵdirectiveInject(PoTreeViewService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTreeViewItemComponent, selectors: [["po-tree-view-item"]], inputs: { item: [InputFlags.None, "p-item", "item"], selectable: [InputFlags.None, "p-selectable", "selectable"], singleSelect: [InputFlags.None, "p-single-select", "singleSelect"], selectedValue: [InputFlags.None, "p-selected-value", "selectedValue"] }, decls: 3, vars: 5, consts: [[1, "po-tree-view-item"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value", "p-expanded", "p-selected"], ["class", "po-tree-view-item-group", 4, "ngIf"], [1, "po-tree-view-item-group"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value"]], template: function PoTreeViewItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "li", 0)(1, "po-tree-view-item-header", 1);
      ɵɵlistener("p-expanded", function PoTreeViewItemComponent_Template_po_tree_view_item_header_p_expanded_1_listener($event) {
        return ctx.onClick($event);
      })("p-selected", function PoTreeViewItemComponent_Template_po_tree_view_item_header_p_selected_1_listener() {
        return ctx.onSelect(ctx.item);
      });
      ɵɵelementEnd();
      ɵɵtemplate(2, PoTreeViewItemComponent_ul_2_Template, 2, 3, "ul", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("p-item", ctx.item)("p-selectable", ctx.selectable)("p-single-select", ctx.singleSelect)("p-selected-value", ctx.selectedValue);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasSubItems);
    }
  }, dependencies: [NgForOf, NgIf, _PoTreeViewItemComponent, PoTreeViewItemHeaderComponent], encapsulation: 2, data: { animation: [
    trigger("toggleBody", [
      state("collapsed", style({
        "overflow-y": "hidden",
        visibility: "hidden",
        opacity: 0,
        height: "0"
      })),
      transition("expanded => collapsed", [
        style({ height: "*" }),
        animate(100, style({ opacity: 0 })),
        animate(200, style({ height: 0 }))
      ]),
      transition("collapsed => expanded", [
        style({ height: "0" }),
        animate(100, style({ opacity: 1 })),
        animate(200, style({ height: "*" }))
      ])
    ])
  ] }, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewItemComponent, [{
    type: Component,
    args: [{ selector: "po-tree-view-item", changeDetection: ChangeDetectionStrategy.OnPush, animations: [
      trigger("toggleBody", [
        state("collapsed", style({
          "overflow-y": "hidden",
          visibility: "hidden",
          opacity: 0,
          height: "0"
        })),
        transition("expanded => collapsed", [
          style({ height: "*" }),
          animate(100, style({ opacity: 0 })),
          animate(200, style({ height: 0 }))
        ]),
        transition("collapsed => expanded", [
          style({ height: "0" }),
          animate(100, style({ opacity: 1 })),
          animate(200, style({ height: "*" }))
        ])
      ])
    ], template: `<li class="po-tree-view-item">
  <po-tree-view-item-header
    [p-item]="item"
    [p-selectable]="selectable"
    [p-single-select]="singleSelect"
    [p-selected-value]="selectedValue"
    (p-expanded)="onClick($event)"
    (p-selected)="onSelect(item)"
  >
  </po-tree-view-item-header>

  <ul *ngIf="hasSubItems" class="po-tree-view-item-group" [@toggleBody]="item.expanded ? 'expanded' : 'collapsed'">
    <po-tree-view-item
      *ngFor="let subItem of item.subItems; trackBy: trackByFunction"
      [p-item]="subItem"
      [p-selectable]="selectable"
      [p-single-select]="singleSelect"
      [p-selected-value]="selectedValue"
    >
    </po-tree-view-item>
  </ul>
</li>
` }]
  }], () => [{ type: PoTreeViewService }], { item: [{
    type: Input,
    args: ["p-item"]
  }], selectable: [{
    type: Input,
    args: ["p-selectable"]
  }], singleSelect: [{
    type: Input,
    args: ["p-single-select"]
  }], selectedValue: [{
    type: Input,
    args: ["p-selected-value"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTreeViewItemComponent, { className: "PoTreeViewItemComponent", filePath: "lib/components/po-tree-view/po-tree-view-item/po-tree-view-item.component.ts", lineNumber: 35 });
})();
function PoTreeViewComponent_po_container_0_po_tree_view_item_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "po-tree-view-item", 4);
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("p-item", item_r2)("p-selectable", ctx_r1.selectable)("p-single-select", ctx_r1.singleSelect)("p-selected-value", ctx_r1.selectedValue);
  }
}
function PoTreeViewComponent_po_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-container", 1)(1, "ul", 2);
    ɵɵtemplate(2, PoTreeViewComponent_po_container_0_po_tree_view_item_2_Template, 1, 4, "po-tree-view-item", 3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.items)("ngForTrackBy", ctx_r0.trackByFunction);
  }
}
var PoTreeViewComponent = class _PoTreeViewComponent extends PoTreeViewBaseComponent {
  treeViewService;
  get hasItems() {
    return !!(this.items && this.items.length);
  }
  constructor(treeViewService) {
    super();
    this.treeViewService = treeViewService;
  }
  ngOnInit() {
    this.treeViewService.onExpand().subscribe((treeViewItem) => {
      this.emitExpanded(treeViewItem);
    });
    this.treeViewService.onSelect().subscribe((treeViewItem) => {
      this.emitSelected(treeViewItem);
    });
  }
  ngOnChanges(changes) {
    if (changes?.["inputedItems"]) {
      this.items = this.inputedItems;
    }
  }
  trackByFunction(index) {
    return index;
  }
  static ɵfac = function PoTreeViewComponent_Factory(t) {
    return new (t || _PoTreeViewComponent)(ɵɵdirectiveInject(PoTreeViewService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoTreeViewComponent, selectors: [["po-tree-view"]], features: [ɵɵProvidersFeature([PoTreeViewService]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature], decls: 1, vars: 1, consts: [["p-no-padding", "", 4, "ngIf"], ["p-no-padding", ""], [1, "po-tree-view"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "p-item", "p-selectable", "p-single-select", "p-selected-value"]], template: function PoTreeViewComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PoTreeViewComponent_po_container_0_Template, 3, 2, "po-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.hasItems);
    }
  }, dependencies: [NgForOf, NgIf, PoContainerComponent, PoTreeViewItemComponent], encapsulation: 2, changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewComponent, [{
    type: Component,
    args: [{ selector: "po-tree-view", changeDetection: ChangeDetectionStrategy.OnPush, providers: [PoTreeViewService], template: '<po-container *ngIf="hasItems" p-no-padding>\n  <ul class="po-tree-view">\n    <po-tree-view-item\n      *ngFor="let item of items; trackBy: trackByFunction"\n      [p-item]="item"\n      [p-selectable]="selectable"\n      [p-single-select]="singleSelect"\n      [p-selected-value]="selectedValue"\n    >\n    </po-tree-view-item>\n  </ul>\n</po-container>\n' }]
  }], () => [{ type: PoTreeViewService }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoTreeViewComponent, { className: "PoTreeViewComponent", filePath: "lib/components/po-tree-view/po-tree-view.component.ts", lineNumber: 38 });
})();
var PoTreeViewModule = class _PoTreeViewModule {
  static ɵfac = function PoTreeViewModule_Factory(t) {
    return new (t || _PoTreeViewModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoTreeViewModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, FormsModule, PoContainerModule, PoFieldModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoTreeViewModule, [{
    type: NgModule,
    args: [{
      declarations: [PoTreeViewComponent, PoTreeViewItemComponent, PoTreeViewItemHeaderComponent],
      exports: [PoTreeViewComponent],
      imports: [CommonModule, FormsModule, PoContainerModule, PoFieldModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoTreeViewModule, { declarations: [PoTreeViewComponent, PoTreeViewItemComponent, PoTreeViewItemHeaderComponent], imports: [CommonModule, FormsModule, PoContainerModule, PoFieldModule], exports: [PoTreeViewComponent] });
})();
var PoWidgetBaseComponent = class _PoWidgetBaseComponent {
  /** Descrição da segunda ação. */
  secondaryLabel;
  /**
   * @optional
   *
   * @description
   *
   * Ação que será executada quando o usuário clicar sobre a área total do `po-widget`.
   */
  click = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será disparada com o valor do `p-disabled` quando esta propriedade for alterada.
   */
  onDisabled = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será chamada na primeira ação.
   */
  primaryAction = new EventEmitter();
  /**
   * @optional
   *
   * @description
   *
   * Função que será chamada na segunda ação.
   */
  secondaryAction = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Função chamada ao clicar no ícone de configuração
   */
  setting = new EventEmitter();
  /**
   * @optional
   *
   * @description
   * Função que será chamada ao clicar no título.
   */
  titleAction = new EventEmitter();
  containerHeight = "auto";
  id = uuid();
  _background;
  _disabled = false;
  _height;
  _help;
  _noShadow = false;
  _primary = false;
  _primaryLabel;
  _title;
  /**
   * @optional
   *
   * @description
   *
   * Aplicação de imagem de fundo.
   * > Se a imagem escolhida intervir na legibilidade do texto contido no `p-widget`,
   * pode-se utilizar a propriedade `p-primary` em conjunto para que os textos fiquem na cor branca.
   *
   */
  set background(value) {
    this._background = value && typeof value === "string" ? value : void 0;
  }
  get background() {
    return this._background;
  }
  /**
   * @optional
   *
   * @description
   *
   * Desabilita todas as ações do componente.
   *
   * @default `false`
   */
  set disabled(value) {
    this._disabled = convertToBoolean(value);
    this.onDisabled.emit(this.disabled);
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * @optional
   *
   * @description
   *
   * Define a altura do `po-widget`.
   * A altura mínima para o `po-widget` depende do que será exibido através das propriedades `p-primary-label`,
   * `p-setting`, `p-help` e `p-title`.
   * > Caso não seja informado valor, a propriedade irá assumir o tamanho do conteúdo.
   */
  set height(value) {
    this._height = parseInt(value, 10);
    this.setHeight(this.height);
  }
  get height() {
    return this._height;
  }
  /**
   * @optional
   *
   * @description
   *
   * Link de ajuda
   */
  set help(value) {
    this._help = isTypeof(value, "string") ? value : "";
    this.setHeight(this.height);
  }
  get help() {
    return this._help;
  }
  /**
   *
   * @optional
   *
   * @description
   *
   * Desabilita a sombra do `po-widget` quando o mesmo for clicável.
   *
   * @default `true`
   */
  set noShadow(value) {
    this._noShadow = value === "" ? true : convertToBoolean(value);
    this.setHeight(this.height);
  }
  get noShadow() {
    return this._noShadow;
  }
  /**
   * @optional
   *
   * @description
   *
   * Opção para que o `po-widget` fique em destaque.
   *
   * @default `false`
   */
  set primary(value) {
    this._primary = value === "" ? true : convertToBoolean(value);
  }
  get primary() {
    return this._primary;
  }
  /**
   * @optional
   *
   * @description
   *
   * Descrição da primeira ação.
   *
   * @default `false`
   */
  set primaryLabel(value) {
    this._primaryLabel = isTypeof(value, "string") ? value : "";
    this.setHeight(this.height);
  }
  get primaryLabel() {
    return this._primaryLabel;
  }
  /**
   * @optional
   *
   * @description
   *
   * Título do `po-widget`.
   *
   * @default `false`
   */
  set title(value) {
    this._title = isTypeof(value, "string") ? value : "";
    this.setHeight(this.height);
  }
  get title() {
    return this._title;
  }
  static ɵfac = function PoWidgetBaseComponent_Factory(t) {
    return new (t || _PoWidgetBaseComponent)();
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoWidgetBaseComponent, inputs: { secondaryLabel: [InputFlags.None, "p-secondary-label", "secondaryLabel"], background: [InputFlags.None, "p-background", "background"], disabled: [InputFlags.None, "p-disabled", "disabled"], height: [InputFlags.None, "p-height", "height"], help: [InputFlags.None, "p-help", "help"], noShadow: [InputFlags.None, "p-no-shadow", "noShadow"], primary: [InputFlags.None, "p-primary", "primary"], primaryLabel: [InputFlags.None, "p-primary-label", "primaryLabel"], title: [InputFlags.None, "p-title", "title"] }, outputs: { click: "p-click", onDisabled: "p-on-disabled", primaryAction: "p-primary-action", secondaryAction: "p-secondary-action", setting: "p-setting", titleAction: "p-title-action" } });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoWidgetBaseComponent, [{
    type: Directive
  }], null, { secondaryLabel: [{
    type: Input,
    args: ["p-secondary-label"]
  }], click: [{
    type: Output,
    args: ["p-click"]
  }], onDisabled: [{
    type: Output,
    args: ["p-on-disabled"]
  }], primaryAction: [{
    type: Output,
    args: ["p-primary-action"]
  }], secondaryAction: [{
    type: Output,
    args: ["p-secondary-action"]
  }], setting: [{
    type: Output,
    args: ["p-setting"]
  }], titleAction: [{
    type: Output,
    args: ["p-title-action"]
  }], background: [{
    type: Input,
    args: ["p-background"]
  }], disabled: [{
    type: Input,
    args: ["p-disabled"]
  }], height: [{
    type: Input,
    args: ["p-height"]
  }], help: [{
    type: Input,
    args: ["p-help"]
  }], noShadow: [{
    type: Input,
    args: ["p-no-shadow"]
  }], primary: [{
    type: Input,
    args: ["p-primary"]
  }], primaryLabel: [{
    type: Input,
    args: ["p-primary-label"]
  }], title: [{
    type: Input,
    args: ["p-title"]
  }] });
})();
function PoWidgetComponent_div_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 9);
    ɵɵlistener("click", function PoWidgetComponent_div_1_span_1_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6.runTitleAction($event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2.title, " ");
  }
}
function PoWidgetComponent_div_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r3.title);
  }
}
function PoWidgetComponent_div_1_div_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13);
    ɵɵlistener("click", function PoWidgetComponent_div_1_div_4_span_1_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r10.settingOutput($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext(3);
    ɵɵpropertyInterpolate1("id", "settingAction-", ctx_r8.id, "");
  }
}
function PoWidgetComponent_div_1_div_4_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 14);
    ɵɵlistener("click", function PoWidgetComponent_div_1_div_4_span_2_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r12.openHelp($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(3);
    ɵɵpropertyInterpolate1("id", "helpLink-", ctx_r9.id, "");
  }
}
function PoWidgetComponent_div_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtemplate(1, PoWidgetComponent_div_1_div_4_span_1_Template, 1, 1, "span", 11)(2, PoWidgetComponent_div_1_div_4_span_2_Template, 1, 1, "span", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.setting.observers[0]);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.help);
  }
}
function PoWidgetComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtemplate(1, PoWidgetComponent_div_1_span_1_Template, 2, 1, "span", 6)(2, PoWidgetComponent_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 7, ɵɵtemplateRefExtractor)(4, PoWidgetComponent_div_1_div_4_Template, 3, 2, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const _r4 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showTitleAction)("ngIfElse", _r4);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.setting.observers[0] || ctx_r0.help);
  }
}
function PoWidgetComponent_div_5_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18)(1, "a", 19);
    ɵɵlistener("click", function PoWidgetComponent_div_5_div_1_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r18);
      const ctx_r17 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r17.runPrimaryAction($event));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "primaryAct-", ctx_r14.id, "");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r14.primaryLabel);
  }
}
function PoWidgetComponent_div_5_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "a", 19);
    ɵɵlistener("click", function PoWidgetComponent_div_5_div_2_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r20);
      const ctx_r19 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r19.runPrimaryAction($event));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r15 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "primaryAct-", ctx_r15.id, "");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r15.primaryLabel);
  }
}
function PoWidgetComponent_div_5_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "a", 19);
    ɵɵlistener("click", function PoWidgetComponent_div_5_div_3_Template_a_click_1_listener($event) {
      ɵɵrestoreView(_r22);
      const ctx_r21 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r21.runSecondaryAction($event));
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r16 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "secondaryAct-", ctx_r16.id, "");
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r16.secondaryLabel);
  }
}
function PoWidgetComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, PoWidgetComponent_div_5_div_1_Template, 3, 2, "div", 16)(2, PoWidgetComponent_div_5_div_2_Template, 3, 2, "div", 17)(3, PoWidgetComponent_div_5_div_3_Template, 3, 2, "div", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.secondaryLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.secondaryLabel);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.secondaryLabel);
  }
}
var _c0$1 = ["*"];
var PoWidgetComponent = class _PoWidgetComponent extends PoWidgetBaseComponent {
  get showTitleAction() {
    return !!this.titleAction.observers[0];
  }
  constructor(viewRef) {
    super();
  }
  ngOnInit() {
    this.setHeight(this.height);
  }
  hasTitleHelpOrSetting() {
    return !!this.title || !!this.help || !!this.setting.observers[0];
  }
  onClick(event) {
    if (this.click.observed && !this.disabled) {
      this.click.emit(event);
    }
  }
  onKeyDown(event) {
    if (this.click.observed && !this.disabled && (event.which === PoKeyCodeEnum.space || event.keyCode === PoKeyCodeEnum.space)) {
      this.click.emit(event);
      event.preventDefault();
    }
  }
  openHelp(event) {
    if (!this.disabled) {
      event.stopPropagation();
      window.open(this.help, "_blank");
    }
  }
  runPrimaryAction(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.primaryAction.emit();
    }
  }
  runSecondaryAction(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.secondaryAction.emit();
    }
  }
  runTitleAction(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.titleAction.emit();
    }
  }
  setHeight(height) {
    if (height) {
      let bodyHeight = height;
      const hasSettingOrHelp = this.setting.observers.length > 0 || this.help;
      const footerBorder = 1;
      const footerHeight = 40;
      const settingHeight = 37;
      const shadowHeight = 2;
      const titleHeight = 50;
      if (this.noShadow) {
        bodyHeight -= shadowHeight;
      }
      if (hasSettingOrHelp && !this.title) {
        bodyHeight -= settingHeight;
      }
      if (this.title) {
        bodyHeight -= titleHeight;
      }
      if (this.primaryLabel) {
        bodyHeight -= footerHeight + footerBorder;
      }
      this.containerHeight = `${bodyHeight}px`;
    } else {
      this.containerHeight = `auto`;
    }
  }
  settingOutput(event) {
    if (!this.disabled) {
      event.stopPropagation();
      this.setting.emit();
    }
  }
  static ɵfac = function PoWidgetComponent_Factory(t) {
    return new (t || _PoWidgetComponent)(ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoWidgetComponent, selectors: [["po-widget"]], features: [ɵɵInheritDefinitionFeature], ngContentSelectors: _c0$1, decls: 6, vars: 16, consts: [[3, "tabindex", "click", "keydown"], ["class", "po-widget-header", 4, "ngIf"], ["p-no-border", "", 3, "p-height"], [1, "po-widget-body"], ["class", "po-widget-footer", 4, "ngIf"], [1, "po-widget-header"], ["class", "po-widget-title-action", 3, "click", 4, "ngIf", "ngIfElse"], ["noTitleAction", ""], ["class", "po-pull-right", 4, "ngIf"], [1, "po-widget-title-action", 3, "click"], [1, "po-pull-right"], ["class", "po-clickable po-icon po-icon-settings", 3, "id", "click", 4, "ngIf"], ["class", "po-clickable po-icon po-icon-help", 3, "id", "click", 4, "ngIf"], [1, "po-clickable", "po-icon", "po-icon-settings", 3, "id", "click"], [1, "po-clickable", "po-icon", "po-icon-help", 3, "id", "click"], [1, "po-widget-footer"], ["class", "po-widget-xl", 4, "ngIf"], ["class", "po-widget-md", 4, "ngIf"], [1, "po-widget-xl"], [1, "po-widget-action", 3, "id", "click"], [1, "po-widget-md"]], template: function PoWidgetComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function PoWidgetComponent_Template_div_click_0_listener($event) {
        return ctx.onClick($event);
      })("keydown", function PoWidgetComponent_Template_div_keydown_0_listener($event) {
        return ctx.onKeyDown($event);
      });
      ɵɵtemplate(1, PoWidgetComponent_div_1_Template, 5, 3, "div", 1);
      ɵɵelementStart(2, "po-container", 2)(3, "div", 3);
      ɵɵprojection(4);
      ɵɵelementEnd()();
      ɵɵtemplate(5, PoWidgetComponent_div_5_Template, 4, 3, "div", 4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("background-image", ctx.background ? "url(" + ctx.background + ")" : void 0);
      ɵɵclassProp("po-clickable", ctx.click.observers.length)("po-widget", !ctx.primary)("po-widget-disabled", ctx.disabled)("po-widget-primary", ctx.primary)("po-widget-no-shadow", ctx.click.observers.length && ctx.noShadow);
      ɵɵproperty("tabindex", ctx.disabled || !ctx.click.observers.length ? -1 : 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasTitleHelpOrSetting());
      ɵɵadvance();
      ɵɵproperty("p-height", ctx.containerHeight);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.primaryLabel);
    }
  }, dependencies: [NgIf, PoContainerComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoWidgetComponent, [{
    type: Component,
    args: [{ selector: "po-widget", template: `<div
  [class.po-clickable]="click.observers.length"
  [class.po-widget]="!primary"
  [class.po-widget-disabled]="disabled"
  [class.po-widget-primary]="primary"
  [class.po-widget-no-shadow]="click.observers.length && noShadow"
  [style.background-image]="background ? 'url(' + background + ')' : undefined"
  (click)="onClick($event)"
  (keydown)="onKeyDown($event)"
  [tabindex]="disabled || !click.observers.length ? -1 : 0"
>
  <div *ngIf="hasTitleHelpOrSetting()" class="po-widget-header">
    <span *ngIf="showTitleAction; else noTitleAction" class="po-widget-title-action" (click)="runTitleAction($event)">
      {{ title }}
    </span>
    <ng-template #noTitleAction>{{ title }}</ng-template>

    <div *ngIf="setting.observers[0] || help" class="po-pull-right">
      <span
        id="settingAction-{{ id }}"
        *ngIf="setting.observers[0]"
        class="po-clickable po-icon po-icon-settings"
        (click)="settingOutput($event)"
      >
      </span>
      <span id="helpLink-{{ id }}" *ngIf="help" class="po-clickable po-icon po-icon-help" (click)="openHelp($event)">
      </span>
    </div>
  </div>

  <po-container p-no-border [p-height]="containerHeight">
    <div class="po-widget-body">
      <ng-content></ng-content>
    </div>
  </po-container>

  <div *ngIf="primaryLabel" class="po-widget-footer">
    <div class="po-widget-xl" *ngIf="!secondaryLabel">
      <a class="po-widget-action" id="primaryAct-{{ id }}" (click)="runPrimaryAction($event)">{{ primaryLabel }}</a>
    </div>

    <div class="po-widget-md" *ngIf="secondaryLabel">
      <a class="po-widget-action" id="primaryAct-{{ id }}" (click)="runPrimaryAction($event)">{{ primaryLabel }}</a>
    </div>
    <div class="po-widget-md" *ngIf="secondaryLabel">
      <a class="po-widget-action" id="secondaryAct-{{ id }}" (click)="runSecondaryAction($event)">{{
        secondaryLabel
      }}</a>
    </div>
  </div>
</div>
` }]
  }], () => [{ type: ViewContainerRef }], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoWidgetComponent, { className: "PoWidgetComponent", filePath: "lib/components/po-widget/po-widget.component.ts", lineNumber: 36 });
})();
var PoWidgetModule = class _PoWidgetModule {
  static ɵfac = function PoWidgetModule_Factory(t) {
    return new (t || _PoWidgetModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoWidgetModule });
  static ɵinj = ɵɵdefineInjector({ imports: [CommonModule, PoContainerModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoWidgetModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoContainerModule],
      exports: [PoWidgetComponent],
      declarations: [PoWidgetComponent]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoWidgetModule, { declarations: [PoWidgetComponent], imports: [CommonModule, PoContainerModule], exports: [PoWidgetComponent] });
})();
var PoComponentsModule = class _PoComponentsModule {
  static ɵfac = function PoComponentsModule_Factory(t) {
    return new (t || _PoComponentsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoComponentsModule });
  static ɵinj = ɵɵdefineInjector({ imports: [
    PoAccordionModule,
    PoAvatarModule,
    PoBreadcrumbModule,
    PoButtonModule,
    PoButtonGroupModule,
    PoCalendarModule,
    PoChartModule,
    PoContainerModule,
    PoDisclaimerGroupModule,
    PoDisclaimerModule,
    PoDividerModule,
    PoDropdownModule,
    PoDynamicModule,
    PoFieldModule,
    PoGaugeModule,
    PoGridModule,
    PoIconModule,
    PoInfoModule,
    PoListViewModule,
    PoListBoxModule,
    PoLoadingModule,
    PoLogoModule,
    PoMenuModule,
    PoMenuPanelModule,
    PoModalModule,
    PoNavbarModule,
    PoOverlayModule,
    PoPageModule,
    PoPopoverModule,
    PoPopupModule,
    PoProgressModule,
    PoSlideModule,
    PoStepperModule,
    PoTableModule,
    PoTabsModule,
    PoTagModule,
    PoToolbarModule,
    PoTreeViewModule,
    PoWidgetModule,
    PoLinkModule,
    PoLabelModule,
    PoImageModule,
    PoPageSlideModule,
    PoSwitchModule,
    PoSearchModule,
    PoBadgeModule,
    PoAccordionModule,
    PoAvatarModule,
    PoBreadcrumbModule,
    PoButtonModule,
    PoButtonGroupModule,
    PoCalendarModule,
    PoChartModule,
    PoContainerModule,
    PoDisclaimerGroupModule,
    PoDisclaimerModule,
    PoDividerModule,
    PoDropdownModule,
    PoDynamicModule,
    PoFieldModule,
    PoGaugeModule,
    PoGridModule,
    PoIconModule,
    PoInfoModule,
    PoListViewModule,
    PoListBoxModule,
    PoLoadingModule,
    PoLogoModule,
    PoMenuModule,
    PoMenuPanelModule,
    PoModalModule,
    PoNavbarModule,
    PoOverlayModule,
    PoPageModule,
    PoPopoverModule,
    PoPopupModule,
    PoProgressModule,
    PoSlideModule,
    PoStepperModule,
    PoTableModule,
    PoTabsModule,
    PoTagModule,
    PoToolbarModule,
    PoTreeViewModule,
    PoWidgetModule,
    PoLinkModule,
    PoLabelModule,
    PoImageModule,
    PoPageSlideModule,
    PoSwitchModule,
    PoSearchModule,
    PoBadgeModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoComponentsModule, [{
    type: NgModule,
    args: [{
      imports: [
        PoAccordionModule,
        PoAvatarModule,
        PoBreadcrumbModule,
        PoButtonModule,
        PoButtonGroupModule,
        PoCalendarModule,
        PoChartModule,
        PoContainerModule,
        PoDisclaimerGroupModule,
        PoDisclaimerModule,
        PoDividerModule,
        PoDropdownModule,
        PoDynamicModule,
        PoFieldModule,
        PoGaugeModule,
        PoGridModule,
        PoIconModule,
        PoInfoModule,
        PoListViewModule,
        PoListBoxModule,
        PoLoadingModule,
        PoLogoModule,
        PoMenuModule,
        PoMenuPanelModule,
        PoModalModule,
        PoNavbarModule,
        PoOverlayModule,
        PoPageModule,
        PoPopoverModule,
        PoPopupModule,
        PoProgressModule,
        PoSlideModule,
        PoStepperModule,
        PoTableModule,
        PoTabsModule,
        PoTagModule,
        PoToolbarModule,
        PoTreeViewModule,
        PoWidgetModule,
        PoLinkModule,
        PoLabelModule,
        PoImageModule,
        PoPageSlideModule,
        PoSwitchModule,
        PoSearchModule,
        PoBadgeModule
      ],
      exports: [
        PoAccordionModule,
        PoAvatarModule,
        PoBreadcrumbModule,
        PoButtonModule,
        PoButtonGroupModule,
        PoCalendarModule,
        PoChartModule,
        PoContainerModule,
        PoDisclaimerGroupModule,
        PoDisclaimerModule,
        PoDividerModule,
        PoDropdownModule,
        PoDynamicModule,
        PoFieldModule,
        PoGaugeModule,
        PoGridModule,
        PoIconModule,
        PoInfoModule,
        PoListViewModule,
        PoListBoxModule,
        PoLoadingModule,
        PoLogoModule,
        PoMenuModule,
        PoMenuPanelModule,
        PoModalModule,
        PoNavbarModule,
        PoOverlayModule,
        PoPageModule,
        PoPopoverModule,
        PoPopupModule,
        PoProgressModule,
        PoSlideModule,
        PoStepperModule,
        PoTableModule,
        PoTabsModule,
        PoTagModule,
        PoToolbarModule,
        PoTreeViewModule,
        PoWidgetModule,
        PoLinkModule,
        PoLabelModule,
        PoImageModule,
        PoPageSlideModule,
        PoSwitchModule,
        PoSearchModule,
        PoBadgeModule
      ],
      providers: [],
      bootstrap: [],
      declarations: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoComponentsModule, { imports: [
    PoAccordionModule,
    PoAvatarModule,
    PoBreadcrumbModule,
    PoButtonModule,
    PoButtonGroupModule,
    PoCalendarModule,
    PoChartModule,
    PoContainerModule,
    PoDisclaimerGroupModule,
    PoDisclaimerModule,
    PoDividerModule,
    PoDropdownModule,
    PoDynamicModule,
    PoFieldModule,
    PoGaugeModule,
    PoGridModule,
    PoIconModule,
    PoInfoModule,
    PoListViewModule,
    PoListBoxModule,
    PoLoadingModule,
    PoLogoModule,
    PoMenuModule,
    PoMenuPanelModule,
    PoModalModule,
    PoNavbarModule,
    PoOverlayModule,
    PoPageModule,
    PoPopoverModule,
    PoPopupModule,
    PoProgressModule,
    PoSlideModule,
    PoStepperModule,
    PoTableModule,
    PoTabsModule,
    PoTagModule,
    PoToolbarModule,
    PoTreeViewModule,
    PoWidgetModule,
    PoLinkModule,
    PoLabelModule,
    PoImageModule,
    PoPageSlideModule,
    PoSwitchModule,
    PoSearchModule,
    PoBadgeModule
  ], exports: [
    PoAccordionModule,
    PoAvatarModule,
    PoBreadcrumbModule,
    PoButtonModule,
    PoButtonGroupModule,
    PoCalendarModule,
    PoChartModule,
    PoContainerModule,
    PoDisclaimerGroupModule,
    PoDisclaimerModule,
    PoDividerModule,
    PoDropdownModule,
    PoDynamicModule,
    PoFieldModule,
    PoGaugeModule,
    PoGridModule,
    PoIconModule,
    PoInfoModule,
    PoListViewModule,
    PoListBoxModule,
    PoLoadingModule,
    PoLogoModule,
    PoMenuModule,
    PoMenuPanelModule,
    PoModalModule,
    PoNavbarModule,
    PoOverlayModule,
    PoPageModule,
    PoPopoverModule,
    PoPopupModule,
    PoProgressModule,
    PoSlideModule,
    PoStepperModule,
    PoTableModule,
    PoTabsModule,
    PoTagModule,
    PoToolbarModule,
    PoTreeViewModule,
    PoWidgetModule,
    PoLinkModule,
    PoLabelModule,
    PoImageModule,
    PoPageSlideModule,
    PoSwitchModule,
    PoSearchModule,
    PoBadgeModule
  ] });
})();
var PoDirectivesModule = class _PoDirectivesModule {
  static ɵfac = function PoDirectivesModule_Factory(t) {
    return new (t || _PoDirectivesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoDirectivesModule });
  static ɵinj = ɵɵdefineInjector({ imports: [PoTooltipModule, PoTooltipModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoDirectivesModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoTooltipModule],
      exports: [PoTooltipModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoDirectivesModule, { imports: [PoTooltipModule], exports: [PoTooltipModule] });
})();
var PoGuardsModule = class _PoGuardsModule {
  static ɵfac = function PoGuardsModule_Factory(t) {
    return new (t || _PoGuardsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoGuardsModule });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoGuardsModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [],
      exports: [],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
var poHttpInterceptorDetailLiteralsDefault = {
  en: {
    closeButton: "Close",
    details: "Details",
    detail: "Detail",
    error: "Error",
    warning: "Warning",
    information: "Information",
    success: "Success"
  },
  es: {
    closeButton: "Cerrar",
    details: "Detalles",
    detail: "Detalle",
    error: "Error",
    warning: "Advertencia",
    information: "Informacion",
    success: "Éxito"
  },
  pt: {
    closeButton: "Fechar",
    details: "Detalhes",
    detail: "Detalhe",
    error: "Erro",
    warning: "Aviso",
    information: "Informação",
    success: "Sucesso"
  },
  ru: {
    closeButton: "Закрывать",
    details: "Детали",
    detail: "Деталь",
    error: "Ошибка",
    warning: "Предупреждение",
    information: "Информация",
    success: "Yспех"
  }
};
function PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_ng_template_1_Template(rf, ctx) {
}
var _c02 = (a0) => ({ detail: a0 });
function PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-accordion-item", 7);
    ɵɵtemplate(1, PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r6 = ctx.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    const _r4 = ɵɵreference(6);
    ɵɵproperty("p-label", ctx_r5.formatDetailItemTitle(detail_r6));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c02, detail_r6));
  }
}
function PoHttpInterceptorDetailComponent_po_accordion_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "po-accordion", 5);
    ɵɵtemplate(1, PoHttpInterceptorDetailComponent_po_accordion_2_po_accordion_item_1_Template, 2, 5, "po-accordion-item", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.details);
  }
}
var _c110 = () => ({});
function PoHttpInterceptorDetailComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const _r4 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", _r4)("ngTemplateOutletContext", ɵɵpureFunction1(3, _c02, ctx_r1.details[0] || ɵɵpureFunction0(2, _c110)));
  }
}
function PoHttpInterceptorDetailComponent_ng_template_5_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "po-tag", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const detail_r8 = ɵɵnextContext().detail;
    const ctx_r9 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("p-color", ctx_r9.typeColor(detail_r8.type))("p-value", ctx_r9.typeValue(detail_r8.type));
  }
}
function PoHttpInterceptorDetailComponent_ng_template_5_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p")(1, "strong");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const detail_r8 = ɵɵnextContext().detail;
    ɵɵadvance(2);
    ɵɵtextInterpolate(detail_r8.code);
  }
}
function PoHttpInterceptorDetailComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, PoHttpInterceptorDetailComponent_ng_template_5_div_0_Template, 2, 2, "div", 9)(1, PoHttpInterceptorDetailComponent_ng_template_5_p_1_Template, 3, 1, "p", 10);
    ɵɵelementStart(2, "div", 1)(3, "p");
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const detail_r8 = ctx.detail;
    ɵɵproperty("ngIf", detail_r8.type);
    ɵɵadvance();
    ɵɵproperty("ngIf", detail_r8.detailTitle);
    ɵɵadvance(3);
    ɵɵtextInterpolate(detail_r8.detailedMessage);
  }
}
var colors = { success: "color-11", error: "color-07", warning: "color-08", info: "" };
var PoHttpInterceptorDetailComponent = class _PoHttpInterceptorDetailComponent {
  languageService;
  modal;
  closed = new EventEmitter();
  details = [];
  title;
  language;
  literals;
  // eslint-disable-next-line @typescript-eslint/member-ordering
  primaryAction;
  constructor(languageService) {
    this.languageService = languageService;
    this.language = this.languageService?.getShortLanguage();
    this.literals = poHttpInterceptorDetailLiteralsDefault[this.language];
  }
  ngOnInit() {
    this.primaryAction = {
      action: () => this.close(),
      label: this.literals.closeButton
    };
  }
  set detail(details) {
    if (details && details.length) {
      this.details = this.filterByValidDetails(details);
    }
    this.title = this.formatTitle(this.details);
  }
  close() {
    this.modal.close();
    this.closed.emit();
  }
  formatDetailItemTitle(detail) {
    return detail.detailTitle ? detail.detailTitle : detail.code ? `${detail.code} - ${detail.message}` : detail.message;
  }
  open() {
    this.modal.open();
  }
  typeColor(type) {
    return colors[type];
  }
  typeValue(type) {
    return poHttpInterceptorDetailLiteralsDefault[this.language][type] || type;
  }
  addValidDetail(newDetails, detail) {
    return detail.message ? newDetails.concat(this.getValidDetailProperties(detail)) : newDetails;
  }
  getValidDetailProperties({ code, message, detailedMessage, type, detailTitle }) {
    return detailTitle ? { code, message, detailedMessage, type, detailTitle } : { code, message, detailedMessage, type };
  }
  filterByValidDetails(details) {
    return details.reduce((newDetails, detail) => this.addValidDetail(newDetails, detail), []);
  }
  formatTitle(details) {
    return details.length > 1 ? `${this.literals.details} (${details.length})` : details.length === 1 ? this.formatDetailItemTitle(details[0]) : this.literals.detail;
  }
  static ɵfac = function PoHttpInterceptorDetailComponent_Factory(t) {
    return new (t || _PoHttpInterceptorDetailComponent)(ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵcmp = ɵɵdefineComponent({ type: _PoHttpInterceptorDetailComponent, selectors: [["po-http-interceptor-detail"]], viewQuery: function PoHttpInterceptorDetailComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PoModalComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
    }
  }, decls: 7, vars: 4, consts: [["p-hide-close", "", "p-size", "lg", 3, "p-primary-action", "p-title"], [1, "po-row"], ["class", "po-md-12 po-mt-1 po-mb-1", 4, "ngIf", "ngIfElse"], ["elseBlock", ""], ["body", ""], [1, "po-md-12", "po-mt-1", "po-mb-1"], [3, "p-label", 4, "ngFor", "ngForOf"], [3, "p-label"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "po-row po-mb-1", 4, "ngIf"], [4, "ngIf"], [1, "po-row", "po-mb-1"], [3, "p-color", "p-value"]], template: function PoHttpInterceptorDetailComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "po-modal", 0)(1, "div", 1);
      ɵɵtemplate(2, PoHttpInterceptorDetailComponent_po_accordion_2_Template, 2, 1, "po-accordion", 2);
      ɵɵelementEnd()();
      ɵɵtemplate(3, PoHttpInterceptorDetailComponent_ng_template_3_Template, 1, 5, "ng-template", null, 3, ɵɵtemplateRefExtractor)(5, PoHttpInterceptorDetailComponent_ng_template_5_Template, 5, 3, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(4);
      ɵɵproperty("p-primary-action", ctx.primaryAction)("p-title", ctx.title);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.details.length > 1)("ngIfElse", _r2);
    }
  }, dependencies: [NgForOf, NgIf, NgTemplateOutlet, PoAccordionComponent, PoAccordionItemComponent, PoModalComponent, PoTagComponent], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpInterceptorDetailComponent, [{
    type: Component,
    args: [{ selector: "po-http-interceptor-detail", template: '<po-modal p-hide-close p-size="lg" [p-primary-action]="primaryAction" [p-title]="title">\n  <div class="po-row">\n    <po-accordion class="po-md-12 po-mt-1 po-mb-1" *ngIf="details.length > 1; else elseBlock">\n      <po-accordion-item *ngFor="let detail of details" [p-label]="formatDetailItemTitle(detail)">\n        <ng-template [ngTemplateOutlet]="body" [ngTemplateOutletContext]="{ detail }"></ng-template>\n      </po-accordion-item>\n    </po-accordion>\n  </div>\n</po-modal>\n\n<ng-template #elseBlock>\n  <ng-container [ngTemplateOutlet]="body" [ngTemplateOutletContext]="{ detail: details[0] || {} }"></ng-container>\n</ng-template>\n\n<ng-template #body let-detail="detail">\n  <div *ngIf="detail.type" class="po-row po-mb-1">\n    <po-tag [p-color]="typeColor(detail.type)" [p-value]="typeValue(detail.type)"></po-tag>\n  </div>\n\n  <p *ngIf="detail.detailTitle">\n    <strong>{{ detail.code }}</strong>\n  </p>\n\n  <div class="po-row">\n    <p>{{ detail.detailedMessage }}</p>\n  </div>\n</ng-template>\n' }]
  }], () => [{ type: PoLanguageService }], { modal: [{
    type: ViewChild,
    args: [PoModalComponent, { static: true }]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassDebugInfo(PoHttpInterceptorDetailComponent, { className: "PoHttpInterceptorDetailComponent", filePath: "lib/interceptors/po-http-interceptor/po-http-interceptor-detail/po-http-interceptor-detail.component.ts", lineNumber: 23 });
})();
var poHttpInterceptorLiterals = {
  pt: {
    help: "Ajuda",
    details: "Detalhes",
    serverNotResponse: "Servidor não está respondendo"
  },
  en: {
    help: "Help",
    details: "Details",
    serverNotResponse: "Server is not responding"
  },
  es: {
    help: "Ayuda",
    details: "Detalles",
    serverNotResponse: "El servidor no está respondiendo"
  },
  ru: {
    help: "Помогите",
    details: "Детали",
    serverNotResponse: "Сервер не отвечает"
  }
};
var NO_ERROR_HEADER_PARAM = "X-PO-No-Error";
var NO_MESSAGE_HEADER_PARAM = "X-PO-No-Message";
var PoHttpInterceptorBaseService = class {
  componentInjector;
  notification;
  languageService;
  notificationTypes = ["success", "warning", "error", "information"];
  literals;
  httpInterceptorDetailComponent = void 0;
  constructor(componentInjector, notification, languageService) {
    this.componentInjector = componentInjector;
    this.notification = notification;
    this.languageService = languageService;
    this.literals = poHttpInterceptorLiterals[this.languageService?.getShortLanguage()];
  }
  intercept(request, next) {
    const cloneRequest = request.clone();
    request = request && this.hasParameters(request) ? this.cloneRequestWithoutParameters(request) : request;
    return next.handle(request).pipe(tap((response) => {
      if (response instanceof HttpResponse) {
        this.processResponse(response, cloneRequest);
      }
    }, (error) => {
      this.processErrorResponse(error, cloneRequest);
    }));
  }
  processResponse(response, request) {
    const hasNoMessageParam = this.hasNoMessageParam(request);
    if (!hasNoMessageParam && response.body && response.body._messages) {
      const messages = response.body._messages;
      if (messages instanceof Array) {
        messages.forEach((message) => {
          this.showNotification(message);
        });
      } else {
        this.showNotification(messages);
      }
    }
  }
  processErrorResponse(response, request) {
    const errorResponse = response.status !== 0 ? response.error : { code: 0, message: this.literals.serverNotResponse, detailedMessage: response.message };
    const hasNoErrorParam = this.hasNoErrorParam(request);
    const hasNoMessageParam = this.hasNoMessageParam(request);
    const errorResponseValidTypes = this.notificationTypes.slice(1);
    if (errorResponse && errorResponse.message && !hasNoErrorParam && !hasNoMessageParam) {
      this.showNotification(__spreadProps(__spreadValues({}, errorResponse), {
        type: errorResponseValidTypes.includes(errorResponse.type) ? errorResponse.type : "error"
      }));
    }
  }
  cloneRequestWithoutParameters(request) {
    const headers = request.headers.delete(NO_ERROR_HEADER_PARAM).delete(NO_MESSAGE_HEADER_PARAM);
    return request.clone({ headers });
  }
  createModal(responseMessage) {
    const details = responseMessage.details ? [responseMessage, ...responseMessage.details] : [responseMessage];
    this.httpInterceptorDetailComponent = this.componentInjector.createComponentInApplication(PoHttpInterceptorDetailComponent);
    this.httpInterceptorDetailComponent.instance.detail = details;
    this.httpInterceptorDetailComponent.instance.closed.subscribe(() => this.destroyModal());
    this.httpInterceptorDetailComponent.instance.open();
  }
  destroyModal() {
    if (this.httpInterceptorDetailComponent) {
      this.componentInjector.destroyComponentInApplication(this.httpInterceptorDetailComponent);
      this.httpInterceptorDetailComponent = void 0;
    }
  }
  hasMessage(responseMessage) {
    const hasMessageProperties = responseMessage.message;
    return responseMessage && hasMessageProperties;
  }
  hasNoErrorParam(request) {
    const noErrorParam = request && request.headers.get(NO_ERROR_HEADER_PARAM);
    return noErrorParam && noErrorParam.toString().toLocaleLowerCase() === "true";
  }
  hasNoMessageParam(request) {
    const noMessageParam = request && request.headers.get(NO_MESSAGE_HEADER_PARAM);
    return noMessageParam && noMessageParam.toString().toLocaleLowerCase() === "true";
  }
  hasParameters(request) {
    return request.headers.has(NO_ERROR_HEADER_PARAM) || request.headers.has(NO_MESSAGE_HEADER_PARAM);
  }
  showNotification(response) {
    if (!this.hasMessage(response)) {
      return;
    }
    const typeNotification = this.notificationTypes.includes(response.type) ? response.type : "information";
    const notificationAction = this.generateNotificationAction(response);
    this.notification[typeNotification]({
      message: response.message,
      actionLabel: notificationAction.label,
      action: notificationAction.action
    });
  }
  generateDetailModal(responseMessage) {
    return () => {
      if (!this.httpInterceptorDetailComponent) {
        this.createModal(responseMessage);
      }
    };
  }
  generateNotificationAction(responseMessage) {
    let notificationAction;
    let notificationLabel;
    if (responseMessage.helpUrl && !(responseMessage.detailedMessage || responseMessage.details)) {
      notificationLabel = this.literals.help;
      notificationAction = this.generateUrlHelpFunction(responseMessage.helpUrl);
    } else if (responseMessage.detailedMessage || responseMessage.details) {
      notificationLabel = this.literals.details;
      notificationAction = this.generateDetailModal(responseMessage);
    }
    return { label: notificationLabel, action: notificationAction };
  }
  generateUrlHelpFunction(helpUrl) {
    return () => {
      window.open(helpUrl, "_blank");
    };
  }
};
var PoHttpInterceptorService = class _PoHttpInterceptorService extends PoHttpInterceptorBaseService {
  constructor(notification, componentInjector, languageService) {
    super(componentInjector, notification, languageService);
  }
  static ɵfac = function PoHttpInterceptorService_Factory(t) {
    return new (t || _PoHttpInterceptorService)(ɵɵinject(PoNotificationService), ɵɵinject(PoComponentInjectorService), ɵɵinject(PoLanguageService));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoHttpInterceptorService, factory: _PoHttpInterceptorService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpInterceptorService, [{
    type: Injectable
  }], () => [{ type: PoNotificationService }, { type: PoComponentInjectorService }, { type: PoLanguageService }], null);
})();
var PoHttpInterceptorModule = class _PoHttpInterceptorModule {
  static ɵfac = function PoHttpInterceptorModule_Factory(t) {
    return new (t || _PoHttpInterceptorModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoHttpInterceptorModule });
  static ɵinj = ɵɵdefineInjector({ providers: [
    PoHttpInterceptorService,
    PoNotificationService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: PoHttpInterceptorService,
      multi: true
    }
  ], imports: [CommonModule, PoAccordionModule, PoModalModule, PoNotificationModule, PoTagModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpInterceptorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, PoAccordionModule, PoModalModule, PoNotificationModule, PoTagModule],
      declarations: [PoHttpInterceptorDetailComponent],
      providers: [
        PoHttpInterceptorService,
        PoNotificationService,
        {
          provide: HTTP_INTERCEPTORS,
          useClass: PoHttpInterceptorService,
          multi: true
        }
      ]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoHttpInterceptorModule, { declarations: [PoHttpInterceptorDetailComponent], imports: [CommonModule, PoAccordionModule, PoModalModule, PoNotificationModule, PoTagModule] });
})();
var PoHttpRequesControltService = class _PoHttpRequesControltService {
  controlHttpRequest = new Subject();
  getControlHttpRequest() {
    return this.controlHttpRequest.asObservable();
  }
  send(value = 0) {
    this.controlHttpRequest.next(value);
  }
  static ɵfac = function PoHttpRequesControltService_Factory(t) {
    return new (t || _PoHttpRequesControltService)();
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoHttpRequesControltService, factory: _PoHttpRequesControltService.ɵfac });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpRequesControltService, [{
    type: Injectable
  }], null, null);
})();
var noCountPendingRequests = "X-PO-No-Count-Pending-Requests";
var screenLock = "X-PO-Screen-Lock";
var PoHttpRequestInterceptorService = class _PoHttpRequestInterceptorService {
  controlHttpRequest;
  poComponentInjector;
  loadingOverlayComponent = void 0;
  pendingRequests = 0;
  overlayRequests = 0;
  constructor(controlHttpRequest, poComponentInjector) {
    this.controlHttpRequest = controlHttpRequest;
    this.poComponentInjector = poComponentInjector;
  }
  intercept(request, next) {
    const requestClone = request.clone();
    request = this.requestCloneWithoutHeaderParam([noCountPendingRequests, screenLock], request);
    this.setCountPendingRequests(true, requestClone);
    this.setCountOverlayRequests(true, requestClone);
    return next.handle(request).pipe(finalize(() => {
      this.setCountPendingRequests(false, requestClone);
      this.setCountOverlayRequests(false, requestClone);
    }));
  }
  getCountPendingRequests() {
    return this.controlHttpRequest.getControlHttpRequest();
  }
  buildLoading() {
    if (!this.loadingOverlayComponent) {
      this.loadingOverlayComponent = this.poComponentInjector.createComponentInApplication(PoLoadingOverlayComponent);
      this.loadingOverlayComponent.instance.screenLock = true;
      this.loadingOverlayComponent.instance.changeDetector.detectChanges();
    }
  }
  destroyLoading() {
    if (this.loadingOverlayComponent) {
      this.poComponentInjector.destroyComponentInApplication(this.loadingOverlayComponent);
      this.loadingOverlayComponent = void 0;
    }
  }
  requestCloneWithoutHeaderParam(headersParams, request) {
    let isRequestClone = false;
    headersParams.forEach((headerParam) => {
      if (request.headers.has(headerParam)) {
        request = request.clone({ headers: request.headers.delete(headerParam) });
        isRequestClone = true;
      }
    });
    return isRequestClone ? request.clone({ headers: request.headers }) : request;
  }
  setCountPendingRequests(isIncrement, request) {
    const hasCountPendingRequestHeaderParam = request.headers.has(noCountPendingRequests);
    const headerParam = request.headers.get(noCountPendingRequests);
    if (hasCountPendingRequestHeaderParam && headerParam.toString().toLowerCase() === "true") {
      return;
    }
    this.pendingRequests += isIncrement ? 1 : -1;
    this.controlHttpRequest.send(this.pendingRequests);
  }
  setCountOverlayRequests(isIncrement, request) {
    const hasOverlayRequestHeaderParam = request.headers.has(screenLock);
    if (hasOverlayRequestHeaderParam) {
      const headerParam = request.headers.get(screenLock);
      if (headerParam.toString().toLowerCase() === "false") {
        return;
      }
      this.overlayRequests += isIncrement ? 1 : -1;
      this.overlayRequests > 0 ? this.buildLoading() : this.destroyLoading();
    }
  }
  static ɵfac = function PoHttpRequestInterceptorService_Factory(t) {
    return new (t || _PoHttpRequestInterceptorService)(ɵɵinject(PoHttpRequesControltService), ɵɵinject(PoComponentInjectorService));
  };
  static ɵprov = ɵɵdefineInjectable({ token: _PoHttpRequestInterceptorService, factory: _PoHttpRequestInterceptorService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpRequestInterceptorService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{ type: PoHttpRequesControltService }, { type: PoComponentInjectorService }], null);
})();
var PoHttpRequestModule = class _PoHttpRequestModule {
  static ɵfac = function PoHttpRequestModule_Factory(t) {
    return new (t || _PoHttpRequestModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoHttpRequestModule });
  static ɵinj = ɵɵdefineInjector({ providers: [
    PoHttpRequesControltService,
    PoHttpRequestInterceptorService,
    PoComponentInjectorService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: PoHttpRequestInterceptorService,
      multi: true
    }
  ], imports: [PoLoadingModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoHttpRequestModule, [{
    type: NgModule,
    args: [{
      imports: [PoLoadingModule],
      providers: [
        PoHttpRequesControltService,
        PoHttpRequestInterceptorService,
        PoComponentInjectorService,
        {
          provide: HTTP_INTERCEPTORS,
          useClass: PoHttpRequestInterceptorService,
          multi: true
        }
      ]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoHttpRequestModule, { imports: [PoLoadingModule] });
})();
var PoInterceptorsModule = class _PoInterceptorsModule {
  static ɵfac = function PoInterceptorsModule_Factory(t) {
    return new (t || _PoInterceptorsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoInterceptorsModule });
  static ɵinj = ɵɵdefineInjector({ imports: [PoHttpInterceptorModule, PoHttpRequestModule, PoHttpInterceptorModule, PoHttpRequestModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoInterceptorsModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoHttpInterceptorModule, PoHttpRequestModule],
      exports: [PoHttpInterceptorModule, PoHttpRequestModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoInterceptorsModule, { imports: [PoHttpInterceptorModule, PoHttpRequestModule], exports: [PoHttpInterceptorModule, PoHttpRequestModule] });
})();
var PoPipesModule = class _PoPipesModule {
  static ɵfac = function PoPipesModule_Factory(t) {
    return new (t || _PoPipesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoPipesModule });
  static ɵinj = ɵɵdefineInjector({ imports: [PoTimeModule, PoTimeModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoPipesModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [PoTimeModule],
      exports: [PoTimeModule],
      providers: [],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoPipesModule, { imports: [PoTimeModule], exports: [PoTimeModule] });
})();
var PoModule = class _PoModule {
  static ɵfac = function PoModule_Factory(t) {
    return new (t || _PoModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoModule });
  static ɵinj = ɵɵdefineInjector({ providers: [PoNotificationService], imports: [
    PoComponentsModule,
    PoDirectivesModule,
    PoGuardsModule,
    PoInterceptorsModule,
    PoPipesModule,
    PoServicesModule,
    PoComponentsModule,
    PoDirectivesModule,
    PoInterceptorsModule,
    PoGuardsModule,
    PoPipesModule,
    PoServicesModule
  ] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      imports: [
        PoComponentsModule,
        PoDirectivesModule,
        PoGuardsModule,
        PoInterceptorsModule,
        PoPipesModule,
        PoServicesModule
      ],
      exports: [
        PoComponentsModule,
        PoDirectivesModule,
        PoInterceptorsModule,
        PoGuardsModule,
        PoPipesModule,
        PoServicesModule
      ],
      providers: [PoNotificationService],
      bootstrap: []
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoModule, { imports: [
    PoComponentsModule,
    PoDirectivesModule,
    PoGuardsModule,
    PoInterceptorsModule,
    PoPipesModule,
    PoServicesModule
  ], exports: [
    PoComponentsModule,
    PoDirectivesModule,
    PoInterceptorsModule,
    PoGuardsModule,
    PoPipesModule,
    PoServicesModule
  ] });
})();
var ForceBooleanComponentEnum;
(function(ForceBooleanComponentEnum2) {
  ForceBooleanComponentEnum2["switch"] = "switch";
  ForceBooleanComponentEnum2["checkbox"] = "checkbox";
})(ForceBooleanComponentEnum || (ForceBooleanComponentEnum = {}));
var ForceOptionComponentEnum;
(function(ForceOptionComponentEnum2) {
  ForceOptionComponentEnum2["radioGroup"] = "radioGroup";
  ForceOptionComponentEnum2["select"] = "select";
})(ForceOptionComponentEnum || (ForceOptionComponentEnum = {}));
function validatePropertyOnLifeCycle(decoratorProperties, lifecycleName, callback) {
  const { target, property } = decoratorProperties;
  const emptyFunction = () => {
  };
  const lifecycleFunctionClone = target[lifecycleName] || emptyFunction;
  Object.defineProperty(target, lifecycleName, {
    value: function() {
      callback.call(this, property, target);
      lifecycleFunctionClone.call(this);
    }
  });
}
function changeValueByCallback(decoratorProperties, decoratorName, callback) {
  const { target, property, originalDescriptor } = decoratorProperties;
  const privatePropertyName = createPrivateProperty(target, property, decoratorName);
  return {
    get: getter(originalDescriptor, privatePropertyName),
    set: setter(originalDescriptor, callback, privatePropertyName)
  };
}
function setter(originalDescriptor, callback, privatePropertyName) {
  return function(value) {
    if (originalDescriptor && originalDescriptor.set) {
      originalDescriptor.set.bind(this)(callback(value));
    }
    this[privatePropertyName] = callback(value);
  };
}
function getter(originalDescriptor, privatePropName) {
  return function() {
    return originalDescriptor && originalDescriptor.get ? originalDescriptor.get.bind(this)() : this[privatePropName];
  };
}
function createPrivateProperty(target, propertyName, decoratorName) {
  const privatePropName = `$$__${propertyName}`;
  if (Object.prototype.hasOwnProperty.call(target, privatePropName)) {
    console.warn(`The prop "${privatePropName}" is already exist, it will be overrided by ${decoratorName} decorator.`);
  }
  Object.defineProperty(target, privatePropName, {
    configurable: true,
    writable: true
  });
  return privatePropName;
}
function InputBoolean() {
  return function(target, property, originalDescriptor) {
    const decoratorProperties = { target, property, originalDescriptor };
    return changeValueByCallback(decoratorProperties, "InputBoolean", convertToBoolean);
  };
}
function InputRequired() {
  return function(target, property) {
    const decoratorProperties = { target, property };
    validatePropertyOnLifeCycle(decoratorProperties, "ngOnInit", validateProperty);
  };
}
function validateProperty(property, target) {
  if (this[property] == null) {
    console.warn(`${target.constructor.name}: ${property} is required, but was not provided`);
  }
}
var I18N_CONFIG = new InjectionToken("I18N_CONFIG");
var PoI18nBaseService = class _PoI18nBaseService {
  config;
  http;
  languageService;
  varI18n = {};
  contextDefault;
  useCache = false;
  servicesContext = {};
  constructor(config, http, languageService) {
    this.config = config;
    this.http = http;
    this.languageService = languageService;
    this.setConfig(config);
  }
  /**
   * <a id="get-language"></a>
   * Método que retorna o idioma padrão ativo.
   *
   * A busca deste idioma pelo método será feita na seguinte ordem:
   *
   *   1 - o idioma que foi armazenado no *localStorage*, através do método [`setLanguage()`](documentation/po-i18n#setLanguage).
   *
   *   2 - o valor inserido no módulo do i18n através do parâmetro `config`, sendo o idioma inserido na propriedade
   * `language` da interface [`PoI18nConfigDefault`](documentation/po-i18n#poI18nConfigDefault).
   *
   *   3 - o idioma do navegador utilizado.
   *
   * > Caso o idioma do navegador não seja suportado pelo PO (`pt`, `en`, `es` ou `ru`), será retornado valor `pt`.
   *
   * @returns {string} sigla do idioma padrão.
   */
  getLanguage() {
    return this.languageService.getLanguage();
  }
  getLiterals(options = {}) {
    const language = options["language"] ? options["language"].toLowerCase() : this.getLanguage();
    const context = options["context"] ? options["context"] : this.contextDefault;
    const literals = options["literals"] ? options["literals"] : [];
    return new Observable((observer) => {
      if (this.servicesContext[context]) {
        this.getLiteralsFromContextService(language, context, literals, observer);
      } else {
        this.getLiteralsFromContextConstant(language, context, literals, observer);
      }
    });
  }
  /**
   * Método que retorna o idioma padrão ativo, com somente a abreviação do idioma (duas primeiras letras).
   * Por exemplo: "pt" ou "es".
   *
   * A busca deste idioma é baseada no método [**getLanguage()**](/documentation/po-i18n#get-language).
   *
   * @returns {string} sigla do idioma padrão.
   */
  getShortLanguage() {
    return this.languageService.getShortLanguage();
  }
  /**
   * <a id="setLanguage"></a>
   * Método para alterar o idioma padrão do módulo do i18n.
   *
   * Ao utilizar este método, o idioma ficará gravado no armazenamento local do navegador, que será utilizado pelo
   * serviço do `i18n` para buscar as literais no idioma padrão.
   *
   * @param {string} language Sigla do idioma.
   *
   * Esta sigla deve ser composta por duas letras representando o idioma,
   * podendo ser adicionado outras duas letras representando o país, por exemplo: `pt`, `pt-BR`, `pt-br`, `en` ou `en-US`.
   *
   * > Caso seja informado um valor diferente deste padrão, o mesmo será ignorado.
   *
   * @param {boolean} reload Indica se a página atual poderá ser recarregada após a alteração do idioma.
   *
   * Este recurso pode ser útil para os usuários que utilizam o método `getLiterals()` do serviço do i18n para poder
   * buscar novamente as literais no novo idioma configurado.
   */
  setLanguage(language, reload = false) {
    if (!isLanguage(language)) {
      return;
    }
    this.languageService.setLanguage(language);
    if (reload) {
      reloadCurrentPage();
    }
  }
  setConfig(config) {
    if (config["default"]) {
      this.languageService.setLanguageDefault(config["default"]["language"]);
      this.contextDefault = config["default"]["context"] ? config["default"]["context"] : "";
      this.useCache = config["default"]["cache"] ? config["default"]["cache"] : false;
    }
    if (config["contexts"]) {
      this.setVarI18n(config["contexts"]);
      if (!this.contextDefault) {
        for (const context in config["contexts"]) {
          if (this.config["contexts"].hasOwnProperty(context)) {
            this.contextDefault = context;
            break;
          }
        }
      }
    }
  }
  // Processo de busca de um contexto que contém serviço.
  //    1 - Procura na variável I18n deste serviço
  //    2 - Procura no local storage (Se o cache estiver definido como true na configuração do módulo)
  //    3 - Dispara o serviço, mesmo que já tenha encontrado no local storage, para garantir a atualização
  //    4 - Se nenhuma literal for encontrada, então busca em pt-br
  getLiteralsFromContextService(language, context, literals, observer, translations = {}, languageAlternative = null) {
    const languageSearch = languageAlternative ? languageAlternative : language;
    translations = this.mergeObject(translations, this.searchInVarI18n(languageSearch, context, literals));
    if (this.countObject(translations) > 0) {
      observer.next(translations);
    }
    this.getLiteralsLocalStorageAndCache(languageSearch, context, literals, observer, translations, languageAlternative);
  }
  // Procura no local storage e em seguida no serviço
  // Caso não encontre nem no serviço, recomeça a busca em pt-br
  getLiteralsLocalStorageAndCache(language, context, literals, observer, translations, languageAlternative = null) {
    const languageSearch = languageAlternative ? languageAlternative : language;
    let translationTemp;
    if (this.useCache) {
      translationTemp = this.searchInLocalStorage(languageSearch, context, literals);
      if (this.countObject(translationTemp) > 0) {
        this.updateVarI18n(language, context, translationTemp);
        translations = this.mergeObject(translationTemp, translations);
        observer.next(translations);
      }
    }
    this.getHttpService(this.servicesContext[context], languageSearch, literals).subscribe((response) => {
      if (response) {
        this.updateLocalStorage(language, context, response);
        this.updateVarI18n(language, context, response);
        translationTemp = this.searchInVarI18n(language, context, literals);
        translations = this.mergeObject(translationTemp, translations);
        observer.next(translations);
      }
      if (literals.length > this.countObject(translations)) {
        if (languageAlternative === "pt-br") {
          translations = this.completeFaultLiterals(language, context, literals, translations);
          this.updateLocalStorage(language, context, translations);
          this.updateVarI18n(language, context, translations);
          observer.next(translations);
        } else {
          this.getLiteralsFromContextService(language, context, literals, observer, translations, "pt-br");
        }
      }
    });
  }
  // Procura pela lista de literais
  // Se não encontrar todas, procura em pt-br
  getLiteralsFromContextConstant(language, context, literals, observer, translations = {}) {
    translations = this.mergeObject(translations, this.searchInVarI18n(language, context, literals));
    if (this.countObject(translations) > 0) {
      observer.next(translations);
    }
    if (literals.length > 0) {
      if (literals.length > this.countObject(translations)) {
        if (language === "pt-br") {
          translations = this.completeFaultLiterals(language, context, literals, translations);
          observer.next(translations);
        } else {
          this.getLiteralsFromContextConstant("pt-br", context, literals, observer, translations);
        }
      }
    } else {
      if (this.countObject(translations) === 0 && language !== "pt-br") {
        this.getLiteralsFromContextConstant("pt-br", context, literals, observer, translations);
      }
      observer.next(translations);
      observer.complete();
    }
  }
  // Busca pelas literais no local storage
  searchInLocalStorage(language, context, literals) {
    const translations = {};
    if (literals.length > 0) {
      for (let i = 0; i < literals.length; i++) {
        const literal = literals[i];
        const translation = localStorage.getItem(language + "-" + context + "-" + literal);
        if (translation) {
          translations[literal] = translation;
        }
      }
    }
    return translations;
  }
  // Busca pelas literais na variável do serviço
  searchInVarI18n(language, context, literals) {
    let translations = {};
    if (this.varI18n[language] && this.varI18n[language][context]) {
      const content = this.varI18n[language][context];
      if (literals.length > 0) {
        for (let i = 0; i < literals.length; i++) {
          const literal = literals[i];
          if (content.hasOwnProperty(literal)) {
            translations[literal] = content[literal];
          }
        }
      } else {
        translations = __spreadValues({}, content);
      }
    }
    return translations;
  }
  // Atualiza o local storage
  updateLocalStorage(language, context, data) {
    if (this.useCache) {
      for (const literal of Object.keys(data)) {
        localStorage.setItem(language + "-" + context + "-" + literal, data[literal]);
      }
    }
  }
  // Atualiza a variável local com as literais com os objetos passados na configuração
  setVarI18n(contexts) {
    for (const context of Object.keys(contexts)) {
      const contextContent = contexts[context];
      for (const language of Object.keys(contextContent)) {
        const languageContent = contextContent[language];
        if (language === "url") {
          this.servicesContext[context] = languageContent;
        } else {
          this.updateVarI18n(language, context, languageContent);
        }
      }
    }
  }
  // Atualiza a variável local com as literais idioma e contexto
  updateVarI18n(language, context, data) {
    language = language.toLowerCase();
    if (!this.varI18n[language]) {
      this.varI18n[language] = { [context]: {} };
    }
    if (!this.varI18n[language][context]) {
      this.varI18n[language][context] = {};
    }
    this.varI18n[language][context] = this.mergeObject(data, this.varI18n[language][context]);
  }
  getHttpService(url, language, literals) {
    let param = "?language=" + language;
    if (literals.length > 0) {
      param += "&literals=" + literals.join();
    }
    url = url.replace(/\/$/, "");
    return this.http.get(`${url}${param}`);
  }
  // Completa com o nome da literais, as que não foram encontradas
  completeFaultLiterals(language, context, literals, translations) {
    for (let i = 0; i < literals.length; i++) {
      const literal = literals[i];
      if (!translations[literal]) {
        translations[literal] = literal;
      }
    }
    return translations;
  }
  // Conta os atributos do objeto
  countObject(obj) {
    return Object.keys(obj).length;
  }
  // Faz o merge dos objetos, sempre dando preferência para o primeiro objeto de parâmetro
  mergeObject(objPermanent, obj) {
    return __spreadValues(__spreadValues({}, obj), objPermanent);
  }
  static ɵfac = function PoI18nBaseService_Factory(t) {
    return new (t || _PoI18nBaseService)(ɵɵdirectiveInject(I18N_CONFIG), ɵɵdirectiveInject(HttpClient), ɵɵdirectiveInject(PoLanguageService));
  };
  static ɵdir = ɵɵdefineDirective({ type: _PoI18nBaseService });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nBaseService, [{
    type: Directive
  }], () => [{ type: void 0, decorators: [{
    type: Inject,
    args: [I18N_CONFIG]
  }] }, { type: HttpClient, decorators: [{
    type: Inject,
    args: [HttpClient]
  }] }, { type: PoLanguageService }], null);
})();
var PoI18nService = class _PoI18nService extends PoI18nBaseService {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵPoI18nService_BaseFactory;
    return function PoI18nService_Factory(t) {
      return (ɵPoI18nService_BaseFactory || (ɵPoI18nService_BaseFactory = ɵɵgetInheritedFactory(_PoI18nService)))(t || _PoI18nService);
    };
  })();
  static ɵprov = ɵɵdefineInjectable({ token: _PoI18nService, factory: _PoI18nService.ɵfac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nService, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();
function returnPoI18nService(config, http, languageService) {
  return new PoI18nService(config, http, languageService);
}
var PoI18nModule = class _PoI18nModule {
  static config(config) {
    return {
      ngModule: _PoI18nModule,
      providers: [
        {
          provide: I18N_CONFIG,
          useValue: config
        },
        {
          provide: APP_INITIALIZER,
          useFactory: initializeLanguageDefault,
          multi: true,
          deps: [I18N_CONFIG, PoLanguageService]
        },
        {
          provide: PoI18nService,
          useFactory: returnPoI18nService,
          deps: [I18N_CONFIG, HttpClient, PoLanguageService]
        }
      ]
    };
  }
  static ɵfac = function PoI18nModule_Factory(t) {
    return new (t || _PoI18nModule)();
  };
  static ɵmod = ɵɵdefineNgModule({ type: _PoI18nModule });
  static ɵinj = ɵɵdefineInjector({ imports: [PoLanguageModule] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PoI18nModule, [{
    type: NgModule,
    args: [{
      imports: [PoLanguageModule]
    }]
  }], null, null);
})();
(function() {
  (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(PoI18nModule, { imports: [PoLanguageModule] });
})();
function initializeLanguageDefault(config, languageService) {
  const setDefaultLanguage = () => {
    if (config.default.language) {
      languageService.setLanguageDefault(config.default.language);
    }
  };
  return setDefaultLanguage;
}
export {
  ForceBooleanComponentEnum,
  ForceOptionComponentEnum,
  I18N_CONFIG,
  InputBoolean,
  InputRequired,
  PO_CONTROL_POSITIONS,
  PoAccordionComponent,
  PoAccordionItemComponent,
  PoAccordionModule,
  PoActiveOverlayModule,
  PoActiveOverlayService,
  PoAvatarComponent,
  PoAvatarModule,
  PoBadgeComponent,
  PoBadgeModule,
  PoBreadcrumbComponent,
  PoBreadcrumbModule,
  PoButtonComponent,
  PoButtonGroupComponent,
  PoButtonGroupModule,
  PoButtonGroupToggle,
  PoButtonModule,
  PoCalendarComponent,
  PoCalendarMode,
  PoCalendarModule,
  PoChartComponent,
  PoChartModule,
  PoChartType,
  PoCheckboxComponent,
  PoCheckboxGroupComponent,
  PoCheckboxGroupModule,
  PoCheckboxModule,
  PoCheckboxSize,
  PoCleanComponent,
  PoCleanModule,
  PoColorPaletteModule,
  PoColorPaletteService,
  PoComboComponent,
  PoComboFilterMode,
  PoComboOptionTemplateDirective,
  PoComponentInjectorModule,
  PoComponentInjectorService,
  PoComponentsModule,
  PoContainerComponent,
  PoContainerModule,
  PoControlPositionModule,
  PoDateService,
  PoDateTimeModule,
  PoDatepickerComponent,
  PoDatepickerIsoFormat,
  PoDatepickerModule,
  PoDatepickerRangeComponent,
  PoDecimalComponent,
  PoDialogComponent,
  PoDialogModule,
  PoDialogService,
  PoDialogType,
  PoDirectivesModule,
  PoDisclaimerComponent,
  PoDisclaimerGroupComponent,
  PoDisclaimerGroupModule,
  PoDisclaimerModule,
  PoDividerComponent,
  PoDividerModule,
  PoDividerSize,
  PoDropdownComponent,
  PoDropdownModule,
  PoDynamicFieldType,
  PoDynamicFormComponent,
  PoDynamicModule,
  PoDynamicViewComponent,
  PoEmailComponent,
  PoFieldContainerBottomComponent,
  PoFieldContainerComponent,
  PoFieldContainerModule,
  PoFieldModule,
  PoGaugeComponent,
  PoGaugeModule,
  PoGridComponent,
  PoGridModule,
  PoGuardsModule,
  PoHttpInterceptorModule,
  PoHttpInterceptorService,
  PoHttpRequestInterceptorService,
  PoHttpRequestModule,
  PoI18nModule,
  PoI18nPipe,
  PoI18nService,
  PoIconComponent,
  PoIconModule,
  PoImageComponent,
  PoImageModule,
  PoInfoComponent,
  PoInfoModule,
  PoInfoOrientation,
  PoInputComponent,
  PoInterceptorsModule,
  PoItemListComponent,
  PoLabelComponent,
  PoLabelModule,
  PoLanguageModule,
  PoLanguageService,
  PoLinkComponent,
  PoLinkModule,
  PoListBoxComponent,
  PoListBoxModule,
  PoListViewComponent,
  PoListViewContentTemplateDirective,
  PoListViewDetailTemplateDirective,
  PoListViewModule,
  PoLoadingComponent,
  PoLoadingIconComponent,
  PoLoadingModule,
  PoLoadingOverlayComponent,
  PoLoginComponent,
  PoLogoComponent,
  PoLogoModule,
  PoLookupComponent,
  PoLookupModalComponent,
  PoMenuComponent,
  PoMenuGlobalService,
  PoMenuHeaderTemplateDirective,
  PoMenuModule,
  PoMenuPanelComponent,
  PoMenuPanelModule,
  PoModalComponent,
  PoModalFooterComponent,
  PoModalModule,
  PoModule,
  PoMultiselectComponent,
  PoMultiselectFilterMode,
  PoMultiselectOptionTemplateDirective,
  PoNavbarComponent,
  PoNavbarModule,
  PoNotificationModule,
  PoNotificationService,
  PoNumberComponent,
  PoOverlayComponent,
  PoOverlayModule,
  PoPageDefaultComponent,
  PoPageDetailComponent,
  PoPageEditComponent,
  PoPageListComponent,
  PoPageModule,
  PoPageSlideComponent,
  PoPageSlideModule,
  PoPasswordComponent,
  PoPipesModule,
  PoPopoverComponent,
  PoPopoverModule,
  PoPopupComponent,
  PoPopupModule,
  PoProgressComponent,
  PoProgressModule,
  PoProgressSize,
  PoProgressStatus,
  PoRadioComponent,
  PoRadioGroupComponent,
  PoRadioGroupModule,
  PoRadioModule,
  PoRichTextComponent,
  PoSearchComponent,
  PoSearchFilterMode,
  PoSearchListComponent,
  PoSearchModule,
  PoSelectComponent,
  PoServicesModule,
  PoSlideComponent,
  PoSlideContentTemplateDirective,
  PoSlideModule,
  PoStepComponent,
  PoStepperComponent,
  PoStepperModule,
  PoStepperOrientation,
  PoStepperStatus,
  PoSwitchComponent,
  PoSwitchLabelPosition,
  PoSwitchModule,
  PoTabComponent,
  PoTableCellTemplateDirective,
  PoTableColumnFrozenDirective,
  PoTableColumnSortType,
  PoTableColumnSpacing,
  PoTableColumnTemplateDirective,
  PoTableComponent,
  PoTableModule,
  PoTableRowTemplateArrowDirection,
  PoTableRowTemplateDirective,
  PoTabsComponent,
  PoTabsModule,
  PoTabsService,
  PoTagComponent,
  PoTagModule,
  PoTagOrientation,
  PoTagType,
  PoTextareaComponent,
  PoTimeModule,
  PoTimePipe,
  PoToasterOrientation,
  PoToasterType,
  PoToolbarComponent,
  PoToolbarModule,
  PoTooltipDirective,
  PoTooltipModule,
  PoTreeViewComponent,
  PoTreeViewModule,
  PoUploadComponent,
  PoUploadFile,
  PoUploadStatus,
  PoUrlComponent,
  PoWidgetComponent,
  PoWidgetModule,
  initializeLanguageDefault,
  poBreadcrumbLiterals,
  poDialogAlertLiteralsDefault,
  poDialogConfirmLiteralsDefault,
  poLanguageDefault,
  poLocaleDateSeparatorList,
  poLocaleDecimalSeparatorList,
  poLocaleDefault,
  poLocaleThousandSeparatorList,
  poLocales,
  poTabsLiterals,
  returnPoI18nService
};
/*! Bundled license information:

@angular/animations/fesm2022/animations.mjs:
  (**
   * @license Angular v17.3.1
   * (c) 2010-2022 Google LLC. https://angular.io/
   * License: MIT
   *)

@angular/forms/fesm2022/forms.mjs:
  (**
   * @license Angular v17.3.1
   * (c) 2010-2022 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
//# sourceMappingURL=@po-ui_ng-components.js.map
